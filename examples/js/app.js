/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"app": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push(["./examples/scripts/index.js",0]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./examples/bezier-curve.js":
/*!**********************************!*\
  !*** ./examples/bezier-curve.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _domCanvas = __webpack_require__(/*! ../lib/dom/dom-canvas */ \"./lib/dom/dom-canvas.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _hermiteCurve = __webpack_require__(/*! ../lib/mathf/hermite-curve */ \"./lib/mathf/hermite-curve.js\");\n\nvar _cubicBezier = __webpack_require__(/*! ../lib/mathf/cubic-bezier */ \"./lib/mathf/cubic-bezier.js\");\n\n/**\n * Demonstrates basic usage of BezierCurve\n */\nclass BezierCurveSample {\n  constructor() {\n    console.log('Bezier Curve Sample');\n    this.canvas = document.getElementById('canvas');\n    this.canvas.width = this.canvas.offsetWidth;\n    this.canvas.height = this.canvas.offsetHeight;\n    this.context = this.canvas.getContext('2d'); // Control points, since the CubicBezier class.\n\n    let c1 = new _vector.Vector(50, 400);\n    let c2 = new _vector.Vector(100, 200);\n    let c3 = new _vector.Vector(300, 300);\n    let c4 = new _vector.Vector(400, 400); // Set the number of points we want to draw.\n\n    let drawPoints = 500; // The amount of progress to per dot.\n\n    let progressSpan = 1 / drawPoints;\n\n    for (let step = 0; step < drawPoints; step++) {\n      // Draw a dot along the curve.  The progress value goes from 0-1.\n      let progress = step * progressSpan;\n\n      _domCanvas.domCanvas.setFillColor(this.context, 'orange');\n\n      _domCanvas.domCanvas.setStrokeColor(this.context, 'orange');\n\n      const vector = _cubicBezier.CubicBezier.getPoint(progress, c1, c2, c3, c4);\n\n      _domCanvas.domCanvas.vectorPoint(this.context, vector, 2);\n    } // Now draw out a large dot for each point.\n\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'red');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'red');\n\n    _domCanvas.domCanvas.vectorPoint(this.context, c1);\n\n    _domCanvas.domCanvas.quickText(this.context, 'c1', c1.x, c1.y - 4);\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'blue');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'blue');\n\n    _domCanvas.domCanvas.quickText(this.context, 'c2', c2.x, c2.y - 4);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, c2);\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'green');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'green');\n\n    _domCanvas.domCanvas.quickText(this.context, 'c3', c3.x, c3.y - 4);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, c3);\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'purple');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'purple');\n\n    _domCanvas.domCanvas.quickText(this.context, 'c4', c4.x, c4.y - 4);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, c4);\n  }\n\n}\n\nexports.default = BezierCurveSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9iZXppZXItY3VydmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9iZXppZXItY3VydmUuanM/ODM1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9kb21DYW52YXMgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20tY2FudmFzXCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvdmVjdG9yXCIpO1xuXG52YXIgX2hlcm1pdGVDdXJ2ZSA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvaGVybWl0ZS1jdXJ2ZVwiKTtcblxudmFyIF9jdWJpY0JlemllciA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvY3ViaWMtYmV6aWVyXCIpO1xuXG4vKipcbiAqIERlbW9uc3RyYXRlcyBiYXNpYyB1c2FnZSBvZiBCZXppZXJDdXJ2ZVxuICovXG5jbGFzcyBCZXppZXJDdXJ2ZVNhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdCZXppZXIgQ3VydmUgU2FtcGxlJyk7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzJyk7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsgLy8gQ29udHJvbCBwb2ludHMsIHNpbmNlIHRoZSBDdWJpY0JlemllciBjbGFzcy5cblxuICAgIGxldCBjMSA9IG5ldyBfdmVjdG9yLlZlY3Rvcig1MCwgNDAwKTtcbiAgICBsZXQgYzIgPSBuZXcgX3ZlY3Rvci5WZWN0b3IoMTAwLCAyMDApO1xuICAgIGxldCBjMyA9IG5ldyBfdmVjdG9yLlZlY3RvcigzMDAsIDMwMCk7XG4gICAgbGV0IGM0ID0gbmV3IF92ZWN0b3IuVmVjdG9yKDQwMCwgNDAwKTsgLy8gU2V0IHRoZSBudW1iZXIgb2YgcG9pbnRzIHdlIHdhbnQgdG8gZHJhdy5cblxuICAgIGxldCBkcmF3UG9pbnRzID0gNTAwOyAvLyBUaGUgYW1vdW50IG9mIHByb2dyZXNzIHRvIHBlciBkb3QuXG5cbiAgICBsZXQgcHJvZ3Jlc3NTcGFuID0gMSAvIGRyYXdQb2ludHM7XG5cbiAgICBmb3IgKGxldCBzdGVwID0gMDsgc3RlcCA8IGRyYXdQb2ludHM7IHN0ZXArKykge1xuICAgICAgLy8gRHJhdyBhIGRvdCBhbG9uZyB0aGUgY3VydmUuICBUaGUgcHJvZ3Jlc3MgdmFsdWUgZ29lcyBmcm9tIDAtMS5cbiAgICAgIGxldCBwcm9ncmVzcyA9IHN0ZXAgKiBwcm9ncmVzc1NwYW47XG5cbiAgICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnNldEZpbGxDb2xvcih0aGlzLmNvbnRleHQsICdvcmFuZ2UnKTtcblxuICAgICAgX2RvbUNhbnZhcy5kb21DYW52YXMuc2V0U3Ryb2tlQ29sb3IodGhpcy5jb250ZXh0LCAnb3JhbmdlJyk7XG5cbiAgICAgIGNvbnN0IHZlY3RvciA9IF9jdWJpY0Jlemllci5DdWJpY0Jlemllci5nZXRQb2ludChwcm9ncmVzcywgYzEsIGMyLCBjMywgYzQpO1xuXG4gICAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy52ZWN0b3JQb2ludCh0aGlzLmNvbnRleHQsIHZlY3RvciwgMik7XG4gICAgfSAvLyBOb3cgZHJhdyBvdXQgYSBsYXJnZSBkb3QgZm9yIGVhY2ggcG9pbnQuXG5cblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnNldEZpbGxDb2xvcih0aGlzLmNvbnRleHQsICdyZWQnKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnNldFN0cm9rZUNvbG9yKHRoaXMuY29udGV4dCwgJ3JlZCcpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMudmVjdG9yUG9pbnQodGhpcy5jb250ZXh0LCBjMSk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5xdWlja1RleHQodGhpcy5jb250ZXh0LCAnYzEnLCBjMS54LCBjMS55IC0gNCk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRGaWxsQ29sb3IodGhpcy5jb250ZXh0LCAnYmx1ZScpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMuc2V0U3Ryb2tlQ29sb3IodGhpcy5jb250ZXh0LCAnYmx1ZScpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMucXVpY2tUZXh0KHRoaXMuY29udGV4dCwgJ2MyJywgYzIueCwgYzIueSAtIDQpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMudmVjdG9yUG9pbnQodGhpcy5jb250ZXh0LCBjMik7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRGaWxsQ29sb3IodGhpcy5jb250ZXh0LCAnZ3JlZW4nKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnNldFN0cm9rZUNvbG9yKHRoaXMuY29udGV4dCwgJ2dyZWVuJyk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5xdWlja1RleHQodGhpcy5jb250ZXh0LCAnYzMnLCBjMy54LCBjMy55IC0gNCk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy52ZWN0b3JQb2ludCh0aGlzLmNvbnRleHQsIGMzKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnNldEZpbGxDb2xvcih0aGlzLmNvbnRleHQsICdwdXJwbGUnKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnNldFN0cm9rZUNvbG9yKHRoaXMuY29udGV4dCwgJ3B1cnBsZScpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMucXVpY2tUZXh0KHRoaXMuY29udGV4dCwgJ2M0JywgYzQueCwgYzQueSAtIDQpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMudmVjdG9yUG9pbnQodGhpcy5jb250ZXh0LCBjNCk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBCZXppZXJDdXJ2ZVNhbXBsZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/bezier-curve.js\n");

/***/ }),

/***/ "./examples/canvas-image-sequence.js":
/*!*******************************************!*\
  !*** ./examples/canvas-image-sequence.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _canvasImageSequence = __webpack_require__(/*! ../lib/dom/canvas-image-sequence */ \"./lib/dom/canvas-image-sequence.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\n/**\n * This sample show the most basic uses of CanvasImageSequence which is\n * updated by the scroll position of a position sticky based container.\n */\nclass CanvasImageSequenceSample {\n  constructor() {\n    console.log('canvas image sequence');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Instance of rafProgress.\n\n    this.rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        this.rafProgress.easeTo(this.progress, 0.25, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.rafProgress.watch(this.onProgressUpdate.bind(this)); // Generate image sources.\n\n    this.canvasImageSources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.canvasImageSources.push('./public/frames/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.canvasImageSequence = new _canvasImageSequence.CanvasImageSequence(this.canvasContainerElement, [{\n      images: this.canvasImageSources\n    }], {\n      ariaLabel: 'Aria label test'\n    }); // this.canvasImageSequence.lerpAmount = 0.02;\n    // Load the iamges.\n\n    this.canvasImageSequence.load().then(() => {\n      // When ready render whatever the current easedProgress value is.\n      this.canvasImageSequence.renderByProgress(this.rafProgress.currentProgress);\n    });\n  }\n\n  onProgressUpdate(easedProgress, direction) {\n    this.canvasImageSequence.renderByProgress(easedProgress);\n  }\n\n}\n\nexports.default = CanvasImageSequenceSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9jYW52YXMtaW1hZ2Utc2VxdWVuY2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9jYW52YXMtaW1hZ2Utc2VxdWVuY2UuanM/NzdkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yYWZQcm9ncmVzcyA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZi1wcm9ncmVzc1wiKTtcblxudmFyIF9jYW52YXNJbWFnZVNlcXVlbmNlID0gcmVxdWlyZShcIi4uL2xpYi9kb20vY2FudmFzLWltYWdlLXNlcXVlbmNlXCIpO1xuXG52YXIgX2Vhc2UgPSByZXF1aXJlKFwiLi4vbGliL2Vhc2UvZWFzZVwiKTtcblxudmFyIF9kb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb21cIik7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS13YXRjaGVyXCIpO1xuXG4vKipcbiAqIFRoaXMgc2FtcGxlIHNob3cgdGhlIG1vc3QgYmFzaWMgdXNlcyBvZiBDYW52YXNJbWFnZVNlcXVlbmNlIHdoaWNoIGlzXG4gKiB1cGRhdGVkIGJ5IHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgYSBwb3NpdGlvbiBzdGlja3kgYmFzZWQgY29udGFpbmVyLlxuICovXG5jbGFzcyBDYW52YXNJbWFnZVNlcXVlbmNlU2FtcGxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coJ2NhbnZhcyBpbWFnZSBzZXF1ZW5jZScpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5jYW52YXNDb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbnZhcy1jb250YWluZXInKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyZW50Jyk7IC8vIEluc3RhbmNlIG9mIHJhZlByb2dyZXNzLlxuXG4gICAgdGhpcy5yYWZQcm9ncmVzcyA9IG5ldyBfcmFmUHJvZ3Jlc3MuUmFmUHJvZ3Jlc3MoKTsgLy8gVXBkYXRlIHRoZSBwcm9ncmVzcyB2YWx1ZSBwZXIgc2Nyb2xsLlxuXG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Njcm9sbCcsXG4gICAgICBjYWxsYmFjazogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAwLjI1LCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gICAgICB9LFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTsgLy8gVXBkYXRlIHByb2dyZXNzIGltbWVkaWF0ZWx5IG9uIGxvYWQuXG5cbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDEsIF9lYXNlLkVBU0UuTGluZWFyKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzLndhdGNoKHRoaXMub25Qcm9ncmVzc1VwZGF0ZS5iaW5kKHRoaXMpKTsgLy8gR2VuZXJhdGUgaW1hZ2Ugc291cmNlcy5cblxuICAgIHRoaXMuY2FudmFzSW1hZ2VTb3VyY2VzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSAxNTM7IGkrKykge1xuICAgICAgbGV0IHZhbHVlID0gaSArICcnO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5wYWRTdGFydCg0LCAnMCcpO1xuICAgICAgdGhpcy5jYW52YXNJbWFnZVNvdXJjZXMucHVzaCgnLi9wdWJsaWMvZnJhbWVzL3RodW1iJyArIHZhbHVlICsgJy5qcGcnKTtcbiAgICB9IC8vIENyZWF0ZSBDYW52YXMgSW1hZ2UgU2VxdWVuZWNlXG5cblxuICAgIHRoaXMuY2FudmFzSW1hZ2VTZXF1ZW5jZSA9IG5ldyBfY2FudmFzSW1hZ2VTZXF1ZW5jZS5DYW52YXNJbWFnZVNlcXVlbmNlKHRoaXMuY2FudmFzQ29udGFpbmVyRWxlbWVudCwgW3tcbiAgICAgIGltYWdlczogdGhpcy5jYW52YXNJbWFnZVNvdXJjZXNcbiAgICB9XSwge1xuICAgICAgYXJpYUxhYmVsOiAnQXJpYSBsYWJlbCB0ZXN0J1xuICAgIH0pOyAvLyB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UubGVycEFtb3VudCA9IDAuMDI7XG4gICAgLy8gTG9hZCB0aGUgaWFtZ2VzLlxuXG4gICAgdGhpcy5jYW52YXNJbWFnZVNlcXVlbmNlLmxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIFdoZW4gcmVhZHkgcmVuZGVyIHdoYXRldmVyIHRoZSBjdXJyZW50IGVhc2VkUHJvZ3Jlc3MgdmFsdWUgaXMuXG4gICAgICB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UucmVuZGVyQnlQcm9ncmVzcyh0aGlzLnJhZlByb2dyZXNzLmN1cnJlbnRQcm9ncmVzcyk7XG4gICAgfSk7XG4gIH1cblxuICBvblByb2dyZXNzVXBkYXRlKGVhc2VkUHJvZ3Jlc3MsIGRpcmVjdGlvbikge1xuICAgIHRoaXMuY2FudmFzSW1hZ2VTZXF1ZW5jZS5yZW5kZXJCeVByb2dyZXNzKGVhc2VkUHJvZ3Jlc3MpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2FudmFzSW1hZ2VTZXF1ZW5jZVNhbXBsZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/canvas-image-sequence.js\n");

/***/ }),

/***/ "./examples/canvas-image-sequence10.js":
/*!*********************************************!*\
  !*** ./examples/canvas-image-sequence10.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _canvasImageSequence = __webpack_require__(/*! ../lib/dom/canvas-image-sequence */ \"./lib/dom/canvas-image-sequence.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\n/**\n * This sample show loading multiple image sets\n */\nclass CanvasImageSequenceSample10 {\n  constructor() {\n    console.log('canvas image sequence 10');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Instance of rafProgress.\n\n    this.rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        this.rafProgress.easeTo(this.progress, 0.25, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.rafProgress.watch(this.onProgressUpdate.bind(this)); // Generate image sources.\n\n    this.canvasImageSources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.canvasImageSources.push('./public/frames/thumb' + value + '.jpg');\n    } // Generate a second \"mobile\" image sources.\n\n\n    this.mobileImageSources = [];\n\n    for (let i = 1; i <= 120; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.mobileImageSources.push('./public/frames2/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.canvasImageSequence = new _canvasImageSequence.CanvasImageSequence(this.canvasContainerElement, [{\n      images: this.canvasImageSources,\n      when: () => {\n        return window.innerWidth >= 768;\n      }\n    }, {\n      images: this.mobileImageSources,\n      when: () => {\n        return window.innerWidth < 768;\n      }\n    }]); // this.canvasImageSequence.lerpAmount = 0.02;\n    // Load the iamges.\n\n    this.canvasImageSequence.load().then(() => {\n      // When ready render whatever the current easedProgress value is.\n      this.canvasImageSequence.renderByProgress(this.rafProgress.currentProgress);\n    });\n  }\n\n  onProgressUpdate(easedProgress, direction) {\n    this.canvasImageSequence.renderByProgress(easedProgress); // On each update event, we are going to acquire the pixel\n    // colors at coordinate x,y.\n\n    const hexColor = this.canvasImageSequence.getHexColorAtPoint(new _vector.Vector(500, 500));\n    console.log(hexColor); // Now we set the background to that color.\n\n    this.parentElement.style.backgroundColor = hexColor;\n  }\n\n}\n\nexports.default = CanvasImageSequenceSample10;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9jYW52YXMtaW1hZ2Utc2VxdWVuY2UxMC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2NhbnZhcy1pbWFnZS1zZXF1ZW5jZTEwLmpzPzMyOGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWYtcHJvZ3Jlc3NcIik7XG5cbnZhciBfY2FudmFzSW1hZ2VTZXF1ZW5jZSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2NhbnZhcy1pbWFnZS1zZXF1ZW5jZVwiKTtcblxudmFyIF9lYXNlID0gcmVxdWlyZShcIi4uL2xpYi9lYXNlL2Vhc2VcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL3ZlY3RvclwiKTtcblxuLyoqXG4gKiBUaGlzIHNhbXBsZSBzaG93IGxvYWRpbmcgbXVsdGlwbGUgaW1hZ2Ugc2V0c1xuICovXG5jbGFzcyBDYW52YXNJbWFnZVNlcXVlbmNlU2FtcGxlMTAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygnY2FudmFzIGltYWdlIHNlcXVlbmNlIDEwJyk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLWNvbnRhaW5lcicpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJlbnQnKTsgLy8gSW5zdGFuY2Ugb2YgcmFmUHJvZ3Jlc3MuXG5cbiAgICB0aGlzLnJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcygpOyAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIHZhbHVlIHBlciBzY3JvbGwuXG5cbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnc2Nyb2xsJyxcbiAgICAgIGNhbGxiYWNrOiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDAuMjUsIF9lYXNlLkVBU0UuTGluZWFyKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pOyAvLyBVcGRhdGUgcHJvZ3Jlc3MgaW1tZWRpYXRlbHkgb24gbG9hZC5cblxuICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMSwgX2Vhc2UuRUFTRS5MaW5lYXIpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3Mud2F0Y2godGhpcy5vblByb2dyZXNzVXBkYXRlLmJpbmQodGhpcykpOyAvLyBHZW5lcmF0ZSBpbWFnZSBzb3VyY2VzLlxuXG4gICAgdGhpcy5jYW52YXNJbWFnZVNvdXJjZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IDE1MzsgaSsrKSB7XG4gICAgICBsZXQgdmFsdWUgPSBpICsgJyc7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnBhZFN0YXJ0KDQsICcwJyk7XG4gICAgICB0aGlzLmNhbnZhc0ltYWdlU291cmNlcy5wdXNoKCcuL3B1YmxpYy9mcmFtZXMvdGh1bWInICsgdmFsdWUgKyAnLmpwZycpO1xuICAgIH0gLy8gR2VuZXJhdGUgYSBzZWNvbmQgXCJtb2JpbGVcIiBpbWFnZSBzb3VyY2VzLlxuXG5cbiAgICB0aGlzLm1vYmlsZUltYWdlU291cmNlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMTIwOyBpKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9IGkgKyAnJztcbiAgICAgIHZhbHVlID0gdmFsdWUucGFkU3RhcnQoNCwgJzAnKTtcbiAgICAgIHRoaXMubW9iaWxlSW1hZ2VTb3VyY2VzLnB1c2goJy4vcHVibGljL2ZyYW1lczIvdGh1bWInICsgdmFsdWUgKyAnLmpwZycpO1xuICAgIH0gLy8gQ3JlYXRlIENhbnZhcyBJbWFnZSBTZXF1ZW5lY2VcblxuXG4gICAgdGhpcy5jYW52YXNJbWFnZVNlcXVlbmNlID0gbmV3IF9jYW52YXNJbWFnZVNlcXVlbmNlLkNhbnZhc0ltYWdlU2VxdWVuY2UodGhpcy5jYW52YXNDb250YWluZXJFbGVtZW50LCBbe1xuICAgICAgaW1hZ2VzOiB0aGlzLmNhbnZhc0ltYWdlU291cmNlcyxcbiAgICAgIHdoZW46ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoID49IDc2ODtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBpbWFnZXM6IHRoaXMubW9iaWxlSW1hZ2VTb3VyY2VzLFxuICAgICAgd2hlbjogKCkgPT4ge1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggPCA3Njg7XG4gICAgICB9XG4gICAgfV0pOyAvLyB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UubGVycEFtb3VudCA9IDAuMDI7XG4gICAgLy8gTG9hZCB0aGUgaWFtZ2VzLlxuXG4gICAgdGhpcy5jYW52YXNJbWFnZVNlcXVlbmNlLmxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIFdoZW4gcmVhZHkgcmVuZGVyIHdoYXRldmVyIHRoZSBjdXJyZW50IGVhc2VkUHJvZ3Jlc3MgdmFsdWUgaXMuXG4gICAgICB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UucmVuZGVyQnlQcm9ncmVzcyh0aGlzLnJhZlByb2dyZXNzLmN1cnJlbnRQcm9ncmVzcyk7XG4gICAgfSk7XG4gIH1cblxuICBvblByb2dyZXNzVXBkYXRlKGVhc2VkUHJvZ3Jlc3MsIGRpcmVjdGlvbikge1xuICAgIHRoaXMuY2FudmFzSW1hZ2VTZXF1ZW5jZS5yZW5kZXJCeVByb2dyZXNzKGVhc2VkUHJvZ3Jlc3MpOyAvLyBPbiBlYWNoIHVwZGF0ZSBldmVudCwgd2UgYXJlIGdvaW5nIHRvIGFjcXVpcmUgdGhlIHBpeGVsXG4gICAgLy8gY29sb3JzIGF0IGNvb3JkaW5hdGUgeCx5LlxuXG4gICAgY29uc3QgaGV4Q29sb3IgPSB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UuZ2V0SGV4Q29sb3JBdFBvaW50KG5ldyBfdmVjdG9yLlZlY3Rvcig1MDAsIDUwMCkpO1xuICAgIGNvbnNvbGUubG9nKGhleENvbG9yKTsgLy8gTm93IHdlIHNldCB0aGUgYmFja2dyb3VuZCB0byB0aGF0IGNvbG9yLlxuXG4gICAgdGhpcy5wYXJlbnRFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGhleENvbG9yO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2FudmFzSW1hZ2VTZXF1ZW5jZVNhbXBsZTEwOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/canvas-image-sequence10.js\n");

/***/ }),

/***/ "./examples/canvas-image-sequence2.js":
/*!********************************************!*\
  !*** ./examples/canvas-image-sequence2.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _canvasImageSequence = __webpack_require__(/*! ../lib/dom/canvas-image-sequence */ \"./lib/dom/canvas-image-sequence.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\n/**\n * This sample expands on canvas image sequence sample 1 and demonstrates\n * usage of multiinterpolate.\n */\nclass CanvasImageSequenceSample2 {\n  constructor() {\n    console.log('canvas image sequence2');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Instance of rafProgress.\n\n    this.rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        this.rafProgress.easeTo(this.progress, 0.25, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.rafProgress.watch(this.onProgressUpdate.bind(this)); // Generate image sources.\n\n    this.canvasImageSources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.canvasImageSources.push('./public/frames/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.canvasImageSequence = new _canvasImageSequence.CanvasImageSequence(this.canvasContainerElement, [{\n      images: this.canvasImageSources\n    }]);\n    let progressPoints = [{\n      from: 0,\n      to: 0.5,\n      start: 0,\n      end: 1\n    }, {\n      from: 0.5,\n      to: 1,\n      start: 1,\n      end: 0\n    }];\n    this.canvasImageSequence.setMultiInterpolation(progressPoints); // Load the iamges.\n\n    this.canvasImageSequence.load().then(() => {\n      // When ready render whatever the current easedProgress value is.\n      this.canvasImageSequence.renderByProgress(this.rafProgress.currentProgress);\n    });\n  }\n\n  onProgressUpdate(easedProgress, direction) {\n    this.canvasImageSequence.renderByProgress(easedProgress);\n  }\n\n}\n\nexports.default = CanvasImageSequenceSample2;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9jYW52YXMtaW1hZ2Utc2VxdWVuY2UyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvY2FudmFzLWltYWdlLXNlcXVlbmNlMi5qcz9hZWM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JhZlByb2dyZXNzID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmLXByb2dyZXNzXCIpO1xuXG52YXIgX2NhbnZhc0ltYWdlU2VxdWVuY2UgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9jYW52YXMtaW1hZ2Utc2VxdWVuY2VcIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG52YXIgX2RvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbVwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbi8qKlxuICogVGhpcyBzYW1wbGUgZXhwYW5kcyBvbiBjYW52YXMgaW1hZ2Ugc2VxdWVuY2Ugc2FtcGxlIDEgYW5kIGRlbW9uc3RyYXRlc1xuICogdXNhZ2Ugb2YgbXVsdGlpbnRlcnBvbGF0ZS5cbiAqL1xuY2xhc3MgQ2FudmFzSW1hZ2VTZXF1ZW5jZVNhbXBsZTIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygnY2FudmFzIGltYWdlIHNlcXVlbmNlMicpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5jYW52YXNDb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbnZhcy1jb250YWluZXInKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyZW50Jyk7IC8vIEluc3RhbmNlIG9mIHJhZlByb2dyZXNzLlxuXG4gICAgdGhpcy5yYWZQcm9ncmVzcyA9IG5ldyBfcmFmUHJvZ3Jlc3MuUmFmUHJvZ3Jlc3MoKTsgLy8gVXBkYXRlIHRoZSBwcm9ncmVzcyB2YWx1ZSBwZXIgc2Nyb2xsLlxuXG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Njcm9sbCcsXG4gICAgICBjYWxsYmFjazogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAwLjI1LCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gICAgICB9LFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTsgLy8gVXBkYXRlIHByb2dyZXNzIGltbWVkaWF0ZWx5IG9uIGxvYWQuXG5cbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDEsIF9lYXNlLkVBU0UuTGluZWFyKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzLndhdGNoKHRoaXMub25Qcm9ncmVzc1VwZGF0ZS5iaW5kKHRoaXMpKTsgLy8gR2VuZXJhdGUgaW1hZ2Ugc291cmNlcy5cblxuICAgIHRoaXMuY2FudmFzSW1hZ2VTb3VyY2VzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSAxNTM7IGkrKykge1xuICAgICAgbGV0IHZhbHVlID0gaSArICcnO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5wYWRTdGFydCg0LCAnMCcpO1xuICAgICAgdGhpcy5jYW52YXNJbWFnZVNvdXJjZXMucHVzaCgnLi9wdWJsaWMvZnJhbWVzL3RodW1iJyArIHZhbHVlICsgJy5qcGcnKTtcbiAgICB9IC8vIENyZWF0ZSBDYW52YXMgSW1hZ2UgU2VxdWVuZWNlXG5cblxuICAgIHRoaXMuY2FudmFzSW1hZ2VTZXF1ZW5jZSA9IG5ldyBfY2FudmFzSW1hZ2VTZXF1ZW5jZS5DYW52YXNJbWFnZVNlcXVlbmNlKHRoaXMuY2FudmFzQ29udGFpbmVyRWxlbWVudCwgW3tcbiAgICAgIGltYWdlczogdGhpcy5jYW52YXNJbWFnZVNvdXJjZXNcbiAgICB9XSk7XG4gICAgbGV0IHByb2dyZXNzUG9pbnRzID0gW3tcbiAgICAgIGZyb206IDAsXG4gICAgICB0bzogMC41LFxuICAgICAgc3RhcnQ6IDAsXG4gICAgICBlbmQ6IDFcbiAgICB9LCB7XG4gICAgICBmcm9tOiAwLjUsXG4gICAgICB0bzogMSxcbiAgICAgIHN0YXJ0OiAxLFxuICAgICAgZW5kOiAwXG4gICAgfV07XG4gICAgdGhpcy5jYW52YXNJbWFnZVNlcXVlbmNlLnNldE11bHRpSW50ZXJwb2xhdGlvbihwcm9ncmVzc1BvaW50cyk7IC8vIExvYWQgdGhlIGlhbWdlcy5cblxuICAgIHRoaXMuY2FudmFzSW1hZ2VTZXF1ZW5jZS5sb2FkKCkudGhlbigoKSA9PiB7XG4gICAgICAvLyBXaGVuIHJlYWR5IHJlbmRlciB3aGF0ZXZlciB0aGUgY3VycmVudCBlYXNlZFByb2dyZXNzIHZhbHVlIGlzLlxuICAgICAgdGhpcy5jYW52YXNJbWFnZVNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3ModGhpcy5yYWZQcm9ncmVzcy5jdXJyZW50UHJvZ3Jlc3MpO1xuICAgIH0pO1xuICB9XG5cbiAgb25Qcm9ncmVzc1VwZGF0ZShlYXNlZFByb2dyZXNzLCBkaXJlY3Rpb24pIHtcbiAgICB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UucmVuZGVyQnlQcm9ncmVzcyhlYXNlZFByb2dyZXNzKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc0ltYWdlU2VxdWVuY2VTYW1wbGUyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/canvas-image-sequence2.js\n");

/***/ }),

/***/ "./examples/canvas-image-sequence3.js":
/*!********************************************!*\
  !*** ./examples/canvas-image-sequence3.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _canvasImageSequence = __webpack_require__(/*! ../lib/dom/canvas-image-sequence */ \"./lib/dom/canvas-image-sequence.js\");\n\n/**\n * CanvasImageSequence play feature.\n */\nclass CanvasImageSequenceSample3 {\n  constructor() {\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Generate image sources.\n\n    this.canvasImageSources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.canvasImageSources.push('./public/frames/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.canvasImageSequence = new _canvasImageSequence.CanvasImageSequence(this.canvasContainerElement, [{\n      images: this.canvasImageSources\n    }]);\n    let progressPoints = [{\n      from: 0,\n      to: 0.5,\n      start: 0,\n      end: 1\n    }, {\n      from: 0.5,\n      to: 1,\n      start: 1,\n      end: 0\n    }];\n    this.canvasImageSequence.setMultiInterpolation(progressPoints); // Load the iamges.\n\n    this.canvasImageSequence.load().then(() => {\n      // On load, play the sequence from 0 - 1.\n      this.canvasImageSequence.play(0, 1, 3000).then(() => {\n        console.log('play complete');\n      });\n    });\n  }\n\n}\n\nexports.default = CanvasImageSequenceSample3;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9jYW52YXMtaW1hZ2Utc2VxdWVuY2UzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvY2FudmFzLWltYWdlLXNlcXVlbmNlMy5qcz9lZjkxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NhbnZhc0ltYWdlU2VxdWVuY2UgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9jYW52YXMtaW1hZ2Utc2VxdWVuY2VcIik7XG5cbi8qKlxuICogQ2FudmFzSW1hZ2VTZXF1ZW5jZSBwbGF5IGZlYXR1cmUuXG4gKi9cbmNsYXNzIENhbnZhc0ltYWdlU2VxdWVuY2VTYW1wbGUzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jYW52YXNDb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbnZhcy1jb250YWluZXInKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyZW50Jyk7IC8vIEdlbmVyYXRlIGltYWdlIHNvdXJjZXMuXG5cbiAgICB0aGlzLmNhbnZhc0ltYWdlU291cmNlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMTUzOyBpKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9IGkgKyAnJztcbiAgICAgIHZhbHVlID0gdmFsdWUucGFkU3RhcnQoNCwgJzAnKTtcbiAgICAgIHRoaXMuY2FudmFzSW1hZ2VTb3VyY2VzLnB1c2goJy4vcHVibGljL2ZyYW1lcy90aHVtYicgKyB2YWx1ZSArICcuanBnJyk7XG4gICAgfSAvLyBDcmVhdGUgQ2FudmFzIEltYWdlIFNlcXVlbmVjZVxuXG5cbiAgICB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UgPSBuZXcgX2NhbnZhc0ltYWdlU2VxdWVuY2UuQ2FudmFzSW1hZ2VTZXF1ZW5jZSh0aGlzLmNhbnZhc0NvbnRhaW5lckVsZW1lbnQsIFt7XG4gICAgICBpbWFnZXM6IHRoaXMuY2FudmFzSW1hZ2VTb3VyY2VzXG4gICAgfV0pO1xuICAgIGxldCBwcm9ncmVzc1BvaW50cyA9IFt7XG4gICAgICBmcm9tOiAwLFxuICAgICAgdG86IDAuNSxcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiAxXG4gICAgfSwge1xuICAgICAgZnJvbTogMC41LFxuICAgICAgdG86IDEsXG4gICAgICBzdGFydDogMSxcbiAgICAgIGVuZDogMFxuICAgIH1dO1xuICAgIHRoaXMuY2FudmFzSW1hZ2VTZXF1ZW5jZS5zZXRNdWx0aUludGVycG9sYXRpb24ocHJvZ3Jlc3NQb2ludHMpOyAvLyBMb2FkIHRoZSBpYW1nZXMuXG5cbiAgICB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UubG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gT24gbG9hZCwgcGxheSB0aGUgc2VxdWVuY2UgZnJvbSAwIC0gMS5cbiAgICAgIHRoaXMuY2FudmFzSW1hZ2VTZXF1ZW5jZS5wbGF5KDAsIDEsIDMwMDApLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygncGxheSBjb21wbGV0ZScpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBDYW52YXNJbWFnZVNlcXVlbmNlU2FtcGxlMzsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/canvas-image-sequence3.js\n");

/***/ }),

/***/ "./examples/canvas-image-sequence4.js":
/*!********************************************!*\
  !*** ./examples/canvas-image-sequence4.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _canvasImageSequence = __webpack_require__(/*! ../lib/dom/canvas-image-sequence */ \"./lib/dom/canvas-image-sequence.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\n/**\n * This sample expands on canvas image sequence sample 1 and demonstrates\n * usage of multiinterpolate.\n */\nclass CanvasImageSequenceSample3 {\n  constructor() {\n    console.log('canvas image sequence4');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Instance of rafProgress.\n\n    this.rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        this.rafProgress.easeTo(this.progress, 0.25, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.rafProgress.watch(this.onProgressUpdate.bind(this)); // Generate image sources.\n\n    this.canvasImageSources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.canvasImageSources.push('./public/frames/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.canvasImageSequence = new _canvasImageSequence.CanvasImageSequence(this.canvasContainerElement, [{\n      images: this.canvasImageSources\n    }]); // We set the lerp value.\n\n    this.canvasImageSequence.lerpAmount = 0.01; // Load the iamges.\n\n    this.canvasImageSequence.load().then(() => {\n      // On load, play the sequence from 0 - 1.\n      this.canvasImageSequence.play(0, 1, 1000).then(() => {\n        console.log('done', this.rafProgress.currentProgress); // Update the progress to the current scroll when done.\n        //\n        // At this time, the playing ends at 1 but the scroll progress\n        // could be something else so it will lerp \"towards\" the\n        // scroll position since we have lerp set.\n\n        this.canvasImageSequence.renderByProgress(this.rafProgress.currentProgress);\n      });\n    });\n  }\n\n  onProgressUpdate(easedProgress, direction) {\n    this.canvasImageSequence.renderByProgress(easedProgress);\n  }\n\n}\n\nexports.default = CanvasImageSequenceSample3;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9jYW52YXMtaW1hZ2Utc2VxdWVuY2U0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvY2FudmFzLWltYWdlLXNlcXVlbmNlNC5qcz9mMmJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JhZlByb2dyZXNzID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmLXByb2dyZXNzXCIpO1xuXG52YXIgX2NhbnZhc0ltYWdlU2VxdWVuY2UgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9jYW52YXMtaW1hZ2Utc2VxdWVuY2VcIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG52YXIgX2RvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbVwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbi8qKlxuICogVGhpcyBzYW1wbGUgZXhwYW5kcyBvbiBjYW52YXMgaW1hZ2Ugc2VxdWVuY2Ugc2FtcGxlIDEgYW5kIGRlbW9uc3RyYXRlc1xuICogdXNhZ2Ugb2YgbXVsdGlpbnRlcnBvbGF0ZS5cbiAqL1xuY2xhc3MgQ2FudmFzSW1hZ2VTZXF1ZW5jZVNhbXBsZTMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygnY2FudmFzIGltYWdlIHNlcXVlbmNlNCcpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5jYW52YXNDb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbnZhcy1jb250YWluZXInKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyZW50Jyk7IC8vIEluc3RhbmNlIG9mIHJhZlByb2dyZXNzLlxuXG4gICAgdGhpcy5yYWZQcm9ncmVzcyA9IG5ldyBfcmFmUHJvZ3Jlc3MuUmFmUHJvZ3Jlc3MoKTsgLy8gVXBkYXRlIHRoZSBwcm9ncmVzcyB2YWx1ZSBwZXIgc2Nyb2xsLlxuXG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Njcm9sbCcsXG4gICAgICBjYWxsYmFjazogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAwLjI1LCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gICAgICB9LFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTsgLy8gVXBkYXRlIHByb2dyZXNzIGltbWVkaWF0ZWx5IG9uIGxvYWQuXG5cbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDEsIF9lYXNlLkVBU0UuTGluZWFyKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzLndhdGNoKHRoaXMub25Qcm9ncmVzc1VwZGF0ZS5iaW5kKHRoaXMpKTsgLy8gR2VuZXJhdGUgaW1hZ2Ugc291cmNlcy5cblxuICAgIHRoaXMuY2FudmFzSW1hZ2VTb3VyY2VzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSAxNTM7IGkrKykge1xuICAgICAgbGV0IHZhbHVlID0gaSArICcnO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5wYWRTdGFydCg0LCAnMCcpO1xuICAgICAgdGhpcy5jYW52YXNJbWFnZVNvdXJjZXMucHVzaCgnLi9wdWJsaWMvZnJhbWVzL3RodW1iJyArIHZhbHVlICsgJy5qcGcnKTtcbiAgICB9IC8vIENyZWF0ZSBDYW52YXMgSW1hZ2UgU2VxdWVuZWNlXG5cblxuICAgIHRoaXMuY2FudmFzSW1hZ2VTZXF1ZW5jZSA9IG5ldyBfY2FudmFzSW1hZ2VTZXF1ZW5jZS5DYW52YXNJbWFnZVNlcXVlbmNlKHRoaXMuY2FudmFzQ29udGFpbmVyRWxlbWVudCwgW3tcbiAgICAgIGltYWdlczogdGhpcy5jYW52YXNJbWFnZVNvdXJjZXNcbiAgICB9XSk7IC8vIFdlIHNldCB0aGUgbGVycCB2YWx1ZS5cblxuICAgIHRoaXMuY2FudmFzSW1hZ2VTZXF1ZW5jZS5sZXJwQW1vdW50ID0gMC4wMTsgLy8gTG9hZCB0aGUgaWFtZ2VzLlxuXG4gICAgdGhpcy5jYW52YXNJbWFnZVNlcXVlbmNlLmxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIE9uIGxvYWQsIHBsYXkgdGhlIHNlcXVlbmNlIGZyb20gMCAtIDEuXG4gICAgICB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UucGxheSgwLCAxLCAxMDAwKS50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ2RvbmUnLCB0aGlzLnJhZlByb2dyZXNzLmN1cnJlbnRQcm9ncmVzcyk7IC8vIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MgdG8gdGhlIGN1cnJlbnQgc2Nyb2xsIHdoZW4gZG9uZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQXQgdGhpcyB0aW1lLCB0aGUgcGxheWluZyBlbmRzIGF0IDEgYnV0IHRoZSBzY3JvbGwgcHJvZ3Jlc3NcbiAgICAgICAgLy8gY291bGQgYmUgc29tZXRoaW5nIGVsc2Ugc28gaXQgd2lsbCBsZXJwIFwidG93YXJkc1wiIHRoZVxuICAgICAgICAvLyBzY3JvbGwgcG9zaXRpb24gc2luY2Ugd2UgaGF2ZSBsZXJwIHNldC5cblxuICAgICAgICB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UucmVuZGVyQnlQcm9ncmVzcyh0aGlzLnJhZlByb2dyZXNzLmN1cnJlbnRQcm9ncmVzcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uUHJvZ3Jlc3NVcGRhdGUoZWFzZWRQcm9ncmVzcywgZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5jYW52YXNJbWFnZVNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3MoZWFzZWRQcm9ncmVzcyk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBDYW52YXNJbWFnZVNlcXVlbmNlU2FtcGxlMzsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/canvas-image-sequence4.js\n");

/***/ }),

/***/ "./examples/canvas-image-sequence5.js":
/*!********************************************!*\
  !*** ./examples/canvas-image-sequence5.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _canvasImageSequence = __webpack_require__(/*! ../lib/dom/canvas-image-sequence */ \"./lib/dom/canvas-image-sequence.js\");\n\n/**\n * CanvasImageSequence play feature.\n */\nclass CanvasImageSequenceSample5 {\n  constructor() {\n    console.log('canvasImageSequence5');\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Generate image sources.\n\n    this.canvasImageSources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.canvasImageSources.push('./public/frames/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.canvasImageSequence = new _canvasImageSequence.CanvasImageSequence(this.canvasContainerElement, [{\n      images: this.canvasImageSources\n    }]);\n    this.canvasImageSequence.lerpAmount = 0.01;\n    this.canvasImageSequence.load().then(() => {\n      this.canvasImageSequence.renderByProgress(0); // Immediately set to 1.  Because we previously set it to 0 and\n      // no 1 and we have lerp set, canvasImageSequence will lerp\n      // towards that value.\n\n      this.canvasImageSequence.renderByProgress(1);\n    });\n  }\n\n}\n\nexports.default = CanvasImageSequenceSample5;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9jYW52YXMtaW1hZ2Utc2VxdWVuY2U1LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvY2FudmFzLWltYWdlLXNlcXVlbmNlNS5qcz80ZTBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NhbnZhc0ltYWdlU2VxdWVuY2UgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9jYW52YXMtaW1hZ2Utc2VxdWVuY2VcIik7XG5cbi8qKlxuICogQ2FudmFzSW1hZ2VTZXF1ZW5jZSBwbGF5IGZlYXR1cmUuXG4gKi9cbmNsYXNzIENhbnZhc0ltYWdlU2VxdWVuY2VTYW1wbGU1IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coJ2NhbnZhc0ltYWdlU2VxdWVuY2U1Jyk7XG4gICAgdGhpcy5jYW52YXNDb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbnZhcy1jb250YWluZXInKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyZW50Jyk7IC8vIEdlbmVyYXRlIGltYWdlIHNvdXJjZXMuXG5cbiAgICB0aGlzLmNhbnZhc0ltYWdlU291cmNlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMTUzOyBpKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9IGkgKyAnJztcbiAgICAgIHZhbHVlID0gdmFsdWUucGFkU3RhcnQoNCwgJzAnKTtcbiAgICAgIHRoaXMuY2FudmFzSW1hZ2VTb3VyY2VzLnB1c2goJy4vcHVibGljL2ZyYW1lcy90aHVtYicgKyB2YWx1ZSArICcuanBnJyk7XG4gICAgfSAvLyBDcmVhdGUgQ2FudmFzIEltYWdlIFNlcXVlbmVjZVxuXG5cbiAgICB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UgPSBuZXcgX2NhbnZhc0ltYWdlU2VxdWVuY2UuQ2FudmFzSW1hZ2VTZXF1ZW5jZSh0aGlzLmNhbnZhc0NvbnRhaW5lckVsZW1lbnQsIFt7XG4gICAgICBpbWFnZXM6IHRoaXMuY2FudmFzSW1hZ2VTb3VyY2VzXG4gICAgfV0pO1xuICAgIHRoaXMuY2FudmFzSW1hZ2VTZXF1ZW5jZS5sZXJwQW1vdW50ID0gMC4wMTtcbiAgICB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UubG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5jYW52YXNJbWFnZVNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3MoMCk7IC8vIEltbWVkaWF0ZWx5IHNldCB0byAxLiAgQmVjYXVzZSB3ZSBwcmV2aW91c2x5IHNldCBpdCB0byAwIGFuZFxuICAgICAgLy8gbm8gMSBhbmQgd2UgaGF2ZSBsZXJwIHNldCwgY2FudmFzSW1hZ2VTZXF1ZW5jZSB3aWxsIGxlcnBcbiAgICAgIC8vIHRvd2FyZHMgdGhhdCB2YWx1ZS5cblxuICAgICAgdGhpcy5jYW52YXNJbWFnZVNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3MoMSk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBDYW52YXNJbWFnZVNlcXVlbmNlU2FtcGxlNTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/canvas-image-sequence5.js\n");

/***/ }),

/***/ "./examples/canvas-image-sequence7.js":
/*!********************************************!*\
  !*** ./examples/canvas-image-sequence7.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _canvasImageSequence = __webpack_require__(/*! ../lib/dom/canvas-image-sequence */ \"./lib/dom/canvas-image-sequence.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\n/**\n * This sample demonstrates CanvasImageSequence sizing with cover\n */\nclass CanvasImageSequenceSample7 {\n  constructor() {\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Instance of rafProgress.\n\n    this.rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        this.rafProgress.easeTo(this.progress, 0.25, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.rafProgress.watch(this.onProgressUpdate.bind(this)); // Generate image sources.\n\n    this.canvasImageSources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.canvasImageSources.push('./public/frames/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.canvasImageSequence = new _canvasImageSequence.CanvasImageSequence(this.canvasContainerElement, [{\n      images: this.canvasImageSources\n    }], {\n      cover: true // top: 0,\n      // left: 0\n\n    }); // Load the images\n\n    this.canvasImageSequence.load().then(() => {\n      // When ready render whatever the current easedProgress value is.\n      this.canvasImageSequence.renderByProgress(this.rafProgress.currentProgress);\n    });\n  }\n\n  onProgressUpdate(easedProgress, direction) {\n    this.canvasImageSequence.renderByProgress(easedProgress);\n  }\n\n}\n\nexports.default = CanvasImageSequenceSample7;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9jYW52YXMtaW1hZ2Utc2VxdWVuY2U3LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvY2FudmFzLWltYWdlLXNlcXVlbmNlNy5qcz9mOWMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JhZlByb2dyZXNzID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmLXByb2dyZXNzXCIpO1xuXG52YXIgX2NhbnZhc0ltYWdlU2VxdWVuY2UgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9jYW52YXMtaW1hZ2Utc2VxdWVuY2VcIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG52YXIgX2RvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbVwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbi8qKlxuICogVGhpcyBzYW1wbGUgZGVtb25zdHJhdGVzIENhbnZhc0ltYWdlU2VxdWVuY2Ugc2l6aW5nIHdpdGggY292ZXJcbiAqL1xuY2xhc3MgQ2FudmFzSW1hZ2VTZXF1ZW5jZVNhbXBsZTcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRvbVdhdGNoZXIgPSBuZXcgX2RvbVdhdGNoZXIuRG9tV2F0Y2hlcigpO1xuICAgIHRoaXMuY2FudmFzQ29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXMtY29udGFpbmVyJyk7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcmVudCcpOyAvLyBJbnN0YW5jZSBvZiByYWZQcm9ncmVzcy5cblxuICAgIHRoaXMucmFmUHJvZ3Jlc3MgPSBuZXcgX3JhZlByb2dyZXNzLlJhZlByb2dyZXNzKCk7IC8vIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MgdmFsdWUgcGVyIHNjcm9sbC5cblxuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdzY3JvbGwnLFxuICAgICAgY2FsbGJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMC4yNSwgX2Vhc2UuRUFTRS5MaW5lYXIpO1xuICAgICAgfSxcbiAgICAgIGV2ZW50T3B0aW9uczoge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7IC8vIFVwZGF0ZSBwcm9ncmVzcyBpbW1lZGlhdGVseSBvbiBsb2FkLlxuXG4gICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAxLCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gICAgdGhpcy5yYWZQcm9ncmVzcy53YXRjaCh0aGlzLm9uUHJvZ3Jlc3NVcGRhdGUuYmluZCh0aGlzKSk7IC8vIEdlbmVyYXRlIGltYWdlIHNvdXJjZXMuXG5cbiAgICB0aGlzLmNhbnZhc0ltYWdlU291cmNlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMTUzOyBpKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9IGkgKyAnJztcbiAgICAgIHZhbHVlID0gdmFsdWUucGFkU3RhcnQoNCwgJzAnKTtcbiAgICAgIHRoaXMuY2FudmFzSW1hZ2VTb3VyY2VzLnB1c2goJy4vcHVibGljL2ZyYW1lcy90aHVtYicgKyB2YWx1ZSArICcuanBnJyk7XG4gICAgfSAvLyBDcmVhdGUgQ2FudmFzIEltYWdlIFNlcXVlbmVjZVxuXG5cbiAgICB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UgPSBuZXcgX2NhbnZhc0ltYWdlU2VxdWVuY2UuQ2FudmFzSW1hZ2VTZXF1ZW5jZSh0aGlzLmNhbnZhc0NvbnRhaW5lckVsZW1lbnQsIFt7XG4gICAgICBpbWFnZXM6IHRoaXMuY2FudmFzSW1hZ2VTb3VyY2VzXG4gICAgfV0sIHtcbiAgICAgIGNvdmVyOiB0cnVlIC8vIHRvcDogMCxcbiAgICAgIC8vIGxlZnQ6IDBcblxuICAgIH0pOyAvLyBMb2FkIHRoZSBpbWFnZXNcblxuICAgIHRoaXMuY2FudmFzSW1hZ2VTZXF1ZW5jZS5sb2FkKCkudGhlbigoKSA9PiB7XG4gICAgICAvLyBXaGVuIHJlYWR5IHJlbmRlciB3aGF0ZXZlciB0aGUgY3VycmVudCBlYXNlZFByb2dyZXNzIHZhbHVlIGlzLlxuICAgICAgdGhpcy5jYW52YXNJbWFnZVNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3ModGhpcy5yYWZQcm9ncmVzcy5jdXJyZW50UHJvZ3Jlc3MpO1xuICAgIH0pO1xuICB9XG5cbiAgb25Qcm9ncmVzc1VwZGF0ZShlYXNlZFByb2dyZXNzLCBkaXJlY3Rpb24pIHtcbiAgICB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UucmVuZGVyQnlQcm9ncmVzcyhlYXNlZFByb2dyZXNzKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc0ltYWdlU2VxdWVuY2VTYW1wbGU3OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/canvas-image-sequence7.js\n");

/***/ }),

/***/ "./examples/canvas-image-sequence8.js":
/*!********************************************!*\
  !*** ./examples/canvas-image-sequence8.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _canvasImageSequence = __webpack_require__(/*! ../lib/dom/canvas-image-sequence */ \"./lib/dom/canvas-image-sequence.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\n/**\n * This sample demonstrates CanvasImageSequence with clippings.\n */\nclass CanvasImageSequenceSample8 {\n  constructor() {\n    console.log('canvas image sequence sample 8');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Instance of rafProgress.\n\n    this.rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        this.rafProgress.easeTo(this.progress, 0.25, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.rafProgress.watch(this.onProgressUpdate.bind(this)); // Generate image sources.\n\n    this.canvasImageSources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.canvasImageSources.push('./public/frames/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.canvasImageSequence = new _canvasImageSequence.CanvasImageSequence(this.canvasContainerElement, [{\n      images: this.canvasImageSources\n    }], {\n      cover: true\n    }); // Apply clipping.\n\n    this.canvasImageSequence.setClipInterpolations({\n      type: 'inset',\n      interpolations: [{\n        progress: [{\n          from: 0,\n          to: 1,\n          start: 0.5,\n          end: 0\n        }],\n        id: 'top'\n      }, {\n        progress: [{\n          from: 0,\n          to: 1,\n          start: 0.5,\n          end: 0\n        }],\n        id: 'right'\n      }, {\n        progress: [{\n          from: 0,\n          to: 1,\n          start: 0.5,\n          end: 0\n        }],\n        id: 'bottom'\n      }, {\n        progress: [{\n          from: 0,\n          to: 1,\n          start: 0.5,\n          end: 0\n        }],\n        id: 'left'\n      }, {\n        progress: [{\n          from: 0,\n          to: 0.8,\n          start: 0,\n          end: 60\n        }, {\n          from: 0.8,\n          to: 1,\n          start: 60,\n          end: 0\n        }],\n        id: 'border-radius'\n      }]\n    }); // Load the images\n\n    this.canvasImageSequence.load().then(() => {\n      // When ready render whatever the current easedProgress value is.\n      this.canvasImageSequence.renderByProgress(this.rafProgress.currentProgress);\n    });\n  }\n\n  onProgressUpdate(easedProgress, direction) {\n    this.canvasImageSequence.renderByProgress(easedProgress);\n  }\n\n}\n\nexports.default = CanvasImageSequenceSample8;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9jYW52YXMtaW1hZ2Utc2VxdWVuY2U4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvY2FudmFzLWltYWdlLXNlcXVlbmNlOC5qcz9mYTVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JhZlByb2dyZXNzID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmLXByb2dyZXNzXCIpO1xuXG52YXIgX2NhbnZhc0ltYWdlU2VxdWVuY2UgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9jYW52YXMtaW1hZ2Utc2VxdWVuY2VcIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG52YXIgX2RvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbVwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbi8qKlxuICogVGhpcyBzYW1wbGUgZGVtb25zdHJhdGVzIENhbnZhc0ltYWdlU2VxdWVuY2Ugd2l0aCBjbGlwcGluZ3MuXG4gKi9cbmNsYXNzIENhbnZhc0ltYWdlU2VxdWVuY2VTYW1wbGU4IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coJ2NhbnZhcyBpbWFnZSBzZXF1ZW5jZSBzYW1wbGUgOCcpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5jYW52YXNDb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbnZhcy1jb250YWluZXInKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyZW50Jyk7IC8vIEluc3RhbmNlIG9mIHJhZlByb2dyZXNzLlxuXG4gICAgdGhpcy5yYWZQcm9ncmVzcyA9IG5ldyBfcmFmUHJvZ3Jlc3MuUmFmUHJvZ3Jlc3MoKTsgLy8gVXBkYXRlIHRoZSBwcm9ncmVzcyB2YWx1ZSBwZXIgc2Nyb2xsLlxuXG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Njcm9sbCcsXG4gICAgICBjYWxsYmFjazogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAwLjI1LCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gICAgICB9LFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTsgLy8gVXBkYXRlIHByb2dyZXNzIGltbWVkaWF0ZWx5IG9uIGxvYWQuXG5cbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDEsIF9lYXNlLkVBU0UuTGluZWFyKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzLndhdGNoKHRoaXMub25Qcm9ncmVzc1VwZGF0ZS5iaW5kKHRoaXMpKTsgLy8gR2VuZXJhdGUgaW1hZ2Ugc291cmNlcy5cblxuICAgIHRoaXMuY2FudmFzSW1hZ2VTb3VyY2VzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSAxNTM7IGkrKykge1xuICAgICAgbGV0IHZhbHVlID0gaSArICcnO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5wYWRTdGFydCg0LCAnMCcpO1xuICAgICAgdGhpcy5jYW52YXNJbWFnZVNvdXJjZXMucHVzaCgnLi9wdWJsaWMvZnJhbWVzL3RodW1iJyArIHZhbHVlICsgJy5qcGcnKTtcbiAgICB9IC8vIENyZWF0ZSBDYW52YXMgSW1hZ2UgU2VxdWVuZWNlXG5cblxuICAgIHRoaXMuY2FudmFzSW1hZ2VTZXF1ZW5jZSA9IG5ldyBfY2FudmFzSW1hZ2VTZXF1ZW5jZS5DYW52YXNJbWFnZVNlcXVlbmNlKHRoaXMuY2FudmFzQ29udGFpbmVyRWxlbWVudCwgW3tcbiAgICAgIGltYWdlczogdGhpcy5jYW52YXNJbWFnZVNvdXJjZXNcbiAgICB9XSwge1xuICAgICAgY292ZXI6IHRydWVcbiAgICB9KTsgLy8gQXBwbHkgY2xpcHBpbmcuXG5cbiAgICB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2Uuc2V0Q2xpcEludGVycG9sYXRpb25zKHtcbiAgICAgIHR5cGU6ICdpbnNldCcsXG4gICAgICBpbnRlcnBvbGF0aW9uczogW3tcbiAgICAgICAgcHJvZ3Jlc3M6IFt7XG4gICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICB0bzogMSxcbiAgICAgICAgICBzdGFydDogMC41LFxuICAgICAgICAgIGVuZDogMFxuICAgICAgICB9XSxcbiAgICAgICAgaWQ6ICd0b3AnXG4gICAgICB9LCB7XG4gICAgICAgIHByb2dyZXNzOiBbe1xuICAgICAgICAgIGZyb206IDAsXG4gICAgICAgICAgdG86IDEsXG4gICAgICAgICAgc3RhcnQ6IDAuNSxcbiAgICAgICAgICBlbmQ6IDBcbiAgICAgICAgfV0sXG4gICAgICAgIGlkOiAncmlnaHQnXG4gICAgICB9LCB7XG4gICAgICAgIHByb2dyZXNzOiBbe1xuICAgICAgICAgIGZyb206IDAsXG4gICAgICAgICAgdG86IDEsXG4gICAgICAgICAgc3RhcnQ6IDAuNSxcbiAgICAgICAgICBlbmQ6IDBcbiAgICAgICAgfV0sXG4gICAgICAgIGlkOiAnYm90dG9tJ1xuICAgICAgfSwge1xuICAgICAgICBwcm9ncmVzczogW3tcbiAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgIHRvOiAxLFxuICAgICAgICAgIHN0YXJ0OiAwLjUsXG4gICAgICAgICAgZW5kOiAwXG4gICAgICAgIH1dLFxuICAgICAgICBpZDogJ2xlZnQnXG4gICAgICB9LCB7XG4gICAgICAgIHByb2dyZXNzOiBbe1xuICAgICAgICAgIGZyb206IDAsXG4gICAgICAgICAgdG86IDAuOCxcbiAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICBlbmQ6IDYwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBmcm9tOiAwLjgsXG4gICAgICAgICAgdG86IDEsXG4gICAgICAgICAgc3RhcnQ6IDYwLFxuICAgICAgICAgIGVuZDogMFxuICAgICAgICB9XSxcbiAgICAgICAgaWQ6ICdib3JkZXItcmFkaXVzJ1xuICAgICAgfV1cbiAgICB9KTsgLy8gTG9hZCB0aGUgaW1hZ2VzXG5cbiAgICB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UubG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gV2hlbiByZWFkeSByZW5kZXIgd2hhdGV2ZXIgdGhlIGN1cnJlbnQgZWFzZWRQcm9ncmVzcyB2YWx1ZSBpcy5cbiAgICAgIHRoaXMuY2FudmFzSW1hZ2VTZXF1ZW5jZS5yZW5kZXJCeVByb2dyZXNzKHRoaXMucmFmUHJvZ3Jlc3MuY3VycmVudFByb2dyZXNzKTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uUHJvZ3Jlc3NVcGRhdGUoZWFzZWRQcm9ncmVzcywgZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5jYW52YXNJbWFnZVNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3MoZWFzZWRQcm9ncmVzcyk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBDYW52YXNJbWFnZVNlcXVlbmNlU2FtcGxlODsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/canvas-image-sequence8.js\n");

/***/ }),

/***/ "./examples/canvas-image-sequence9.js":
/*!********************************************!*\
  !*** ./examples/canvas-image-sequence9.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _canvasImageSequence = __webpack_require__(/*! ../lib/dom/canvas-image-sequence */ \"./lib/dom/canvas-image-sequence.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\n/**\n * This sample show loading multiple image sets\n */\nclass CanvasImageSequenceSample9 {\n  constructor() {\n    console.log('canvas image sequence');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Instance of rafProgress.\n\n    this.rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        this.rafProgress.easeTo(this.progress, 0.25, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.rafProgress.watch(this.onProgressUpdate.bind(this)); // Generate image sources.\n\n    this.canvasImageSources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.canvasImageSources.push('./public/frames/thumb' + value + '.jpg');\n    } // Generate a second \"mobile\" image sources.\n\n\n    this.mobileImageSources = [];\n\n    for (let i = 1; i <= 120; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.mobileImageSources.push('./public/frames2/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.canvasImageSequence = new _canvasImageSequence.CanvasImageSequence(this.canvasContainerElement, [{\n      images: this.canvasImageSources,\n      when: () => {\n        return window.innerWidth >= 768;\n      }\n    }, {\n      images: this.mobileImageSources,\n      when: () => {\n        return window.innerWidth < 768;\n      }\n    }]); // this.canvasImageSequence.lerpAmount = 0.02;\n    // Load the iamges.\n\n    this.canvasImageSequence.load().then(() => {\n      // When ready render whatever the current easedProgress value is.\n      this.canvasImageSequence.renderByProgress(this.rafProgress.currentProgress);\n    });\n  }\n\n  onProgressUpdate(easedProgress, direction) {\n    this.canvasImageSequence.renderByProgress(easedProgress);\n  }\n\n}\n\nexports.default = CanvasImageSequenceSample9;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9jYW52YXMtaW1hZ2Utc2VxdWVuY2U5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvY2FudmFzLWltYWdlLXNlcXVlbmNlOS5qcz9kODE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JhZlByb2dyZXNzID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmLXByb2dyZXNzXCIpO1xuXG52YXIgX2NhbnZhc0ltYWdlU2VxdWVuY2UgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9jYW52YXMtaW1hZ2Utc2VxdWVuY2VcIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG52YXIgX2RvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbVwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbi8qKlxuICogVGhpcyBzYW1wbGUgc2hvdyBsb2FkaW5nIG11bHRpcGxlIGltYWdlIHNldHNcbiAqL1xuY2xhc3MgQ2FudmFzSW1hZ2VTZXF1ZW5jZVNhbXBsZTkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygnY2FudmFzIGltYWdlIHNlcXVlbmNlJyk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLWNvbnRhaW5lcicpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJlbnQnKTsgLy8gSW5zdGFuY2Ugb2YgcmFmUHJvZ3Jlc3MuXG5cbiAgICB0aGlzLnJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcygpOyAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIHZhbHVlIHBlciBzY3JvbGwuXG5cbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnc2Nyb2xsJyxcbiAgICAgIGNhbGxiYWNrOiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDAuMjUsIF9lYXNlLkVBU0UuTGluZWFyKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pOyAvLyBVcGRhdGUgcHJvZ3Jlc3MgaW1tZWRpYXRlbHkgb24gbG9hZC5cblxuICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMSwgX2Vhc2UuRUFTRS5MaW5lYXIpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3Mud2F0Y2godGhpcy5vblByb2dyZXNzVXBkYXRlLmJpbmQodGhpcykpOyAvLyBHZW5lcmF0ZSBpbWFnZSBzb3VyY2VzLlxuXG4gICAgdGhpcy5jYW52YXNJbWFnZVNvdXJjZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IDE1MzsgaSsrKSB7XG4gICAgICBsZXQgdmFsdWUgPSBpICsgJyc7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnBhZFN0YXJ0KDQsICcwJyk7XG4gICAgICB0aGlzLmNhbnZhc0ltYWdlU291cmNlcy5wdXNoKCcuL3B1YmxpYy9mcmFtZXMvdGh1bWInICsgdmFsdWUgKyAnLmpwZycpO1xuICAgIH0gLy8gR2VuZXJhdGUgYSBzZWNvbmQgXCJtb2JpbGVcIiBpbWFnZSBzb3VyY2VzLlxuXG5cbiAgICB0aGlzLm1vYmlsZUltYWdlU291cmNlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMTIwOyBpKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9IGkgKyAnJztcbiAgICAgIHZhbHVlID0gdmFsdWUucGFkU3RhcnQoNCwgJzAnKTtcbiAgICAgIHRoaXMubW9iaWxlSW1hZ2VTb3VyY2VzLnB1c2goJy4vcHVibGljL2ZyYW1lczIvdGh1bWInICsgdmFsdWUgKyAnLmpwZycpO1xuICAgIH0gLy8gQ3JlYXRlIENhbnZhcyBJbWFnZSBTZXF1ZW5lY2VcblxuXG4gICAgdGhpcy5jYW52YXNJbWFnZVNlcXVlbmNlID0gbmV3IF9jYW52YXNJbWFnZVNlcXVlbmNlLkNhbnZhc0ltYWdlU2VxdWVuY2UodGhpcy5jYW52YXNDb250YWluZXJFbGVtZW50LCBbe1xuICAgICAgaW1hZ2VzOiB0aGlzLmNhbnZhc0ltYWdlU291cmNlcyxcbiAgICAgIHdoZW46ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoID49IDc2ODtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBpbWFnZXM6IHRoaXMubW9iaWxlSW1hZ2VTb3VyY2VzLFxuICAgICAgd2hlbjogKCkgPT4ge1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggPCA3Njg7XG4gICAgICB9XG4gICAgfV0pOyAvLyB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UubGVycEFtb3VudCA9IDAuMDI7XG4gICAgLy8gTG9hZCB0aGUgaWFtZ2VzLlxuXG4gICAgdGhpcy5jYW52YXNJbWFnZVNlcXVlbmNlLmxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIFdoZW4gcmVhZHkgcmVuZGVyIHdoYXRldmVyIHRoZSBjdXJyZW50IGVhc2VkUHJvZ3Jlc3MgdmFsdWUgaXMuXG4gICAgICB0aGlzLmNhbnZhc0ltYWdlU2VxdWVuY2UucmVuZGVyQnlQcm9ncmVzcyh0aGlzLnJhZlByb2dyZXNzLmN1cnJlbnRQcm9ncmVzcyk7XG4gICAgfSk7XG4gIH1cblxuICBvblByb2dyZXNzVXBkYXRlKGVhc2VkUHJvZ3Jlc3MsIGRpcmVjdGlvbikge1xuICAgIHRoaXMuY2FudmFzSW1hZ2VTZXF1ZW5jZS5yZW5kZXJCeVByb2dyZXNzKGVhc2VkUHJvZ3Jlc3MpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2FudmFzSW1hZ2VTZXF1ZW5jZVNhbXBsZTk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/canvas-image-sequence9.js\n");

/***/ }),

/***/ "./examples/carousel.js":
/*!******************************!*\
  !*** ./examples/carousel.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _carousel = __webpack_require__(/*! ../lib/ui/carousel/carousel */ \"./lib/ui/carousel/carousel.js\");\n\nvar _draggableSlide = __webpack_require__(/*! ../lib/ui/carousel/draggable-slide */ \"./lib/ui/carousel/draggable-slide.js\");\n\n/**\n * Sample showing two Carousel instances synced with CarouselSynchronizer.\n *\n * The top carousel uses the DraggableSlide transition and the bottom is\n * styled through CSS with no special interaction.\n */\nclass CarouselSample {\n  constructor() {\n    function easeOutBounce(x) {\n      const n1 = 7.5625;\n      const d1 = 2.75;\n\n      if (x < 1 / d1) {\n        return n1 * x * x;\n      } else if (x < 2 / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n      } else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n      } else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984375;\n      }\n    }\n\n    const a = new _carousel.Carousel(document.querySelector('.carousel--a'), Array.from(document.querySelectorAll('.carousel--a .slide')), {\n      autoplaySpeed: 3000,\n      loop: true,\n      transition: new _draggableSlide.DraggableSlide({\n        transitionTime: 2000,\n        easingFunction: easeOutBounce\n      })\n    });\n    const b = new _carousel.Carousel(document.querySelector('.nav'), Array.from(document.querySelectorAll('.nav .dot')), {\n      loop: true\n    });\n    const c = new _carousel.Carousel(document.querySelector('.carousel--c'), Array.from(document.querySelectorAll('.carousel--c .slide')), {\n      loop: false,\n      transition: 'draggable'\n    });\n    a.sync(b, c);\n    const d = new _carousel.Carousel(document.querySelector('.carousel--d'), Array.from(document.querySelectorAll('.carousel--d .slide')), {\n      loop: false,\n      transition: 'draggable'\n    });\n  }\n\n}\n\nexports.default = CarouselSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9jYXJvdXNlbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2Nhcm91c2VsLmpzPzdhNmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2Fyb3VzZWwgPSByZXF1aXJlKFwiLi4vbGliL3VpL2Nhcm91c2VsL2Nhcm91c2VsXCIpO1xuXG52YXIgX2RyYWdnYWJsZVNsaWRlID0gcmVxdWlyZShcIi4uL2xpYi91aS9jYXJvdXNlbC9kcmFnZ2FibGUtc2xpZGVcIik7XG5cbi8qKlxuICogU2FtcGxlIHNob3dpbmcgdHdvIENhcm91c2VsIGluc3RhbmNlcyBzeW5jZWQgd2l0aCBDYXJvdXNlbFN5bmNocm9uaXplci5cbiAqXG4gKiBUaGUgdG9wIGNhcm91c2VsIHVzZXMgdGhlIERyYWdnYWJsZVNsaWRlIHRyYW5zaXRpb24gYW5kIHRoZSBib3R0b20gaXNcbiAqIHN0eWxlZCB0aHJvdWdoIENTUyB3aXRoIG5vIHNwZWNpYWwgaW50ZXJhY3Rpb24uXG4gKi9cbmNsYXNzIENhcm91c2VsU2FtcGxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgZnVuY3Rpb24gZWFzZU91dEJvdW5jZSh4KSB7XG4gICAgICBjb25zdCBuMSA9IDcuNTYyNTtcbiAgICAgIGNvbnN0IGQxID0gMi43NTtcblxuICAgICAgaWYgKHggPCAxIC8gZDEpIHtcbiAgICAgICAgcmV0dXJuIG4xICogeCAqIHg7XG4gICAgICB9IGVsc2UgaWYgKHggPCAyIC8gZDEpIHtcbiAgICAgICAgcmV0dXJuIG4xICogKHggLT0gMS41IC8gZDEpICogeCArIDAuNzU7XG4gICAgICB9IGVsc2UgaWYgKHggPCAyLjUgLyBkMSkge1xuICAgICAgICByZXR1cm4gbjEgKiAoeCAtPSAyLjI1IC8gZDEpICogeCArIDAuOTM3NTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuMSAqICh4IC09IDIuNjI1IC8gZDEpICogeCArIDAuOTg0Mzc1O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGEgPSBuZXcgX2Nhcm91c2VsLkNhcm91c2VsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYXJvdXNlbC0tYScpLCBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXJvdXNlbC0tYSAuc2xpZGUnKSksIHtcbiAgICAgIGF1dG9wbGF5U3BlZWQ6IDMwMDAsXG4gICAgICBsb29wOiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbjogbmV3IF9kcmFnZ2FibGVTbGlkZS5EcmFnZ2FibGVTbGlkZSh7XG4gICAgICAgIHRyYW5zaXRpb25UaW1lOiAyMDAwLFxuICAgICAgICBlYXNpbmdGdW5jdGlvbjogZWFzZU91dEJvdW5jZVxuICAgICAgfSlcbiAgICB9KTtcbiAgICBjb25zdCBiID0gbmV3IF9jYXJvdXNlbC5DYXJvdXNlbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubmF2JyksIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm5hdiAuZG90JykpLCB7XG4gICAgICBsb29wOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgYyA9IG5ldyBfY2Fyb3VzZWwuQ2Fyb3VzZWwoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhcm91c2VsLS1jJyksIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhcm91c2VsLS1jIC5zbGlkZScpKSwge1xuICAgICAgbG9vcDogZmFsc2UsXG4gICAgICB0cmFuc2l0aW9uOiAnZHJhZ2dhYmxlJ1xuICAgIH0pO1xuICAgIGEuc3luYyhiLCBjKTtcbiAgICBjb25zdCBkID0gbmV3IF9jYXJvdXNlbC5DYXJvdXNlbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2Fyb3VzZWwtLWQnKSwgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2Fyb3VzZWwtLWQgLnNsaWRlJykpLCB7XG4gICAgICBsb29wOiBmYWxzZSxcbiAgICAgIHRyYW5zaXRpb246ICdkcmFnZ2FibGUnXG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBDYXJvdXNlbFNhbXBsZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/carousel.js\n");

/***/ }),

/***/ "./examples/catmull-rom.js":
/*!*********************************!*\
  !*** ./examples/catmull-rom.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _domCanvas = __webpack_require__(/*! ../lib/dom/dom-canvas */ \"./lib/dom/dom-canvas.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _catmullRom = __webpack_require__(/*! ../lib/mathf/catmull-rom */ \"./lib/mathf/catmull-rom.js\");\n\n/**\n * Demonstrates basic usage of CatmullRom\n */\nclass CatmullRomSample {\n  constructor() {\n    this.canvas = document.getElementById('canvas');\n    this.canvas.width = this.canvas.offsetWidth;\n    this.canvas.height = this.canvas.offsetHeight;\n    this.context = this.canvas.getContext('2d');\n    console.log('catmull rom sample'); // Start by defining our control points\n\n    const points = [new _vector.Vector(0, 500), new _vector.Vector(100, 200), new _vector.Vector(200, 400), new _vector.Vector(300, 200), new _vector.Vector(400, 350), new _vector.Vector(500, 300)]; // Now create a catmullRom Interpolation.\n\n    let catmullInterpolation = _catmullRom.CatmullRom.interpolate(points, 0.5, 0.5); // Now create a catmullRom with low tension\n\n\n    let catmullInterpolationLow = _catmullRom.CatmullRom.interpolate(points, 0, 0); // Now create a catmullRom with high tension\n\n\n    let catmullInterpolationHigh = _catmullRom.CatmullRom.interpolate(points, 1, 1); // Set the number of points we want to draw along the spline.\n\n\n    let drawPoints = 500; // The amount of progress to per dot.\n\n    let progressSpan = 1 / drawPoints; // Loop throught the drawPoints.\n\n    for (let step = 0; step < drawPoints; step++) {\n      // Get the x,y value along the catmull rom spline based on the\n      // current progress.\n      let progress = step * progressSpan;\n      let vector; // Draw the low tension vesion.\n\n      _domCanvas.domCanvas.setFillColor(this.context, 'orange');\n\n      _domCanvas.domCanvas.setStrokeColor(this.context, 'orange');\n\n      vector = catmullInterpolationLow(progress);\n\n      _domCanvas.domCanvas.vectorPoint(this.context, vector, 2); // Draw the high tension vesion.\n\n\n      _domCanvas.domCanvas.setFillColor(this.context, 'blue');\n\n      _domCanvas.domCanvas.setStrokeColor(this.context, 'blue');\n\n      vector = catmullInterpolationHigh(progress);\n\n      _domCanvas.domCanvas.vectorPoint(this.context, vector, 2); // Now draw it out.\n\n\n      _domCanvas.domCanvas.setFillColor(this.context, 'green');\n\n      _domCanvas.domCanvas.setStrokeColor(this.context, 'green');\n\n      vector = catmullInterpolation(progress);\n\n      _domCanvas.domCanvas.vectorPoint(this.context, vector, 5);\n    } // Now draw out the original points in red.\n\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'red');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'red');\n\n    points.forEach(point => {\n      _domCanvas.domCanvas.vectorPoint(this.context, point);\n    });\n  }\n\n}\n\nexports.default = CatmullRomSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9jYXRtdWxsLXJvbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2NhdG11bGwtcm9tLmpzP2M4NzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZG9tQ2FudmFzID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLWNhbnZhc1wiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL3ZlY3RvclwiKTtcblxudmFyIF9jYXRtdWxsUm9tID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9jYXRtdWxsLXJvbVwiKTtcblxuLyoqXG4gKiBEZW1vbnN0cmF0ZXMgYmFzaWMgdXNhZ2Ugb2YgQ2F0bXVsbFJvbVxuICovXG5jbGFzcyBDYXRtdWxsUm9tU2FtcGxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzJyk7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjb25zb2xlLmxvZygnY2F0bXVsbCByb20gc2FtcGxlJyk7IC8vIFN0YXJ0IGJ5IGRlZmluaW5nIG91ciBjb250cm9sIHBvaW50c1xuXG4gICAgY29uc3QgcG9pbnRzID0gW25ldyBfdmVjdG9yLlZlY3RvcigwLCA1MDApLCBuZXcgX3ZlY3Rvci5WZWN0b3IoMTAwLCAyMDApLCBuZXcgX3ZlY3Rvci5WZWN0b3IoMjAwLCA0MDApLCBuZXcgX3ZlY3Rvci5WZWN0b3IoMzAwLCAyMDApLCBuZXcgX3ZlY3Rvci5WZWN0b3IoNDAwLCAzNTApLCBuZXcgX3ZlY3Rvci5WZWN0b3IoNTAwLCAzMDApXTsgLy8gTm93IGNyZWF0ZSBhIGNhdG11bGxSb20gSW50ZXJwb2xhdGlvbi5cblxuICAgIGxldCBjYXRtdWxsSW50ZXJwb2xhdGlvbiA9IF9jYXRtdWxsUm9tLkNhdG11bGxSb20uaW50ZXJwb2xhdGUocG9pbnRzLCAwLjUsIDAuNSk7IC8vIE5vdyBjcmVhdGUgYSBjYXRtdWxsUm9tIHdpdGggbG93IHRlbnNpb25cblxuXG4gICAgbGV0IGNhdG11bGxJbnRlcnBvbGF0aW9uTG93ID0gX2NhdG11bGxSb20uQ2F0bXVsbFJvbS5pbnRlcnBvbGF0ZShwb2ludHMsIDAsIDApOyAvLyBOb3cgY3JlYXRlIGEgY2F0bXVsbFJvbSB3aXRoIGhpZ2ggdGVuc2lvblxuXG5cbiAgICBsZXQgY2F0bXVsbEludGVycG9sYXRpb25IaWdoID0gX2NhdG11bGxSb20uQ2F0bXVsbFJvbS5pbnRlcnBvbGF0ZShwb2ludHMsIDEsIDEpOyAvLyBTZXQgdGhlIG51bWJlciBvZiBwb2ludHMgd2Ugd2FudCB0byBkcmF3IGFsb25nIHRoZSBzcGxpbmUuXG5cblxuICAgIGxldCBkcmF3UG9pbnRzID0gNTAwOyAvLyBUaGUgYW1vdW50IG9mIHByb2dyZXNzIHRvIHBlciBkb3QuXG5cbiAgICBsZXQgcHJvZ3Jlc3NTcGFuID0gMSAvIGRyYXdQb2ludHM7IC8vIExvb3AgdGhyb3VnaHQgdGhlIGRyYXdQb2ludHMuXG5cbiAgICBmb3IgKGxldCBzdGVwID0gMDsgc3RlcCA8IGRyYXdQb2ludHM7IHN0ZXArKykge1xuICAgICAgLy8gR2V0IHRoZSB4LHkgdmFsdWUgYWxvbmcgdGhlIGNhdG11bGwgcm9tIHNwbGluZSBiYXNlZCBvbiB0aGVcbiAgICAgIC8vIGN1cnJlbnQgcHJvZ3Jlc3MuXG4gICAgICBsZXQgcHJvZ3Jlc3MgPSBzdGVwICogcHJvZ3Jlc3NTcGFuO1xuICAgICAgbGV0IHZlY3RvcjsgLy8gRHJhdyB0aGUgbG93IHRlbnNpb24gdmVzaW9uLlxuXG4gICAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRGaWxsQ29sb3IodGhpcy5jb250ZXh0LCAnb3JhbmdlJyk7XG5cbiAgICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnNldFN0cm9rZUNvbG9yKHRoaXMuY29udGV4dCwgJ29yYW5nZScpO1xuXG4gICAgICB2ZWN0b3IgPSBjYXRtdWxsSW50ZXJwb2xhdGlvbkxvdyhwcm9ncmVzcyk7XG5cbiAgICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnZlY3RvclBvaW50KHRoaXMuY29udGV4dCwgdmVjdG9yLCAyKTsgLy8gRHJhdyB0aGUgaGlnaCB0ZW5zaW9uIHZlc2lvbi5cblxuXG4gICAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRGaWxsQ29sb3IodGhpcy5jb250ZXh0LCAnYmx1ZScpO1xuXG4gICAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRTdHJva2VDb2xvcih0aGlzLmNvbnRleHQsICdibHVlJyk7XG5cbiAgICAgIHZlY3RvciA9IGNhdG11bGxJbnRlcnBvbGF0aW9uSGlnaChwcm9ncmVzcyk7XG5cbiAgICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnZlY3RvclBvaW50KHRoaXMuY29udGV4dCwgdmVjdG9yLCAyKTsgLy8gTm93IGRyYXcgaXQgb3V0LlxuXG5cbiAgICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnNldEZpbGxDb2xvcih0aGlzLmNvbnRleHQsICdncmVlbicpO1xuXG4gICAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRTdHJva2VDb2xvcih0aGlzLmNvbnRleHQsICdncmVlbicpO1xuXG4gICAgICB2ZWN0b3IgPSBjYXRtdWxsSW50ZXJwb2xhdGlvbihwcm9ncmVzcyk7XG5cbiAgICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnZlY3RvclBvaW50KHRoaXMuY29udGV4dCwgdmVjdG9yLCA1KTtcbiAgICB9IC8vIE5vdyBkcmF3IG91dCB0aGUgb3JpZ2luYWwgcG9pbnRzIGluIHJlZC5cblxuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMuc2V0RmlsbENvbG9yKHRoaXMuY29udGV4dCwgJ3JlZCcpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMuc2V0U3Ryb2tlQ29sb3IodGhpcy5jb250ZXh0LCAncmVkJyk7XG5cbiAgICBwb2ludHMuZm9yRWFjaChwb2ludCA9PiB7XG4gICAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy52ZWN0b3JQb2ludCh0aGlzLmNvbnRleHQsIHBvaW50KTtcbiAgICB9KTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhdG11bGxSb21TYW1wbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/catmull-rom.js\n");

/***/ }),

/***/ "./examples/css-var-interpolate.js":
/*!*****************************************!*\
  !*** ./examples/css-var-interpolate.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _cssVarInterpolate = __webpack_require__(/*! ../lib/interpolate/css-var-interpolate */ \"./lib/interpolate/css-var-interpolate.js\");\n\nclass CssVarInterpolateSample {\n  constructor() {\n    console.log('css var interpolate sample');\n    this.ball = document.getElementById('ball');\n    this.range = document.getElementById('range');\n    this.cssVarInterpolate = new _cssVarInterpolate.CssVarInterpolate(this.ball, {\n      interpolations: [{\n        progress: [{\n          from: 0,\n          to: 1,\n          start: 0,\n          end: 500\n        }],\n        id: '--x'\n      }, {\n        progress: [{\n          from: 0,\n          to: 0.2,\n          start: 0,\n          end: 100,\n          easingFunction: _ease.EASE.easeOutSine\n        }, {\n          from: 0.2,\n          to: 0.3,\n          start: 100,\n          end: 300,\n          easingFunction: _ease.EASE.easeOutSine\n        }, {\n          from: 0.3,\n          to: 0.5,\n          start: 300,\n          end: 0,\n          easingFunction: _ease.EASE.easeOutSine\n        }, {\n          from: 0.5,\n          to: 1,\n          start: 0,\n          end: 500,\n          easingFunction: _ease.EASE.easeInQuad\n        }],\n        id: '--y'\n      }]\n    }); // Here is an example of using RafProgress to ease out the progress\n    // values.\n\n    const rafProgress = new _rafProgress.RafProgress(easedProgress => {\n      this.cssVarInterpolate.update(easedProgress);\n    });\n    rafProgress.setCurrentProgress(+this.range.value); // Update rafProgress each time the value of range changes.\n\n    this.range.addEventListener('input', () => {\n      rafProgress.easeTo(+this.range.value, 0.1, _ease.EASE.easeInOutQuad);\n    });\n  }\n\n}\n\nexports.default = CssVarInterpolateSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9jc3MtdmFyLWludGVycG9sYXRlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvY3NzLXZhci1pbnRlcnBvbGF0ZS5qcz8wMDNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JhZlByb2dyZXNzID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmLXByb2dyZXNzXCIpO1xuXG52YXIgX2Vhc2UgPSByZXF1aXJlKFwiLi4vbGliL2Vhc2UvZWFzZVwiKTtcblxudmFyIF9jc3NWYXJJbnRlcnBvbGF0ZSA9IHJlcXVpcmUoXCIuLi9saWIvaW50ZXJwb2xhdGUvY3NzLXZhci1pbnRlcnBvbGF0ZVwiKTtcblxuY2xhc3MgQ3NzVmFySW50ZXJwb2xhdGVTYW1wbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygnY3NzIHZhciBpbnRlcnBvbGF0ZSBzYW1wbGUnKTtcbiAgICB0aGlzLmJhbGwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmFsbCcpO1xuICAgIHRoaXMucmFuZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmFuZ2UnKTtcbiAgICB0aGlzLmNzc1ZhckludGVycG9sYXRlID0gbmV3IF9jc3NWYXJJbnRlcnBvbGF0ZS5Dc3NWYXJJbnRlcnBvbGF0ZSh0aGlzLmJhbGwsIHtcbiAgICAgIGludGVycG9sYXRpb25zOiBbe1xuICAgICAgICBwcm9ncmVzczogW3tcbiAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgIHRvOiAxLFxuICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgIGVuZDogNTAwXG4gICAgICAgIH1dLFxuICAgICAgICBpZDogJy0teCdcbiAgICAgIH0sIHtcbiAgICAgICAgcHJvZ3Jlc3M6IFt7XG4gICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICB0bzogMC4yLFxuICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgIGVuZDogMTAwLFxuICAgICAgICAgIGVhc2luZ0Z1bmN0aW9uOiBfZWFzZS5FQVNFLmVhc2VPdXRTaW5lXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBmcm9tOiAwLjIsXG4gICAgICAgICAgdG86IDAuMyxcbiAgICAgICAgICBzdGFydDogMTAwLFxuICAgICAgICAgIGVuZDogMzAwLFxuICAgICAgICAgIGVhc2luZ0Z1bmN0aW9uOiBfZWFzZS5FQVNFLmVhc2VPdXRTaW5lXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBmcm9tOiAwLjMsXG4gICAgICAgICAgdG86IDAuNSxcbiAgICAgICAgICBzdGFydDogMzAwLFxuICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgICBlYXNpbmdGdW5jdGlvbjogX2Vhc2UuRUFTRS5lYXNlT3V0U2luZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZnJvbTogMC41LFxuICAgICAgICAgIHRvOiAxLFxuICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgIGVuZDogNTAwLFxuICAgICAgICAgIGVhc2luZ0Z1bmN0aW9uOiBfZWFzZS5FQVNFLmVhc2VJblF1YWRcbiAgICAgICAgfV0sXG4gICAgICAgIGlkOiAnLS15J1xuICAgICAgfV1cbiAgICB9KTsgLy8gSGVyZSBpcyBhbiBleGFtcGxlIG9mIHVzaW5nIFJhZlByb2dyZXNzIHRvIGVhc2Ugb3V0IHRoZSBwcm9ncmVzc1xuICAgIC8vIHZhbHVlcy5cblxuICAgIGNvbnN0IHJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcyhlYXNlZFByb2dyZXNzID0+IHtcbiAgICAgIHRoaXMuY3NzVmFySW50ZXJwb2xhdGUudXBkYXRlKGVhc2VkUHJvZ3Jlc3MpO1xuICAgIH0pO1xuICAgIHJhZlByb2dyZXNzLnNldEN1cnJlbnRQcm9ncmVzcygrdGhpcy5yYW5nZS52YWx1ZSk7IC8vIFVwZGF0ZSByYWZQcm9ncmVzcyBlYWNoIHRpbWUgdGhlIHZhbHVlIG9mIHJhbmdlIGNoYW5nZXMuXG5cbiAgICB0aGlzLnJhbmdlLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgcmFmUHJvZ3Jlc3MuZWFzZVRvKCt0aGlzLnJhbmdlLnZhbHVlLCAwLjEsIF9lYXNlLkVBU0UuZWFzZUluT3V0UXVhZCk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBDc3NWYXJJbnRlcnBvbGF0ZVNhbXBsZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/css-var-interpolate.js\n");

/***/ }),

/***/ "./examples/css-var-interpolate2.js":
/*!******************************************!*\
  !*** ./examples/css-var-interpolate2.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _cssVarInterpolate = __webpack_require__(/*! ../lib/interpolate/css-var-interpolate */ \"./lib/interpolate/css-var-interpolate.js\");\n\nclass CssVarInterpolateSample2 {\n  constructor() {\n    console.log('css var interpolate sample 2');\n    this.ball = document.getElementById('ball');\n    this.range = document.getElementById('range');\n    this.cssVarInterpolate = new _cssVarInterpolate.CssVarInterpolate(document.getElementById('container'), {\n      interpolations: [{\n        progress: [{\n          from: 0,\n          to: 0.5,\n          start: 'rgba(255, 128, 0, 0.3)',\n          // orange\n          end: 'rgba(255, 153, 204, 1)' // pink\n\n        }, {\n          from: 0.5,\n          to: 1,\n          start: 'rgba(255, 153, 204, 1)',\n          // pink\n          end: 'rgba(0, 0, 255, 1)' // blue\n\n        }],\n        id: '--background'\n      }, {\n        progress: [{\n          from: 0,\n          to: 1,\n          start: '0px',\n          end: '500px'\n        }],\n        id: '--x'\n      }, {\n        progress: [{\n          from: 0,\n          to: 0.2,\n          start: '0px',\n          end: '100px',\n          easingFunction: _ease.EASE.easeOutSine\n        }, {\n          from: 0.2,\n          to: 0.3,\n          start: '100px',\n          end: '300px',\n          easingFunction: _ease.EASE.easeOutSine\n        }, {\n          from: 0.3,\n          to: 0.5,\n          start: '300px',\n          end: '0px',\n          easingFunction: _ease.EASE.easeOutSine\n        }, {\n          from: 0.5,\n          to: 1,\n          start: '0px',\n          end: '500px',\n          easingFunction: _ease.EASE.easeInQuad\n        }],\n        id: '--y'\n      }]\n    }); // Here is an example of using RafProgress to ease out the progress\n    // values.\n\n    const rafProgress = new _rafProgress.RafProgress(easedProgress => {\n      this.cssVarInterpolate.update(easedProgress);\n    });\n    rafProgress.setCurrentProgress(+this.range.value); // Update rafProgress each time the value of range changes.\n\n    this.range.addEventListener('input', () => {\n      rafProgress.easeTo(+this.range.value, 0.1, _ease.EASE.easeInOutQuad);\n    });\n  }\n\n}\n\nexports.default = CssVarInterpolateSample2;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9jc3MtdmFyLWludGVycG9sYXRlMi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2Nzcy12YXItaW50ZXJwb2xhdGUyLmpzP2E5MzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0aGYgPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL21hdGhmXCIpO1xuXG52YXIgX3JhZlByb2dyZXNzID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmLXByb2dyZXNzXCIpO1xuXG52YXIgX2Vhc2UgPSByZXF1aXJlKFwiLi4vbGliL2Vhc2UvZWFzZVwiKTtcblxudmFyIF9jc3NWYXJJbnRlcnBvbGF0ZSA9IHJlcXVpcmUoXCIuLi9saWIvaW50ZXJwb2xhdGUvY3NzLXZhci1pbnRlcnBvbGF0ZVwiKTtcblxuY2xhc3MgQ3NzVmFySW50ZXJwb2xhdGVTYW1wbGUyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coJ2NzcyB2YXIgaW50ZXJwb2xhdGUgc2FtcGxlIDInKTtcbiAgICB0aGlzLmJhbGwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmFsbCcpO1xuICAgIHRoaXMucmFuZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmFuZ2UnKTtcbiAgICB0aGlzLmNzc1ZhckludGVycG9sYXRlID0gbmV3IF9jc3NWYXJJbnRlcnBvbGF0ZS5Dc3NWYXJJbnRlcnBvbGF0ZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJyksIHtcbiAgICAgIGludGVycG9sYXRpb25zOiBbe1xuICAgICAgICBwcm9ncmVzczogW3tcbiAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgIHRvOiAwLjUsXG4gICAgICAgICAgc3RhcnQ6ICdyZ2JhKDI1NSwgMTI4LCAwLCAwLjMpJyxcbiAgICAgICAgICAvLyBvcmFuZ2VcbiAgICAgICAgICBlbmQ6ICdyZ2JhKDI1NSwgMTUzLCAyMDQsIDEpJyAvLyBwaW5rXG5cbiAgICAgICAgfSwge1xuICAgICAgICAgIGZyb206IDAuNSxcbiAgICAgICAgICB0bzogMSxcbiAgICAgICAgICBzdGFydDogJ3JnYmEoMjU1LCAxNTMsIDIwNCwgMSknLFxuICAgICAgICAgIC8vIHBpbmtcbiAgICAgICAgICBlbmQ6ICdyZ2JhKDAsIDAsIDI1NSwgMSknIC8vIGJsdWVcblxuICAgICAgICB9XSxcbiAgICAgICAgaWQ6ICctLWJhY2tncm91bmQnXG4gICAgICB9LCB7XG4gICAgICAgIHByb2dyZXNzOiBbe1xuICAgICAgICAgIGZyb206IDAsXG4gICAgICAgICAgdG86IDEsXG4gICAgICAgICAgc3RhcnQ6ICcwcHgnLFxuICAgICAgICAgIGVuZDogJzUwMHB4J1xuICAgICAgICB9XSxcbiAgICAgICAgaWQ6ICctLXgnXG4gICAgICB9LCB7XG4gICAgICAgIHByb2dyZXNzOiBbe1xuICAgICAgICAgIGZyb206IDAsXG4gICAgICAgICAgdG86IDAuMixcbiAgICAgICAgICBzdGFydDogJzBweCcsXG4gICAgICAgICAgZW5kOiAnMTAwcHgnLFxuICAgICAgICAgIGVhc2luZ0Z1bmN0aW9uOiBfZWFzZS5FQVNFLmVhc2VPdXRTaW5lXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBmcm9tOiAwLjIsXG4gICAgICAgICAgdG86IDAuMyxcbiAgICAgICAgICBzdGFydDogJzEwMHB4JyxcbiAgICAgICAgICBlbmQ6ICczMDBweCcsXG4gICAgICAgICAgZWFzaW5nRnVuY3Rpb246IF9lYXNlLkVBU0UuZWFzZU91dFNpbmVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGZyb206IDAuMyxcbiAgICAgICAgICB0bzogMC41LFxuICAgICAgICAgIHN0YXJ0OiAnMzAwcHgnLFxuICAgICAgICAgIGVuZDogJzBweCcsXG4gICAgICAgICAgZWFzaW5nRnVuY3Rpb246IF9lYXNlLkVBU0UuZWFzZU91dFNpbmVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGZyb206IDAuNSxcbiAgICAgICAgICB0bzogMSxcbiAgICAgICAgICBzdGFydDogJzBweCcsXG4gICAgICAgICAgZW5kOiAnNTAwcHgnLFxuICAgICAgICAgIGVhc2luZ0Z1bmN0aW9uOiBfZWFzZS5FQVNFLmVhc2VJblF1YWRcbiAgICAgICAgfV0sXG4gICAgICAgIGlkOiAnLS15J1xuICAgICAgfV1cbiAgICB9KTsgLy8gSGVyZSBpcyBhbiBleGFtcGxlIG9mIHVzaW5nIFJhZlByb2dyZXNzIHRvIGVhc2Ugb3V0IHRoZSBwcm9ncmVzc1xuICAgIC8vIHZhbHVlcy5cblxuICAgIGNvbnN0IHJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcyhlYXNlZFByb2dyZXNzID0+IHtcbiAgICAgIHRoaXMuY3NzVmFySW50ZXJwb2xhdGUudXBkYXRlKGVhc2VkUHJvZ3Jlc3MpO1xuICAgIH0pO1xuICAgIHJhZlByb2dyZXNzLnNldEN1cnJlbnRQcm9ncmVzcygrdGhpcy5yYW5nZS52YWx1ZSk7IC8vIFVwZGF0ZSByYWZQcm9ncmVzcyBlYWNoIHRpbWUgdGhlIHZhbHVlIG9mIHJhbmdlIGNoYW5nZXMuXG5cbiAgICB0aGlzLnJhbmdlLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgcmFmUHJvZ3Jlc3MuZWFzZVRvKCt0aGlzLnJhbmdlLnZhbHVlLCAwLjEsIF9lYXNlLkVBU0UuZWFzZUluT3V0UXVhZCk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBDc3NWYXJJbnRlcnBvbGF0ZVNhbXBsZTI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/css-var-interpolate2.js\n");

/***/ }),

/***/ "./examples/css-var-interpolate3.js":
/*!******************************************!*\
  !*** ./examples/css-var-interpolate3.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _func = __webpack_require__(/*! ../lib/func/func */ \"./lib/func/func.js\");\n\nvar _elementVisibility = __webpack_require__(/*! ../lib/dom/element-visibility */ \"./lib/dom/element-visibility.js\");\n\nvar _cssVarInterpolate = __webpack_require__(/*! ../lib/interpolate/css-var-interpolate */ \"./lib/interpolate/css-var-interpolate.js\");\n\nclass CssVarInterpolateSample3 {\n  constructor() {\n    console.log('css var interpolate');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.parentElement = document.getElementById('parent');\n    this.childElement = document.getElementById('child'); // Element visibility.  Add 100px before and after the module.\n\n    this.ev = _elementVisibility.elementVisibility.inview(this.parentElement, {\n      rootMargin: '100px'\n    }); // Instance of rafProgress.\n\n    this.rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    let throttleThreshold = 24;\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      // Throttle the scroll.\n      callback: _func.func.throttle(event => {\n        this.onScroll();\n      }, throttleThreshold),\n      // Run scroll updates only when the element is visible.\n      runWhen: () => {\n        return this.ev.state().ready && this.ev.state().inview;\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // On init, immediately update the raf progress without lerping.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.rafProgress.watch(this.onProgressUpdate.bind(this)); // Setup css var interpolate.\n\n    this.cssVarInterpolate = new _cssVarInterpolate.CssVarInterpolate( // This is the element the css variables get scoped to.\n    this.parentElement, {\n      interpolations: [{\n        progress: [{\n          from: 0,\n          to: 1,\n          start: '0px',\n          end: '500px'\n        }],\n        id: '--x'\n      }, {\n        progress: [{\n          from: 0,\n          to: 0.2,\n          start: '0px',\n          end: '100px',\n          easingFunction: _ease.EASE.easeOutSine\n        }, {\n          from: 0.2,\n          to: 0.3,\n          start: '100px',\n          end: '300px',\n          easingFunction: _ease.EASE.easeOutSine\n        }, {\n          from: 0.3,\n          to: 0.5,\n          start: '300px',\n          end: '0px',\n          easingFunction: _ease.EASE.easeOutSine\n        }, {\n          from: 0.5,\n          to: 1,\n          start: '0px',\n          end: '500px',\n          easingFunction: _ease.EASE.easeInQuad\n        }],\n        id: '--y'\n      }]\n    }); // Run scroll once.\n\n    this.domWatcher.run('scroll');\n  }\n\n  onScroll() {\n    // Calculate 'how much' we have scrolled into the parent element from 0-1.\n    // Optionally add offset to this if needed.\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 0.25, _ease.EASE.Linear);\n  } // Runs every time eased progress is updated.\n\n\n  onProgressUpdate(easedProgress, direction) {\n    this.cssVarInterpolate.update(easedProgress);\n  }\n\n  dispose() {\n    this.domWatcher.dispose();\n    this.ev.dispose();\n  }\n\n}\n\nexports.default = CssVarInterpolateSample3;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9jc3MtdmFyLWludGVycG9sYXRlMy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2Nzcy12YXItaW50ZXJwb2xhdGUzLmpzPzg3MDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWYtcHJvZ3Jlc3NcIik7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS13YXRjaGVyXCIpO1xuXG52YXIgX2Vhc2UgPSByZXF1aXJlKFwiLi4vbGliL2Vhc2UvZWFzZVwiKTtcblxudmFyIF9kb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb21cIik7XG5cbnZhciBfZnVuYyA9IHJlcXVpcmUoXCIuLi9saWIvZnVuYy9mdW5jXCIpO1xuXG52YXIgX2VsZW1lbnRWaXNpYmlsaXR5ID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZWxlbWVudC12aXNpYmlsaXR5XCIpO1xuXG52YXIgX2Nzc1ZhckludGVycG9sYXRlID0gcmVxdWlyZShcIi4uL2xpYi9pbnRlcnBvbGF0ZS9jc3MtdmFyLWludGVycG9sYXRlXCIpO1xuXG5jbGFzcyBDc3NWYXJJbnRlcnBvbGF0ZVNhbXBsZTMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygnY3NzIHZhciBpbnRlcnBvbGF0ZScpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcmVudCcpO1xuICAgIHRoaXMuY2hpbGRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoaWxkJyk7IC8vIEVsZW1lbnQgdmlzaWJpbGl0eS4gIEFkZCAxMDBweCBiZWZvcmUgYW5kIGFmdGVyIHRoZSBtb2R1bGUuXG5cbiAgICB0aGlzLmV2ID0gX2VsZW1lbnRWaXNpYmlsaXR5LmVsZW1lbnRWaXNpYmlsaXR5Lmludmlldyh0aGlzLnBhcmVudEVsZW1lbnQsIHtcbiAgICAgIHJvb3RNYXJnaW46ICcxMDBweCdcbiAgICB9KTsgLy8gSW5zdGFuY2Ugb2YgcmFmUHJvZ3Jlc3MuXG5cbiAgICB0aGlzLnJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcygpOyAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIHZhbHVlIHBlciBzY3JvbGwuXG5cbiAgICBsZXQgdGhyb3R0bGVUaHJlc2hvbGQgPSAyNDtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnc2Nyb2xsJyxcbiAgICAgIC8vIFRocm90dGxlIHRoZSBzY3JvbGwuXG4gICAgICBjYWxsYmFjazogX2Z1bmMuZnVuYy50aHJvdHRsZShldmVudCA9PiB7XG4gICAgICAgIHRoaXMub25TY3JvbGwoKTtcbiAgICAgIH0sIHRocm90dGxlVGhyZXNob2xkKSxcbiAgICAgIC8vIFJ1biBzY3JvbGwgdXBkYXRlcyBvbmx5IHdoZW4gdGhlIGVsZW1lbnQgaXMgdmlzaWJsZS5cbiAgICAgIHJ1bldoZW46ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXYuc3RhdGUoKS5yZWFkeSAmJiB0aGlzLmV2LnN0YXRlKCkuaW52aWV3O1xuICAgICAgfSxcbiAgICAgIGV2ZW50T3B0aW9uczoge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7IC8vIE9uIGluaXQsIGltbWVkaWF0ZWx5IHVwZGF0ZSB0aGUgcmFmIHByb2dyZXNzIHdpdGhvdXQgbGVycGluZy5cblxuICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMSwgX2Vhc2UuRUFTRS5MaW5lYXIpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3Mud2F0Y2godGhpcy5vblByb2dyZXNzVXBkYXRlLmJpbmQodGhpcykpOyAvLyBTZXR1cCBjc3MgdmFyIGludGVycG9sYXRlLlxuXG4gICAgdGhpcy5jc3NWYXJJbnRlcnBvbGF0ZSA9IG5ldyBfY3NzVmFySW50ZXJwb2xhdGUuQ3NzVmFySW50ZXJwb2xhdGUoIC8vIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhlIGNzcyB2YXJpYWJsZXMgZ2V0IHNjb3BlZCB0by5cbiAgICB0aGlzLnBhcmVudEVsZW1lbnQsIHtcbiAgICAgIGludGVycG9sYXRpb25zOiBbe1xuICAgICAgICBwcm9ncmVzczogW3tcbiAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgIHRvOiAxLFxuICAgICAgICAgIHN0YXJ0OiAnMHB4JyxcbiAgICAgICAgICBlbmQ6ICc1MDBweCdcbiAgICAgICAgfV0sXG4gICAgICAgIGlkOiAnLS14J1xuICAgICAgfSwge1xuICAgICAgICBwcm9ncmVzczogW3tcbiAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgIHRvOiAwLjIsXG4gICAgICAgICAgc3RhcnQ6ICcwcHgnLFxuICAgICAgICAgIGVuZDogJzEwMHB4JyxcbiAgICAgICAgICBlYXNpbmdGdW5jdGlvbjogX2Vhc2UuRUFTRS5lYXNlT3V0U2luZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZnJvbTogMC4yLFxuICAgICAgICAgIHRvOiAwLjMsXG4gICAgICAgICAgc3RhcnQ6ICcxMDBweCcsXG4gICAgICAgICAgZW5kOiAnMzAwcHgnLFxuICAgICAgICAgIGVhc2luZ0Z1bmN0aW9uOiBfZWFzZS5FQVNFLmVhc2VPdXRTaW5lXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBmcm9tOiAwLjMsXG4gICAgICAgICAgdG86IDAuNSxcbiAgICAgICAgICBzdGFydDogJzMwMHB4JyxcbiAgICAgICAgICBlbmQ6ICcwcHgnLFxuICAgICAgICAgIGVhc2luZ0Z1bmN0aW9uOiBfZWFzZS5FQVNFLmVhc2VPdXRTaW5lXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBmcm9tOiAwLjUsXG4gICAgICAgICAgdG86IDEsXG4gICAgICAgICAgc3RhcnQ6ICcwcHgnLFxuICAgICAgICAgIGVuZDogJzUwMHB4JyxcbiAgICAgICAgICBlYXNpbmdGdW5jdGlvbjogX2Vhc2UuRUFTRS5lYXNlSW5RdWFkXG4gICAgICAgIH1dLFxuICAgICAgICBpZDogJy0teSdcbiAgICAgIH1dXG4gICAgfSk7IC8vIFJ1biBzY3JvbGwgb25jZS5cblxuICAgIHRoaXMuZG9tV2F0Y2hlci5ydW4oJ3Njcm9sbCcpO1xuICB9XG5cbiAgb25TY3JvbGwoKSB7XG4gICAgLy8gQ2FsY3VsYXRlICdob3cgbXVjaCcgd2UgaGF2ZSBzY3JvbGxlZCBpbnRvIHRoZSBwYXJlbnQgZWxlbWVudCBmcm9tIDAtMS5cbiAgICAvLyBPcHRpb25hbGx5IGFkZCBvZmZzZXQgdG8gdGhpcyBpZiBuZWVkZWQuXG4gICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAwLjI1LCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gIH0gLy8gUnVucyBldmVyeSB0aW1lIGVhc2VkIHByb2dyZXNzIGlzIHVwZGF0ZWQuXG5cblxuICBvblByb2dyZXNzVXBkYXRlKGVhc2VkUHJvZ3Jlc3MsIGRpcmVjdGlvbikge1xuICAgIHRoaXMuY3NzVmFySW50ZXJwb2xhdGUudXBkYXRlKGVhc2VkUHJvZ3Jlc3MpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmRvbVdhdGNoZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuZXYuZGlzcG9zZSgpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gQ3NzVmFySW50ZXJwb2xhdGVTYW1wbGUzOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/css-var-interpolate3.js\n");

/***/ }),

/***/ "./examples/dom-canvas.js":
/*!********************************!*\
  !*** ./examples/dom-canvas.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _domCanvas = __webpack_require__(/*! ../lib/dom/dom-canvas */ \"./lib/dom/dom-canvas.js\");\n\nclass DomCanvasSample {\n  constructor() {\n    this.canvas = document.getElementById('canvas');\n    this.canvas.width = this.canvas.offsetWidth;\n    this.canvas.height = this.canvas.offsetHeight;\n    this.context = this.canvas.getContext('2d'); // Add some text.\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'orange');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'orange');\n\n    _domCanvas.domCanvas.quickText(this.context, 'hello this is some text', 500, 500); // Draw quad\n\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'blue');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'blue');\n\n    _domCanvas.domCanvas.vectorQuadrilateral(this.context, new _vector.Vector(10, 10), new _vector.Vector(100, 10), new _vector.Vector(100, 100), new _vector.Vector(10, 100));\n\n    _domCanvas.domCanvas.setFillColor(this.context, '#EFEFEF');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, '#EFEFEF');\n\n    _domCanvas.domCanvas.vectorQuadrilateral(this.context, new _vector.Vector(200, 200), new _vector.Vector(400, 200), new _vector.Vector(400, 400), new _vector.Vector(200, 400)); // Let's get the color at 205, 205.\n\n\n    let rgb = _domCanvas.domCanvas.getColorAtPointAsHex(this.context, new _vector.Vector(205, 205));\n  }\n\n}\n\nexports.default = DomCanvasSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9kb20tY2FudmFzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvZG9tLWNhbnZhcy5qcz8zMGNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvdmVjdG9yXCIpO1xuXG52YXIgX2RvbUNhbnZhcyA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS1jYW52YXNcIik7XG5cbmNsYXNzIERvbUNhbnZhc1NhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpO1xuICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMub2Zmc2V0SGVpZ2h0O1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7IC8vIEFkZCBzb21lIHRleHQuXG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRGaWxsQ29sb3IodGhpcy5jb250ZXh0LCAnb3JhbmdlJyk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRTdHJva2VDb2xvcih0aGlzLmNvbnRleHQsICdvcmFuZ2UnKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnF1aWNrVGV4dCh0aGlzLmNvbnRleHQsICdoZWxsbyB0aGlzIGlzIHNvbWUgdGV4dCcsIDUwMCwgNTAwKTsgLy8gRHJhdyBxdWFkXG5cblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnNldEZpbGxDb2xvcih0aGlzLmNvbnRleHQsICdibHVlJyk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRTdHJva2VDb2xvcih0aGlzLmNvbnRleHQsICdibHVlJyk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy52ZWN0b3JRdWFkcmlsYXRlcmFsKHRoaXMuY29udGV4dCwgbmV3IF92ZWN0b3IuVmVjdG9yKDEwLCAxMCksIG5ldyBfdmVjdG9yLlZlY3RvcigxMDAsIDEwKSwgbmV3IF92ZWN0b3IuVmVjdG9yKDEwMCwgMTAwKSwgbmV3IF92ZWN0b3IuVmVjdG9yKDEwLCAxMDApKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnNldEZpbGxDb2xvcih0aGlzLmNvbnRleHQsICcjRUZFRkVGJyk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRTdHJva2VDb2xvcih0aGlzLmNvbnRleHQsICcjRUZFRkVGJyk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy52ZWN0b3JRdWFkcmlsYXRlcmFsKHRoaXMuY29udGV4dCwgbmV3IF92ZWN0b3IuVmVjdG9yKDIwMCwgMjAwKSwgbmV3IF92ZWN0b3IuVmVjdG9yKDQwMCwgMjAwKSwgbmV3IF92ZWN0b3IuVmVjdG9yKDQwMCwgNDAwKSwgbmV3IF92ZWN0b3IuVmVjdG9yKDIwMCwgNDAwKSk7IC8vIExldCdzIGdldCB0aGUgY29sb3IgYXQgMjA1LCAyMDUuXG5cblxuICAgIGxldCByZ2IgPSBfZG9tQ2FudmFzLmRvbUNhbnZhcy5nZXRDb2xvckF0UG9pbnRBc0hleCh0aGlzLmNvbnRleHQsIG5ldyBfdmVjdG9yLlZlY3RvcigyMDUsIDIwNSkpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gRG9tQ2FudmFzU2FtcGxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/dom-canvas.js\n");

/***/ }),

/***/ "./examples/dom-watcher.js":
/*!*********************************!*\
  !*** ./examples/dom-watcher.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _func = __webpack_require__(/*! ../lib/func/func */ \"./lib/func/func.js\");\n\nclass DomWatcherSample {\n  constructor() {\n    console.log('this is working');\n    const watcher = new _domWatcher.DomWatcher();\n    watcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        console.log('i am scrolling', event);\n      },\n      eventOptions: {\n        passive: true\n      },\n      id: 'scrollWatch'\n    });\n    watcher.run('scrollWatch');\n    watcher.add({\n      element: window,\n      on: 'smartResize',\n      callback: event => {\n        console.log('I am smart resizing');\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // Add a watcher to button1 to remove the scroll watching.\n\n    watcher.add({\n      element: document.getElementById('button1'),\n      on: 'click',\n      callback: () => {\n        console.log('you clicked button 1');\n        watcher.removeById('scrollWatch');\n      }\n    }); // Add a watcher to button2 that only works when viewport is\n    // small\n\n    watcher.add({\n      element: document.getElementById('button2'),\n      on: 'click',\n      callback: () => {\n        console.log('you clicked button 2');\n      },\n      runWhen: () => {\n        return window.innerWidth <= 800;\n      }\n    }); // A mouse move watcher.\n\n    watcher.add({\n      element: document.body,\n      on: 'mousemove',\n      callback: _func.func.debounce(event => {\n        console.log('movemove!!');\n      }, 500)\n    });\n    watcher.add({\n      element: document.getElementById('button3'),\n      on: 'click',\n      callback: () => {\n        watcher.removeAll();\n      }\n    });\n  }\n\n}\n\nexports.default = DomWatcherSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9kb20td2F0Y2hlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2RvbS13YXRjaGVyLmpzPzk1NzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS13YXRjaGVyXCIpO1xuXG52YXIgX2Z1bmMgPSByZXF1aXJlKFwiLi4vbGliL2Z1bmMvZnVuY1wiKTtcblxuY2xhc3MgRG9tV2F0Y2hlclNhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCd0aGlzIGlzIHdvcmtpbmcnKTtcbiAgICBjb25zdCB3YXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB3YXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Njcm9sbCcsXG4gICAgICBjYWxsYmFjazogZXZlbnQgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnaSBhbSBzY3JvbGxpbmcnLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0sXG4gICAgICBpZDogJ3Njcm9sbFdhdGNoJ1xuICAgIH0pO1xuICAgIHdhdGNoZXIucnVuKCdzY3JvbGxXYXRjaCcpO1xuICAgIHdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnc21hcnRSZXNpemUnLFxuICAgICAgY2FsbGJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0kgYW0gc21hcnQgcmVzaXppbmcnKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pOyAvLyBBZGQgYSB3YXRjaGVyIHRvIGJ1dHRvbjEgdG8gcmVtb3ZlIHRoZSBzY3JvbGwgd2F0Y2hpbmcuXG5cbiAgICB3YXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnV0dG9uMScpLFxuICAgICAgb246ICdjbGljaycsXG4gICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygneW91IGNsaWNrZWQgYnV0dG9uIDEnKTtcbiAgICAgICAgd2F0Y2hlci5yZW1vdmVCeUlkKCdzY3JvbGxXYXRjaCcpO1xuICAgICAgfVxuICAgIH0pOyAvLyBBZGQgYSB3YXRjaGVyIHRvIGJ1dHRvbjIgdGhhdCBvbmx5IHdvcmtzIHdoZW4gdmlld3BvcnQgaXNcbiAgICAvLyBzbWFsbFxuXG4gICAgd2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J1dHRvbjInKSxcbiAgICAgIG9uOiAnY2xpY2snLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ3lvdSBjbGlja2VkIGJ1dHRvbiAyJyk7XG4gICAgICB9LFxuICAgICAgcnVuV2hlbjogKCkgPT4ge1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggPD0gODAwO1xuICAgICAgfVxuICAgIH0pOyAvLyBBIG1vdXNlIG1vdmUgd2F0Y2hlci5cblxuICAgIHdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmJvZHksXG4gICAgICBvbjogJ21vdXNlbW92ZScsXG4gICAgICBjYWxsYmFjazogX2Z1bmMuZnVuYy5kZWJvdW5jZShldmVudCA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdtb3ZlbW92ZSEhJyk7XG4gICAgICB9LCA1MDApXG4gICAgfSk7XG4gICAgd2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J1dHRvbjMnKSxcbiAgICAgIG9uOiAnY2xpY2snLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgd2F0Y2hlci5yZW1vdmVBbGwoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERvbVdhdGNoZXJTYW1wbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/dom-watcher.js\n");

/***/ }),

/***/ "./examples/easer-disable-raf.js":
/*!***************************************!*\
  !*** ./examples/easer-disable-raf.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _easer = __webpack_require__(/*! ../lib/ease/easer */ \"./lib/ease/easer.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nclass EaserDisableRafSample {\n  constructor() {\n    console.log('easer - disable raf sample');\n    const ball = document.getElementById('ball');\n    this.durationElement = document.getElementById('duration');\n    this.delayElement = document.getElementById('delay');\n    let duration = 1000;\n    let delay = 0;\n    this.durationElement.value = duration;\n    this.delayElement.value = delay; // Create easer.\n\n    const easer = new _easer.Easer({\n      duration: duration,\n      delay: delay,\n      easeFunction: _ease.EASE.easeInOutExpo,\n      disableRaf: true\n    });\n    easer.onUpdate((progression, complete) => {\n      console.log('progression', progression);\n      ball.style.transform = `translateX(${progression * 80}vw)`;\n    });\n    easer.onComplete((progression, complete) => {\n      console.log('complete', progression);\n    }); // Easer expects to be updated on each raf cycle.\n\n    this.raf = new _raf.Raf(() => {\n      easer.calculate();\n    });\n    this.raf.start(); // Start the easer on clicking the button.\n\n    document.getElementById('start').addEventListener('click', () => {\n      console.log('starting easer');\n      easer.start();\n    }); // Update\n\n    document.getElementById('update').addEventListener('click', () => {\n      console.log('updated settings');\n      easer.reset({\n        duration: +this.durationElement.value,\n        delay: +this.delayElement.value\n      });\n    });\n  }\n\n}\n\nexports.default = EaserDisableRafSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9lYXNlci1kaXNhYmxlLXJhZi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2Vhc2VyLWRpc2FibGUtcmFmLmpzP2MyZTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2Vhc2VyID0gcmVxdWlyZShcIi4uL2xpYi9lYXNlL2Vhc2VyXCIpO1xuXG52YXIgX2Vhc2UgPSByZXF1aXJlKFwiLi4vbGliL2Vhc2UvZWFzZVwiKTtcblxuY2xhc3MgRWFzZXJEaXNhYmxlUmFmU2FtcGxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coJ2Vhc2VyIC0gZGlzYWJsZSByYWYgc2FtcGxlJyk7XG4gICAgY29uc3QgYmFsbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiYWxsJyk7XG4gICAgdGhpcy5kdXJhdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHVyYXRpb24nKTtcbiAgICB0aGlzLmRlbGF5RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZWxheScpO1xuICAgIGxldCBkdXJhdGlvbiA9IDEwMDA7XG4gICAgbGV0IGRlbGF5ID0gMDtcbiAgICB0aGlzLmR1cmF0aW9uRWxlbWVudC52YWx1ZSA9IGR1cmF0aW9uO1xuICAgIHRoaXMuZGVsYXlFbGVtZW50LnZhbHVlID0gZGVsYXk7IC8vIENyZWF0ZSBlYXNlci5cblxuICAgIGNvbnN0IGVhc2VyID0gbmV3IF9lYXNlci5FYXNlcih7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBkZWxheTogZGVsYXksXG4gICAgICBlYXNlRnVuY3Rpb246IF9lYXNlLkVBU0UuZWFzZUluT3V0RXhwbyxcbiAgICAgIGRpc2FibGVSYWY6IHRydWVcbiAgICB9KTtcbiAgICBlYXNlci5vblVwZGF0ZSgocHJvZ3Jlc3Npb24sIGNvbXBsZXRlKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygncHJvZ3Jlc3Npb24nLCBwcm9ncmVzc2lvbik7XG4gICAgICBiYWxsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7cHJvZ3Jlc3Npb24gKiA4MH12dylgO1xuICAgIH0pO1xuICAgIGVhc2VyLm9uQ29tcGxldGUoKHByb2dyZXNzaW9uLCBjb21wbGV0ZSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ2NvbXBsZXRlJywgcHJvZ3Jlc3Npb24pO1xuICAgIH0pOyAvLyBFYXNlciBleHBlY3RzIHRvIGJlIHVwZGF0ZWQgb24gZWFjaCByYWYgY3ljbGUuXG5cbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZigoKSA9PiB7XG4gICAgICBlYXNlci5jYWxjdWxhdGUoKTtcbiAgICB9KTtcbiAgICB0aGlzLnJhZi5zdGFydCgpOyAvLyBTdGFydCB0aGUgZWFzZXIgb24gY2xpY2tpbmcgdGhlIGJ1dHRvbi5cblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFydCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ3N0YXJ0aW5nIGVhc2VyJyk7XG4gICAgICBlYXNlci5zdGFydCgpO1xuICAgIH0pOyAvLyBVcGRhdGVcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1cGRhdGUnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCd1cGRhdGVkIHNldHRpbmdzJyk7XG4gICAgICBlYXNlci5yZXNldCh7XG4gICAgICAgIGR1cmF0aW9uOiArdGhpcy5kdXJhdGlvbkVsZW1lbnQudmFsdWUsXG4gICAgICAgIGRlbGF5OiArdGhpcy5kZWxheUVsZW1lbnQudmFsdWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gRWFzZXJEaXNhYmxlUmFmU2FtcGxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/easer-disable-raf.js\n");

/***/ }),

/***/ "./examples/easer.js":
/*!***************************!*\
  !*** ./examples/easer.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _easer = __webpack_require__(/*! ../lib/ease/easer */ \"./lib/ease/easer.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nclass EaserSample {\n  constructor() {\n    console.log('easer');\n    const ball = document.getElementById('ball');\n    this.durationElement = document.getElementById('duration');\n    this.delayElement = document.getElementById('delay');\n    let duration = 1000;\n    let delay = 0;\n    this.durationElement.value = duration;\n    this.delayElement.value = delay; // Create easer.\n\n    const easer = new _easer.Easer({\n      duration: duration,\n      delay: delay,\n      easeFunction: _ease.EASE.easeInOutExpo\n    });\n    easer.onUpdate((progression, complete) => {\n      console.log('progression', progression);\n      ball.style.transform = `translateX(${progression * 80}vw)`;\n    }); // Start the easer on clicking the button.\n\n    document.getElementById('start').addEventListener('click', () => {\n      console.log('starting easer');\n      easer.start().then(() => {\n        console.log('all done');\n      });\n    }); // Update\n\n    document.getElementById('update').addEventListener('click', () => {\n      console.log('updated settings');\n      easer.reset({\n        duration: +this.durationElement.value,\n        delay: +this.delayElement.value\n      });\n    });\n  }\n\n}\n\nexports.default = EaserSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9lYXNlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2Vhc2VyLmpzPzdjZmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZWFzZXIgPSByZXF1aXJlKFwiLi4vbGliL2Vhc2UvZWFzZXJcIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG5jbGFzcyBFYXNlclNhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdlYXNlcicpO1xuICAgIGNvbnN0IGJhbGwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmFsbCcpO1xuICAgIHRoaXMuZHVyYXRpb25FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2R1cmF0aW9uJyk7XG4gICAgdGhpcy5kZWxheUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGVsYXknKTtcbiAgICBsZXQgZHVyYXRpb24gPSAxMDAwO1xuICAgIGxldCBkZWxheSA9IDA7XG4gICAgdGhpcy5kdXJhdGlvbkVsZW1lbnQudmFsdWUgPSBkdXJhdGlvbjtcbiAgICB0aGlzLmRlbGF5RWxlbWVudC52YWx1ZSA9IGRlbGF5OyAvLyBDcmVhdGUgZWFzZXIuXG5cbiAgICBjb25zdCBlYXNlciA9IG5ldyBfZWFzZXIuRWFzZXIoe1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgZWFzZUZ1bmN0aW9uOiBfZWFzZS5FQVNFLmVhc2VJbk91dEV4cG9cbiAgICB9KTtcbiAgICBlYXNlci5vblVwZGF0ZSgocHJvZ3Jlc3Npb24sIGNvbXBsZXRlKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygncHJvZ3Jlc3Npb24nLCBwcm9ncmVzc2lvbik7XG4gICAgICBiYWxsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7cHJvZ3Jlc3Npb24gKiA4MH12dylgO1xuICAgIH0pOyAvLyBTdGFydCB0aGUgZWFzZXIgb24gY2xpY2tpbmcgdGhlIGJ1dHRvbi5cblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFydCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ3N0YXJ0aW5nIGVhc2VyJyk7XG4gICAgICBlYXNlci5zdGFydCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnYWxsIGRvbmUnKTtcbiAgICAgIH0pO1xuICAgIH0pOyAvLyBVcGRhdGVcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1cGRhdGUnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCd1cGRhdGVkIHNldHRpbmdzJyk7XG4gICAgICBlYXNlci5yZXNldCh7XG4gICAgICAgIGR1cmF0aW9uOiArdGhpcy5kdXJhdGlvbkVsZW1lbnQudmFsdWUsXG4gICAgICAgIGRlbGF5OiArdGhpcy5kZWxheUVsZW1lbnQudmFsdWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gRWFzZXJTYW1wbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/easer.js\n");

/***/ }),

/***/ "./examples/glsl-playground.js":
/*!*************************************!*\
  !*** ./examples/glsl-playground.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n/**\n * https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram\n * https://gist.github.com/uxder/cc02c445c2f7b4679e48e91d2920c832\n *\n * Uniforms\n * - pass data between the control program (in this case three.js) and shaders\n * - each uniform will store a common value for each vertex and pixel.\n * - we call it uniform because it indicates that the same value will be the same\n *   for each vertex and pixel.\n *\n * Note different ways to access vector uniforms\n * - u_mouse.x = u_mouse[0]\n * - u_resolution.y = u_resolution[1]\n */\n\n/*\n* Vertex Shader\n* - Vertex should set the vec4 gl_Position.\n* - Applied per vertices of the mesh geometry.\n*\n* The position needs to condiser the model view projection.\n* model - moves the vertex from local to world\n* view - moves the vertex from world space to camera\n* projection - moves the vertex clip to screen space coordinates (3d -> 2d)\n*\n* So to move the vertex, you want multiply the position vec3 by the model view projectiion\n* but since you can't multiply vec3 * mat4, convert the vec3 into a vec4 by adding a\n* w dimension as 1.0.   vec4(position, 1.0).\n*\n* In effect you are doing:\n* gl_Position = Project (mat4) * View (mat4) * Model (mat4) * vec4 (position, w)\n*\n* resulting in a default vertex shader of:\n* gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n*/\nconst vshader = `\nvoid main() {\n\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n\n  // Make each vertices position half.\n  //   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position * 0.5, 1.0 );\n}\n`;\n/**\n *\n * Frag Shader\n * - Frag should set the gl_FragColor.\n * - gl_FragColor is type vec4 for\n * - Applied per pixel of the mesh.\n *\n * Three.js Color translates to vec3 type which we pass as a uniform u_color.\n *\n */\n\nconst fshader = `\nuniform vec3 u_color;\n\nvoid main (void)\n{\n// Green\n//   gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n\n// Red\n//   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n// From uniform\n  gl_FragColor = vec4(u_color, 1.0);\n\n// You can swap the rgba order if you want to green blue red alpha.\n//   gl_FragColor = vec4(u_color, 1.0).gbra;\n\n\n}\n`;\n\nclass GlslPlayground {\n  constructor() {\n    this.scene = new THREE.Scene();\n    this.clock = new THREE.Clock(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.uniforms = {\n      u_color: {\n        value: new THREE.Color(0xffff00)\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n  }\n\n  onRaf() {\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQuanM/ZGVkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90aHJlZSA9IHJlcXVpcmUoXCJ0aHJlZVwiKTtcblxudmFyIFRIUkVFID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3RocmVlKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS13YXRjaGVyXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8qKlxuICogaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNhcGkvZW4vcmVuZGVyZXJzL3dlYmdsL1dlYkdMUHJvZ3JhbVxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vdXhkZXIvY2MwMmM0NDVjMmY3YjQ2NzllNDhlOTFkMjkyMGM4MzJcbiAqXG4gKiBVbmlmb3Jtc1xuICogLSBwYXNzIGRhdGEgYmV0d2VlbiB0aGUgY29udHJvbCBwcm9ncmFtIChpbiB0aGlzIGNhc2UgdGhyZWUuanMpIGFuZCBzaGFkZXJzXG4gKiAtIGVhY2ggdW5pZm9ybSB3aWxsIHN0b3JlIGEgY29tbW9uIHZhbHVlIGZvciBlYWNoIHZlcnRleCBhbmQgcGl4ZWwuXG4gKiAtIHdlIGNhbGwgaXQgdW5pZm9ybSBiZWNhdXNlIGl0IGluZGljYXRlcyB0aGF0IHRoZSBzYW1lIHZhbHVlIHdpbGwgYmUgdGhlIHNhbWVcbiAqICAgZm9yIGVhY2ggdmVydGV4IGFuZCBwaXhlbC5cbiAqXG4gKiBOb3RlIGRpZmZlcmVudCB3YXlzIHRvIGFjY2VzcyB2ZWN0b3IgdW5pZm9ybXNcbiAqIC0gdV9tb3VzZS54ID0gdV9tb3VzZVswXVxuICogLSB1X3Jlc29sdXRpb24ueSA9IHVfcmVzb2x1dGlvblsxXVxuICovXG5cbi8qXG4qIFZlcnRleCBTaGFkZXJcbiogLSBWZXJ0ZXggc2hvdWxkIHNldCB0aGUgdmVjNCBnbF9Qb3NpdGlvbi5cbiogLSBBcHBsaWVkIHBlciB2ZXJ0aWNlcyBvZiB0aGUgbWVzaCBnZW9tZXRyeS5cbipcbiogVGhlIHBvc2l0aW9uIG5lZWRzIHRvIGNvbmRpc2VyIHRoZSBtb2RlbCB2aWV3IHByb2plY3Rpb24uXG4qIG1vZGVsIC0gbW92ZXMgdGhlIHZlcnRleCBmcm9tIGxvY2FsIHRvIHdvcmxkXG4qIHZpZXcgLSBtb3ZlcyB0aGUgdmVydGV4IGZyb20gd29ybGQgc3BhY2UgdG8gY2FtZXJhXG4qIHByb2plY3Rpb24gLSBtb3ZlcyB0aGUgdmVydGV4IGNsaXAgdG8gc2NyZWVuIHNwYWNlIGNvb3JkaW5hdGVzICgzZCAtPiAyZClcbipcbiogU28gdG8gbW92ZSB0aGUgdmVydGV4LCB5b3Ugd2FudCBtdWx0aXBseSB0aGUgcG9zaXRpb24gdmVjMyBieSB0aGUgbW9kZWwgdmlldyBwcm9qZWN0aWlvblxuKiBidXQgc2luY2UgeW91IGNhbid0IG11bHRpcGx5IHZlYzMgKiBtYXQ0LCBjb252ZXJ0IHRoZSB2ZWMzIGludG8gYSB2ZWM0IGJ5IGFkZGluZyBhXG4qIHcgZGltZW5zaW9uIGFzIDEuMC4gICB2ZWM0KHBvc2l0aW9uLCAxLjApLlxuKlxuKiBJbiBlZmZlY3QgeW91IGFyZSBkb2luZzpcbiogZ2xfUG9zaXRpb24gPSBQcm9qZWN0IChtYXQ0KSAqIFZpZXcgKG1hdDQpICogTW9kZWwgKG1hdDQpICogdmVjNCAocG9zaXRpb24sIHcpXG4qXG4qIHJlc3VsdGluZyBpbiBhIGRlZmF1bHQgdmVydGV4IHNoYWRlciBvZjpcbiogZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xuKi9cbmNvbnN0IHZzaGFkZXIgPSBgXG52b2lkIG1haW4oKSB7XG5cbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xuXG4gIC8vIE1ha2UgZWFjaCB2ZXJ0aWNlcyBwb3NpdGlvbiBoYWxmLlxuICAvLyAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uICogMC41LCAxLjAgKTtcbn1cbmA7XG4vKipcbiAqXG4gKiBGcmFnIFNoYWRlclxuICogLSBGcmFnIHNob3VsZCBzZXQgdGhlIGdsX0ZyYWdDb2xvci5cbiAqIC0gZ2xfRnJhZ0NvbG9yIGlzIHR5cGUgdmVjNCBmb3JcbiAqIC0gQXBwbGllZCBwZXIgcGl4ZWwgb2YgdGhlIG1lc2guXG4gKlxuICogVGhyZWUuanMgQ29sb3IgdHJhbnNsYXRlcyB0byB2ZWMzIHR5cGUgd2hpY2ggd2UgcGFzcyBhcyBhIHVuaWZvcm0gdV9jb2xvci5cbiAqXG4gKi9cblxuY29uc3QgZnNoYWRlciA9IGBcbnVuaWZvcm0gdmVjMyB1X2NvbG9yO1xuXG52b2lkIG1haW4gKHZvaWQpXG57XG4vLyBHcmVlblxuLy8gICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMS4wLCAwLjAsIDEuMCk7XG5cbi8vIFJlZFxuLy8gICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMC4wLCAwLjAsIDEuMCk7XG5cbi8vIEZyb20gdW5pZm9ybVxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHVfY29sb3IsIDEuMCk7XG5cbi8vIFlvdSBjYW4gc3dhcCB0aGUgcmdiYSBvcmRlciBpZiB5b3Ugd2FudCB0byBncmVlbiBibHVlIHJlZCBhbHBoYS5cbi8vICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh1X2NvbG9yLCAxLjApLmdicmE7XG5cblxufVxuYDtcblxuY2xhc3MgR2xzbFBsYXlncm91bmQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgdGhpcy5jbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpOyAvLyAyeDJcblxuICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgtMSwgMSwgMSwgLTEsIDAuMSwgMTApO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgdGhpcy5yYWYgPSBuZXcgX3JhZi5SYWYodGhpcy5vblJhZi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIgPSBuZXcgX2RvbVdhdGNoZXIuRG9tV2F0Y2hlcigpO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdyZXNpemUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25SZXNpemUuYmluZCh0aGlzKSxcbiAgICAgIGV2ZW50T3B0aW9uczoge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgIHVfY29sb3I6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweGZmZmYwMClcbiAgICAgIH1cbiAgICB9OyAvLyAyeDIgc28gaXQgZmlsbCB0aGUgc2NyZWVuLlxuXG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDIsIDIpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZzaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZnNoYWRlclxuICAgIH0pOyAvLyBDcmVhdGUgbWVzaCAoZ2VvbSArIG1hdGVyaWFsKVxuXG4gICAgdGhpcy5wbGFuZSA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMucGxhbmUpO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAxO1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGlmIChhc3BlY3RSYXRpbyA+PSAxKSB7XG4gICAgICB3aWR0aCA9IDE7XG4gICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB3aW5kb3cuaW5uZXJXaWR0aCAqIHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdFJhdGlvO1xuICAgICAgaGVpZ2h0ID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbWVyYS5sZWZ0ID0gLXdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnJpZ2h0ID0gd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEudG9wID0gaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLmJvdHRvbSA9IC1oZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgfVxuXG4gIG9uUmFmKCkge1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdsc2xQbGF5Z3JvdW5kOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/glsl-playground.js\n");

/***/ }),

/***/ "./examples/glsl-playground10.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground10.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//  // https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739068\n//\nconst vshader = `\nvarying vec3 v_position; // Declare v_position\nvoid main() {\n  // Set the uv value.  Three.js passes the uv value by default of the current vertices.\n  v_position = position;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nvarying vec3 v_position;\n\n// Determine if a particular pixel is within the boundaries of a rectangle box.\n// Returns 1.0 when point pt,  is inside a rectangle defined by size and center.\n// pt - the point to test\n// size - the size of the rect\n// center - the center of the rect\nfloat rect(vec2 pt, vec2 size, vec2 center) {\n    // We need to offset the position of the virtual box to do a hit test.\n    vec2 p = pt - center;\n    vec2 halfsize = size * 0.5; // Half the size since we just need\n\n    // Now do a hit test of this rectangle and see if pt falls within it.\n    // float horz = (v_position.x > -halfsize.x && v_position.x < halfsize.x) ?\n    float horz = step(-halfsize.x, p.x) - step(halfsize.x, p.x);\n    float vert = step(-halfsize.y, p.y) - step(halfsize.y, p.y);\n    return horz * vert;\n}\n\n//\n// A classic 2d rotation matrix.\n//\n// mat2 mat = getRotationMatrix(rotationInRadians);\n// vec2 rotatedPoint = mat * v_position.xy;\n//\n//\n// Accepts an radian angle (theta) and returns a mat2 rotation matrix.\n// s = sin(theta)\n// c = cos(theta)\n//\n// Returned mat2\n//\n//    mat2          *      vec2.xy = new rotated position\n// --        ---         ---  --\n// |   c   -s  |    *    |   x  |  = new rotated position.\n// |   s    c  |         |   y  |\n// ---       ---         --    --\n//\n//\n// For example:\n// rotation 0\n// sin(0) = 0, cos(0) = 1\n//  1   0         x      1*x + 0*x     x\n//  0   1    *    y   =  0*y + 1*y  =  y\n// rotation of zero has no effect.\n\n\n// rotation 180 degrees (3.14 radian)\n// sin(3.14) = 0, cos(3.14) = -1\n//  -1   0         x      -1*x + 0*x     -x\n//  0   -1    *    y   =  0*y + 1*-y  =  -y\n// rotation makes it 180 flipping x,y so it's correct.\n//\nmat2 getRotationMatrix(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat2(c, -s, s, c);\n}\n\nvoid main (void)\n{\n  vec2 center = vec2(0.5, 0.0);\n\n  // Use time as the angle theta.\n  mat2 mat = getRotationMatrix(u_time);\n\n  // Transform the center v_position with the rotation matrix.\n  // We literally move/ shift the currently evaluated pixel point.\n   vec2 pt = mat * v_position.xy;\n\n  // Better version of the above which accounts for center point.\n  // To do this, we account of the center point by subtracking it from the\n  // v_position, then do the matrix tranform and then add it back.\n  //   vec2 pt = (mat * (v_position.xy - center)) + center;\n\n  // Use the new pt point to calculate to see if that point is in the\n  // considered rectangle.\n  float inRect = rect(pt.xy, vec2(0.3), center);\n\n  vec3 color = vec3(1.0, 1.0, 0.0) * inRect;\n  gl_FragColor = vec4(color, 1.0);\n\n\n\n\n\n\n}\n`;\n\nclass GlslPlayground10 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color: {\n        value: new THREE.Color(0xff0000)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground10;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQxMC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDEwLmpzPzgyZWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vL1xuLy8gIC8vIGh0dHBzOi8vd3d3LnVkZW15LmNvbS9jb3Vyc2UvbGVhcm4tZ2xzbC1zaGFkZXJzLWZyb20tc2NyYXRjaC9sZWFybi9sZWN0dXJlLzEzNzM5MDY4XG4vL1xuY29uc3QgdnNoYWRlciA9IGBcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uOyAvLyBEZWNsYXJlIHZfcG9zaXRpb25cbnZvaWQgbWFpbigpIHtcbiAgLy8gU2V0IHRoZSB1diB2YWx1ZS4gIFRocmVlLmpzIHBhc3NlcyB0aGUgdXYgdmFsdWUgYnkgZGVmYXVsdCBvZiB0aGUgY3VycmVudCB2ZXJ0aWNlcy5cbiAgdl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbnVuaWZvcm0gdmVjMiB1X21vdXNlO1xudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gdmVjMyB1X2NvbG9yO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG5cbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xuXG4vLyBEZXRlcm1pbmUgaWYgYSBwYXJ0aWN1bGFyIHBpeGVsIGlzIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiBhIHJlY3RhbmdsZSBib3guXG4vLyBSZXR1cm5zIDEuMCB3aGVuIHBvaW50IHB0LCAgaXMgaW5zaWRlIGEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgc2l6ZSBhbmQgY2VudGVyLlxuLy8gcHQgLSB0aGUgcG9pbnQgdG8gdGVzdFxuLy8gc2l6ZSAtIHRoZSBzaXplIG9mIHRoZSByZWN0XG4vLyBjZW50ZXIgLSB0aGUgY2VudGVyIG9mIHRoZSByZWN0XG5mbG9hdCByZWN0KHZlYzIgcHQsIHZlYzIgc2l6ZSwgdmVjMiBjZW50ZXIpIHtcbiAgICAvLyBXZSBuZWVkIHRvIG9mZnNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHZpcnR1YWwgYm94IHRvIGRvIGEgaGl0IHRlc3QuXG4gICAgdmVjMiBwID0gcHQgLSBjZW50ZXI7XG4gICAgdmVjMiBoYWxmc2l6ZSA9IHNpemUgKiAwLjU7IC8vIEhhbGYgdGhlIHNpemUgc2luY2Ugd2UganVzdCBuZWVkXG5cbiAgICAvLyBOb3cgZG8gYSBoaXQgdGVzdCBvZiB0aGlzIHJlY3RhbmdsZSBhbmQgc2VlIGlmIHB0IGZhbGxzIHdpdGhpbiBpdC5cbiAgICAvLyBmbG9hdCBob3J6ID0gKHZfcG9zaXRpb24ueCA+IC1oYWxmc2l6ZS54ICYmIHZfcG9zaXRpb24ueCA8IGhhbGZzaXplLngpID9cbiAgICBmbG9hdCBob3J6ID0gc3RlcCgtaGFsZnNpemUueCwgcC54KSAtIHN0ZXAoaGFsZnNpemUueCwgcC54KTtcbiAgICBmbG9hdCB2ZXJ0ID0gc3RlcCgtaGFsZnNpemUueSwgcC55KSAtIHN0ZXAoaGFsZnNpemUueSwgcC55KTtcbiAgICByZXR1cm4gaG9yeiAqIHZlcnQ7XG59XG5cbi8vXG4vLyBBIGNsYXNzaWMgMmQgcm90YXRpb24gbWF0cml4LlxuLy9cbi8vIG1hdDIgbWF0ID0gZ2V0Um90YXRpb25NYXRyaXgocm90YXRpb25JblJhZGlhbnMpO1xuLy8gdmVjMiByb3RhdGVkUG9pbnQgPSBtYXQgKiB2X3Bvc2l0aW9uLnh5O1xuLy9cbi8vXG4vLyBBY2NlcHRzIGFuIHJhZGlhbiBhbmdsZSAodGhldGEpIGFuZCByZXR1cm5zIGEgbWF0MiByb3RhdGlvbiBtYXRyaXguXG4vLyBzID0gc2luKHRoZXRhKVxuLy8gYyA9IGNvcyh0aGV0YSlcbi8vXG4vLyBSZXR1cm5lZCBtYXQyXG4vL1xuLy8gICAgbWF0MiAgICAgICAgICAqICAgICAgdmVjMi54eSA9IG5ldyByb3RhdGVkIHBvc2l0aW9uXG4vLyAtLSAgICAgICAgLS0tICAgICAgICAgLS0tICAtLVxuLy8gfCAgIGMgICAtcyAgfCAgICAqICAgIHwgICB4ICB8ICA9IG5ldyByb3RhdGVkIHBvc2l0aW9uLlxuLy8gfCAgIHMgICAgYyAgfCAgICAgICAgIHwgICB5ICB8XG4vLyAtLS0gICAgICAgLS0tICAgICAgICAgLS0gICAgLS1cbi8vXG4vL1xuLy8gRm9yIGV4YW1wbGU6XG4vLyByb3RhdGlvbiAwXG4vLyBzaW4oMCkgPSAwLCBjb3MoMCkgPSAxXG4vLyAgMSAgIDAgICAgICAgICB4ICAgICAgMSp4ICsgMCp4ICAgICB4XG4vLyAgMCAgIDEgICAgKiAgICB5ICAgPSAgMCp5ICsgMSp5ICA9ICB5XG4vLyByb3RhdGlvbiBvZiB6ZXJvIGhhcyBubyBlZmZlY3QuXG5cblxuLy8gcm90YXRpb24gMTgwIGRlZ3JlZXMgKDMuMTQgcmFkaWFuKVxuLy8gc2luKDMuMTQpID0gMCwgY29zKDMuMTQpID0gLTFcbi8vICAtMSAgIDAgICAgICAgICB4ICAgICAgLTEqeCArIDAqeCAgICAgLXhcbi8vICAwICAgLTEgICAgKiAgICB5ICAgPSAgMCp5ICsgMSoteSAgPSAgLXlcbi8vIHJvdGF0aW9uIG1ha2VzIGl0IDE4MCBmbGlwcGluZyB4LHkgc28gaXQncyBjb3JyZWN0LlxuLy9cbm1hdDIgZ2V0Um90YXRpb25NYXRyaXgoZmxvYXQgdGhldGEpIHtcbiAgICBmbG9hdCBzID0gc2luKHRoZXRhKTtcbiAgICBmbG9hdCBjID0gY29zKHRoZXRhKTtcbiAgICByZXR1cm4gbWF0MihjLCAtcywgcywgYyk7XG59XG5cbnZvaWQgbWFpbiAodm9pZClcbntcbiAgdmVjMiBjZW50ZXIgPSB2ZWMyKDAuNSwgMC4wKTtcblxuICAvLyBVc2UgdGltZSBhcyB0aGUgYW5nbGUgdGhldGEuXG4gIG1hdDIgbWF0ID0gZ2V0Um90YXRpb25NYXRyaXgodV90aW1lKTtcblxuICAvLyBUcmFuc2Zvcm0gdGhlIGNlbnRlciB2X3Bvc2l0aW9uIHdpdGggdGhlIHJvdGF0aW9uIG1hdHJpeC5cbiAgLy8gV2UgbGl0ZXJhbGx5IG1vdmUvIHNoaWZ0IHRoZSBjdXJyZW50bHkgZXZhbHVhdGVkIHBpeGVsIHBvaW50LlxuICAgdmVjMiBwdCA9IG1hdCAqIHZfcG9zaXRpb24ueHk7XG5cbiAgLy8gQmV0dGVyIHZlcnNpb24gb2YgdGhlIGFib3ZlIHdoaWNoIGFjY291bnRzIGZvciBjZW50ZXIgcG9pbnQuXG4gIC8vIFRvIGRvIHRoaXMsIHdlIGFjY291bnQgb2YgdGhlIGNlbnRlciBwb2ludCBieSBzdWJ0cmFja2luZyBpdCBmcm9tIHRoZVxuICAvLyB2X3Bvc2l0aW9uLCB0aGVuIGRvIHRoZSBtYXRyaXggdHJhbmZvcm0gYW5kIHRoZW4gYWRkIGl0IGJhY2suXG4gIC8vICAgdmVjMiBwdCA9IChtYXQgKiAodl9wb3NpdGlvbi54eSAtIGNlbnRlcikpICsgY2VudGVyO1xuXG4gIC8vIFVzZSB0aGUgbmV3IHB0IHBvaW50IHRvIGNhbGN1bGF0ZSB0byBzZWUgaWYgdGhhdCBwb2ludCBpcyBpbiB0aGVcbiAgLy8gY29uc2lkZXJlZCByZWN0YW5nbGUuXG4gIGZsb2F0IGluUmVjdCA9IHJlY3QocHQueHksIHZlYzIoMC4zKSwgY2VudGVyKTtcblxuICB2ZWMzIGNvbG9yID0gdmVjMygxLjAsIDEuMCwgMC4wKSAqIGluUmVjdDtcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcblxuXG5cblxuXG5cbn1cbmA7XG5cbmNsYXNzIEdsc2xQbGF5Z3JvdW5kMTAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vIDJ4MlxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMC4xLCAxMCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgdV9jb2xvcjoge1xuICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKDB4ZmYwMDAwKVxuICAgICAgfSxcbiAgICAgIC8vIEZsb2F0XG4gICAgICB1X3RpbWU6IHtcbiAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgfSxcbiAgICAgIC8vIFZlYzIgMCwwIGF0IHRvcCwgbGVmdCBhbmQgd2luZG93LmlubmVyV2lkdGggYW5kIHdpbmRvdy5pbm5lckhlaWdodCBhdCBib3R0b20gcmlnaHQuXG4gICAgICB1X21vdXNlOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMC4wLFxuICAgICAgICAgIHk6IDAuMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVmVjMiBTY3JlZW4gcmVzb2x1dGlvblxuICAgICAgdV9yZXNvbHV0aW9uOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvLyAyeDIgc28gaXQgZmlsbCB0aGUgc2NyZWVuLlxuXG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDIsIDIpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZzaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZnNoYWRlclxuICAgIH0pOyAvLyBDcmVhdGUgbWVzaCAoZ2VvbSArIG1hdGVyaWFsKVxuXG4gICAgdGhpcy5wbGFuZSA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMucGxhbmUpO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAxO1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGlmIChhc3BlY3RSYXRpbyA+PSAxKSB7XG4gICAgICB3aWR0aCA9IDE7XG4gICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB3aW5kb3cuaW5uZXJXaWR0aCAqIHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdFJhdGlvO1xuICAgICAgaGVpZ2h0ID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbWVyYS5sZWZ0ID0gLXdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnJpZ2h0ID0gd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEudG9wID0gaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLmJvdHRvbSA9IC1oZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS54ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGV2dCkge1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS54ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRYIDogZXZ0LmNsaWVudFg7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnkgPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFkgOiBldnQuY2xpZW50WTtcbiAgfVxuXG4gIG9uUmFmKGRlbHRhKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X3RpbWUudmFsdWUgKz0gdGhpcy5yYWYuZ2V0RGVsdGEodHJ1ZSk7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gR2xzbFBsYXlncm91bmQxMDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/glsl-playground10.js\n");

/***/ }),

/***/ "./examples/glsl-playground11.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground11.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//  // https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739068\n//\nconst vshader = `\nvarying vec3 v_position; // Declare v_position\nvoid main() {\n  // Set the uv value.  Three.js passes the uv value by default of the current vertices.\n  v_position = position;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nvarying vec3 v_position;\n\n// Determine if a particular pixel is within the boundaries of a rectangle box.\n// Returns 1.0 when point pt,  is inside a rectangle defined by size and center.\n// pt - the point to test\n// anchor - the rectangle anchor point\n// size - the size of the rect\n// center - the center of the rect\nfloat rect(vec2 pt, vec2 anchor, vec2 size, vec2 center) {\n    // We need to offset the position of the virtual box to do a hit test.\n    vec2 p = pt - center;\n    vec2 halfsize = size * 0.5; // Half the size since we just need\n\n    // Now do a hit test of this rectangle and see if pt falls within it.\n    // float horz = (v_position.x > -halfsize.x && v_position.x < halfsize.x) ?\n    float horz = step(-halfsize.x - anchor.x, p.x) - step(halfsize.x - anchor.x, p.x);\n    float vert = step(-halfsize.y - anchor.y, p.y) - step(halfsize.y - anchor.y, p.y);\n    return horz * vert;\n}\n\n//\n// A classic 2d rotation matrix.\n//\n// mat2 mat = getRotationMatrix(rotationInRadians);\n// vec2 rotatedPoint = mat * v_position.xy;\n//\n//\n// Accepts an radian angle (theta) and returns a mat2 rotation matrix.\n// s = sin(theta)\n// c = cos(theta)\n//\n// Returned mat2\n//\n//    mat2          *      vec2.xy = new rotated position\n// --        ---         ---  --\n// |   c   -s  |    *    |   x  |  = new rotated position.\n// |   s    c  |         |   y  |\n// ---       ---         --    --\n//\n//\n// For example:\n// rotation 0\n// sin(0) = 0, cos(0) = 1\n//  1   0         x      1*x + 0*x     x\n//  0   1    *    y   =  0*y + 1*y  =  y\n// rotation of zero has no effect.\n\n\n// rotation 180 degrees (3.14 radian)\n// sin(3.14) = 0, cos(3.14) = -1\n//  -1   0         x      -1*x + 0*x     -x\n//  0   -1    *    y   =  0*y + 1*-y  =  -y\n// rotation makes it 180 flipping x,y so it's correct.\n//\nmat2 getRotationMatrix(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat2(c, -s, s, c);\n}\n\n\n/**\n * Return a mat2 scale matrix.\n *\n * mat2 scaleMat = getScaleMatrix(1.5);\n * mat2 rotateMat = getRotationMatrix(rotationInRadians);\n * vec2 scaledPoint = scaleMat * v_position.xy;\n * vec2 scaledAndRotatedPoint = scaleMat * rotateMat * v_position.xy;\n *\n */\nmat2 getScaleMatrix(float scale) {\n    return mat2(scale, 0, 0, scale);\n}\n\n\nvoid main (void)\n{\n  vec2 center = vec2(0.2, 0.0);\n\n  // Use time as the angle theta.\n  mat2 rotationMatrix = getRotationMatrix(u_time);\n\n  // Create scale matrix based on time\n  mat2 scaleMatrix = getScaleMatrix(\n      ((sin(u_time) + 1.0) / 2.0) + 0.5 // Normalized sin + 0.5 offset so it ranges from 0.5 - 1.5\n   );\n\n\n  // Apply the scale + rotation matrix to the current v_position\n   vec2 pt = scaleMatrix * rotationMatrix * v_position.xy;\n\n  // Better version of the above which accounts for center point.\n  // To do this, we account of the center point by subtracking it from the\n  // v_position, then do the matrix tranform and then add it back.\n//   vec2 pt = (rotationMatrix * (v_position.xy - center)) + center;\n\n  // Use the new pt point to calculate to see if that point is in the\n  // considered rectangle.\n  float inRect = rect(pt.xy, vec2(0.15), vec2(0.3), center);\n\n  vec3 color = vec3(1.0, 1.0, 0.0) * inRect;\n  gl_FragColor = vec4(color, 1.0);\n\n\n\n\n\n\n}\n`;\n\nclass GlslPlayground10 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color: {\n        value: new THREE.Color(0xff0000)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground10;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQxMS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDExLmpzPzljMDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vL1xuLy8gIC8vIGh0dHBzOi8vd3d3LnVkZW15LmNvbS9jb3Vyc2UvbGVhcm4tZ2xzbC1zaGFkZXJzLWZyb20tc2NyYXRjaC9sZWFybi9sZWN0dXJlLzEzNzM5MDY4XG4vL1xuY29uc3QgdnNoYWRlciA9IGBcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uOyAvLyBEZWNsYXJlIHZfcG9zaXRpb25cbnZvaWQgbWFpbigpIHtcbiAgLy8gU2V0IHRoZSB1diB2YWx1ZS4gIFRocmVlLmpzIHBhc3NlcyB0aGUgdXYgdmFsdWUgYnkgZGVmYXVsdCBvZiB0aGUgY3VycmVudCB2ZXJ0aWNlcy5cbiAgdl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbnVuaWZvcm0gdmVjMiB1X21vdXNlO1xudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gdmVjMyB1X2NvbG9yO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG5cbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xuXG4vLyBEZXRlcm1pbmUgaWYgYSBwYXJ0aWN1bGFyIHBpeGVsIGlzIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiBhIHJlY3RhbmdsZSBib3guXG4vLyBSZXR1cm5zIDEuMCB3aGVuIHBvaW50IHB0LCAgaXMgaW5zaWRlIGEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgc2l6ZSBhbmQgY2VudGVyLlxuLy8gcHQgLSB0aGUgcG9pbnQgdG8gdGVzdFxuLy8gYW5jaG9yIC0gdGhlIHJlY3RhbmdsZSBhbmNob3IgcG9pbnRcbi8vIHNpemUgLSB0aGUgc2l6ZSBvZiB0aGUgcmVjdFxuLy8gY2VudGVyIC0gdGhlIGNlbnRlciBvZiB0aGUgcmVjdFxuZmxvYXQgcmVjdCh2ZWMyIHB0LCB2ZWMyIGFuY2hvciwgdmVjMiBzaXplLCB2ZWMyIGNlbnRlcikge1xuICAgIC8vIFdlIG5lZWQgdG8gb2Zmc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgdmlydHVhbCBib3ggdG8gZG8gYSBoaXQgdGVzdC5cbiAgICB2ZWMyIHAgPSBwdCAtIGNlbnRlcjtcbiAgICB2ZWMyIGhhbGZzaXplID0gc2l6ZSAqIDAuNTsgLy8gSGFsZiB0aGUgc2l6ZSBzaW5jZSB3ZSBqdXN0IG5lZWRcblxuICAgIC8vIE5vdyBkbyBhIGhpdCB0ZXN0IG9mIHRoaXMgcmVjdGFuZ2xlIGFuZCBzZWUgaWYgcHQgZmFsbHMgd2l0aGluIGl0LlxuICAgIC8vIGZsb2F0IGhvcnogPSAodl9wb3NpdGlvbi54ID4gLWhhbGZzaXplLnggJiYgdl9wb3NpdGlvbi54IDwgaGFsZnNpemUueCkgP1xuICAgIGZsb2F0IGhvcnogPSBzdGVwKC1oYWxmc2l6ZS54IC0gYW5jaG9yLngsIHAueCkgLSBzdGVwKGhhbGZzaXplLnggLSBhbmNob3IueCwgcC54KTtcbiAgICBmbG9hdCB2ZXJ0ID0gc3RlcCgtaGFsZnNpemUueSAtIGFuY2hvci55LCBwLnkpIC0gc3RlcChoYWxmc2l6ZS55IC0gYW5jaG9yLnksIHAueSk7XG4gICAgcmV0dXJuIGhvcnogKiB2ZXJ0O1xufVxuXG4vL1xuLy8gQSBjbGFzc2ljIDJkIHJvdGF0aW9uIG1hdHJpeC5cbi8vXG4vLyBtYXQyIG1hdCA9IGdldFJvdGF0aW9uTWF0cml4KHJvdGF0aW9uSW5SYWRpYW5zKTtcbi8vIHZlYzIgcm90YXRlZFBvaW50ID0gbWF0ICogdl9wb3NpdGlvbi54eTtcbi8vXG4vL1xuLy8gQWNjZXB0cyBhbiByYWRpYW4gYW5nbGUgKHRoZXRhKSBhbmQgcmV0dXJucyBhIG1hdDIgcm90YXRpb24gbWF0cml4LlxuLy8gcyA9IHNpbih0aGV0YSlcbi8vIGMgPSBjb3ModGhldGEpXG4vL1xuLy8gUmV0dXJuZWQgbWF0MlxuLy9cbi8vICAgIG1hdDIgICAgICAgICAgKiAgICAgIHZlYzIueHkgPSBuZXcgcm90YXRlZCBwb3NpdGlvblxuLy8gLS0gICAgICAgIC0tLSAgICAgICAgIC0tLSAgLS1cbi8vIHwgICBjICAgLXMgIHwgICAgKiAgICB8ICAgeCAgfCAgPSBuZXcgcm90YXRlZCBwb3NpdGlvbi5cbi8vIHwgICBzICAgIGMgIHwgICAgICAgICB8ICAgeSAgfFxuLy8gLS0tICAgICAgIC0tLSAgICAgICAgIC0tICAgIC0tXG4vL1xuLy9cbi8vIEZvciBleGFtcGxlOlxuLy8gcm90YXRpb24gMFxuLy8gc2luKDApID0gMCwgY29zKDApID0gMVxuLy8gIDEgICAwICAgICAgICAgeCAgICAgIDEqeCArIDAqeCAgICAgeFxuLy8gIDAgICAxICAgICogICAgeSAgID0gIDAqeSArIDEqeSAgPSAgeVxuLy8gcm90YXRpb24gb2YgemVybyBoYXMgbm8gZWZmZWN0LlxuXG5cbi8vIHJvdGF0aW9uIDE4MCBkZWdyZWVzICgzLjE0IHJhZGlhbilcbi8vIHNpbigzLjE0KSA9IDAsIGNvcygzLjE0KSA9IC0xXG4vLyAgLTEgICAwICAgICAgICAgeCAgICAgIC0xKnggKyAwKnggICAgIC14XG4vLyAgMCAgIC0xICAgICogICAgeSAgID0gIDAqeSArIDEqLXkgID0gIC15XG4vLyByb3RhdGlvbiBtYWtlcyBpdCAxODAgZmxpcHBpbmcgeCx5IHNvIGl0J3MgY29ycmVjdC5cbi8vXG5tYXQyIGdldFJvdGF0aW9uTWF0cml4KGZsb2F0IHRoZXRhKSB7XG4gICAgZmxvYXQgcyA9IHNpbih0aGV0YSk7XG4gICAgZmxvYXQgYyA9IGNvcyh0aGV0YSk7XG4gICAgcmV0dXJuIG1hdDIoYywgLXMsIHMsIGMpO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIGEgbWF0MiBzY2FsZSBtYXRyaXguXG4gKlxuICogbWF0MiBzY2FsZU1hdCA9IGdldFNjYWxlTWF0cml4KDEuNSk7XG4gKiBtYXQyIHJvdGF0ZU1hdCA9IGdldFJvdGF0aW9uTWF0cml4KHJvdGF0aW9uSW5SYWRpYW5zKTtcbiAqIHZlYzIgc2NhbGVkUG9pbnQgPSBzY2FsZU1hdCAqIHZfcG9zaXRpb24ueHk7XG4gKiB2ZWMyIHNjYWxlZEFuZFJvdGF0ZWRQb2ludCA9IHNjYWxlTWF0ICogcm90YXRlTWF0ICogdl9wb3NpdGlvbi54eTtcbiAqXG4gKi9cbm1hdDIgZ2V0U2NhbGVNYXRyaXgoZmxvYXQgc2NhbGUpIHtcbiAgICByZXR1cm4gbWF0MihzY2FsZSwgMCwgMCwgc2NhbGUpO1xufVxuXG5cbnZvaWQgbWFpbiAodm9pZClcbntcbiAgdmVjMiBjZW50ZXIgPSB2ZWMyKDAuMiwgMC4wKTtcblxuICAvLyBVc2UgdGltZSBhcyB0aGUgYW5nbGUgdGhldGEuXG4gIG1hdDIgcm90YXRpb25NYXRyaXggPSBnZXRSb3RhdGlvbk1hdHJpeCh1X3RpbWUpO1xuXG4gIC8vIENyZWF0ZSBzY2FsZSBtYXRyaXggYmFzZWQgb24gdGltZVxuICBtYXQyIHNjYWxlTWF0cml4ID0gZ2V0U2NhbGVNYXRyaXgoXG4gICAgICAoKHNpbih1X3RpbWUpICsgMS4wKSAvIDIuMCkgKyAwLjUgLy8gTm9ybWFsaXplZCBzaW4gKyAwLjUgb2Zmc2V0IHNvIGl0IHJhbmdlcyBmcm9tIDAuNSAtIDEuNVxuICAgKTtcblxuXG4gIC8vIEFwcGx5IHRoZSBzY2FsZSArIHJvdGF0aW9uIG1hdHJpeCB0byB0aGUgY3VycmVudCB2X3Bvc2l0aW9uXG4gICB2ZWMyIHB0ID0gc2NhbGVNYXRyaXggKiByb3RhdGlvbk1hdHJpeCAqIHZfcG9zaXRpb24ueHk7XG5cbiAgLy8gQmV0dGVyIHZlcnNpb24gb2YgdGhlIGFib3ZlIHdoaWNoIGFjY291bnRzIGZvciBjZW50ZXIgcG9pbnQuXG4gIC8vIFRvIGRvIHRoaXMsIHdlIGFjY291bnQgb2YgdGhlIGNlbnRlciBwb2ludCBieSBzdWJ0cmFja2luZyBpdCBmcm9tIHRoZVxuICAvLyB2X3Bvc2l0aW9uLCB0aGVuIGRvIHRoZSBtYXRyaXggdHJhbmZvcm0gYW5kIHRoZW4gYWRkIGl0IGJhY2suXG4vLyAgIHZlYzIgcHQgPSAocm90YXRpb25NYXRyaXggKiAodl9wb3NpdGlvbi54eSAtIGNlbnRlcikpICsgY2VudGVyO1xuXG4gIC8vIFVzZSB0aGUgbmV3IHB0IHBvaW50IHRvIGNhbGN1bGF0ZSB0byBzZWUgaWYgdGhhdCBwb2ludCBpcyBpbiB0aGVcbiAgLy8gY29uc2lkZXJlZCByZWN0YW5nbGUuXG4gIGZsb2F0IGluUmVjdCA9IHJlY3QocHQueHksIHZlYzIoMC4xNSksIHZlYzIoMC4zKSwgY2VudGVyKTtcblxuICB2ZWMzIGNvbG9yID0gdmVjMygxLjAsIDEuMCwgMC4wKSAqIGluUmVjdDtcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcblxuXG5cblxuXG5cbn1cbmA7XG5cbmNsYXNzIEdsc2xQbGF5Z3JvdW5kMTAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vIDJ4MlxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMC4xLCAxMCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgdV9jb2xvcjoge1xuICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKDB4ZmYwMDAwKVxuICAgICAgfSxcbiAgICAgIC8vIEZsb2F0XG4gICAgICB1X3RpbWU6IHtcbiAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgfSxcbiAgICAgIC8vIFZlYzIgMCwwIGF0IHRvcCwgbGVmdCBhbmQgd2luZG93LmlubmVyV2lkdGggYW5kIHdpbmRvdy5pbm5lckhlaWdodCBhdCBib3R0b20gcmlnaHQuXG4gICAgICB1X21vdXNlOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMC4wLFxuICAgICAgICAgIHk6IDAuMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVmVjMiBTY3JlZW4gcmVzb2x1dGlvblxuICAgICAgdV9yZXNvbHV0aW9uOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvLyAyeDIgc28gaXQgZmlsbCB0aGUgc2NyZWVuLlxuXG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDIsIDIpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZzaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZnNoYWRlclxuICAgIH0pOyAvLyBDcmVhdGUgbWVzaCAoZ2VvbSArIG1hdGVyaWFsKVxuXG4gICAgdGhpcy5wbGFuZSA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMucGxhbmUpO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAxO1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGlmIChhc3BlY3RSYXRpbyA+PSAxKSB7XG4gICAgICB3aWR0aCA9IDE7XG4gICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB3aW5kb3cuaW5uZXJXaWR0aCAqIHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdFJhdGlvO1xuICAgICAgaGVpZ2h0ID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbWVyYS5sZWZ0ID0gLXdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnJpZ2h0ID0gd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEudG9wID0gaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLmJvdHRvbSA9IC1oZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS54ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGV2dCkge1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS54ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRYIDogZXZ0LmNsaWVudFg7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnkgPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFkgOiBldnQuY2xpZW50WTtcbiAgfVxuXG4gIG9uUmFmKGRlbHRhKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X3RpbWUudmFsdWUgKz0gdGhpcy5yYWYuZ2V0RGVsdGEodHJ1ZSk7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gR2xzbFBsYXlncm91bmQxMDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/glsl-playground11.js\n");

/***/ }),

/***/ "./examples/glsl-playground12.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground12.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//  // https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739068\n//\nconst vshader = `\nvarying vec2 v_uv; // Declare v_uv\nvoid main() {\n  // Set the uv value.  Three.js passes the uv value by default of the current vertices.\n  v_uv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nvarying vec2 v_uv;\n\n\nfloat rect(vec2 pt, vec2 size, vec2 center) {\n    // We need to offset the position of the virtual box to do a hit test.\n    vec2 p = pt - center;\n    vec2 halfsize = size * 0.5; // Half the size since we just need\n\n    // Now do a hit test of this rectangle and see if pt falls within it.\n    // float horz = (v_position.x > -halfsize.x && v_position.x < halfsize.x) ?\n    float horz = step(-halfsize.x, p.x) - step(halfsize.x, p.x);\n    float vert = step(-halfsize.y, p.y) - step(halfsize.y, p.y);\n    return horz * vert;\n}\n\nmat2 getRotationMatrix(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat2(c, -s, s, c);\n}\n\n\nmat2 getScaleMatrix(float scale) {\n    return mat2(scale, 0, 0, scale);\n}\n\n\n/**\n * This is an example of tiling. It works because we are working with\n * uv values from 0-1 and use fract to divide it to the screen.\n *\n */\nvoid main (void)\n{\n\n  float tilecount = 6.0;\n//   vec2 tilecount = vec2(50.0, 50.0);\n  vec2 center = vec2(0.5);\n\n  // Use time as the angle theta.\n  mat2 rotationMatrix = getRotationMatrix(u_time);\n\n  // Tiling with fract.  If tilecount is 6, if your window is square, you will\n  // get 6 rows and 6 columns.\n  //\n  // This it the same as:\n  // p.x = fract(v_uv.x * 6.0)\n  // p.y = fract(v_uv.y * 6.0)\n  //\n  // Which assigns the fraction values.\n  vec2 p = fract(v_uv * tilecount);\n\n  // Apply the scale + rotation matrix to the current v_position\n  vec2 pt = (rotationMatrix * (p - center)) + center;\n\n  float inRect = rect(pt, vec2(0.5), center);\n  vec3 color = vec3(1.0, 1.0, 0.0) * inRect;\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground10 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color: {\n        value: new THREE.Color(0xff0000)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground10;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQxMi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDEyLmpzP2NhZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vL1xuLy8gIC8vIGh0dHBzOi8vd3d3LnVkZW15LmNvbS9jb3Vyc2UvbGVhcm4tZ2xzbC1zaGFkZXJzLWZyb20tc2NyYXRjaC9sZWFybi9sZWN0dXJlLzEzNzM5MDY4XG4vL1xuY29uc3QgdnNoYWRlciA9IGBcbnZhcnlpbmcgdmVjMiB2X3V2OyAvLyBEZWNsYXJlIHZfdXZcbnZvaWQgbWFpbigpIHtcbiAgLy8gU2V0IHRoZSB1diB2YWx1ZS4gIFRocmVlLmpzIHBhc3NlcyB0aGUgdXYgdmFsdWUgYnkgZGVmYXVsdCBvZiB0aGUgY3VycmVudCB2ZXJ0aWNlcy5cbiAgdl91diA9IHV2O1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbnVuaWZvcm0gdmVjMiB1X21vdXNlO1xudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gdmVjMyB1X2NvbG9yO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG5cbnZhcnlpbmcgdmVjMiB2X3V2O1xuXG5cbmZsb2F0IHJlY3QodmVjMiBwdCwgdmVjMiBzaXplLCB2ZWMyIGNlbnRlcikge1xuICAgIC8vIFdlIG5lZWQgdG8gb2Zmc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgdmlydHVhbCBib3ggdG8gZG8gYSBoaXQgdGVzdC5cbiAgICB2ZWMyIHAgPSBwdCAtIGNlbnRlcjtcbiAgICB2ZWMyIGhhbGZzaXplID0gc2l6ZSAqIDAuNTsgLy8gSGFsZiB0aGUgc2l6ZSBzaW5jZSB3ZSBqdXN0IG5lZWRcblxuICAgIC8vIE5vdyBkbyBhIGhpdCB0ZXN0IG9mIHRoaXMgcmVjdGFuZ2xlIGFuZCBzZWUgaWYgcHQgZmFsbHMgd2l0aGluIGl0LlxuICAgIC8vIGZsb2F0IGhvcnogPSAodl9wb3NpdGlvbi54ID4gLWhhbGZzaXplLnggJiYgdl9wb3NpdGlvbi54IDwgaGFsZnNpemUueCkgP1xuICAgIGZsb2F0IGhvcnogPSBzdGVwKC1oYWxmc2l6ZS54LCBwLngpIC0gc3RlcChoYWxmc2l6ZS54LCBwLngpO1xuICAgIGZsb2F0IHZlcnQgPSBzdGVwKC1oYWxmc2l6ZS55LCBwLnkpIC0gc3RlcChoYWxmc2l6ZS55LCBwLnkpO1xuICAgIHJldHVybiBob3J6ICogdmVydDtcbn1cblxubWF0MiBnZXRSb3RhdGlvbk1hdHJpeChmbG9hdCB0aGV0YSkge1xuICAgIGZsb2F0IHMgPSBzaW4odGhldGEpO1xuICAgIGZsb2F0IGMgPSBjb3ModGhldGEpO1xuICAgIHJldHVybiBtYXQyKGMsIC1zLCBzLCBjKTtcbn1cblxuXG5tYXQyIGdldFNjYWxlTWF0cml4KGZsb2F0IHNjYWxlKSB7XG4gICAgcmV0dXJuIG1hdDIoc2NhbGUsIDAsIDAsIHNjYWxlKTtcbn1cblxuXG4vKipcbiAqIFRoaXMgaXMgYW4gZXhhbXBsZSBvZiB0aWxpbmcuIEl0IHdvcmtzIGJlY2F1c2Ugd2UgYXJlIHdvcmtpbmcgd2l0aFxuICogdXYgdmFsdWVzIGZyb20gMC0xIGFuZCB1c2UgZnJhY3QgdG8gZGl2aWRlIGl0IHRvIHRoZSBzY3JlZW4uXG4gKlxuICovXG52b2lkIG1haW4gKHZvaWQpXG57XG5cbiAgZmxvYXQgdGlsZWNvdW50ID0gNi4wO1xuLy8gICB2ZWMyIHRpbGVjb3VudCA9IHZlYzIoNTAuMCwgNTAuMCk7XG4gIHZlYzIgY2VudGVyID0gdmVjMigwLjUpO1xuXG4gIC8vIFVzZSB0aW1lIGFzIHRoZSBhbmdsZSB0aGV0YS5cbiAgbWF0MiByb3RhdGlvbk1hdHJpeCA9IGdldFJvdGF0aW9uTWF0cml4KHVfdGltZSk7XG5cbiAgLy8gVGlsaW5nIHdpdGggZnJhY3QuICBJZiB0aWxlY291bnQgaXMgNiwgaWYgeW91ciB3aW5kb3cgaXMgc3F1YXJlLCB5b3Ugd2lsbFxuICAvLyBnZXQgNiByb3dzIGFuZCA2IGNvbHVtbnMuXG4gIC8vXG4gIC8vIFRoaXMgaXQgdGhlIHNhbWUgYXM6XG4gIC8vIHAueCA9IGZyYWN0KHZfdXYueCAqIDYuMClcbiAgLy8gcC55ID0gZnJhY3Qodl91di55ICogNi4wKVxuICAvL1xuICAvLyBXaGljaCBhc3NpZ25zIHRoZSBmcmFjdGlvbiB2YWx1ZXMuXG4gIHZlYzIgcCA9IGZyYWN0KHZfdXYgKiB0aWxlY291bnQpO1xuXG4gIC8vIEFwcGx5IHRoZSBzY2FsZSArIHJvdGF0aW9uIG1hdHJpeCB0byB0aGUgY3VycmVudCB2X3Bvc2l0aW9uXG4gIHZlYzIgcHQgPSAocm90YXRpb25NYXRyaXggKiAocCAtIGNlbnRlcikpICsgY2VudGVyO1xuXG4gIGZsb2F0IGluUmVjdCA9IHJlY3QocHQsIHZlYzIoMC41KSwgY2VudGVyKTtcbiAgdmVjMyBjb2xvciA9IHZlYzMoMS4wLCAxLjAsIDAuMCkgKiBpblJlY3Q7XG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuMCk7XG59XG5gO1xuXG5jbGFzcyBHbHNsUGxheWdyb3VuZDEwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpOyAvLyAyeDJcblxuICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgtMSwgMSwgMSwgLTEsIDAuMSwgMTApO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgdGhpcy5yYWYgPSBuZXcgX3JhZi5SYWYodGhpcy5vblJhZi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIgPSBuZXcgX2RvbVdhdGNoZXIuRG9tV2F0Y2hlcigpO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdyZXNpemUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25SZXNpemUuYmluZCh0aGlzKSxcbiAgICAgIGV2ZW50T3B0aW9uczoge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ21vdXNlbW92ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgIHVfY29sb3I6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweGZmMDAwMClcbiAgICAgIH0sXG4gICAgICAvLyBGbG9hdFxuICAgICAgdV90aW1lOiB7XG4gICAgICAgIHZhbHVlOiAwLjBcbiAgICAgIH0sXG4gICAgICAvLyBWZWMyIDAsMCBhdCB0b3AsIGxlZnQgYW5kIHdpbmRvdy5pbm5lcldpZHRoIGFuZCB3aW5kb3cuaW5uZXJIZWlnaHQgYXQgYm90dG9tIHJpZ2h0LlxuICAgICAgdV9tb3VzZToge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAuMCxcbiAgICAgICAgICB5OiAwLjBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFZlYzIgU2NyZWVuIHJlc29sdXRpb25cbiAgICAgIHVfcmVzb2x1dGlvbjoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgLy8gMngyIHNvIGl0IGZpbGwgdGhlIHNjcmVlbi5cblxuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSgyLCAyKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgdmVydGV4U2hhZGVyOiB2c2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzaGFkZXJcbiAgICB9KTsgLy8gQ3JlYXRlIG1lc2ggKGdlb20gKyBtYXRlcmlhbClcblxuICAgIHRoaXMucGxhbmUgPSBuZXcgVEhSRUUuTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLnBsYW5lKTtcbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gMTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgfVxuXG4gIG9uUmVzaXplKCkge1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBpZiAoYXNwZWN0UmF0aW8gPj0gMSkge1xuICAgICAgd2lkdGggPSAxO1xuICAgICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC8gd2luZG93LmlubmVyV2lkdGggKiB3aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBhc3BlY3RSYXRpbztcbiAgICAgIGhlaWdodCA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5jYW1lcmEubGVmdCA9IC13aWR0aDtcbiAgICB0aGlzLmNhbWVyYS5yaWdodCA9IHdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnRvcCA9IGhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS5ib3R0b20gPSAtaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnkgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIH1cblxuICBvbk1vdXNlTW92ZShldnQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WCA6IGV2dC5jbGllbnRYO1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS55ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRZIDogZXZ0LmNsaWVudFk7XG4gIH1cblxuICBvblJhZihkZWx0YSkge1xuICAgIHRoaXMudW5pZm9ybXMudV90aW1lLnZhbHVlICs9IHRoaXMucmFmLmdldERlbHRhKHRydWUpO1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdsc2xQbGF5Z3JvdW5kMTA7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/glsl-playground12.js\n");

/***/ }),

/***/ "./examples/glsl-playground13.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground13.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//  // https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739068\n//\nconst vshader = `\nvarying vec3 v_position; // Declare v_position\nvarying vec2 v_uv; // Declare v_position\nvoid main() {\n  // Set the uv value.  Three.js passes the uv value by default of the current vertices.\n  v_position = position;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nvarying vec3 v_position;\nvarying vec2 v_uv;\n\nfloat rect(vec2 pt, vec2 size, vec2 center) {\n    // We need to offset the position of the virtual box to do a hit test.\n    vec2 p = pt - center;\n    vec2 halfsize = size * 0.5; // Half the size since we just need\n\n    // Now do a hit test of this rectangle and see if pt falls within it.\n    // float horz = (v_position.x > -halfsize.x && v_position.x < halfsize.x) ?\n    float horz = step(-halfsize.x, p.x) - step(halfsize.x, p.x);\n    float vert = step(-halfsize.y, p.y) - step(halfsize.y, p.y);\n    return horz * vert;\n}\n\nmat2 getRotationMatrix(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat2(c, -s, s, c);\n}\n\nmat2 getScaleMatrix(float scale) {\n    return mat2(scale, 0, 0, scale);\n}\n\n\n/**\n * Checks if a pt is withi a circle that starts from the given center and of a given\n * radius.\n */\nfloat circle(vec2 pt, vec2 center, float radius) {\n    vec2 p = pt - center;\n    return 1.0 - step(radius, length(p));\n}\n\n// Smooth step version of circle function.\nfloat circle(vec2 pt, vec2 center, float radius, bool soften) {\n    vec2 p = pt - center;\n    return 1.0 - smoothstep(radius, radius + radius, length(p));\n}\n\n// Creates a lines circle.\nfloat circle(vec2 pt, vec2 center, float radius, float line_width) {\n    vec2 p = pt - center;\n    float len = length(p);\n    float half_line_width = line_width / 2.0;\n    return step(radius-half_line_width, len) - step(radius + half_line_width, len);\n}\n\n// Creates a line circle with soft edge\nfloat circle(vec2 pt, vec2 center, float radius, float line_width, bool soften) {\n    vec2 p = pt - center;\n    float len = length(p);\n    float softenAmount = 0.5;\n    float edge = (soften) ? radius * softenAmount : 0.0;\n    float half_line_width = line_width / 2.0;\n    return smoothstep(radius - half_line_width - edge, radius - half_line_width, len) -\n        smoothstep(radius + half_line_width, radius + half_line_width + edge, len);\n}\n\n\n\nvoid main (void)\n{\n  vec2 center = vec2(0.0);\n\n  float inCircle = circle(v_position.xy, vec2(-0.5, 0.0), 0.1);\n\n  // Smooth edge with smooth step\n   float inCircle2 = circle(v_position.xy, vec2(0.0, 0.0), 0.1, true);\n\n  // Lined circle example.\n//    float inCircle3 = circle(v_position.xy, vec2(0.5, 0.0), 0.1, 0.01);\n\n  // Lined softed circle example.\n   float inCircle3 = circle(v_position.xy, vec2(0.5, 0.0), 0.1, 0.01, true);\n\n  // Combine outputs.\n  vec3 color =\n       vec3(1.0, 1.0, 0.0) * inCircle  +\n       vec3(1.0, 0.0, 0.0) * inCircle2  +\n       vec3(0.0, 0.0, 1.0) * inCircle3;\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground13 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color: {\n        value: new THREE.Color(0xff0000)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground13;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQxMy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDEzLmpzPzRiMjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vL1xuLy8gIC8vIGh0dHBzOi8vd3d3LnVkZW15LmNvbS9jb3Vyc2UvbGVhcm4tZ2xzbC1zaGFkZXJzLWZyb20tc2NyYXRjaC9sZWFybi9sZWN0dXJlLzEzNzM5MDY4XG4vL1xuY29uc3QgdnNoYWRlciA9IGBcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uOyAvLyBEZWNsYXJlIHZfcG9zaXRpb25cbnZhcnlpbmcgdmVjMiB2X3V2OyAvLyBEZWNsYXJlIHZfcG9zaXRpb25cbnZvaWQgbWFpbigpIHtcbiAgLy8gU2V0IHRoZSB1diB2YWx1ZS4gIFRocmVlLmpzIHBhc3NlcyB0aGUgdXYgdmFsdWUgYnkgZGVmYXVsdCBvZiB0aGUgY3VycmVudCB2ZXJ0aWNlcy5cbiAgdl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbnVuaWZvcm0gdmVjMiB1X21vdXNlO1xudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gdmVjMyB1X2NvbG9yO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG5cbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xudmFyeWluZyB2ZWMyIHZfdXY7XG5cbmZsb2F0IHJlY3QodmVjMiBwdCwgdmVjMiBzaXplLCB2ZWMyIGNlbnRlcikge1xuICAgIC8vIFdlIG5lZWQgdG8gb2Zmc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgdmlydHVhbCBib3ggdG8gZG8gYSBoaXQgdGVzdC5cbiAgICB2ZWMyIHAgPSBwdCAtIGNlbnRlcjtcbiAgICB2ZWMyIGhhbGZzaXplID0gc2l6ZSAqIDAuNTsgLy8gSGFsZiB0aGUgc2l6ZSBzaW5jZSB3ZSBqdXN0IG5lZWRcblxuICAgIC8vIE5vdyBkbyBhIGhpdCB0ZXN0IG9mIHRoaXMgcmVjdGFuZ2xlIGFuZCBzZWUgaWYgcHQgZmFsbHMgd2l0aGluIGl0LlxuICAgIC8vIGZsb2F0IGhvcnogPSAodl9wb3NpdGlvbi54ID4gLWhhbGZzaXplLnggJiYgdl9wb3NpdGlvbi54IDwgaGFsZnNpemUueCkgP1xuICAgIGZsb2F0IGhvcnogPSBzdGVwKC1oYWxmc2l6ZS54LCBwLngpIC0gc3RlcChoYWxmc2l6ZS54LCBwLngpO1xuICAgIGZsb2F0IHZlcnQgPSBzdGVwKC1oYWxmc2l6ZS55LCBwLnkpIC0gc3RlcChoYWxmc2l6ZS55LCBwLnkpO1xuICAgIHJldHVybiBob3J6ICogdmVydDtcbn1cblxubWF0MiBnZXRSb3RhdGlvbk1hdHJpeChmbG9hdCB0aGV0YSkge1xuICAgIGZsb2F0IHMgPSBzaW4odGhldGEpO1xuICAgIGZsb2F0IGMgPSBjb3ModGhldGEpO1xuICAgIHJldHVybiBtYXQyKGMsIC1zLCBzLCBjKTtcbn1cblxubWF0MiBnZXRTY2FsZU1hdHJpeChmbG9hdCBzY2FsZSkge1xuICAgIHJldHVybiBtYXQyKHNjYWxlLCAwLCAwLCBzY2FsZSk7XG59XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwdCBpcyB3aXRoaSBhIGNpcmNsZSB0aGF0IHN0YXJ0cyBmcm9tIHRoZSBnaXZlbiBjZW50ZXIgYW5kIG9mIGEgZ2l2ZW5cbiAqIHJhZGl1cy5cbiAqL1xuZmxvYXQgY2lyY2xlKHZlYzIgcHQsIHZlYzIgY2VudGVyLCBmbG9hdCByYWRpdXMpIHtcbiAgICB2ZWMyIHAgPSBwdCAtIGNlbnRlcjtcbiAgICByZXR1cm4gMS4wIC0gc3RlcChyYWRpdXMsIGxlbmd0aChwKSk7XG59XG5cbi8vIFNtb290aCBzdGVwIHZlcnNpb24gb2YgY2lyY2xlIGZ1bmN0aW9uLlxuZmxvYXQgY2lyY2xlKHZlYzIgcHQsIHZlYzIgY2VudGVyLCBmbG9hdCByYWRpdXMsIGJvb2wgc29mdGVuKSB7XG4gICAgdmVjMiBwID0gcHQgLSBjZW50ZXI7XG4gICAgcmV0dXJuIDEuMCAtIHNtb290aHN0ZXAocmFkaXVzLCByYWRpdXMgKyByYWRpdXMsIGxlbmd0aChwKSk7XG59XG5cbi8vIENyZWF0ZXMgYSBsaW5lcyBjaXJjbGUuXG5mbG9hdCBjaXJjbGUodmVjMiBwdCwgdmVjMiBjZW50ZXIsIGZsb2F0IHJhZGl1cywgZmxvYXQgbGluZV93aWR0aCkge1xuICAgIHZlYzIgcCA9IHB0IC0gY2VudGVyO1xuICAgIGZsb2F0IGxlbiA9IGxlbmd0aChwKTtcbiAgICBmbG9hdCBoYWxmX2xpbmVfd2lkdGggPSBsaW5lX3dpZHRoIC8gMi4wO1xuICAgIHJldHVybiBzdGVwKHJhZGl1cy1oYWxmX2xpbmVfd2lkdGgsIGxlbikgLSBzdGVwKHJhZGl1cyArIGhhbGZfbGluZV93aWR0aCwgbGVuKTtcbn1cblxuLy8gQ3JlYXRlcyBhIGxpbmUgY2lyY2xlIHdpdGggc29mdCBlZGdlXG5mbG9hdCBjaXJjbGUodmVjMiBwdCwgdmVjMiBjZW50ZXIsIGZsb2F0IHJhZGl1cywgZmxvYXQgbGluZV93aWR0aCwgYm9vbCBzb2Z0ZW4pIHtcbiAgICB2ZWMyIHAgPSBwdCAtIGNlbnRlcjtcbiAgICBmbG9hdCBsZW4gPSBsZW5ndGgocCk7XG4gICAgZmxvYXQgc29mdGVuQW1vdW50ID0gMC41O1xuICAgIGZsb2F0IGVkZ2UgPSAoc29mdGVuKSA/IHJhZGl1cyAqIHNvZnRlbkFtb3VudCA6IDAuMDtcbiAgICBmbG9hdCBoYWxmX2xpbmVfd2lkdGggPSBsaW5lX3dpZHRoIC8gMi4wO1xuICAgIHJldHVybiBzbW9vdGhzdGVwKHJhZGl1cyAtIGhhbGZfbGluZV93aWR0aCAtIGVkZ2UsIHJhZGl1cyAtIGhhbGZfbGluZV93aWR0aCwgbGVuKSAtXG4gICAgICAgIHNtb290aHN0ZXAocmFkaXVzICsgaGFsZl9saW5lX3dpZHRoLCByYWRpdXMgKyBoYWxmX2xpbmVfd2lkdGggKyBlZGdlLCBsZW4pO1xufVxuXG5cblxudm9pZCBtYWluICh2b2lkKVxue1xuICB2ZWMyIGNlbnRlciA9IHZlYzIoMC4wKTtcblxuICBmbG9hdCBpbkNpcmNsZSA9IGNpcmNsZSh2X3Bvc2l0aW9uLnh5LCB2ZWMyKC0wLjUsIDAuMCksIDAuMSk7XG5cbiAgLy8gU21vb3RoIGVkZ2Ugd2l0aCBzbW9vdGggc3RlcFxuICAgZmxvYXQgaW5DaXJjbGUyID0gY2lyY2xlKHZfcG9zaXRpb24ueHksIHZlYzIoMC4wLCAwLjApLCAwLjEsIHRydWUpO1xuXG4gIC8vIExpbmVkIGNpcmNsZSBleGFtcGxlLlxuLy8gICAgZmxvYXQgaW5DaXJjbGUzID0gY2lyY2xlKHZfcG9zaXRpb24ueHksIHZlYzIoMC41LCAwLjApLCAwLjEsIDAuMDEpO1xuXG4gIC8vIExpbmVkIHNvZnRlZCBjaXJjbGUgZXhhbXBsZS5cbiAgIGZsb2F0IGluQ2lyY2xlMyA9IGNpcmNsZSh2X3Bvc2l0aW9uLnh5LCB2ZWMyKDAuNSwgMC4wKSwgMC4xLCAwLjAxLCB0cnVlKTtcblxuICAvLyBDb21iaW5lIG91dHB1dHMuXG4gIHZlYzMgY29sb3IgPVxuICAgICAgIHZlYzMoMS4wLCAxLjAsIDAuMCkgKiBpbkNpcmNsZSAgK1xuICAgICAgIHZlYzMoMS4wLCAwLjAsIDAuMCkgKiBpbkNpcmNsZTIgICtcbiAgICAgICB2ZWMzKDAuMCwgMC4wLCAxLjApICogaW5DaXJjbGUzO1xuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1xufVxuYDtcblxuY2xhc3MgR2xzbFBsYXlncm91bmQxMyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTsgLy8gMngyXG5cbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoLTEsIDEsIDEsIC0xLCAwLjEsIDEwKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgIHRoaXMucmFmID0gbmV3IF9yYWYuUmFmKHRoaXMub25SYWYuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAncmVzaXplJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyksXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdtb3VzZW1vdmUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICB1X2NvbG9yOiB7XG4gICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoMHhmZjAwMDApXG4gICAgICB9LFxuICAgICAgLy8gRmxvYXRcbiAgICAgIHVfdGltZToge1xuICAgICAgICB2YWx1ZTogMC4wXG4gICAgICB9LFxuICAgICAgLy8gVmVjMiAwLDAgYXQgdG9wLCBsZWZ0IGFuZCB3aW5kb3cuaW5uZXJXaWR0aCBhbmQgd2luZG93LmlubmVySGVpZ2h0IGF0IGJvdHRvbSByaWdodC5cbiAgICAgIHVfbW91c2U6IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB4OiAwLjAsXG4gICAgICAgICAgeTogMC4wXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBWZWMyIFNjcmVlbiByZXNvbHV0aW9uXG4gICAgICB1X3Jlc29sdXRpb246IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07IC8vIDJ4MiBzbyBpdCBmaWxsIHRoZSBzY3JlZW4uXG5cbiAgICB0aGlzLmdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoMiwgMik7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG4gICAgICB1bmlmb3JtczogdGhpcy51bmlmb3JtcyxcbiAgICAgIHZlcnRleFNoYWRlcjogdnNoYWRlcixcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBmc2hhZGVyXG4gICAgfSk7IC8vIENyZWF0ZSBtZXNoIChnZW9tICsgbWF0ZXJpYWwpXG5cbiAgICB0aGlzLnBsYW5lID0gbmV3IFRIUkVFLk1lc2godGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5wbGFuZSk7XG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiA9IDE7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgIHRoaXMucmFmLnN0YXJ0KCk7XG4gIH1cblxuICBvblJlc2l6ZSgpIHtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgaWYgKGFzcGVjdFJhdGlvID49IDEpIHtcbiAgICAgIHdpZHRoID0gMTtcbiAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAvIHdpbmRvdy5pbm5lcldpZHRoICogd2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gYXNwZWN0UmF0aW87XG4gICAgICBoZWlnaHQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuY2FtZXJhLmxlZnQgPSAtd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEucmlnaHQgPSB3aWR0aDtcbiAgICB0aGlzLmNhbWVyYS50b3AgPSBoZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEuYm90dG9tID0gLWhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS55ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZXZ0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnggPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFggOiBldnQuY2xpZW50WDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueSA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WSA6IGV2dC5jbGllbnRZO1xuICB9XG5cbiAgb25SYWYoZGVsdGEpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfdGltZS52YWx1ZSArPSB0aGlzLnJhZi5nZXREZWx0YSh0cnVlKTtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBHbHNsUGxheWdyb3VuZDEzOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/glsl-playground13.js\n");

/***/ }),

/***/ "./examples/glsl-playground14.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground14.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//  // https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739068\n//\nconst vshader = `\nvarying vec3 v_position; // Declare v_position\nvarying vec2 v_uv; // Declare v_uv\nvoid main() {\n  // Set the uv value.  Three.js passes the uv value by default of the current vertices.\n  v_position = position;\n  v_uv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nvarying vec3 v_position;\nvarying vec2 v_uv;\n\nfloat line(float a, float b, float line_width, float edge_thickness) {\n    float half_line_width = line_width * 0.5;\n    return smoothstep(\n        a - half_line_width - edge_thickness,\n        a - half_line_width,\n        b\n     ) -\n     smoothstep(\n         a + half_line_width,\n         a + half_line_width + edge_thickness,\n         b\n     );\n}\n\nvoid main (void)\n{\n  // Example 1 - v_position\n  // We get a diagnol line since we get 1.0 only where x = y.\n  vec3 color = vec3(1.0) * line(v_position.x, v_position.y, 0.01, 0.001);\n\n\n  // Example 2 - gl_Fragcoord\n  // Uses gl_Fragcoord.  This uses screen space pixel coordinates.\n  // Allows you to draw in pixels.\n//    vec3 color = vec3(1.0) * line(\n//     gl_FragCoord.x,\n//     gl_FragCoord.y,\n//     10.0,  // 10px width\n//     1.0\n//    );\n\n\n  // Example 3 - v_uv\n//    vec3 color = vec3(1.0) * line(\n//     v_uv.x,\n//     v_uv.y,\n//     0.01,\n//     0.001\n//    );\n\n\n   // Example 4 - Sin wave\n//    vec3 color = vec3(1.0) * line(\n//        v_position.y,\n//        // Force since between -0.5 and 0.5\n//        mix(-0.5, 0.5, (sin(v_position.x * 3.1415) + 1.0) / 2.0),\n//        0.05,\n//        0.002\n//    );\n\n\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground14 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color: {\n        value: new THREE.Color(0xff0000)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground14;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQxNC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDE0LmpzPzZmNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vL1xuLy8gIC8vIGh0dHBzOi8vd3d3LnVkZW15LmNvbS9jb3Vyc2UvbGVhcm4tZ2xzbC1zaGFkZXJzLWZyb20tc2NyYXRjaC9sZWFybi9sZWN0dXJlLzEzNzM5MDY4XG4vL1xuY29uc3QgdnNoYWRlciA9IGBcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uOyAvLyBEZWNsYXJlIHZfcG9zaXRpb25cbnZhcnlpbmcgdmVjMiB2X3V2OyAvLyBEZWNsYXJlIHZfdXZcbnZvaWQgbWFpbigpIHtcbiAgLy8gU2V0IHRoZSB1diB2YWx1ZS4gIFRocmVlLmpzIHBhc3NlcyB0aGUgdXYgdmFsdWUgYnkgZGVmYXVsdCBvZiB0aGUgY3VycmVudCB2ZXJ0aWNlcy5cbiAgdl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB2X3V2ID0gdXY7XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcbn1cbmA7XG5jb25zdCBmc2hhZGVyID0gYFxudW5pZm9ybSB2ZWMyIHVfbW91c2U7XG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xudW5pZm9ybSB2ZWMzIHVfY29sb3I7XG51bmlmb3JtIGZsb2F0IHVfdGltZTtcblxudmFyeWluZyB2ZWMzIHZfcG9zaXRpb247XG52YXJ5aW5nIHZlYzIgdl91djtcblxuZmxvYXQgbGluZShmbG9hdCBhLCBmbG9hdCBiLCBmbG9hdCBsaW5lX3dpZHRoLCBmbG9hdCBlZGdlX3RoaWNrbmVzcykge1xuICAgIGZsb2F0IGhhbGZfbGluZV93aWR0aCA9IGxpbmVfd2lkdGggKiAwLjU7XG4gICAgcmV0dXJuIHNtb290aHN0ZXAoXG4gICAgICAgIGEgLSBoYWxmX2xpbmVfd2lkdGggLSBlZGdlX3RoaWNrbmVzcyxcbiAgICAgICAgYSAtIGhhbGZfbGluZV93aWR0aCxcbiAgICAgICAgYlxuICAgICApIC1cbiAgICAgc21vb3Roc3RlcChcbiAgICAgICAgIGEgKyBoYWxmX2xpbmVfd2lkdGgsXG4gICAgICAgICBhICsgaGFsZl9saW5lX3dpZHRoICsgZWRnZV90aGlja25lc3MsXG4gICAgICAgICBiXG4gICAgICk7XG59XG5cbnZvaWQgbWFpbiAodm9pZClcbntcbiAgLy8gRXhhbXBsZSAxIC0gdl9wb3NpdGlvblxuICAvLyBXZSBnZXQgYSBkaWFnbm9sIGxpbmUgc2luY2Ugd2UgZ2V0IDEuMCBvbmx5IHdoZXJlIHggPSB5LlxuICB2ZWMzIGNvbG9yID0gdmVjMygxLjApICogbGluZSh2X3Bvc2l0aW9uLngsIHZfcG9zaXRpb24ueSwgMC4wMSwgMC4wMDEpO1xuXG5cbiAgLy8gRXhhbXBsZSAyIC0gZ2xfRnJhZ2Nvb3JkXG4gIC8vIFVzZXMgZ2xfRnJhZ2Nvb3JkLiAgVGhpcyB1c2VzIHNjcmVlbiBzcGFjZSBwaXhlbCBjb29yZGluYXRlcy5cbiAgLy8gQWxsb3dzIHlvdSB0byBkcmF3IGluIHBpeGVscy5cbi8vICAgIHZlYzMgY29sb3IgPSB2ZWMzKDEuMCkgKiBsaW5lKFxuLy8gICAgIGdsX0ZyYWdDb29yZC54LFxuLy8gICAgIGdsX0ZyYWdDb29yZC55LFxuLy8gICAgIDEwLjAsICAvLyAxMHB4IHdpZHRoXG4vLyAgICAgMS4wXG4vLyAgICApO1xuXG5cbiAgLy8gRXhhbXBsZSAzIC0gdl91dlxuLy8gICAgdmVjMyBjb2xvciA9IHZlYzMoMS4wKSAqIGxpbmUoXG4vLyAgICAgdl91di54LFxuLy8gICAgIHZfdXYueSxcbi8vICAgICAwLjAxLFxuLy8gICAgIDAuMDAxXG4vLyAgICApO1xuXG5cbiAgIC8vIEV4YW1wbGUgNCAtIFNpbiB3YXZlXG4vLyAgICB2ZWMzIGNvbG9yID0gdmVjMygxLjApICogbGluZShcbi8vICAgICAgICB2X3Bvc2l0aW9uLnksXG4vLyAgICAgICAgLy8gRm9yY2Ugc2luY2UgYmV0d2VlbiAtMC41IGFuZCAwLjVcbi8vICAgICAgICBtaXgoLTAuNSwgMC41LCAoc2luKHZfcG9zaXRpb24ueCAqIDMuMTQxNSkgKyAxLjApIC8gMi4wKSxcbi8vICAgICAgICAwLjA1LFxuLy8gICAgICAgIDAuMDAyXG4vLyAgICApO1xuXG5cbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcbn1cbmA7XG5cbmNsYXNzIEdsc2xQbGF5Z3JvdW5kMTQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vIDJ4MlxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMC4xLCAxMCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgdV9jb2xvcjoge1xuICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKDB4ZmYwMDAwKVxuICAgICAgfSxcbiAgICAgIC8vIEZsb2F0XG4gICAgICB1X3RpbWU6IHtcbiAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgfSxcbiAgICAgIC8vIFZlYzIgMCwwIGF0IHRvcCwgbGVmdCBhbmQgd2luZG93LmlubmVyV2lkdGggYW5kIHdpbmRvdy5pbm5lckhlaWdodCBhdCBib3R0b20gcmlnaHQuXG4gICAgICB1X21vdXNlOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMC4wLFxuICAgICAgICAgIHk6IDAuMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVmVjMiBTY3JlZW4gcmVzb2x1dGlvblxuICAgICAgdV9yZXNvbHV0aW9uOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvLyAyeDIgc28gaXQgZmlsbCB0aGUgc2NyZWVuLlxuXG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDIsIDIpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZzaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZnNoYWRlclxuICAgIH0pOyAvLyBDcmVhdGUgbWVzaCAoZ2VvbSArIG1hdGVyaWFsKVxuXG4gICAgdGhpcy5wbGFuZSA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMucGxhbmUpO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAxO1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGlmIChhc3BlY3RSYXRpbyA+PSAxKSB7XG4gICAgICB3aWR0aCA9IDE7XG4gICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB3aW5kb3cuaW5uZXJXaWR0aCAqIHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdFJhdGlvO1xuICAgICAgaGVpZ2h0ID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbWVyYS5sZWZ0ID0gLXdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnJpZ2h0ID0gd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEudG9wID0gaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLmJvdHRvbSA9IC1oZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS54ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGV2dCkge1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS54ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRYIDogZXZ0LmNsaWVudFg7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnkgPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFkgOiBldnQuY2xpZW50WTtcbiAgfVxuXG4gIG9uUmFmKGRlbHRhKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X3RpbWUudmFsdWUgKz0gdGhpcy5yYWYuZ2V0RGVsdGEodHJ1ZSk7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gR2xzbFBsYXlncm91bmQxNDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/glsl-playground14.js\n");

/***/ }),

/***/ "./examples/glsl-playground15.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground15.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739104#questions\n//\nconst vshader = `\nvarying vec3 v_position; // Declare v_position\nvarying vec2 v_uv; // Declare v_uv\nvoid main() {\n  // Set the uv value.  Three.js passes the uv value by default of the current vertices.\n  v_position = position;\n  v_uv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nvarying vec3 v_position;\nvarying vec2 v_uv;\n\n\n\nfloat circle(vec2 pt, vec2 center, float radius, float line_width, float edge_thickness){\n    pt -= center;\n    float len = length(pt);\n    float result = smoothstep(radius-line_width/2.0-edge_thickness, radius-line_width/2.0, len) - smoothstep(radius + line_width/2.0, radius + line_width/2.0 + edge_thickness, len);\n\n    return result;\n  }\n\nfloat line(float a, float b, float line_width, float edge_thickness) {\n    float half_line_width = line_width * 0.5;\n    return smoothstep(\n        a - half_line_width - edge_thickness,\n        a - half_line_width,\n        b\n     ) -\n     smoothstep(\n         a + half_line_width,\n         a + half_line_width + edge_thickness,\n         b\n     );\n}\n\n/**\n * https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13944084#questions\n * Create a polygon.\n */\nfloat polygon(vec2 pt, vec2 center, float radius, int sides, float rotate, float edge_thickness){\n    pt -= center;\n\n    // Angle and radius from the current pixel\n    float theta = atan(pt.y, pt.x) + rotate;\n    float rad = PI2/float(sides);\n\n    // Shaping function that modulate the distance\n    float d = cos(floor(0.5 + theta/rad)*rad-theta)*length(pt);\n\n    return 1.0 - smoothstep(radius, radius + edge_thickness, d);\n  }\n\n\n/**\n *\n * Returns 1.0 when test point is over a sweeping line.\n * pt - test point\n * center - center point\n * radius - radius\n *\n * https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739104#questions\n * https://codepen.io/nik-lever/full/YBBjLo\n *  - green line is vector d\n *  - black line is vector p\n *  - blue line is perpendicular line p and test point.\n */\nfloat sweep(vec2 pt, vec2 center, float radius, float line_width, float edge_thickness){\n    vec2 d = pt - center;\n    float theta = u_time * 2.0;\n\n    // A vector point around circle with given radius from 0,0.\n    vec2 p = vec2(cos(theta), -sin(theta)) * radius;\n\n\n    float h = clamp( dot(d,p)/dot(p,p), 0.0, 1.0 );\n\n    //float h = dot(d,p)/dot(p,p);\n    float l = length(d - p*h);\n\n    float gradient = 0.0;\n    const float gradient_angle = PI * 0.5;\n\n    if (length(d)<radius){\n      float angle = mod(theta + atan(d.y, d.x), PI2);\n      gradient = clamp(gradient_angle - angle, 0.0, gradient_angle)/gradient_angle * 0.5;\n    }\n\n    return gradient + 1.0 - smoothstep(line_width, line_width+edge_thickness, l);\n  }\n\n\nvoid main (void)\n{\n  vec3 axis_color = vec3(0.8);\n  vec3 color = line(v_uv.y, 0.5, 0.002, 0.001) * axis_color;\n  color += line(v_uv.x, 0.5, 0.002, 0.001) * axis_color;\n\n  // Add circles\n  color += circle(v_uv, vec2(0.5), 0.3, 0.002, 0.001) * axis_color;\n  color += circle(v_uv, vec2(0.5), 0.2, 0.002, 0.001) * axis_color;\n  color += circle(v_uv, vec2(0.5), 0.1, 0.002, 0.001) * axis_color;\n\n  // Add sweeping line.\n  color += sweep(v_uv, vec2(0.5), 0.3, 0.003, 0.001) * vec3(0.1, 0.3, 0.1);\n\n  // Add triangular polygons\n  vec3 white = vec3(1.0);\n  color += polygon(\n      v_uv,\n      vec2(0.9 - sin(u_time * 3.0) * 0.05, 0.5),\n      0.005, 3, 0.0, 0.001) * white;\n  color += polygon(\n      v_uv,\n      vec2(0.1 - sin(u_time * 3.0 +PI) * 0.05, 0.5),\n      0.005, 3, PI, 0.001) * white;\n\n\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground15 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color_a: {\n        value: new THREE.Color(0xff0000)\n      },\n      u_color_b: {\n        value: new THREE.Color(0x00ffff)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf() {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground15;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQxNS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDE1LmpzPzExMTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vL1xuLy9cbi8vIGh0dHBzOi8vd3d3LnVkZW15LmNvbS9jb3Vyc2UvbGVhcm4tZ2xzbC1zaGFkZXJzLWZyb20tc2NyYXRjaC9sZWFybi9sZWN0dXJlLzEzNzM5MTA0I3F1ZXN0aW9uc1xuLy9cbmNvbnN0IHZzaGFkZXIgPSBgXG52YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbjsgLy8gRGVjbGFyZSB2X3Bvc2l0aW9uXG52YXJ5aW5nIHZlYzIgdl91djsgLy8gRGVjbGFyZSB2X3V2XG52b2lkIG1haW4oKSB7XG4gIC8vIFNldCB0aGUgdXYgdmFsdWUuICBUaHJlZS5qcyBwYXNzZXMgdGhlIHV2IHZhbHVlIGJ5IGRlZmF1bHQgb2YgdGhlIGN1cnJlbnQgdmVydGljZXMuXG4gIHZfcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdl91diA9IHV2O1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1OVxuI2RlZmluZSBQSTIgNi4yODMxODUzMDcxOFxuXG51bmlmb3JtIHZlYzIgdV9tb3VzZTtcbnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XG51bmlmb3JtIHZlYzMgdV9jb2xvcjtcbnVuaWZvcm0gZmxvYXQgdV90aW1lO1xuXG52YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbjtcbnZhcnlpbmcgdmVjMiB2X3V2O1xuXG5cblxuZmxvYXQgY2lyY2xlKHZlYzIgcHQsIHZlYzIgY2VudGVyLCBmbG9hdCByYWRpdXMsIGZsb2F0IGxpbmVfd2lkdGgsIGZsb2F0IGVkZ2VfdGhpY2tuZXNzKXtcbiAgICBwdCAtPSBjZW50ZXI7XG4gICAgZmxvYXQgbGVuID0gbGVuZ3RoKHB0KTtcbiAgICBmbG9hdCByZXN1bHQgPSBzbW9vdGhzdGVwKHJhZGl1cy1saW5lX3dpZHRoLzIuMC1lZGdlX3RoaWNrbmVzcywgcmFkaXVzLWxpbmVfd2lkdGgvMi4wLCBsZW4pIC0gc21vb3Roc3RlcChyYWRpdXMgKyBsaW5lX3dpZHRoLzIuMCwgcmFkaXVzICsgbGluZV93aWR0aC8yLjAgKyBlZGdlX3RoaWNrbmVzcywgbGVuKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuZmxvYXQgbGluZShmbG9hdCBhLCBmbG9hdCBiLCBmbG9hdCBsaW5lX3dpZHRoLCBmbG9hdCBlZGdlX3RoaWNrbmVzcykge1xuICAgIGZsb2F0IGhhbGZfbGluZV93aWR0aCA9IGxpbmVfd2lkdGggKiAwLjU7XG4gICAgcmV0dXJuIHNtb290aHN0ZXAoXG4gICAgICAgIGEgLSBoYWxmX2xpbmVfd2lkdGggLSBlZGdlX3RoaWNrbmVzcyxcbiAgICAgICAgYSAtIGhhbGZfbGluZV93aWR0aCxcbiAgICAgICAgYlxuICAgICApIC1cbiAgICAgc21vb3Roc3RlcChcbiAgICAgICAgIGEgKyBoYWxmX2xpbmVfd2lkdGgsXG4gICAgICAgICBhICsgaGFsZl9saW5lX3dpZHRoICsgZWRnZV90aGlja25lc3MsXG4gICAgICAgICBiXG4gICAgICk7XG59XG5cbi8qKlxuICogaHR0cHM6Ly93d3cudWRlbXkuY29tL2NvdXJzZS9sZWFybi1nbHNsLXNoYWRlcnMtZnJvbS1zY3JhdGNoL2xlYXJuL2xlY3R1cmUvMTM5NDQwODQjcXVlc3Rpb25zXG4gKiBDcmVhdGUgYSBwb2x5Z29uLlxuICovXG5mbG9hdCBwb2x5Z29uKHZlYzIgcHQsIHZlYzIgY2VudGVyLCBmbG9hdCByYWRpdXMsIGludCBzaWRlcywgZmxvYXQgcm90YXRlLCBmbG9hdCBlZGdlX3RoaWNrbmVzcyl7XG4gICAgcHQgLT0gY2VudGVyO1xuXG4gICAgLy8gQW5nbGUgYW5kIHJhZGl1cyBmcm9tIHRoZSBjdXJyZW50IHBpeGVsXG4gICAgZmxvYXQgdGhldGEgPSBhdGFuKHB0LnksIHB0LngpICsgcm90YXRlO1xuICAgIGZsb2F0IHJhZCA9IFBJMi9mbG9hdChzaWRlcyk7XG5cbiAgICAvLyBTaGFwaW5nIGZ1bmN0aW9uIHRoYXQgbW9kdWxhdGUgdGhlIGRpc3RhbmNlXG4gICAgZmxvYXQgZCA9IGNvcyhmbG9vcigwLjUgKyB0aGV0YS9yYWQpKnJhZC10aGV0YSkqbGVuZ3RoKHB0KTtcblxuICAgIHJldHVybiAxLjAgLSBzbW9vdGhzdGVwKHJhZGl1cywgcmFkaXVzICsgZWRnZV90aGlja25lc3MsIGQpO1xuICB9XG5cblxuLyoqXG4gKlxuICogUmV0dXJucyAxLjAgd2hlbiB0ZXN0IHBvaW50IGlzIG92ZXIgYSBzd2VlcGluZyBsaW5lLlxuICogcHQgLSB0ZXN0IHBvaW50XG4gKiBjZW50ZXIgLSBjZW50ZXIgcG9pbnRcbiAqIHJhZGl1cyAtIHJhZGl1c1xuICpcbiAqIGh0dHBzOi8vd3d3LnVkZW15LmNvbS9jb3Vyc2UvbGVhcm4tZ2xzbC1zaGFkZXJzLWZyb20tc2NyYXRjaC9sZWFybi9sZWN0dXJlLzEzNzM5MTA0I3F1ZXN0aW9uc1xuICogaHR0cHM6Ly9jb2RlcGVuLmlvL25pay1sZXZlci9mdWxsL1lCQmpMb1xuICogIC0gZ3JlZW4gbGluZSBpcyB2ZWN0b3IgZFxuICogIC0gYmxhY2sgbGluZSBpcyB2ZWN0b3IgcFxuICogIC0gYmx1ZSBsaW5lIGlzIHBlcnBlbmRpY3VsYXIgbGluZSBwIGFuZCB0ZXN0IHBvaW50LlxuICovXG5mbG9hdCBzd2VlcCh2ZWMyIHB0LCB2ZWMyIGNlbnRlciwgZmxvYXQgcmFkaXVzLCBmbG9hdCBsaW5lX3dpZHRoLCBmbG9hdCBlZGdlX3RoaWNrbmVzcyl7XG4gICAgdmVjMiBkID0gcHQgLSBjZW50ZXI7XG4gICAgZmxvYXQgdGhldGEgPSB1X3RpbWUgKiAyLjA7XG5cbiAgICAvLyBBIHZlY3RvciBwb2ludCBhcm91bmQgY2lyY2xlIHdpdGggZ2l2ZW4gcmFkaXVzIGZyb20gMCwwLlxuICAgIHZlYzIgcCA9IHZlYzIoY29zKHRoZXRhKSwgLXNpbih0aGV0YSkpICogcmFkaXVzO1xuXG5cbiAgICBmbG9hdCBoID0gY2xhbXAoIGRvdChkLHApL2RvdChwLHApLCAwLjAsIDEuMCApO1xuXG4gICAgLy9mbG9hdCBoID0gZG90KGQscCkvZG90KHAscCk7XG4gICAgZmxvYXQgbCA9IGxlbmd0aChkIC0gcCpoKTtcblxuICAgIGZsb2F0IGdyYWRpZW50ID0gMC4wO1xuICAgIGNvbnN0IGZsb2F0IGdyYWRpZW50X2FuZ2xlID0gUEkgKiAwLjU7XG5cbiAgICBpZiAobGVuZ3RoKGQpPHJhZGl1cyl7XG4gICAgICBmbG9hdCBhbmdsZSA9IG1vZCh0aGV0YSArIGF0YW4oZC55LCBkLngpLCBQSTIpO1xuICAgICAgZ3JhZGllbnQgPSBjbGFtcChncmFkaWVudF9hbmdsZSAtIGFuZ2xlLCAwLjAsIGdyYWRpZW50X2FuZ2xlKS9ncmFkaWVudF9hbmdsZSAqIDAuNTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JhZGllbnQgKyAxLjAgLSBzbW9vdGhzdGVwKGxpbmVfd2lkdGgsIGxpbmVfd2lkdGgrZWRnZV90aGlja25lc3MsIGwpO1xuICB9XG5cblxudm9pZCBtYWluICh2b2lkKVxue1xuICB2ZWMzIGF4aXNfY29sb3IgPSB2ZWMzKDAuOCk7XG4gIHZlYzMgY29sb3IgPSBsaW5lKHZfdXYueSwgMC41LCAwLjAwMiwgMC4wMDEpICogYXhpc19jb2xvcjtcbiAgY29sb3IgKz0gbGluZSh2X3V2LngsIDAuNSwgMC4wMDIsIDAuMDAxKSAqIGF4aXNfY29sb3I7XG5cbiAgLy8gQWRkIGNpcmNsZXNcbiAgY29sb3IgKz0gY2lyY2xlKHZfdXYsIHZlYzIoMC41KSwgMC4zLCAwLjAwMiwgMC4wMDEpICogYXhpc19jb2xvcjtcbiAgY29sb3IgKz0gY2lyY2xlKHZfdXYsIHZlYzIoMC41KSwgMC4yLCAwLjAwMiwgMC4wMDEpICogYXhpc19jb2xvcjtcbiAgY29sb3IgKz0gY2lyY2xlKHZfdXYsIHZlYzIoMC41KSwgMC4xLCAwLjAwMiwgMC4wMDEpICogYXhpc19jb2xvcjtcblxuICAvLyBBZGQgc3dlZXBpbmcgbGluZS5cbiAgY29sb3IgKz0gc3dlZXAodl91diwgdmVjMigwLjUpLCAwLjMsIDAuMDAzLCAwLjAwMSkgKiB2ZWMzKDAuMSwgMC4zLCAwLjEpO1xuXG4gIC8vIEFkZCB0cmlhbmd1bGFyIHBvbHlnb25zXG4gIHZlYzMgd2hpdGUgPSB2ZWMzKDEuMCk7XG4gIGNvbG9yICs9IHBvbHlnb24oXG4gICAgICB2X3V2LFxuICAgICAgdmVjMigwLjkgLSBzaW4odV90aW1lICogMy4wKSAqIDAuMDUsIDAuNSksXG4gICAgICAwLjAwNSwgMywgMC4wLCAwLjAwMSkgKiB3aGl0ZTtcbiAgY29sb3IgKz0gcG9seWdvbihcbiAgICAgIHZfdXYsXG4gICAgICB2ZWMyKDAuMSAtIHNpbih1X3RpbWUgKiAzLjAgK1BJKSAqIDAuMDUsIDAuNSksXG4gICAgICAwLjAwNSwgMywgUEksIDAuMDAxKSAqIHdoaXRlO1xuXG5cbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcbn1cbmA7XG5cbmNsYXNzIEdsc2xQbGF5Z3JvdW5kMTUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vIDJ4MlxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMC4xLCAxMCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgdV9jb2xvcl9hOiB7XG4gICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoMHhmZjAwMDApXG4gICAgICB9LFxuICAgICAgdV9jb2xvcl9iOiB7XG4gICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoMHgwMGZmZmYpXG4gICAgICB9LFxuICAgICAgLy8gRmxvYXRcbiAgICAgIHVfdGltZToge1xuICAgICAgICB2YWx1ZTogMC4wXG4gICAgICB9LFxuICAgICAgLy8gVmVjMiAwLDAgYXQgdG9wLCBsZWZ0IGFuZCB3aW5kb3cuaW5uZXJXaWR0aCBhbmQgd2luZG93LmlubmVySGVpZ2h0IGF0IGJvdHRvbSByaWdodC5cbiAgICAgIHVfbW91c2U6IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB4OiAwLjAsXG4gICAgICAgICAgeTogMC4wXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBWZWMyIFNjcmVlbiByZXNvbHV0aW9uXG4gICAgICB1X3Jlc29sdXRpb246IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07IC8vIDJ4MiBzbyBpdCBmaWxsIHRoZSBzY3JlZW4uXG5cbiAgICB0aGlzLmdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoMiwgMik7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG4gICAgICB1bmlmb3JtczogdGhpcy51bmlmb3JtcyxcbiAgICAgIHZlcnRleFNoYWRlcjogdnNoYWRlcixcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBmc2hhZGVyXG4gICAgfSk7IC8vIENyZWF0ZSBtZXNoIChnZW9tICsgbWF0ZXJpYWwpXG5cbiAgICB0aGlzLnBsYW5lID0gbmV3IFRIUkVFLk1lc2godGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5wbGFuZSk7XG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiA9IDE7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgIHRoaXMucmFmLnN0YXJ0KCk7XG4gIH1cblxuICBvblJlc2l6ZSgpIHtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgaWYgKGFzcGVjdFJhdGlvID49IDEpIHtcbiAgICAgIHdpZHRoID0gMTtcbiAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAvIHdpbmRvdy5pbm5lcldpZHRoICogd2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gYXNwZWN0UmF0aW87XG4gICAgICBoZWlnaHQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuY2FtZXJhLmxlZnQgPSAtd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEucmlnaHQgPSB3aWR0aDtcbiAgICB0aGlzLmNhbWVyYS50b3AgPSBoZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEuYm90dG9tID0gLWhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS55ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZXZ0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnggPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFggOiBldnQuY2xpZW50WDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueSA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WSA6IGV2dC5jbGllbnRZO1xuICB9XG5cbiAgb25SYWYoKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X3RpbWUudmFsdWUgKz0gdGhpcy5yYWYuZ2V0RGVsdGEodHJ1ZSk7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gR2xzbFBsYXlncm91bmQxNTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/glsl-playground15.js\n");

/***/ }),

/***/ "./examples/glsl-playground16.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground16.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739138#questions/\n//\nconst vshader = `\nvarying vec3 v_position; // Declare v_position\nvarying vec2 v_uv; // Declare v_uv\nvoid main() {\n  // Set the uv value.  Three.js passes the uv value by default of the current vertices.\n  v_position = position;\n  v_uv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color_a;\nuniform vec3 u_color_b;\nuniform float u_time;\n\nvarying vec3 v_position;\nvarying vec2 v_uv;\n\n\n\nfloat line(float a, float b, float line_width, float edge_thickness) {\n    float half_line_width = line_width * 0.5;\n    return smoothstep(\n        a - half_line_width - edge_thickness,\n        a - half_line_width,\n        b\n     ) -\n     smoothstep(\n         a + half_line_width,\n         a + half_line_width + edge_thickness,\n         b\n     );\n}\n\n\nfloat brick(vec2 pt, float mortar_height, float edge_thickness){\n    float result = line(pt.y, 0.0, mortar_height, edge_thickness);\n    result += line(pt.y, 0.5, mortar_height, edge_thickness);\n    result += line(pt.y, 1.0, mortar_height, edge_thickness);\n\n    if(pt.y > 0.5) {\n        pt.x = fract(pt.x + 0.5);\n    }\n    result += line(pt.x, 0.5, mortar_height, edge_thickness);\n\n\n    return result;\n  }\n\nvoid main (void)\n{\n  vec2 uv = fract(v_uv*10.0);\n  vec3 white = vec3(1.0);\n  float brickLines = brick(uv, 0.05, 0.001);\n  vec3 color = mix(u_color_a, u_color_b, brickLines);\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground16 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color_a: {\n        value: new THREE.Color(0xff0000)\n      },\n      u_color_b: {\n        value: new THREE.Color(0x00ffff)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground16;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQxNi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDE2LmpzPzRkNTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vL1xuLy8gaHR0cHM6Ly93d3cudWRlbXkuY29tL2NvdXJzZS9sZWFybi1nbHNsLXNoYWRlcnMtZnJvbS1zY3JhdGNoL2xlYXJuL2xlY3R1cmUvMTM3MzkxMzgjcXVlc3Rpb25zL1xuLy9cbmNvbnN0IHZzaGFkZXIgPSBgXG52YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbjsgLy8gRGVjbGFyZSB2X3Bvc2l0aW9uXG52YXJ5aW5nIHZlYzIgdl91djsgLy8gRGVjbGFyZSB2X3V2XG52b2lkIG1haW4oKSB7XG4gIC8vIFNldCB0aGUgdXYgdmFsdWUuICBUaHJlZS5qcyBwYXNzZXMgdGhlIHV2IHZhbHVlIGJ5IGRlZmF1bHQgb2YgdGhlIGN1cnJlbnQgdmVydGljZXMuXG4gIHZfcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdl91diA9IHV2O1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1OVxuI2RlZmluZSBQSTIgNi4yODMxODUzMDcxOFxuXG51bmlmb3JtIHZlYzIgdV9tb3VzZTtcbnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XG51bmlmb3JtIHZlYzMgdV9jb2xvcl9hO1xudW5pZm9ybSB2ZWMzIHVfY29sb3JfYjtcbnVuaWZvcm0gZmxvYXQgdV90aW1lO1xuXG52YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbjtcbnZhcnlpbmcgdmVjMiB2X3V2O1xuXG5cblxuZmxvYXQgbGluZShmbG9hdCBhLCBmbG9hdCBiLCBmbG9hdCBsaW5lX3dpZHRoLCBmbG9hdCBlZGdlX3RoaWNrbmVzcykge1xuICAgIGZsb2F0IGhhbGZfbGluZV93aWR0aCA9IGxpbmVfd2lkdGggKiAwLjU7XG4gICAgcmV0dXJuIHNtb290aHN0ZXAoXG4gICAgICAgIGEgLSBoYWxmX2xpbmVfd2lkdGggLSBlZGdlX3RoaWNrbmVzcyxcbiAgICAgICAgYSAtIGhhbGZfbGluZV93aWR0aCxcbiAgICAgICAgYlxuICAgICApIC1cbiAgICAgc21vb3Roc3RlcChcbiAgICAgICAgIGEgKyBoYWxmX2xpbmVfd2lkdGgsXG4gICAgICAgICBhICsgaGFsZl9saW5lX3dpZHRoICsgZWRnZV90aGlja25lc3MsXG4gICAgICAgICBiXG4gICAgICk7XG59XG5cblxuZmxvYXQgYnJpY2sodmVjMiBwdCwgZmxvYXQgbW9ydGFyX2hlaWdodCwgZmxvYXQgZWRnZV90aGlja25lc3Mpe1xuICAgIGZsb2F0IHJlc3VsdCA9IGxpbmUocHQueSwgMC4wLCBtb3J0YXJfaGVpZ2h0LCBlZGdlX3RoaWNrbmVzcyk7XG4gICAgcmVzdWx0ICs9IGxpbmUocHQueSwgMC41LCBtb3J0YXJfaGVpZ2h0LCBlZGdlX3RoaWNrbmVzcyk7XG4gICAgcmVzdWx0ICs9IGxpbmUocHQueSwgMS4wLCBtb3J0YXJfaGVpZ2h0LCBlZGdlX3RoaWNrbmVzcyk7XG5cbiAgICBpZihwdC55ID4gMC41KSB7XG4gICAgICAgIHB0LnggPSBmcmFjdChwdC54ICsgMC41KTtcbiAgICB9XG4gICAgcmVzdWx0ICs9IGxpbmUocHQueCwgMC41LCBtb3J0YXJfaGVpZ2h0LCBlZGdlX3RoaWNrbmVzcyk7XG5cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxudm9pZCBtYWluICh2b2lkKVxue1xuICB2ZWMyIHV2ID0gZnJhY3Qodl91dioxMC4wKTtcbiAgdmVjMyB3aGl0ZSA9IHZlYzMoMS4wKTtcbiAgZmxvYXQgYnJpY2tMaW5lcyA9IGJyaWNrKHV2LCAwLjA1LCAwLjAwMSk7XG4gIHZlYzMgY29sb3IgPSBtaXgodV9jb2xvcl9hLCB1X2NvbG9yX2IsIGJyaWNrTGluZXMpO1xuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1xufVxuYDtcblxuY2xhc3MgR2xzbFBsYXlncm91bmQxNiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTsgLy8gMngyXG5cbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoLTEsIDEsIDEsIC0xLCAwLjEsIDEwKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgIHRoaXMucmFmID0gbmV3IF9yYWYuUmFmKHRoaXMub25SYWYuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAncmVzaXplJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyksXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdtb3VzZW1vdmUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICB1X2NvbG9yX2E6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweGZmMDAwMClcbiAgICAgIH0sXG4gICAgICB1X2NvbG9yX2I6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweDAwZmZmZilcbiAgICAgIH0sXG4gICAgICAvLyBGbG9hdFxuICAgICAgdV90aW1lOiB7XG4gICAgICAgIHZhbHVlOiAwLjBcbiAgICAgIH0sXG4gICAgICAvLyBWZWMyIDAsMCBhdCB0b3AsIGxlZnQgYW5kIHdpbmRvdy5pbm5lcldpZHRoIGFuZCB3aW5kb3cuaW5uZXJIZWlnaHQgYXQgYm90dG9tIHJpZ2h0LlxuICAgICAgdV9tb3VzZToge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAuMCxcbiAgICAgICAgICB5OiAwLjBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFZlYzIgU2NyZWVuIHJlc29sdXRpb25cbiAgICAgIHVfcmVzb2x1dGlvbjoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgLy8gMngyIHNvIGl0IGZpbGwgdGhlIHNjcmVlbi5cblxuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSgyLCAyKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgdmVydGV4U2hhZGVyOiB2c2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzaGFkZXJcbiAgICB9KTsgLy8gQ3JlYXRlIG1lc2ggKGdlb20gKyBtYXRlcmlhbClcblxuICAgIHRoaXMucGxhbmUgPSBuZXcgVEhSRUUuTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLnBsYW5lKTtcbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gMTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgfVxuXG4gIG9uUmVzaXplKCkge1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBpZiAoYXNwZWN0UmF0aW8gPj0gMSkge1xuICAgICAgd2lkdGggPSAxO1xuICAgICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC8gd2luZG93LmlubmVyV2lkdGggKiB3aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBhc3BlY3RSYXRpbztcbiAgICAgIGhlaWdodCA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5jYW1lcmEubGVmdCA9IC13aWR0aDtcbiAgICB0aGlzLmNhbWVyYS5yaWdodCA9IHdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnRvcCA9IGhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS5ib3R0b20gPSAtaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnkgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIH1cblxuICBvbk1vdXNlTW92ZShldnQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WCA6IGV2dC5jbGllbnRYO1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS55ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRZIDogZXZ0LmNsaWVudFk7XG4gIH1cblxuICBvblJhZihkZWx0YSkge1xuICAgIHRoaXMudW5pZm9ybXMudV90aW1lLnZhbHVlICs9IHRoaXMucmFmLmdldERlbHRhKHRydWUpO1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdsc2xQbGF5Z3JvdW5kMTY7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/glsl-playground16.js\n");

/***/ }),

/***/ "./examples/glsl-playground17.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground17.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739104#questions\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\nconst vshader = `\nvarying vec3 v_position; // Declare v_position\nvarying vec2 v_uv; // Declare v_uv\nvoid main() {\n  // Set the uv value.  Three.js passes the uv value by default of the current vertices.\n  v_position = position;\n  v_uv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nvarying vec3 v_position;\nvarying vec2 v_uv;\n\n// Random with seed\nfloat random (vec2 st, float seed) {\n    const float a = 12.9898;\n    const float b = 78.233;\n    const float c = 43758.543123;\n    return fract(sin(dot(st, vec2(a, b)) + seed) * c );\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st, vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\nfloat noise1(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(random(ip),random(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(random(ip+vec2(0.0,1.0)),random(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n\nfloat noise2 (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid main (void)\n{\n  vec2 st = v_uv;\n\n  // Scale the coordinate system to see\n  // some noise in action\n  vec2 pos = vec2(st*5.0);\n\n  // Use the noise function\n//   float n = noise1(pos);\n  float n = noise2(pos);\n  // Limit out noise, harden the contrast.\n//   n = smoothstep(0.4, 0.6, n);\n\n  gl_FragColor = vec4(vec3(n), 1.0);\n}\n`;\n\nclass GlslPlayground17 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color_a: {\n        value: new THREE.Color(0xff0000)\n      },\n      u_color_b: {\n        value: new THREE.Color(0x00ffff)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground17;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQxNy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDE3LmpzP2EyNmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vL1xuLy9cbi8vIGh0dHBzOi8vd3d3LnVkZW15LmNvbS9jb3Vyc2UvbGVhcm4tZ2xzbC1zaGFkZXJzLWZyb20tc2NyYXRjaC9sZWFybi9sZWN0dXJlLzEzNzM5MTA0I3F1ZXN0aW9uc1xuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF0cmljaW9nb256YWxlenZpdm8vNjcwYzIyZjM5NjZlNjYyZDJmODNcbi8vXG5jb25zdCB2c2hhZGVyID0gYFxudmFyeWluZyB2ZWMzIHZfcG9zaXRpb247IC8vIERlY2xhcmUgdl9wb3NpdGlvblxudmFyeWluZyB2ZWMyIHZfdXY7IC8vIERlY2xhcmUgdl91dlxudm9pZCBtYWluKCkge1xuICAvLyBTZXQgdGhlIHV2IHZhbHVlLiAgVGhyZWUuanMgcGFzc2VzIHRoZSB1diB2YWx1ZSBieSBkZWZhdWx0IG9mIHRoZSBjdXJyZW50IHZlcnRpY2VzLlxuICB2X3Bvc2l0aW9uID0gcG9zaXRpb247XG4gIHZfdXYgPSB1djtcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xufVxuYDtcbmNvbnN0IGZzaGFkZXIgPSBgXG4jZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTlcbiNkZWZpbmUgUEkyIDYuMjgzMTg1MzA3MThcblxudW5pZm9ybSB2ZWMyIHVfbW91c2U7XG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xudW5pZm9ybSB2ZWMzIHVfY29sb3I7XG51bmlmb3JtIGZsb2F0IHVfdGltZTtcblxudmFyeWluZyB2ZWMzIHZfcG9zaXRpb247XG52YXJ5aW5nIHZlYzIgdl91djtcblxuLy8gUmFuZG9tIHdpdGggc2VlZFxuZmxvYXQgcmFuZG9tICh2ZWMyIHN0LCBmbG9hdCBzZWVkKSB7XG4gICAgY29uc3QgZmxvYXQgYSA9IDEyLjk4OTg7XG4gICAgY29uc3QgZmxvYXQgYiA9IDc4LjIzMztcbiAgICBjb25zdCBmbG9hdCBjID0gNDM3NTguNTQzMTIzO1xuICAgIHJldHVybiBmcmFjdChzaW4oZG90KHN0LCB2ZWMyKGEsIGIpKSArIHNlZWQpICogYyApO1xufVxuXG5mbG9hdCByYW5kb20gKHZlYzIgc3QpIHtcbiAgICByZXR1cm4gZnJhY3Qoc2luKGRvdChzdCwgdmVjMigxMi45ODk4LDc4LjIzMykpKVxuICAgICAgICAgICAgICAgICAqIDQzNzU4LjU0NTMxMjMpO1xufVxuZmxvYXQgbm9pc2UxKHZlYzIgcCl7XG5cdHZlYzIgaXAgPSBmbG9vcihwKTtcblx0dmVjMiB1ID0gZnJhY3QocCk7XG5cdHUgPSB1KnUqKDMuMC0yLjAqdSk7XG5cblx0ZmxvYXQgcmVzID0gbWl4KFxuXHRcdG1peChyYW5kb20oaXApLHJhbmRvbShpcCt2ZWMyKDEuMCwwLjApKSx1LngpLFxuXHRcdG1peChyYW5kb20oaXArdmVjMigwLjAsMS4wKSkscmFuZG9tKGlwK3ZlYzIoMS4wLDEuMCkpLHUueCksdS55KTtcblx0cmV0dXJuIHJlcypyZXM7XG59XG5cblxuZmxvYXQgbm9pc2UyICh2ZWMyIHN0KSB7XG4gICAgdmVjMiBpID0gZmxvb3Ioc3QpO1xuICAgIHZlYzIgZiA9IGZyYWN0KHN0KTtcblxuICAgIC8vIEZvdXIgY29ybmVycyBpbiAyRCBvZiBhIHRpbGVcbiAgICBmbG9hdCBhID0gcmFuZG9tKGkpO1xuICAgIGZsb2F0IGIgPSByYW5kb20oaSArIHZlYzIoMS4wLCAwLjApKTtcbiAgICBmbG9hdCBjID0gcmFuZG9tKGkgKyB2ZWMyKDAuMCwgMS4wKSk7XG4gICAgZmxvYXQgZCA9IHJhbmRvbShpICsgdmVjMigxLjAsIDEuMCkpO1xuXG4gICAgLy8gU21vb3RoIEludGVycG9sYXRpb25cblxuICAgIC8vIEN1YmljIEhlcm1pbmUgQ3VydmUuICBTYW1lIGFzIFNtb290aFN0ZXAoKVxuICAgIHZlYzIgdSA9IGYqZiooMy4wLTIuMCpmKTtcbiAgICAvLyB1ID0gc21vb3Roc3RlcCgwLiwxLixmKTtcblxuICAgIC8vIE1peCA0IGNvb3JuZXJzIHBlcmNlbnRhZ2VzXG4gICAgcmV0dXJuIG1peChhLCBiLCB1LngpICtcbiAgICAgICAgICAgIChjIC0gYSkqIHUueSAqICgxLjAgLSB1LngpICtcbiAgICAgICAgICAgIChkIC0gYikgKiB1LnggKiB1Lnk7XG59XG5cbnZvaWQgbWFpbiAodm9pZClcbntcbiAgdmVjMiBzdCA9IHZfdXY7XG5cbiAgLy8gU2NhbGUgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIHRvIHNlZVxuICAvLyBzb21lIG5vaXNlIGluIGFjdGlvblxuICB2ZWMyIHBvcyA9IHZlYzIoc3QqNS4wKTtcblxuICAvLyBVc2UgdGhlIG5vaXNlIGZ1bmN0aW9uXG4vLyAgIGZsb2F0IG4gPSBub2lzZTEocG9zKTtcbiAgZmxvYXQgbiA9IG5vaXNlMihwb3MpO1xuICAvLyBMaW1pdCBvdXQgbm9pc2UsIGhhcmRlbiB0aGUgY29udHJhc3QuXG4vLyAgIG4gPSBzbW9vdGhzdGVwKDAuNCwgMC42LCBuKTtcblxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMobiksIDEuMCk7XG59XG5gO1xuXG5jbGFzcyBHbHNsUGxheWdyb3VuZDE3IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpOyAvLyAyeDJcblxuICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgtMSwgMSwgMSwgLTEsIDAuMSwgMTApO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgdGhpcy5yYWYgPSBuZXcgX3JhZi5SYWYodGhpcy5vblJhZi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIgPSBuZXcgX2RvbVdhdGNoZXIuRG9tV2F0Y2hlcigpO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdyZXNpemUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25SZXNpemUuYmluZCh0aGlzKSxcbiAgICAgIGV2ZW50T3B0aW9uczoge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ21vdXNlbW92ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgIHVfY29sb3JfYToge1xuICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKDB4ZmYwMDAwKVxuICAgICAgfSxcbiAgICAgIHVfY29sb3JfYjoge1xuICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKDB4MDBmZmZmKVxuICAgICAgfSxcbiAgICAgIC8vIEZsb2F0XG4gICAgICB1X3RpbWU6IHtcbiAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgfSxcbiAgICAgIC8vIFZlYzIgMCwwIGF0IHRvcCwgbGVmdCBhbmQgd2luZG93LmlubmVyV2lkdGggYW5kIHdpbmRvdy5pbm5lckhlaWdodCBhdCBib3R0b20gcmlnaHQuXG4gICAgICB1X21vdXNlOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMC4wLFxuICAgICAgICAgIHk6IDAuMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVmVjMiBTY3JlZW4gcmVzb2x1dGlvblxuICAgICAgdV9yZXNvbHV0aW9uOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvLyAyeDIgc28gaXQgZmlsbCB0aGUgc2NyZWVuLlxuXG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDIsIDIpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZzaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZnNoYWRlclxuICAgIH0pOyAvLyBDcmVhdGUgbWVzaCAoZ2VvbSArIG1hdGVyaWFsKVxuXG4gICAgdGhpcy5wbGFuZSA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMucGxhbmUpO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAxO1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGlmIChhc3BlY3RSYXRpbyA+PSAxKSB7XG4gICAgICB3aWR0aCA9IDE7XG4gICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB3aW5kb3cuaW5uZXJXaWR0aCAqIHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdFJhdGlvO1xuICAgICAgaGVpZ2h0ID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbWVyYS5sZWZ0ID0gLXdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnJpZ2h0ID0gd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEudG9wID0gaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLmJvdHRvbSA9IC1oZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS54ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGV2dCkge1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS54ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRYIDogZXZ0LmNsaWVudFg7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnkgPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFkgOiBldnQuY2xpZW50WTtcbiAgfVxuXG4gIG9uUmFmKGRlbHRhKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X3RpbWUudmFsdWUgKz0gdGhpcy5yYWYuZ2V0RGVsdGEodHJ1ZSk7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gR2xzbFBsYXlncm91bmQxNzsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/glsl-playground17.js\n");

/***/ }),

/***/ "./examples/glsl-playground18.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground18.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739104#questions\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\nconst vshader = `\nvarying vec3 v_position; // Declare v_position\nvarying vec2 v_uv; // Declare v_uv\nvoid main() {\n  // Set the uv value.  Three.js passes the uv value by default of the current vertices.\n  v_position = position;\n  v_uv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color_a;\nuniform vec3 u_color_b;\nuniform float u_time;\n\nvarying vec3 v_position;\nvarying vec2 v_uv;\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st, vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nvoid main (void)\n{\n  vec2 st = v_uv;\n\n  // Scale the coordinate system to see\n  // some noise in action\n  vec2 pos = vec2(\n      v_uv.x * 1.4 + 0.01,\n      v_uv.y - u_time * 0.69\n  );\n\n  // Use the noise function\n  float n = noise(pos * 23.0);\n  // Layer2\n  pos = vec2(fract(v_uv.x * 0.5 - 0.0333), v_uv.y * 2.0 - u_time * 0.12);\n  n+= noise(pos * 8.0);\n\n  // Layer 3\n  pos = vec2(v_uv.x * 0.94 - 0.02, v_uv.y * 3.0 - u_time * 0.61);\n  n+= noise(pos * 0.5);\n  n /= 3.0;\n\n\n  vec3 color = mix(u_color_a, u_color_b, n);\n\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground17 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color_a: {\n        value: new THREE.Color(0xff0000)\n      },\n      u_color_b: {\n        value: new THREE.Color(0x00ffff)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground17;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQxOC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDE4LmpzPzBiNWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vL1xuLy9cbi8vIGh0dHBzOi8vd3d3LnVkZW15LmNvbS9jb3Vyc2UvbGVhcm4tZ2xzbC1zaGFkZXJzLWZyb20tc2NyYXRjaC9sZWFybi9sZWN0dXJlLzEzNzM5MTA0I3F1ZXN0aW9uc1xuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF0cmljaW9nb256YWxlenZpdm8vNjcwYzIyZjM5NjZlNjYyZDJmODNcbi8vXG5jb25zdCB2c2hhZGVyID0gYFxudmFyeWluZyB2ZWMzIHZfcG9zaXRpb247IC8vIERlY2xhcmUgdl9wb3NpdGlvblxudmFyeWluZyB2ZWMyIHZfdXY7IC8vIERlY2xhcmUgdl91dlxudm9pZCBtYWluKCkge1xuICAvLyBTZXQgdGhlIHV2IHZhbHVlLiAgVGhyZWUuanMgcGFzc2VzIHRoZSB1diB2YWx1ZSBieSBkZWZhdWx0IG9mIHRoZSBjdXJyZW50IHZlcnRpY2VzLlxuICB2X3Bvc2l0aW9uID0gcG9zaXRpb247XG4gIHZfdXYgPSB1djtcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xufVxuYDtcbmNvbnN0IGZzaGFkZXIgPSBgXG4jZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTlcbiNkZWZpbmUgUEkyIDYuMjgzMTg1MzA3MThcblxudW5pZm9ybSB2ZWMyIHVfbW91c2U7XG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xudW5pZm9ybSB2ZWMzIHVfY29sb3JfYTtcbnVuaWZvcm0gdmVjMyB1X2NvbG9yX2I7XG51bmlmb3JtIGZsb2F0IHVfdGltZTtcblxudmFyeWluZyB2ZWMzIHZfcG9zaXRpb247XG52YXJ5aW5nIHZlYzIgdl91djtcblxuZmxvYXQgcmFuZG9tICh2ZWMyIHN0KSB7XG4gICAgcmV0dXJuIGZyYWN0KHNpbihkb3Qoc3QsIHZlYzIoMTIuOTg5OCw3OC4yMzMpKSlcbiAgICAgICAgICAgICAgICAgKiA0Mzc1OC41NDUzMTIzKTtcbn1cbmZsb2F0IG5vaXNlICh2ZWMyIHN0KSB7XG4gICAgdmVjMiBpID0gZmxvb3Ioc3QpO1xuICAgIHZlYzIgZiA9IGZyYWN0KHN0KTtcblxuICAgIC8vIEZvdXIgY29ybmVycyBpbiAyRCBvZiBhIHRpbGVcbiAgICBmbG9hdCBhID0gcmFuZG9tKGkpO1xuICAgIGZsb2F0IGIgPSByYW5kb20oaSArIHZlYzIoMS4wLCAwLjApKTtcbiAgICBmbG9hdCBjID0gcmFuZG9tKGkgKyB2ZWMyKDAuMCwgMS4wKSk7XG4gICAgZmxvYXQgZCA9IHJhbmRvbShpICsgdmVjMigxLjAsIDEuMCkpO1xuXG4gICAgLy8gU21vb3RoIEludGVycG9sYXRpb25cblxuICAgIC8vIEN1YmljIEhlcm1pbmUgQ3VydmUuICBTYW1lIGFzIFNtb290aFN0ZXAoKVxuICAgIHZlYzIgdSA9IGYqZiooMy4wLTIuMCpmKTtcbiAgICAvLyB1ID0gc21vb3Roc3RlcCgwLiwxLixmKTtcblxuICAgIC8vIE1peCA0IGNvb3JuZXJzIHBlcmNlbnRhZ2VzXG4gICAgcmV0dXJuIG1peChhLCBiLCB1LngpICtcbiAgICAgICAgICAgIChjIC0gYSkqIHUueSAqICgxLjAgLSB1LngpICtcbiAgICAgICAgICAgIChkIC0gYikgKiB1LnggKiB1Lnk7XG59XG5cblxudm9pZCBtYWluICh2b2lkKVxue1xuICB2ZWMyIHN0ID0gdl91djtcblxuICAvLyBTY2FsZSB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gc2VlXG4gIC8vIHNvbWUgbm9pc2UgaW4gYWN0aW9uXG4gIHZlYzIgcG9zID0gdmVjMihcbiAgICAgIHZfdXYueCAqIDEuNCArIDAuMDEsXG4gICAgICB2X3V2LnkgLSB1X3RpbWUgKiAwLjY5XG4gICk7XG5cbiAgLy8gVXNlIHRoZSBub2lzZSBmdW5jdGlvblxuICBmbG9hdCBuID0gbm9pc2UocG9zICogMjMuMCk7XG4gIC8vIExheWVyMlxuICBwb3MgPSB2ZWMyKGZyYWN0KHZfdXYueCAqIDAuNSAtIDAuMDMzMyksIHZfdXYueSAqIDIuMCAtIHVfdGltZSAqIDAuMTIpO1xuICBuKz0gbm9pc2UocG9zICogOC4wKTtcblxuICAvLyBMYXllciAzXG4gIHBvcyA9IHZlYzIodl91di54ICogMC45NCAtIDAuMDIsIHZfdXYueSAqIDMuMCAtIHVfdGltZSAqIDAuNjEpO1xuICBuKz0gbm9pc2UocG9zICogMC41KTtcbiAgbiAvPSAzLjA7XG5cblxuICB2ZWMzIGNvbG9yID0gbWl4KHVfY29sb3JfYSwgdV9jb2xvcl9iLCBuKTtcblxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1xufVxuYDtcblxuY2xhc3MgR2xzbFBsYXlncm91bmQxNyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTsgLy8gMngyXG5cbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoLTEsIDEsIDEsIC0xLCAwLjEsIDEwKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgIHRoaXMucmFmID0gbmV3IF9yYWYuUmFmKHRoaXMub25SYWYuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAncmVzaXplJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyksXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdtb3VzZW1vdmUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICB1X2NvbG9yX2E6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweGZmMDAwMClcbiAgICAgIH0sXG4gICAgICB1X2NvbG9yX2I6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweDAwZmZmZilcbiAgICAgIH0sXG4gICAgICAvLyBGbG9hdFxuICAgICAgdV90aW1lOiB7XG4gICAgICAgIHZhbHVlOiAwLjBcbiAgICAgIH0sXG4gICAgICAvLyBWZWMyIDAsMCBhdCB0b3AsIGxlZnQgYW5kIHdpbmRvdy5pbm5lcldpZHRoIGFuZCB3aW5kb3cuaW5uZXJIZWlnaHQgYXQgYm90dG9tIHJpZ2h0LlxuICAgICAgdV9tb3VzZToge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAuMCxcbiAgICAgICAgICB5OiAwLjBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFZlYzIgU2NyZWVuIHJlc29sdXRpb25cbiAgICAgIHVfcmVzb2x1dGlvbjoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgLy8gMngyIHNvIGl0IGZpbGwgdGhlIHNjcmVlbi5cblxuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSgyLCAyKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgdmVydGV4U2hhZGVyOiB2c2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzaGFkZXJcbiAgICB9KTsgLy8gQ3JlYXRlIG1lc2ggKGdlb20gKyBtYXRlcmlhbClcblxuICAgIHRoaXMucGxhbmUgPSBuZXcgVEhSRUUuTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLnBsYW5lKTtcbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gMTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgfVxuXG4gIG9uUmVzaXplKCkge1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBpZiAoYXNwZWN0UmF0aW8gPj0gMSkge1xuICAgICAgd2lkdGggPSAxO1xuICAgICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC8gd2luZG93LmlubmVyV2lkdGggKiB3aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBhc3BlY3RSYXRpbztcbiAgICAgIGhlaWdodCA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5jYW1lcmEubGVmdCA9IC13aWR0aDtcbiAgICB0aGlzLmNhbWVyYS5yaWdodCA9IHdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnRvcCA9IGhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS5ib3R0b20gPSAtaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnkgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIH1cblxuICBvbk1vdXNlTW92ZShldnQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WCA6IGV2dC5jbGllbnRYO1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS55ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRZIDogZXZ0LmNsaWVudFk7XG4gIH1cblxuICBvblJhZihkZWx0YSkge1xuICAgIHRoaXMudW5pZm9ybXMudV90aW1lLnZhbHVlICs9IHRoaXMucmFmLmdldERlbHRhKHRydWUpO1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdsc2xQbGF5Z3JvdW5kMTc7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/glsl-playground18.js\n");

/***/ }),

/***/ "./examples/glsl-playground19.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground19.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _noise = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/noise */ \"./lib/shaders/three-shader-chunks/noise.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739104#questions\n//\n// Import shader chunks\n(0, _noise.noise)();\nconst vshader = `\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvoid main() {\n  v_position = position;\n  v_uv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\n#include <noise>\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\nuniform vec3 u_LightColor;\nuniform vec3 u_DarkColor;\nuniform float u_Frequency;\nuniform float u_NoiseScale;\nuniform float u_RingScale;\nuniform float u_Contrast;\nuniform float u_time;\n\n\nvarying vec3 v_position;\nvarying vec2 v_uv;\n\n\nvoid main (void)\n{\n\n  vec3 pos = v_position;\n  pos.x += u_time;\n  pos.y += u_time;\n  float n = snoise(pos);\n  float ring = u_Contrast - fract(u_NoiseScale * n);\n  float lerp = pow(ring, u_RingScale) + n;\n  vec3 color = mix(u_DarkColor, u_LightColor, lerp);\n\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground19 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {};\n    this.uniforms.u_time = {\n      value: 0.0\n    };\n    this.uniforms.u_resolution = {\n      value: new THREE.Vector2()\n    };\n    this.uniforms.u_LightColor = {\n      value: new THREE.Color(0xbb905d)\n    };\n    this.uniforms.u_DarkColor = {\n      value: new THREE.Color(0x7d490b)\n    };\n    this.uniforms.u_Frequency = {\n      value: 20.0\n    };\n    this.uniforms.u_NoiseScale = {\n      value: 20.0\n    };\n    this.uniforms.u_RingScale = {\n      value: 0.5\n    };\n    this.uniforms.u_Contrast = {\n      value: 4.0\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {// this.uniforms.u_mouse.value.x = (evt.touches) ? evt.touches[0].clientX : evt.clientX;\n    // this.uniforms.u_mouse.value.y = (evt.touches) ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground19;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQxOS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDE5LmpzP2I5NTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxudmFyIF9ub2lzZSA9IHJlcXVpcmUoXCIuLi9saWIvc2hhZGVycy90aHJlZS1zaGFkZXItY2h1bmtzL25vaXNlXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8vXG4vL1xuLy8gaHR0cHM6Ly93d3cudWRlbXkuY29tL2NvdXJzZS9sZWFybi1nbHNsLXNoYWRlcnMtZnJvbS1zY3JhdGNoL2xlYXJuL2xlY3R1cmUvMTM3MzkxMDQjcXVlc3Rpb25zXG4vL1xuLy8gSW1wb3J0IHNoYWRlciBjaHVua3NcbigwLCBfbm9pc2Uubm9pc2UpKCk7XG5jb25zdCB2c2hhZGVyID0gYFxudmFyeWluZyB2ZWMzIHZfcG9zaXRpb247XG52YXJ5aW5nIHZlYzIgdl91djtcbnZvaWQgbWFpbigpIHtcbiAgdl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB2X3V2ID0gdXY7XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcbn1cbmA7XG5jb25zdCBmc2hhZGVyID0gYFxuI2luY2x1ZGUgPG5vaXNlPlxuI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU5XG4jZGVmaW5lIFBJMiA2LjI4MzE4NTMwNzE4XG5cbnVuaWZvcm0gdmVjMyB1X0xpZ2h0Q29sb3I7XG51bmlmb3JtIHZlYzMgdV9EYXJrQ29sb3I7XG51bmlmb3JtIGZsb2F0IHVfRnJlcXVlbmN5O1xudW5pZm9ybSBmbG9hdCB1X05vaXNlU2NhbGU7XG51bmlmb3JtIGZsb2F0IHVfUmluZ1NjYWxlO1xudW5pZm9ybSBmbG9hdCB1X0NvbnRyYXN0O1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG5cblxudmFyeWluZyB2ZWMzIHZfcG9zaXRpb247XG52YXJ5aW5nIHZlYzIgdl91djtcblxuXG52b2lkIG1haW4gKHZvaWQpXG57XG5cbiAgdmVjMyBwb3MgPSB2X3Bvc2l0aW9uO1xuICBwb3MueCArPSB1X3RpbWU7XG4gIHBvcy55ICs9IHVfdGltZTtcbiAgZmxvYXQgbiA9IHNub2lzZShwb3MpO1xuICBmbG9hdCByaW5nID0gdV9Db250cmFzdCAtIGZyYWN0KHVfTm9pc2VTY2FsZSAqIG4pO1xuICBmbG9hdCBsZXJwID0gcG93KHJpbmcsIHVfUmluZ1NjYWxlKSArIG47XG4gIHZlYzMgY29sb3IgPSBtaXgodV9EYXJrQ29sb3IsIHVfTGlnaHRDb2xvciwgbGVycCk7XG5cbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcbn1cbmA7XG5cbmNsYXNzIEdsc2xQbGF5Z3JvdW5kMTkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vIDJ4MlxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMC4xLCAxMCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zID0ge307XG4gICAgdGhpcy51bmlmb3Jtcy51X3RpbWUgPSB7XG4gICAgICB2YWx1ZTogMC4wXG4gICAgfTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbiA9IHtcbiAgICAgIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMigpXG4gICAgfTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfTGlnaHRDb2xvciA9IHtcbiAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoMHhiYjkwNWQpXG4gICAgfTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfRGFya0NvbG9yID0ge1xuICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweDdkNDkwYilcbiAgICB9O1xuICAgIHRoaXMudW5pZm9ybXMudV9GcmVxdWVuY3kgPSB7XG4gICAgICB2YWx1ZTogMjAuMFxuICAgIH07XG4gICAgdGhpcy51bmlmb3Jtcy51X05vaXNlU2NhbGUgPSB7XG4gICAgICB2YWx1ZTogMjAuMFxuICAgIH07XG4gICAgdGhpcy51bmlmb3Jtcy51X1JpbmdTY2FsZSA9IHtcbiAgICAgIHZhbHVlOiAwLjVcbiAgICB9O1xuICAgIHRoaXMudW5pZm9ybXMudV9Db250cmFzdCA9IHtcbiAgICAgIHZhbHVlOiA0LjBcbiAgICB9OyAvLyAyeDIgc28gaXQgZmlsbCB0aGUgc2NyZWVuLlxuXG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDIsIDIpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZzaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZnNoYWRlclxuICAgIH0pOyAvLyBDcmVhdGUgbWVzaCAoZ2VvbSArIG1hdGVyaWFsKVxuXG4gICAgdGhpcy5wbGFuZSA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMucGxhbmUpO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAxO1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGlmIChhc3BlY3RSYXRpbyA+PSAxKSB7XG4gICAgICB3aWR0aCA9IDE7XG4gICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB3aW5kb3cuaW5uZXJXaWR0aCAqIHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdFJhdGlvO1xuICAgICAgaGVpZ2h0ID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbWVyYS5sZWZ0ID0gLXdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnJpZ2h0ID0gd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEudG9wID0gaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLmJvdHRvbSA9IC1oZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS54ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGV2dCkgey8vIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS54ID0gKGV2dC50b3VjaGVzKSA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFggOiBldnQuY2xpZW50WDtcbiAgICAvLyB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueSA9IChldnQudG91Y2hlcykgPyBldnQudG91Y2hlc1swXS5jbGllbnRZIDogZXZ0LmNsaWVudFk7XG4gIH1cblxuICBvblJhZihkZWx0YSkge1xuICAgIHRoaXMudW5pZm9ybXMudV90aW1lLnZhbHVlICs9IHRoaXMucmFmLmdldERlbHRhKHRydWUpO1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdsc2xQbGF5Z3JvdW5kMTk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/glsl-playground19.js\n");

/***/ }),

/***/ "./examples/glsl-playground2.js":
/*!**************************************!*\
  !*** ./examples/glsl-playground2.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n/**\n * https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram\n */\nconst vshader = `\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\n\nvoid main (void)\n{\n\n// Example 1\n// Get the x,y coordinates of the mouse position (0,0) at top left and (1,1)\n// and assign that.\n// Pass coordinates of normalized mouse positions as red and blue channels.\n//\n//   vec3 color = vec3(u_mouse.x / u_resolution.x, 0.0, u_mouse.y / u_resolution.y);\n//   gl_FragColor = vec4(color, 1.0);\n\n\n// Example 2\n// A simplified version of example 1.\nvec2 v = u_mouse / u_resolution;\nvec3 color = vec3(v.x, 0.0, v.y);\ngl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground2 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color: {\n        value: new THREE.Color(0xff0000)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf() {\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground2;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvZ2xzbC1wbGF5Z3JvdW5kMi5qcz83MzFhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX3JhZiA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZlwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLyoqXG4gKiBodHRwczovL3RocmVlanMub3JnL2RvY3MvI2FwaS9lbi9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9ncmFtXG4gKi9cbmNvbnN0IHZzaGFkZXIgPSBgXG52b2lkIG1haW4oKSB7XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcbn1cbmA7XG5jb25zdCBmc2hhZGVyID0gYFxudW5pZm9ybSB2ZWMyIHVfbW91c2U7XG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xudW5pZm9ybSB2ZWMzIHVfY29sb3I7XG5cbnZvaWQgbWFpbiAodm9pZClcbntcblxuLy8gRXhhbXBsZSAxXG4vLyBHZXQgdGhlIHgseSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2UgcG9zaXRpb24gKDAsMCkgYXQgdG9wIGxlZnQgYW5kICgxLDEpXG4vLyBhbmQgYXNzaWduIHRoYXQuXG4vLyBQYXNzIGNvb3JkaW5hdGVzIG9mIG5vcm1hbGl6ZWQgbW91c2UgcG9zaXRpb25zIGFzIHJlZCBhbmQgYmx1ZSBjaGFubmVscy5cbi8vXG4vLyAgIHZlYzMgY29sb3IgPSB2ZWMzKHVfbW91c2UueCAvIHVfcmVzb2x1dGlvbi54LCAwLjAsIHVfbW91c2UueSAvIHVfcmVzb2x1dGlvbi55KTtcbi8vICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcblxuXG4vLyBFeGFtcGxlIDJcbi8vIEEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIGV4YW1wbGUgMS5cbnZlYzIgdiA9IHVfbW91c2UgLyB1X3Jlc29sdXRpb247XG52ZWMzIGNvbG9yID0gdmVjMyh2LngsIDAuMCwgdi55KTtcbmdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuMCk7XG59XG5gO1xuXG5jbGFzcyBHbHNsUGxheWdyb3VuZDIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vIDJ4MlxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMC4xLCAxMCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgdV9jb2xvcjoge1xuICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKDB4ZmYwMDAwKVxuICAgICAgfSxcbiAgICAgIC8vIEZsb2F0XG4gICAgICB1X3RpbWU6IHtcbiAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgfSxcbiAgICAgIC8vIFZlYzIgMCwwIGF0IHRvcCwgbGVmdCBhbmQgd2luZG93LmlubmVyV2lkdGggYW5kIHdpbmRvdy5pbm5lckhlaWdodCBhdCBib3R0b20gcmlnaHQuXG4gICAgICB1X21vdXNlOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMC4wLFxuICAgICAgICAgIHk6IDAuMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVmVjMiBTY3JlZW4gcmVzb2x1dGlvblxuICAgICAgdV9yZXNvbHV0aW9uOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvLyAyeDIgc28gaXQgZmlsbCB0aGUgc2NyZWVuLlxuXG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDIsIDIpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZzaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZnNoYWRlclxuICAgIH0pOyAvLyBDcmVhdGUgbWVzaCAoZ2VvbSArIG1hdGVyaWFsKVxuXG4gICAgdGhpcy5wbGFuZSA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMucGxhbmUpO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAxO1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGlmIChhc3BlY3RSYXRpbyA+PSAxKSB7XG4gICAgICB3aWR0aCA9IDE7XG4gICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB3aW5kb3cuaW5uZXJXaWR0aCAqIHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdFJhdGlvO1xuICAgICAgaGVpZ2h0ID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbWVyYS5sZWZ0ID0gLXdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnJpZ2h0ID0gd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEudG9wID0gaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLmJvdHRvbSA9IC1oZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS54ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGV2dCkge1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS54ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRYIDogZXZ0LmNsaWVudFg7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnkgPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFkgOiBldnQuY2xpZW50WTtcbiAgfVxuXG4gIG9uUmFmKCkge1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdsc2xQbGF5Z3JvdW5kMjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/glsl-playground2.js\n");

/***/ }),

/***/ "./examples/glsl-playground20.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground20.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _deguMathf = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/degu-mathf */ \"./lib/shaders/three-shader-chunks/degu-mathf.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//\n// Simple Image Texture.\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739104#questions\n// https://codepen.io/nik-lever/pen/wvwZwMR\n//\n// Import shader chunks\n(0, _deguMathf.deguMathf)(THREE);\nconst vshader = `\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvoid main() {\n  v_position = position;\n  v_uv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\n#include <deguMathf>\n#define PI 3.14159265359\n\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nuniform sampler2D u_texture;\n\nvarying vec3 v_position;\nvarying vec2 v_uv;\n\n\nvoid main (void)\n{\n  // Example 1.  Just diplay the image based on uv.\n    // vec2 uv = v_uv;\n  // Get the color for the current pixel location and interpolate it with v_uv.\n    // vec3 color = texture2D(u_texture, uv).rgb;\n\n  // Example 2.  Flip image.\n  // Flip it upside down\n  //   vec2 uv = vec2(v_uv.x, 1.0 - v_uv.y);\n  //   vec3 color = texture2D(u_texture, uv).rgb;\n\n  // Example 3: Rotate the image but this doesn't take care of aspect ratio\n  // so as it rotates the image might warp.\n  //   vec2 center = vec2(0.5);\n  //   vec2 uv = rotate2d(v_uv - center, 1.0) + center;\n  //   vec3 color = texture2D(u_texture, uv).rgb;\n\n  // Example 4: Rotation with image aspect.  Time is used as the angle.\n    vec2 center = vec2(0.5);\n    float imageAspect = 300.0 / 448.0;\n    vec3 backgroundColor = vec3(0.0);\n    vec3 color = deguRotate2dImage(\n        u_texture, imageAspect, v_uv, center, u_time, backgroundColor);\n\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground20 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      // Load a texture.\n      // Ends up being a sampler2D type.\n      u_texture: {\n        value: new THREE.TextureLoader().load('./public/flower.jpg')\n      },\n      u_time: {\n        value: 0.0\n      },\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // The plane size should be the same aspect ratio as the image otherwise,\n    // the image gets stretched.\n\n    this.geometry = new THREE.PlaneGeometry(0.669, 1);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground20;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQyMC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDIwLmpzPzY1N2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxudmFyIF9kZWd1TWF0aGYgPSByZXF1aXJlKFwiLi4vbGliL3NoYWRlcnMvdGhyZWUtc2hhZGVyLWNodW5rcy9kZWd1LW1hdGhmXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8vXG4vL1xuLy8gU2ltcGxlIEltYWdlIFRleHR1cmUuXG4vLyBodHRwczovL3d3dy51ZGVteS5jb20vY291cnNlL2xlYXJuLWdsc2wtc2hhZGVycy1mcm9tLXNjcmF0Y2gvbGVhcm4vbGVjdHVyZS8xMzczOTEwNCNxdWVzdGlvbnNcbi8vIGh0dHBzOi8vY29kZXBlbi5pby9uaWstbGV2ZXIvcGVuL3d2d1p3TVJcbi8vXG4vLyBJbXBvcnQgc2hhZGVyIGNodW5rc1xuKDAsIF9kZWd1TWF0aGYuZGVndU1hdGhmKShUSFJFRSk7XG5jb25zdCB2c2hhZGVyID0gYFxudmFyeWluZyB2ZWMzIHZfcG9zaXRpb247XG52YXJ5aW5nIHZlYzIgdl91djtcbnZvaWQgbWFpbigpIHtcbiAgdl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB2X3V2ID0gdXY7XG4gIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcbn1cbmA7XG5jb25zdCBmc2hhZGVyID0gYFxuI2luY2x1ZGUgPGRlZ3VNYXRoZj5cbiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1OVxuXG51bmlmb3JtIHZlYzIgdV9tb3VzZTtcbnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XG51bmlmb3JtIHZlYzMgdV9jb2xvcjtcbnVuaWZvcm0gZmxvYXQgdV90aW1lO1xuXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XG5cbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xudmFyeWluZyB2ZWMyIHZfdXY7XG5cblxudm9pZCBtYWluICh2b2lkKVxue1xuICAvLyBFeGFtcGxlIDEuICBKdXN0IGRpcGxheSB0aGUgaW1hZ2UgYmFzZWQgb24gdXYuXG4gICAgLy8gdmVjMiB1diA9IHZfdXY7XG4gIC8vIEdldCB0aGUgY29sb3IgZm9yIHRoZSBjdXJyZW50IHBpeGVsIGxvY2F0aW9uIGFuZCBpbnRlcnBvbGF0ZSBpdCB3aXRoIHZfdXYuXG4gICAgLy8gdmVjMyBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2KS5yZ2I7XG5cbiAgLy8gRXhhbXBsZSAyLiAgRmxpcCBpbWFnZS5cbiAgLy8gRmxpcCBpdCB1cHNpZGUgZG93blxuICAvLyAgIHZlYzIgdXYgPSB2ZWMyKHZfdXYueCwgMS4wIC0gdl91di55KTtcbiAgLy8gICB2ZWMzIGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYpLnJnYjtcblxuICAvLyBFeGFtcGxlIDM6IFJvdGF0ZSB0aGUgaW1hZ2UgYnV0IHRoaXMgZG9lc24ndCB0YWtlIGNhcmUgb2YgYXNwZWN0IHJhdGlvXG4gIC8vIHNvIGFzIGl0IHJvdGF0ZXMgdGhlIGltYWdlIG1pZ2h0IHdhcnAuXG4gIC8vICAgdmVjMiBjZW50ZXIgPSB2ZWMyKDAuNSk7XG4gIC8vICAgdmVjMiB1diA9IHJvdGF0ZTJkKHZfdXYgLSBjZW50ZXIsIDEuMCkgKyBjZW50ZXI7XG4gIC8vICAgdmVjMyBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmUsIHV2KS5yZ2I7XG5cbiAgLy8gRXhhbXBsZSA0OiBSb3RhdGlvbiB3aXRoIGltYWdlIGFzcGVjdC4gIFRpbWUgaXMgdXNlZCBhcyB0aGUgYW5nbGUuXG4gICAgdmVjMiBjZW50ZXIgPSB2ZWMyKDAuNSk7XG4gICAgZmxvYXQgaW1hZ2VBc3BlY3QgPSAzMDAuMCAvIDQ0OC4wO1xuICAgIHZlYzMgYmFja2dyb3VuZENvbG9yID0gdmVjMygwLjApO1xuICAgIHZlYzMgY29sb3IgPSBkZWd1Um90YXRlMmRJbWFnZShcbiAgICAgICAgdV90ZXh0dXJlLCBpbWFnZUFzcGVjdCwgdl91diwgY2VudGVyLCB1X3RpbWUsIGJhY2tncm91bmRDb2xvcik7XG5cbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcbn1cbmA7XG5cbmNsYXNzIEdsc2xQbGF5Z3JvdW5kMjAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vIDJ4MlxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMC4xLCAxMCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgLy8gTG9hZCBhIHRleHR1cmUuXG4gICAgICAvLyBFbmRzIHVwIGJlaW5nIGEgc2FtcGxlcjJEIHR5cGUuXG4gICAgICB1X3RleHR1cmU6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnLi9wdWJsaWMvZmxvd2VyLmpwZycpXG4gICAgICB9LFxuICAgICAgdV90aW1lOiB7XG4gICAgICAgIHZhbHVlOiAwLjBcbiAgICAgIH0sXG4gICAgICB1X21vdXNlOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMC4wLFxuICAgICAgICAgIHk6IDAuMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdV9yZXNvbHV0aW9uOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvLyBUaGUgcGxhbmUgc2l6ZSBzaG91bGQgYmUgdGhlIHNhbWUgYXNwZWN0IHJhdGlvIGFzIHRoZSBpbWFnZSBvdGhlcndpc2UsXG4gICAgLy8gdGhlIGltYWdlIGdldHMgc3RyZXRjaGVkLlxuXG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDAuNjY5LCAxKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgdmVydGV4U2hhZGVyOiB2c2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzaGFkZXJcbiAgICB9KTsgLy8gQ3JlYXRlIG1lc2ggKGdlb20gKyBtYXRlcmlhbClcblxuICAgIHRoaXMucGxhbmUgPSBuZXcgVEhSRUUuTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLnBsYW5lKTtcbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gMTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgfVxuXG4gIG9uUmVzaXplKCkge1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBpZiAoYXNwZWN0UmF0aW8gPj0gMSkge1xuICAgICAgd2lkdGggPSAxO1xuICAgICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC8gd2luZG93LmlubmVyV2lkdGggKiB3aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBhc3BlY3RSYXRpbztcbiAgICAgIGhlaWdodCA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5jYW1lcmEubGVmdCA9IC13aWR0aDtcbiAgICB0aGlzLmNhbWVyYS5yaWdodCA9IHdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnRvcCA9IGhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS5ib3R0b20gPSAtaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnkgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIH1cblxuICBvbk1vdXNlTW92ZShldnQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WCA6IGV2dC5jbGllbnRYO1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS55ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRZIDogZXZ0LmNsaWVudFk7XG4gIH1cblxuICBvblJhZihkZWx0YSkge1xuICAgIHRoaXMudW5pZm9ybXMudV90aW1lLnZhbHVlICs9IHRoaXMucmFmLmdldERlbHRhKHRydWUpO1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdsc2xQbGF5Z3JvdW5kMjA7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/glsl-playground20.js\n");

/***/ }),

/***/ "./examples/glsl-playground21.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground21.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _deguMathf = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/degu-mathf */ \"./lib/shaders/three-shader-chunks/degu-mathf.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//\n// Simple Image Texture.\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739104#questions\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739178#questions\n// https://codepen.io/nik-lever/pen/wvwZwMR\n//\n// Import shader chunks\n(0, _deguMathf.deguMathf)(THREE);\nconst vshader = `\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvoid main() {\n  v_position = position;\n  v_uv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\n#include <deguMathf>\n#define PI 3.14159265359\n\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\nuniform float u_duration;\n\nuniform sampler2D u_texture;\n\nvarying vec3 v_position;\nvarying vec2 v_uv;\n\n\nvoid main (void)\n{\n\n    // Use varying position since center is 0.0 and it goes outwards.\n    // This uses NDC coords.\n    vec2 p = v_position.xy;\n\n    // Create a new uv position called ripple that offset the current\n    // uv by given values.\n    //\n    // The goal is to have an offset uv (ripple) and get the pixel color (texel)\n    // of a different location to make the ripple wave effect.\n    //\n\n    // 1) Calculate radiant.\n    // The amount and direction offset.  A diagnal line that extends from center.\n    // Radian determins the \"intensity\" of the ripple, how much it changes.\n    //\n    // radiant\n    //     \\  |\n    //      \\ |\n    // -------|------\n    //        |\n    //        |\n    float len = length(p);\n    vec2 radiant = p / len * 0.03;\n\n\n    // Get new ripple cords adding v_uv and radian and also cos(u_time) offset.\n    // Now we have an offset coordinates for uv in which we can project texel\n    // colors.\n    // Simplest form of ripple.\n    // vec2 ripple = v_uv + radiant * cos(u_time);\n\n\n    // More complex version that accounts for more ripple.\n    float rippleCount = 20.0;\n    vec2 ripple = v_uv + radiant * cos(len * rippleCount - u_time * 4.0);\n\n\n    // Optional step - delta ripple.\n    // We could add a delta to interpolate back and forth between\n    // normal image and ripple image.\n    //\n    // The delta could also be passed as a uniform.  When delta is,\n    // 1.0, the ripple would be animating and as it goes down to\n    // 0.0, the ripple stops.\n    //\n    // The amount of time remaining in radians.  This is between 0 and 2PI.\n    // float amountOfTimeRemainingInRadians =\n    //     mod(u_time, u_duration) * (2.0 * PI / u_duration);\n    // Using the time remaining in radians, set the delta as a normalizedSin.\n    // float delta = normalizedSin(amountOfTimeRemainingInRadians);\n    // Mix between ripple and non ripple\n    // vec2 uv = mix(ripple, v_uv, delta);\n\n\n    // Optional: Normal continous ripple\n    // If skipping delta, you could just do a continous ripple.\n    // vec2 uv = mix(ripple, v_uv, 0.0);\n    vec2 uv = ripple;\n\n\n\n    vec3 color = texture2D(u_texture, uv).rgb;\n\n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground21 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      // Load a texture.\n      // Ends up being a sampler2D type.\n      u_texture: {\n        value: new THREE.TextureLoader().load('./public/flower.jpg')\n      },\n      u_time: {\n        value: 0.0\n      },\n      u_duration: {\n        value: 0.8\n      },\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // The plane size should be the same aspect ratio as the image otherwise,\n    // the image gets stretched.\n\n    this.geometry = new THREE.PlaneGeometry(0.669, 1);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground21;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQyMS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDIxLmpzP2ZmN2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxudmFyIF9kZWd1TWF0aGYgPSByZXF1aXJlKFwiLi4vbGliL3NoYWRlcnMvdGhyZWUtc2hhZGVyLWNodW5rcy9kZWd1LW1hdGhmXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8vXG4vL1xuLy8gU2ltcGxlIEltYWdlIFRleHR1cmUuXG4vLyBodHRwczovL3d3dy51ZGVteS5jb20vY291cnNlL2xlYXJuLWdsc2wtc2hhZGVycy1mcm9tLXNjcmF0Y2gvbGVhcm4vbGVjdHVyZS8xMzczOTEwNCNxdWVzdGlvbnNcbi8vIGh0dHBzOi8vd3d3LnVkZW15LmNvbS9jb3Vyc2UvbGVhcm4tZ2xzbC1zaGFkZXJzLWZyb20tc2NyYXRjaC9sZWFybi9sZWN0dXJlLzEzNzM5MTc4I3F1ZXN0aW9uc1xuLy8gaHR0cHM6Ly9jb2RlcGVuLmlvL25pay1sZXZlci9wZW4vd3Z3WndNUlxuLy9cbi8vIEltcG9ydCBzaGFkZXIgY2h1bmtzXG4oMCwgX2RlZ3VNYXRoZi5kZWd1TWF0aGYpKFRIUkVFKTtcbmNvbnN0IHZzaGFkZXIgPSBgXG52YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbjtcbnZhcnlpbmcgdmVjMiB2X3V2O1xudm9pZCBtYWluKCkge1xuICB2X3Bvc2l0aW9uID0gcG9zaXRpb247XG4gIHZfdXYgPSB1djtcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xufVxuYDtcbmNvbnN0IGZzaGFkZXIgPSBgXG4jaW5jbHVkZSA8ZGVndU1hdGhmPlxuI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU5XG5cbnVuaWZvcm0gdmVjMiB1X21vdXNlO1xudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gdmVjMyB1X2NvbG9yO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG51bmlmb3JtIGZsb2F0IHVfZHVyYXRpb247XG5cbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTtcblxudmFyeWluZyB2ZWMzIHZfcG9zaXRpb247XG52YXJ5aW5nIHZlYzIgdl91djtcblxuXG52b2lkIG1haW4gKHZvaWQpXG57XG5cbiAgICAvLyBVc2UgdmFyeWluZyBwb3NpdGlvbiBzaW5jZSBjZW50ZXIgaXMgMC4wIGFuZCBpdCBnb2VzIG91dHdhcmRzLlxuICAgIC8vIFRoaXMgdXNlcyBOREMgY29vcmRzLlxuICAgIHZlYzIgcCA9IHZfcG9zaXRpb24ueHk7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgdXYgcG9zaXRpb24gY2FsbGVkIHJpcHBsZSB0aGF0IG9mZnNldCB0aGUgY3VycmVudFxuICAgIC8vIHV2IGJ5IGdpdmVuIHZhbHVlcy5cbiAgICAvL1xuICAgIC8vIFRoZSBnb2FsIGlzIHRvIGhhdmUgYW4gb2Zmc2V0IHV2IChyaXBwbGUpIGFuZCBnZXQgdGhlIHBpeGVsIGNvbG9yICh0ZXhlbClcbiAgICAvLyBvZiBhIGRpZmZlcmVudCBsb2NhdGlvbiB0byBtYWtlIHRoZSByaXBwbGUgd2F2ZSBlZmZlY3QuXG4gICAgLy9cblxuICAgIC8vIDEpIENhbGN1bGF0ZSByYWRpYW50LlxuICAgIC8vIFRoZSBhbW91bnQgYW5kIGRpcmVjdGlvbiBvZmZzZXQuICBBIGRpYWduYWwgbGluZSB0aGF0IGV4dGVuZHMgZnJvbSBjZW50ZXIuXG4gICAgLy8gUmFkaWFuIGRldGVybWlucyB0aGUgXCJpbnRlbnNpdHlcIiBvZiB0aGUgcmlwcGxlLCBob3cgbXVjaCBpdCBjaGFuZ2VzLlxuICAgIC8vXG4gICAgLy8gcmFkaWFudFxuICAgIC8vICAgICBcXCAgfFxuICAgIC8vICAgICAgXFwgfFxuICAgIC8vIC0tLS0tLS18LS0tLS0tXG4gICAgLy8gICAgICAgIHxcbiAgICAvLyAgICAgICAgfFxuICAgIGZsb2F0IGxlbiA9IGxlbmd0aChwKTtcbiAgICB2ZWMyIHJhZGlhbnQgPSBwIC8gbGVuICogMC4wMztcblxuXG4gICAgLy8gR2V0IG5ldyByaXBwbGUgY29yZHMgYWRkaW5nIHZfdXYgYW5kIHJhZGlhbiBhbmQgYWxzbyBjb3ModV90aW1lKSBvZmZzZXQuXG4gICAgLy8gTm93IHdlIGhhdmUgYW4gb2Zmc2V0IGNvb3JkaW5hdGVzIGZvciB1diBpbiB3aGljaCB3ZSBjYW4gcHJvamVjdCB0ZXhlbFxuICAgIC8vIGNvbG9ycy5cbiAgICAvLyBTaW1wbGVzdCBmb3JtIG9mIHJpcHBsZS5cbiAgICAvLyB2ZWMyIHJpcHBsZSA9IHZfdXYgKyByYWRpYW50ICogY29zKHVfdGltZSk7XG5cblxuICAgIC8vIE1vcmUgY29tcGxleCB2ZXJzaW9uIHRoYXQgYWNjb3VudHMgZm9yIG1vcmUgcmlwcGxlLlxuICAgIGZsb2F0IHJpcHBsZUNvdW50ID0gMjAuMDtcbiAgICB2ZWMyIHJpcHBsZSA9IHZfdXYgKyByYWRpYW50ICogY29zKGxlbiAqIHJpcHBsZUNvdW50IC0gdV90aW1lICogNC4wKTtcblxuXG4gICAgLy8gT3B0aW9uYWwgc3RlcCAtIGRlbHRhIHJpcHBsZS5cbiAgICAvLyBXZSBjb3VsZCBhZGQgYSBkZWx0YSB0byBpbnRlcnBvbGF0ZSBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuXG4gICAgLy8gbm9ybWFsIGltYWdlIGFuZCByaXBwbGUgaW1hZ2UuXG4gICAgLy9cbiAgICAvLyBUaGUgZGVsdGEgY291bGQgYWxzbyBiZSBwYXNzZWQgYXMgYSB1bmlmb3JtLiAgV2hlbiBkZWx0YSBpcyxcbiAgICAvLyAxLjAsIHRoZSByaXBwbGUgd291bGQgYmUgYW5pbWF0aW5nIGFuZCBhcyBpdCBnb2VzIGRvd24gdG9cbiAgICAvLyAwLjAsIHRoZSByaXBwbGUgc3RvcHMuXG4gICAgLy9cbiAgICAvLyBUaGUgYW1vdW50IG9mIHRpbWUgcmVtYWluaW5nIGluIHJhZGlhbnMuICBUaGlzIGlzIGJldHdlZW4gMCBhbmQgMlBJLlxuICAgIC8vIGZsb2F0IGFtb3VudE9mVGltZVJlbWFpbmluZ0luUmFkaWFucyA9XG4gICAgLy8gICAgIG1vZCh1X3RpbWUsIHVfZHVyYXRpb24pICogKDIuMCAqIFBJIC8gdV9kdXJhdGlvbik7XG4gICAgLy8gVXNpbmcgdGhlIHRpbWUgcmVtYWluaW5nIGluIHJhZGlhbnMsIHNldCB0aGUgZGVsdGEgYXMgYSBub3JtYWxpemVkU2luLlxuICAgIC8vIGZsb2F0IGRlbHRhID0gbm9ybWFsaXplZFNpbihhbW91bnRPZlRpbWVSZW1haW5pbmdJblJhZGlhbnMpO1xuICAgIC8vIE1peCBiZXR3ZWVuIHJpcHBsZSBhbmQgbm9uIHJpcHBsZVxuICAgIC8vIHZlYzIgdXYgPSBtaXgocmlwcGxlLCB2X3V2LCBkZWx0YSk7XG5cblxuICAgIC8vIE9wdGlvbmFsOiBOb3JtYWwgY29udGlub3VzIHJpcHBsZVxuICAgIC8vIElmIHNraXBwaW5nIGRlbHRhLCB5b3UgY291bGQganVzdCBkbyBhIGNvbnRpbm91cyByaXBwbGUuXG4gICAgLy8gdmVjMiB1diA9IG1peChyaXBwbGUsIHZfdXYsIDAuMCk7XG4gICAgdmVjMiB1diA9IHJpcHBsZTtcblxuXG5cbiAgICB2ZWMzIGNvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdXYpLnJnYjtcblxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuMCk7XG59XG5gO1xuXG5jbGFzcyBHbHNsUGxheWdyb3VuZDIxIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpOyAvLyAyeDJcblxuICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgtMSwgMSwgMSwgLTEsIDAuMSwgMTApO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgdGhpcy5yYWYgPSBuZXcgX3JhZi5SYWYodGhpcy5vblJhZi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIgPSBuZXcgX2RvbVdhdGNoZXIuRG9tV2F0Y2hlcigpO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdyZXNpemUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25SZXNpemUuYmluZCh0aGlzKSxcbiAgICAgIGV2ZW50T3B0aW9uczoge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ21vdXNlbW92ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgIC8vIExvYWQgYSB0ZXh0dXJlLlxuICAgICAgLy8gRW5kcyB1cCBiZWluZyBhIHNhbXBsZXIyRCB0eXBlLlxuICAgICAgdV90ZXh0dXJlOiB7XG4gICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoJy4vcHVibGljL2Zsb3dlci5qcGcnKVxuICAgICAgfSxcbiAgICAgIHVfdGltZToge1xuICAgICAgICB2YWx1ZTogMC4wXG4gICAgICB9LFxuICAgICAgdV9kdXJhdGlvbjoge1xuICAgICAgICB2YWx1ZTogMC44XG4gICAgICB9LFxuICAgICAgdV9tb3VzZToge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAuMCxcbiAgICAgICAgICB5OiAwLjBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVfcmVzb2x1dGlvbjoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgLy8gVGhlIHBsYW5lIHNpemUgc2hvdWxkIGJlIHRoZSBzYW1lIGFzcGVjdCByYXRpbyBhcyB0aGUgaW1hZ2Ugb3RoZXJ3aXNlLFxuICAgIC8vIHRoZSBpbWFnZSBnZXRzIHN0cmV0Y2hlZC5cblxuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSgwLjY2OSwgMSk7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG4gICAgICB1bmlmb3JtczogdGhpcy51bmlmb3JtcyxcbiAgICAgIHZlcnRleFNoYWRlcjogdnNoYWRlcixcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBmc2hhZGVyXG4gICAgfSk7IC8vIENyZWF0ZSBtZXNoIChnZW9tICsgbWF0ZXJpYWwpXG5cbiAgICB0aGlzLnBsYW5lID0gbmV3IFRIUkVFLk1lc2godGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5wbGFuZSk7XG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiA9IDE7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgIHRoaXMucmFmLnN0YXJ0KCk7XG4gIH1cblxuICBvblJlc2l6ZSgpIHtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgaWYgKGFzcGVjdFJhdGlvID49IDEpIHtcbiAgICAgIHdpZHRoID0gMTtcbiAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAvIHdpbmRvdy5pbm5lcldpZHRoICogd2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gYXNwZWN0UmF0aW87XG4gICAgICBoZWlnaHQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuY2FtZXJhLmxlZnQgPSAtd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEucmlnaHQgPSB3aWR0aDtcbiAgICB0aGlzLmNhbWVyYS50b3AgPSBoZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEuYm90dG9tID0gLWhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS55ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZXZ0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnggPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFggOiBldnQuY2xpZW50WDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueSA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WSA6IGV2dC5jbGllbnRZO1xuICB9XG5cbiAgb25SYWYoZGVsdGEpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfdGltZS52YWx1ZSArPSB0aGlzLnJhZi5nZXREZWx0YSh0cnVlKTtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBHbHNsUGxheWdyb3VuZDIxOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/glsl-playground21.js\n");

/***/ }),

/***/ "./examples/glsl-playground22.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground22.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _deguMathf = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/degu-mathf */ \"./lib/shaders/three-shader-chunks/degu-mathf.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//\n// Simple Image Texture.\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739104#questions\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739178#questions\n// https://codepen.io/nik-lever/pen/wvwZwMR\n// https://codepen.io/nik-lever/pen/PVMQbP\n//\n// Import shader chunks\n(0, _deguMathf.deguMathf)(THREE);\nconst vshader = `\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvoid main() {\n  v_position = position;\n  v_uv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\n#include <deguMathf>\n#define PI 3.14159265359\n\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\nuniform float u_duration;\n\nuniform sampler2D u_texture1;\nuniform sampler2D u_texture2;\n\nvarying vec3 v_position;\nvarying vec2 v_uv;\n\n\nvoid main (void)\n{\n\n    // Use varying position since center is 0.0 and it goes outwards.\n    // This uses NDC coords.\n    // vec2 p = v_position.xy;\n    vec2 p = -1.0 + 2.0 * v_uv;\n\n    // LEN\n    //        |   /\n    //        |  /\n    // -------|------\n    //        |\n    //        |\n    float len = length(p);\n    // Intensity.\n    vec2 radiant = p / len * 0.02;\n    float rippleCount = 30.0;\n    vec2 ripple = v_uv + radiant * cos(len * rippleCount - u_time * 4.0);\n\n\n    // The time. 1.0 if the animation is complete.\n    float progress = u_time / u_duration;\n    // Mix between ripple and non ripple to get UV coords to map final texel.\n    vec2 uv = mix(ripple, v_uv, progress);\n\n    // Get texel at uv for the pic 1 and pic 2.\n    vec3 color1 = texture2D(u_texture1, uv).rgb;\n    vec3 color2 = texture2D(u_texture2, uv).rgb;\n\n    // Simple cross fade.\n    // vec3 color = mix(color1, color2, progress);\n\n    // Optional:\n    // Blend between 0.14 - 0.25 edge around progress.\n    // Creates a circular wipe.\n    // https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739182#questions\n    float fade = smoothstep(progress * 1.4, progress * 2.5, len);\n\n    // Mix it\n    vec3 color = mix(color2, color1, fade);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground21 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      // Load a texture.\n      // Ends up being a sampler2D type.\n      u_texture1: {\n        value: null\n      },\n      u_texture2: {\n        value: null\n      },\n      u_time: {\n        value: 0.0\n      },\n      u_duration: {\n        value: 2.0\n      },\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // The plane size should be the same aspect ratio as the image otherwise,\n    // the image gets stretched.\n\n    this.geometry = new THREE.PlaneGeometry(0.669, 1);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n    this.slideIndex = 0;\n    this.textures = [new THREE.TextureLoader().load('./public/random.jpg'), new THREE.TextureLoader().load('./public/random2.jpg'), new THREE.TextureLoader().load('./public/random3.jpg')]; // Fake a slideshow for now.\n\n    setInterval(() => {\n      this.slideIndex++;\n      this.displayIndex();\n    }, 3000);\n    this.displayIndex();\n  }\n\n  displayIndex() {\n    // Reset the time value.\n    this.uniforms.u_time.value = 0;\n    this.uniforms.u_texture1.value = this.textures[this.slideIndex];\n    this.uniforms.u_texture2.value = this.textures[this.slideIndex + 1];\n\n    if (this.slideIndex >= this.textures.length - 1) {\n      this.uniforms.u_texture1.value = this.textures[this.slideIndex];\n      this.uniforms.u_texture2.value = this.textures[0];\n      this.slideIndex = -1;\n    }\n\n    console.log(this.slideIndex);\n    console.log(this.uniforms.u_texture1.value);\n    console.log(this.uniforms.u_texture2.value);\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf() {\n    const delta = this.raf.getDelta(true);\n\n    if (this.uniforms.u_time.value < this.uniforms.u_duration.value) {\n      this.uniforms.u_time.value += delta;\n    } else {\n      this.uniforms.u_time.value = this.uniforms.u_duration.value;\n    }\n\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground21;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQyMi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDIyLmpzPzdmMjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxudmFyIF9kZWd1TWF0aGYgPSByZXF1aXJlKFwiLi4vbGliL3NoYWRlcnMvdGhyZWUtc2hhZGVyLWNodW5rcy9kZWd1LW1hdGhmXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8vXG4vL1xuLy8gU2ltcGxlIEltYWdlIFRleHR1cmUuXG4vLyBodHRwczovL3d3dy51ZGVteS5jb20vY291cnNlL2xlYXJuLWdsc2wtc2hhZGVycy1mcm9tLXNjcmF0Y2gvbGVhcm4vbGVjdHVyZS8xMzczOTEwNCNxdWVzdGlvbnNcbi8vIGh0dHBzOi8vd3d3LnVkZW15LmNvbS9jb3Vyc2UvbGVhcm4tZ2xzbC1zaGFkZXJzLWZyb20tc2NyYXRjaC9sZWFybi9sZWN0dXJlLzEzNzM5MTc4I3F1ZXN0aW9uc1xuLy8gaHR0cHM6Ly9jb2RlcGVuLmlvL25pay1sZXZlci9wZW4vd3Z3WndNUlxuLy8gaHR0cHM6Ly9jb2RlcGVuLmlvL25pay1sZXZlci9wZW4vUFZNUWJQXG4vL1xuLy8gSW1wb3J0IHNoYWRlciBjaHVua3NcbigwLCBfZGVndU1hdGhmLmRlZ3VNYXRoZikoVEhSRUUpO1xuY29uc3QgdnNoYWRlciA9IGBcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xudmFyeWluZyB2ZWMyIHZfdXY7XG52b2lkIG1haW4oKSB7XG4gIHZfcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdl91diA9IHV2O1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbiNpbmNsdWRlIDxkZWd1TWF0aGY+XG4jZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTlcblxudW5pZm9ybSB2ZWMyIHVfbW91c2U7XG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xudW5pZm9ybSB2ZWMzIHVfY29sb3I7XG51bmlmb3JtIGZsb2F0IHVfdGltZTtcbnVuaWZvcm0gZmxvYXQgdV9kdXJhdGlvbjtcblxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlMTtcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTI7XG5cbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xudmFyeWluZyB2ZWMyIHZfdXY7XG5cblxudm9pZCBtYWluICh2b2lkKVxue1xuXG4gICAgLy8gVXNlIHZhcnlpbmcgcG9zaXRpb24gc2luY2UgY2VudGVyIGlzIDAuMCBhbmQgaXQgZ29lcyBvdXR3YXJkcy5cbiAgICAvLyBUaGlzIHVzZXMgTkRDIGNvb3Jkcy5cbiAgICAvLyB2ZWMyIHAgPSB2X3Bvc2l0aW9uLnh5O1xuICAgIHZlYzIgcCA9IC0xLjAgKyAyLjAgKiB2X3V2O1xuXG4gICAgLy8gTEVOXG4gICAgLy8gICAgICAgIHwgICAvXG4gICAgLy8gICAgICAgIHwgIC9cbiAgICAvLyAtLS0tLS0tfC0tLS0tLVxuICAgIC8vICAgICAgICB8XG4gICAgLy8gICAgICAgIHxcbiAgICBmbG9hdCBsZW4gPSBsZW5ndGgocCk7XG4gICAgLy8gSW50ZW5zaXR5LlxuICAgIHZlYzIgcmFkaWFudCA9IHAgLyBsZW4gKiAwLjAyO1xuICAgIGZsb2F0IHJpcHBsZUNvdW50ID0gMzAuMDtcbiAgICB2ZWMyIHJpcHBsZSA9IHZfdXYgKyByYWRpYW50ICogY29zKGxlbiAqIHJpcHBsZUNvdW50IC0gdV90aW1lICogNC4wKTtcblxuXG4gICAgLy8gVGhlIHRpbWUuIDEuMCBpZiB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLlxuICAgIGZsb2F0IHByb2dyZXNzID0gdV90aW1lIC8gdV9kdXJhdGlvbjtcbiAgICAvLyBNaXggYmV0d2VlbiByaXBwbGUgYW5kIG5vbiByaXBwbGUgdG8gZ2V0IFVWIGNvb3JkcyB0byBtYXAgZmluYWwgdGV4ZWwuXG4gICAgdmVjMiB1diA9IG1peChyaXBwbGUsIHZfdXYsIHByb2dyZXNzKTtcblxuICAgIC8vIEdldCB0ZXhlbCBhdCB1diBmb3IgdGhlIHBpYyAxIGFuZCBwaWMgMi5cbiAgICB2ZWMzIGNvbG9yMSA9IHRleHR1cmUyRCh1X3RleHR1cmUxLCB1dikucmdiO1xuICAgIHZlYzMgY29sb3IyID0gdGV4dHVyZTJEKHVfdGV4dHVyZTIsIHV2KS5yZ2I7XG5cbiAgICAvLyBTaW1wbGUgY3Jvc3MgZmFkZS5cbiAgICAvLyB2ZWMzIGNvbG9yID0gbWl4KGNvbG9yMSwgY29sb3IyLCBwcm9ncmVzcyk7XG5cbiAgICAvLyBPcHRpb25hbDpcbiAgICAvLyBCbGVuZCBiZXR3ZWVuIDAuMTQgLSAwLjI1IGVkZ2UgYXJvdW5kIHByb2dyZXNzLlxuICAgIC8vIENyZWF0ZXMgYSBjaXJjdWxhciB3aXBlLlxuICAgIC8vIGh0dHBzOi8vd3d3LnVkZW15LmNvbS9jb3Vyc2UvbGVhcm4tZ2xzbC1zaGFkZXJzLWZyb20tc2NyYXRjaC9sZWFybi9sZWN0dXJlLzEzNzM5MTgyI3F1ZXN0aW9uc1xuICAgIGZsb2F0IGZhZGUgPSBzbW9vdGhzdGVwKHByb2dyZXNzICogMS40LCBwcm9ncmVzcyAqIDIuNSwgbGVuKTtcblxuICAgIC8vIE1peCBpdFxuICAgIHZlYzMgY29sb3IgPSBtaXgoY29sb3IyLCBjb2xvcjEsIGZhZGUpO1xuXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcbn1cbmA7XG5cbmNsYXNzIEdsc2xQbGF5Z3JvdW5kMjEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vIDJ4MlxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMC4xLCAxMCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgLy8gTG9hZCBhIHRleHR1cmUuXG4gICAgICAvLyBFbmRzIHVwIGJlaW5nIGEgc2FtcGxlcjJEIHR5cGUuXG4gICAgICB1X3RleHR1cmUxOiB7XG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9LFxuICAgICAgdV90ZXh0dXJlMjoge1xuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSxcbiAgICAgIHVfdGltZToge1xuICAgICAgICB2YWx1ZTogMC4wXG4gICAgICB9LFxuICAgICAgdV9kdXJhdGlvbjoge1xuICAgICAgICB2YWx1ZTogMi4wXG4gICAgICB9LFxuICAgICAgdV9tb3VzZToge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAuMCxcbiAgICAgICAgICB5OiAwLjBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVfcmVzb2x1dGlvbjoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgLy8gVGhlIHBsYW5lIHNpemUgc2hvdWxkIGJlIHRoZSBzYW1lIGFzcGVjdCByYXRpbyBhcyB0aGUgaW1hZ2Ugb3RoZXJ3aXNlLFxuICAgIC8vIHRoZSBpbWFnZSBnZXRzIHN0cmV0Y2hlZC5cblxuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSgwLjY2OSwgMSk7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG4gICAgICB1bmlmb3JtczogdGhpcy51bmlmb3JtcyxcbiAgICAgIHZlcnRleFNoYWRlcjogdnNoYWRlcixcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBmc2hhZGVyXG4gICAgfSk7IC8vIENyZWF0ZSBtZXNoIChnZW9tICsgbWF0ZXJpYWwpXG5cbiAgICB0aGlzLnBsYW5lID0gbmV3IFRIUkVFLk1lc2godGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5wbGFuZSk7XG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiA9IDE7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgIHRoaXMucmFmLnN0YXJ0KCk7XG4gICAgdGhpcy5zbGlkZUluZGV4ID0gMDtcbiAgICB0aGlzLnRleHR1cmVzID0gW25ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnLi9wdWJsaWMvcmFuZG9tLmpwZycpLCBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoJy4vcHVibGljL3JhbmRvbTIuanBnJyksIG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnLi9wdWJsaWMvcmFuZG9tMy5qcGcnKV07IC8vIEZha2UgYSBzbGlkZXNob3cgZm9yIG5vdy5cblxuICAgIHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMuc2xpZGVJbmRleCsrO1xuICAgICAgdGhpcy5kaXNwbGF5SW5kZXgoKTtcbiAgICB9LCAzMDAwKTtcbiAgICB0aGlzLmRpc3BsYXlJbmRleCgpO1xuICB9XG5cbiAgZGlzcGxheUluZGV4KCkge1xuICAgIC8vIFJlc2V0IHRoZSB0aW1lIHZhbHVlLlxuICAgIHRoaXMudW5pZm9ybXMudV90aW1lLnZhbHVlID0gMDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfdGV4dHVyZTEudmFsdWUgPSB0aGlzLnRleHR1cmVzW3RoaXMuc2xpZGVJbmRleF07XG4gICAgdGhpcy51bmlmb3Jtcy51X3RleHR1cmUyLnZhbHVlID0gdGhpcy50ZXh0dXJlc1t0aGlzLnNsaWRlSW5kZXggKyAxXTtcblxuICAgIGlmICh0aGlzLnNsaWRlSW5kZXggPj0gdGhpcy50ZXh0dXJlcy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLnVfdGV4dHVyZTEudmFsdWUgPSB0aGlzLnRleHR1cmVzW3RoaXMuc2xpZGVJbmRleF07XG4gICAgICB0aGlzLnVuaWZvcm1zLnVfdGV4dHVyZTIudmFsdWUgPSB0aGlzLnRleHR1cmVzWzBdO1xuICAgICAgdGhpcy5zbGlkZUluZGV4ID0gLTE7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2codGhpcy5zbGlkZUluZGV4KTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnVuaWZvcm1zLnVfdGV4dHVyZTEudmFsdWUpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMudW5pZm9ybXMudV90ZXh0dXJlMi52YWx1ZSk7XG4gIH1cblxuICBvblJlc2l6ZSgpIHtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgaWYgKGFzcGVjdFJhdGlvID49IDEpIHtcbiAgICAgIHdpZHRoID0gMTtcbiAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAvIHdpbmRvdy5pbm5lcldpZHRoICogd2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gYXNwZWN0UmF0aW87XG4gICAgICBoZWlnaHQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuY2FtZXJhLmxlZnQgPSAtd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEucmlnaHQgPSB3aWR0aDtcbiAgICB0aGlzLmNhbWVyYS50b3AgPSBoZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEuYm90dG9tID0gLWhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS55ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZXZ0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnggPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFggOiBldnQuY2xpZW50WDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueSA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WSA6IGV2dC5jbGllbnRZO1xuICB9XG5cbiAgb25SYWYoKSB7XG4gICAgY29uc3QgZGVsdGEgPSB0aGlzLnJhZi5nZXREZWx0YSh0cnVlKTtcblxuICAgIGlmICh0aGlzLnVuaWZvcm1zLnVfdGltZS52YWx1ZSA8IHRoaXMudW5pZm9ybXMudV9kdXJhdGlvbi52YWx1ZSkge1xuICAgICAgdGhpcy51bmlmb3Jtcy51X3RpbWUudmFsdWUgKz0gZGVsdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5pZm9ybXMudV90aW1lLnZhbHVlID0gdGhpcy51bmlmb3Jtcy51X2R1cmF0aW9uLnZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdsc2xQbGF5Z3JvdW5kMjE7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/glsl-playground22.js\n");

/***/ }),

/***/ "./examples/glsl-playground23.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground23.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _deguMathf = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/degu-mathf */ \"./lib/shaders/three-shader-chunks/degu-mathf.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//\n// Simple Image Texture.\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739104#questions\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739178#questions\n// https://codepen.io/nik-lever/pen/ZwgrRR\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739190#questions/8753186\n// https://codepen.io/nik-lever/pen/PVMRXa\n//\n// Import shader chunks\n(0, _deguMathf.deguMathf)(THREE);\n/**\n * Class that creates canvas text in three.js.\n * Thanks to Nik Lever.\n */\n\nclass CanvasText {\n  constructor(scene, msg, config, material) {\n    this.config = config === undefined ? {\n      font: 'sans',\n      size: 30,\n      h1size: 50,\n      padding: 10,\n      colour: '#fff',\n      width: 256,\n      height: 256\n    } : config;\n    const planeMaterial = material === undefined ? new THREE.MeshBasicMaterial({\n      transparent: true\n    }) : material;\n    this.planesize = config.planesize ? config.planesize : {\n      width: 0.5,\n      height: 0.5\n    };\n    const planeGeometry = new THREE.PlaneGeometry(this.planesize.width, this.planesize.height);\n    this.mesh = new THREE.Mesh(planeGeometry, planeMaterial);\n    if (this.config.zpos) this.mesh.position.z = this.config.zpos;\n    scene.add(this.mesh);\n    this.update(msg);\n  }\n\n  update(msg) {\n    if (this.mesh === undefined) return;\n    let context = this.context;\n\n    if (context === undefined) {\n      const canvas = this.createOffscreenCanvas(this.config.width, this.config.height);\n      this.context = canvas.getContext('2d');\n      context = this.context;\n      context.font = `${this.config.size}pt ${this.config.font}`;\n      context.fillStyle = this.config.colour;\n      context.textAlign = 'center';\n      this.texture = new THREE.CanvasTexture(canvas);\n\n      if (this.mesh.material.uniforms !== undefined) {\n        this.mesh.material.uniforms.u_tex = {\n          value: this.texture\n        };\n      } else {\n        this.mesh.material.map = this.texture;\n      }\n    }\n\n    const bg = this.img;\n    context.clearRect(0, 0, this.config.width, this.config.height);\n\n    if (this.config.debug) {\n      context.beginPath();\n      context.rect(0, 0, this.config.width, this.config.height);\n      context.stroke();\n    }\n\n    this.wrapText(msg, context);\n    this.texture.needsUpdate = true;\n  }\n\n  createOffscreenCanvas(w, h) {\n    const canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h;\n    return canvas;\n  }\n\n  wrapText(msg, context) {\n    const words = msg.text.split(' ');\n    let line = '';\n    const lines = [];\n    const maxWidth = this.config.width - 2 * this.config.padding;\n    const lineHeight = this.config.size + 8;\n    context.font = `${this.config.size}pt ${this.config.font}`;\n    words.forEach(function (word) {\n      const testLine = `${line}${word} `;\n      const metrics = context.measureText(testLine);\n      const testWidth = metrics.width;\n\n      if (testWidth > maxWidth) {\n        lines.push(line);\n        line = `${word} `;\n      } else {\n        line = testLine;\n      }\n    });\n    if (line != '') lines.push(line);\n    let y = this.config.height - lines.length * lineHeight;\n    const centerX = this.config.width / 2;\n    lines.forEach(function (line) {\n      context.fillText(line, centerX, y);\n      y += lineHeight;\n    });\n    y = this.config.height - (lines.length + 1.5) * lineHeight;\n    context.font = `${this.config.h1size}pt ${this.config.font}`;\n    context.fillText(msg.name, centerX, y);\n  }\n\n  positionText(camera, pos) {\n    if (!this.planesize) return;\n\n    if (pos.bottom !== undefined) {\n      this.mesh.position.y = pos.bottom + this.planesize.height / 2 + camera.bottom;\n    } else if (pos.top !== undefined) {\n      this.mesh.position.y = camera.top - pos.top - this.planesize.height / 2;\n    } else {\n      this.mesh.position.y = 0;\n    }\n\n    if (pos.left !== undefined) {\n      this.mesh.position.x = pos.left + this.planesize.width / 2 + camera.left;\n    } else if (pos.right !== undefined) {\n      this.mesh.position.x = camera.right - pos.right - this.planesize.width / 2;\n    } else {\n      this.mesh.position.x = 0;\n    }\n  }\n\n}\n\nconst vshader = `\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvoid main() {\n  v_position = position;\n  v_uv = uv;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\n#include <deguMathf>\n#define PI 3.14159265359\n\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\nuniform float u_duration;\n\nuniform sampler2D u_texture1;\nuniform sampler2D u_texture2;\n\nvarying vec3 v_position;\nvarying vec2 v_uv;\n\n\nvoid main (void)\n{\n    // vec2 p = v_position.xy;\n    vec2 p = -1.0 + 2.0 * v_uv;\n\n    float len = length(p);\n    vec2 radiant = p / len * 0.02;\n    float rippleCount = 30.0;\n    vec2 ripple = v_uv + radiant * cos(len * rippleCount - u_time * 4.0);\n    float progress = u_time / u_duration;\n    vec2 uv = mix(ripple, v_uv, progress);\n\n    vec3 color1 = texture2D(u_texture1, uv).rgb;\n    vec3 color2 = texture2D(u_texture2, uv).rgb;\n    float fade = smoothstep(progress * 1.4, progress * 2.5, len);\n\n    // Mix it\n    vec3 color = mix(color2, color1, fade);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n`; // Version to just display text\n\nconst textFragShader = `\n#include <deguMathf>\n#define PI 3.14159265359\n\nuniform float u_time;\nuniform float u_duration;\nuniform sampler2D u_tex;\n\nvarying vec3 v_position;\nvarying vec2 v_uv;\n\nvoid main (void)\n{\n    gl_FragColor = texture2D(u_tex, v_uv);\n}\n`; // Twirling text version.\n\nconst textFragShader2 = `\n  uniform sampler2D u_tex;\n  uniform float u_time;\n  uniform float u_duration;\n  uniform float u_twirls;\n\n  varying vec2 v_uv;\n\n  vec4 twirl(sampler2D tex, vec2 uv, float time){\n    if (time<0.0) time = 0.0;\n\n    vec2 center = vec2(0.5);\n    vec2 tc = uv - center;\n    float dist = length(tc);\n\n    if (dist < 0.5){\n      float delta = (0.5 - dist) / 0.5;\n      float theta = delta * delta * time * u_twirls;\n      float s = sin(theta);\n      float c = cos(theta);\n      mat2 mat = mat2(c,s,-s,c);\n      tc = mat * tc;\n      //tc = vec2(dot(tc, vec2(c, -s)), dot(tc, vec2(s, c)));\n    }\n\n    tc += center;\n    vec4 color = texture2D(tex, tc);\n    color.a = mix(0.0, color.a, min(u_time, 1.0));\n    return color;\n  }\n\n  void main(void){\n    gl_FragColor = twirl(u_tex, v_uv, u_duration - u_time);\n  }\n`;\n\nclass GlslPlayground23 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      // Load a texture.\n      // Ends up being a sampler2D type.\n      u_texture1: {\n        value: null\n      },\n      u_texture2: {\n        value: null\n      },\n      u_time: {\n        value: 0.0\n      },\n      u_duration: {\n        value: 2.0\n      },\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // The plane size should be the same aspect ratio as the image otherwise,\n    // the image gets stretched.\n\n    this.geometry = new THREE.PlaneGeometry(0.669, 1);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane); // Text for slides.\n\n    this.text = [{\n      name: \"test1\",\n      text: \"This is the first text\"\n    }, {\n      name: \"test2\",\n      text: \"This is the second text\"\n    }, {\n      name: \"test3\",\n      text: \"This is the third text\"\n    }]; // Add a second plane to hold the text.\n\n    this.uniforms2 = {\n      u_time: {\n        value: 0.0\n      },\n      u_duration: {\n        value: 0.7\n      },\n      u_twirls: {\n        value: 4\n      }\n    };\n    this.material2 = new THREE.ShaderMaterial({\n      uniforms: this.uniforms2,\n      vertexShader: vshader,\n      // Normal text\n      // fragmentShader: textFragShader,\n      fragmentShader: textFragShader2,\n      transparent: true\n    });\n    const config = {\n      font: 'Josefin Sans',\n      size: 16,\n      h1size: 30,\n      padding: 10,\n      colour: '#fff',\n      width: 512,\n      height: 256,\n      zpos: 0.005,\n      planesize: {\n        width: 1,\n        height: 0.5\n      }\n    };\n    this.canvasText = new CanvasText(this.scene, this.text[1], config, this.material2);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n    this.slideIndex = 0;\n    this.textures = [new THREE.TextureLoader().load('./public/random.jpg'), new THREE.TextureLoader().load('./public/random2.jpg'), new THREE.TextureLoader().load('./public/random3.jpg')]; // Fake a slideshow for now.\n\n    setInterval(() => {\n      this.slideIndex++;\n      this.displayIndex();\n    }, 3000);\n    this.displayIndex();\n  }\n\n  displayIndex() {\n    // Reset the time value.\n    this.uniforms.u_time.value = 0;\n    this.uniforms2.u_time.value = 0;\n    this.canvasText.update(this.text[this.slideIndex]);\n    this.uniforms.u_texture1.value = this.textures[this.slideIndex];\n    this.uniforms.u_texture2.value = this.textures[this.slideIndex + 1];\n\n    if (this.slideIndex >= this.textures.length - 1) {\n      this.uniforms.u_texture1.value = this.textures[this.slideIndex];\n      this.uniforms.u_texture2.value = this.textures[0];\n      this.slideIndex = -1;\n    }\n\n    console.log(this.slideIndex);\n    console.log(this.uniforms.u_texture1.value);\n    console.log(this.uniforms.u_texture2.value);\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n    this.canvasText.positionText(this.camera, {\n      bottom: 0.1\n    });\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf() {\n    const delta = this.raf.getDelta(true);\n\n    if (this.uniforms.u_time.value < this.uniforms.u_duration.value) {\n      this.uniforms.u_time.value += delta;\n      this.uniforms2.u_time.value += delta;\n    } else {\n      this.uniforms.u_time.value = this.uniforms.u_duration.value;\n      this.uniforms2.u_time.value = this.uniforms2.u_duration.value;\n    }\n\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground23;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQyMy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDIzLmpzPzQ0MjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxudmFyIF9kZWd1TWF0aGYgPSByZXF1aXJlKFwiLi4vbGliL3NoYWRlcnMvdGhyZWUtc2hhZGVyLWNodW5rcy9kZWd1LW1hdGhmXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8vXG4vL1xuLy8gU2ltcGxlIEltYWdlIFRleHR1cmUuXG4vLyBodHRwczovL3d3dy51ZGVteS5jb20vY291cnNlL2xlYXJuLWdsc2wtc2hhZGVycy1mcm9tLXNjcmF0Y2gvbGVhcm4vbGVjdHVyZS8xMzczOTEwNCNxdWVzdGlvbnNcbi8vIGh0dHBzOi8vd3d3LnVkZW15LmNvbS9jb3Vyc2UvbGVhcm4tZ2xzbC1zaGFkZXJzLWZyb20tc2NyYXRjaC9sZWFybi9sZWN0dXJlLzEzNzM5MTc4I3F1ZXN0aW9uc1xuLy8gaHR0cHM6Ly9jb2RlcGVuLmlvL25pay1sZXZlci9wZW4vWndnclJSXG4vLyBodHRwczovL3d3dy51ZGVteS5jb20vY291cnNlL2xlYXJuLWdsc2wtc2hhZGVycy1mcm9tLXNjcmF0Y2gvbGVhcm4vbGVjdHVyZS8xMzczOTE5MCNxdWVzdGlvbnMvODc1MzE4NlxuLy8gaHR0cHM6Ly9jb2RlcGVuLmlvL25pay1sZXZlci9wZW4vUFZNUlhhXG4vL1xuLy8gSW1wb3J0IHNoYWRlciBjaHVua3NcbigwLCBfZGVndU1hdGhmLmRlZ3VNYXRoZikoVEhSRUUpO1xuLyoqXG4gKiBDbGFzcyB0aGF0IGNyZWF0ZXMgY2FudmFzIHRleHQgaW4gdGhyZWUuanMuXG4gKiBUaGFua3MgdG8gTmlrIExldmVyLlxuICovXG5cbmNsYXNzIENhbnZhc1RleHQge1xuICBjb25zdHJ1Y3RvcihzY2VuZSwgbXNnLCBjb25maWcsIG1hdGVyaWFsKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWcgPT09IHVuZGVmaW5lZCA/IHtcbiAgICAgIGZvbnQ6ICdzYW5zJyxcbiAgICAgIHNpemU6IDMwLFxuICAgICAgaDFzaXplOiA1MCxcbiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgY29sb3VyOiAnI2ZmZicsXG4gICAgICB3aWR0aDogMjU2LFxuICAgICAgaGVpZ2h0OiAyNTZcbiAgICB9IDogY29uZmlnO1xuICAgIGNvbnN0IHBsYW5lTWF0ZXJpYWwgPSBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkID8gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlXG4gICAgfSkgOiBtYXRlcmlhbDtcbiAgICB0aGlzLnBsYW5lc2l6ZSA9IGNvbmZpZy5wbGFuZXNpemUgPyBjb25maWcucGxhbmVzaXplIDoge1xuICAgICAgd2lkdGg6IDAuNSxcbiAgICAgIGhlaWdodDogMC41XG4gICAgfTtcbiAgICBjb25zdCBwbGFuZUdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkodGhpcy5wbGFuZXNpemUud2lkdGgsIHRoaXMucGxhbmVzaXplLmhlaWdodCk7XG4gICAgdGhpcy5tZXNoID0gbmV3IFRIUkVFLk1lc2gocGxhbmVHZW9tZXRyeSwgcGxhbmVNYXRlcmlhbCk7XG4gICAgaWYgKHRoaXMuY29uZmlnLnpwb3MpIHRoaXMubWVzaC5wb3NpdGlvbi56ID0gdGhpcy5jb25maWcuenBvcztcbiAgICBzY2VuZS5hZGQodGhpcy5tZXNoKTtcbiAgICB0aGlzLnVwZGF0ZShtc2cpO1xuICB9XG5cbiAgdXBkYXRlKG1zZykge1xuICAgIGlmICh0aGlzLm1lc2ggPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGxldCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jcmVhdGVPZmZzY3JlZW5DYW52YXModGhpcy5jb25maWcud2lkdGgsIHRoaXMuY29uZmlnLmhlaWdodCk7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICBjb250ZXh0LmZvbnQgPSBgJHt0aGlzLmNvbmZpZy5zaXplfXB0ICR7dGhpcy5jb25maWcuZm9udH1gO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmNvbmZpZy5jb2xvdXI7XG4gICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdGhpcy50ZXh0dXJlID0gbmV3IFRIUkVFLkNhbnZhc1RleHR1cmUoY2FudmFzKTtcblxuICAgICAgaWYgKHRoaXMubWVzaC5tYXRlcmlhbC51bmlmb3JtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubWVzaC5tYXRlcmlhbC51bmlmb3Jtcy51X3RleCA9IHtcbiAgICAgICAgICB2YWx1ZTogdGhpcy50ZXh0dXJlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1lc2gubWF0ZXJpYWwubWFwID0gdGhpcy50ZXh0dXJlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJnID0gdGhpcy5pbWc7XG4gICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jb25maWcud2lkdGgsIHRoaXMuY29uZmlnLmhlaWdodCk7XG5cbiAgICBpZiAodGhpcy5jb25maWcuZGVidWcpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LnJlY3QoMCwgMCwgdGhpcy5jb25maWcud2lkdGgsIHRoaXMuY29uZmlnLmhlaWdodCk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIHRoaXMud3JhcFRleHQobXNnLCBjb250ZXh0KTtcbiAgICB0aGlzLnRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgY3JlYXRlT2Zmc2NyZWVuQ2FudmFzKHcsIGgpIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSB3O1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoO1xuICAgIHJldHVybiBjYW52YXM7XG4gIH1cblxuICB3cmFwVGV4dChtc2csIGNvbnRleHQpIHtcbiAgICBjb25zdCB3b3JkcyA9IG1zZy50ZXh0LnNwbGl0KCcgJyk7XG4gICAgbGV0IGxpbmUgPSAnJztcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIGNvbnN0IG1heFdpZHRoID0gdGhpcy5jb25maWcud2lkdGggLSAyICogdGhpcy5jb25maWcucGFkZGluZztcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gdGhpcy5jb25maWcuc2l6ZSArIDg7XG4gICAgY29udGV4dC5mb250ID0gYCR7dGhpcy5jb25maWcuc2l6ZX1wdCAke3RoaXMuY29uZmlnLmZvbnR9YDtcbiAgICB3b3Jkcy5mb3JFYWNoKGZ1bmN0aW9uICh3b3JkKSB7XG4gICAgICBjb25zdCB0ZXN0TGluZSA9IGAke2xpbmV9JHt3b3JkfSBgO1xuICAgICAgY29uc3QgbWV0cmljcyA9IGNvbnRleHQubWVhc3VyZVRleHQodGVzdExpbmUpO1xuICAgICAgY29uc3QgdGVzdFdpZHRoID0gbWV0cmljcy53aWR0aDtcblxuICAgICAgaWYgKHRlc3RXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIGxpbmUgPSBgJHt3b3JkfSBgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZSA9IHRlc3RMaW5lO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChsaW5lICE9ICcnKSBsaW5lcy5wdXNoKGxpbmUpO1xuICAgIGxldCB5ID0gdGhpcy5jb25maWcuaGVpZ2h0IC0gbGluZXMubGVuZ3RoICogbGluZUhlaWdodDtcbiAgICBjb25zdCBjZW50ZXJYID0gdGhpcy5jb25maWcud2lkdGggLyAyO1xuICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGNvbnRleHQuZmlsbFRleHQobGluZSwgY2VudGVyWCwgeSk7XG4gICAgICB5ICs9IGxpbmVIZWlnaHQ7XG4gICAgfSk7XG4gICAgeSA9IHRoaXMuY29uZmlnLmhlaWdodCAtIChsaW5lcy5sZW5ndGggKyAxLjUpICogbGluZUhlaWdodDtcbiAgICBjb250ZXh0LmZvbnQgPSBgJHt0aGlzLmNvbmZpZy5oMXNpemV9cHQgJHt0aGlzLmNvbmZpZy5mb250fWA7XG4gICAgY29udGV4dC5maWxsVGV4dChtc2cubmFtZSwgY2VudGVyWCwgeSk7XG4gIH1cblxuICBwb3NpdGlvblRleHQoY2FtZXJhLCBwb3MpIHtcbiAgICBpZiAoIXRoaXMucGxhbmVzaXplKSByZXR1cm47XG5cbiAgICBpZiAocG9zLmJvdHRvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm1lc2gucG9zaXRpb24ueSA9IHBvcy5ib3R0b20gKyB0aGlzLnBsYW5lc2l6ZS5oZWlnaHQgLyAyICsgY2FtZXJhLmJvdHRvbTtcbiAgICB9IGVsc2UgaWYgKHBvcy50b3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5tZXNoLnBvc2l0aW9uLnkgPSBjYW1lcmEudG9wIC0gcG9zLnRvcCAtIHRoaXMucGxhbmVzaXplLmhlaWdodCAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVzaC5wb3NpdGlvbi55ID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zLmxlZnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5tZXNoLnBvc2l0aW9uLnggPSBwb3MubGVmdCArIHRoaXMucGxhbmVzaXplLndpZHRoIC8gMiArIGNhbWVyYS5sZWZ0O1xuICAgIH0gZWxzZSBpZiAocG9zLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubWVzaC5wb3NpdGlvbi54ID0gY2FtZXJhLnJpZ2h0IC0gcG9zLnJpZ2h0IC0gdGhpcy5wbGFuZXNpemUud2lkdGggLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lc2gucG9zaXRpb24ueCA9IDA7XG4gICAgfVxuICB9XG5cbn1cblxuY29uc3QgdnNoYWRlciA9IGBcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xudmFyeWluZyB2ZWMyIHZfdXY7XG52b2lkIG1haW4oKSB7XG4gIHZfcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgdl91diA9IHV2O1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbiNpbmNsdWRlIDxkZWd1TWF0aGY+XG4jZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTlcblxudW5pZm9ybSB2ZWMyIHVfbW91c2U7XG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xudW5pZm9ybSB2ZWMzIHVfY29sb3I7XG51bmlmb3JtIGZsb2F0IHVfdGltZTtcbnVuaWZvcm0gZmxvYXQgdV9kdXJhdGlvbjtcblxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlMTtcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZTI7XG5cbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xudmFyeWluZyB2ZWMyIHZfdXY7XG5cblxudm9pZCBtYWluICh2b2lkKVxue1xuICAgIC8vIHZlYzIgcCA9IHZfcG9zaXRpb24ueHk7XG4gICAgdmVjMiBwID0gLTEuMCArIDIuMCAqIHZfdXY7XG5cbiAgICBmbG9hdCBsZW4gPSBsZW5ndGgocCk7XG4gICAgdmVjMiByYWRpYW50ID0gcCAvIGxlbiAqIDAuMDI7XG4gICAgZmxvYXQgcmlwcGxlQ291bnQgPSAzMC4wO1xuICAgIHZlYzIgcmlwcGxlID0gdl91diArIHJhZGlhbnQgKiBjb3MobGVuICogcmlwcGxlQ291bnQgLSB1X3RpbWUgKiA0LjApO1xuICAgIGZsb2F0IHByb2dyZXNzID0gdV90aW1lIC8gdV9kdXJhdGlvbjtcbiAgICB2ZWMyIHV2ID0gbWl4KHJpcHBsZSwgdl91diwgcHJvZ3Jlc3MpO1xuXG4gICAgdmVjMyBjb2xvcjEgPSB0ZXh0dXJlMkQodV90ZXh0dXJlMSwgdXYpLnJnYjtcbiAgICB2ZWMzIGNvbG9yMiA9IHRleHR1cmUyRCh1X3RleHR1cmUyLCB1dikucmdiO1xuICAgIGZsb2F0IGZhZGUgPSBzbW9vdGhzdGVwKHByb2dyZXNzICogMS40LCBwcm9ncmVzcyAqIDIuNSwgbGVuKTtcblxuICAgIC8vIE1peCBpdFxuICAgIHZlYzMgY29sb3IgPSBtaXgoY29sb3IyLCBjb2xvcjEsIGZhZGUpO1xuXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcbn1cbmA7IC8vIFZlcnNpb24gdG8ganVzdCBkaXNwbGF5IHRleHRcblxuY29uc3QgdGV4dEZyYWdTaGFkZXIgPSBgXG4jaW5jbHVkZSA8ZGVndU1hdGhmPlxuI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU5XG5cbnVuaWZvcm0gZmxvYXQgdV90aW1lO1xudW5pZm9ybSBmbG9hdCB1X2R1cmF0aW9uO1xudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXg7XG5cbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xudmFyeWluZyB2ZWMyIHZfdXY7XG5cbnZvaWQgbWFpbiAodm9pZClcbntcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXgsIHZfdXYpO1xufVxuYDsgLy8gVHdpcmxpbmcgdGV4dCB2ZXJzaW9uLlxuXG5jb25zdCB0ZXh0RnJhZ1NoYWRlcjIgPSBgXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4O1xuICB1bmlmb3JtIGZsb2F0IHVfdGltZTtcbiAgdW5pZm9ybSBmbG9hdCB1X2R1cmF0aW9uO1xuICB1bmlmb3JtIGZsb2F0IHVfdHdpcmxzO1xuXG4gIHZhcnlpbmcgdmVjMiB2X3V2O1xuXG4gIHZlYzQgdHdpcmwoc2FtcGxlcjJEIHRleCwgdmVjMiB1diwgZmxvYXQgdGltZSl7XG4gICAgaWYgKHRpbWU8MC4wKSB0aW1lID0gMC4wO1xuXG4gICAgdmVjMiBjZW50ZXIgPSB2ZWMyKDAuNSk7XG4gICAgdmVjMiB0YyA9IHV2IC0gY2VudGVyO1xuICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgodGMpO1xuXG4gICAgaWYgKGRpc3QgPCAwLjUpe1xuICAgICAgZmxvYXQgZGVsdGEgPSAoMC41IC0gZGlzdCkgLyAwLjU7XG4gICAgICBmbG9hdCB0aGV0YSA9IGRlbHRhICogZGVsdGEgKiB0aW1lICogdV90d2lybHM7XG4gICAgICBmbG9hdCBzID0gc2luKHRoZXRhKTtcbiAgICAgIGZsb2F0IGMgPSBjb3ModGhldGEpO1xuICAgICAgbWF0MiBtYXQgPSBtYXQyKGMscywtcyxjKTtcbiAgICAgIHRjID0gbWF0ICogdGM7XG4gICAgICAvL3RjID0gdmVjMihkb3QodGMsIHZlYzIoYywgLXMpKSwgZG90KHRjLCB2ZWMyKHMsIGMpKSk7XG4gICAgfVxuXG4gICAgdGMgKz0gY2VudGVyO1xuICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodGV4LCB0Yyk7XG4gICAgY29sb3IuYSA9IG1peCgwLjAsIGNvbG9yLmEsIG1pbih1X3RpbWUsIDEuMCkpO1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIHZvaWQgbWFpbih2b2lkKXtcbiAgICBnbF9GcmFnQ29sb3IgPSB0d2lybCh1X3RleCwgdl91diwgdV9kdXJhdGlvbiAtIHVfdGltZSk7XG4gIH1cbmA7XG5cbmNsYXNzIEdsc2xQbGF5Z3JvdW5kMjMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vIDJ4MlxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMC4xLCAxMCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgLy8gTG9hZCBhIHRleHR1cmUuXG4gICAgICAvLyBFbmRzIHVwIGJlaW5nIGEgc2FtcGxlcjJEIHR5cGUuXG4gICAgICB1X3RleHR1cmUxOiB7XG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9LFxuICAgICAgdV90ZXh0dXJlMjoge1xuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSxcbiAgICAgIHVfdGltZToge1xuICAgICAgICB2YWx1ZTogMC4wXG4gICAgICB9LFxuICAgICAgdV9kdXJhdGlvbjoge1xuICAgICAgICB2YWx1ZTogMi4wXG4gICAgICB9LFxuICAgICAgdV9tb3VzZToge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAuMCxcbiAgICAgICAgICB5OiAwLjBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVfcmVzb2x1dGlvbjoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgLy8gVGhlIHBsYW5lIHNpemUgc2hvdWxkIGJlIHRoZSBzYW1lIGFzcGVjdCByYXRpbyBhcyB0aGUgaW1hZ2Ugb3RoZXJ3aXNlLFxuICAgIC8vIHRoZSBpbWFnZSBnZXRzIHN0cmV0Y2hlZC5cblxuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSgwLjY2OSwgMSk7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG4gICAgICB1bmlmb3JtczogdGhpcy51bmlmb3JtcyxcbiAgICAgIHZlcnRleFNoYWRlcjogdnNoYWRlcixcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBmc2hhZGVyXG4gICAgfSk7IC8vIENyZWF0ZSBtZXNoIChnZW9tICsgbWF0ZXJpYWwpXG5cbiAgICB0aGlzLnBsYW5lID0gbmV3IFRIUkVFLk1lc2godGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5wbGFuZSk7IC8vIFRleHQgZm9yIHNsaWRlcy5cblxuICAgIHRoaXMudGV4dCA9IFt7XG4gICAgICBuYW1lOiBcInRlc3QxXCIsXG4gICAgICB0ZXh0OiBcIlRoaXMgaXMgdGhlIGZpcnN0IHRleHRcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwidGVzdDJcIixcbiAgICAgIHRleHQ6IFwiVGhpcyBpcyB0aGUgc2Vjb25kIHRleHRcIlxuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwidGVzdDNcIixcbiAgICAgIHRleHQ6IFwiVGhpcyBpcyB0aGUgdGhpcmQgdGV4dFwiXG4gICAgfV07IC8vIEFkZCBhIHNlY29uZCBwbGFuZSB0byBob2xkIHRoZSB0ZXh0LlxuXG4gICAgdGhpcy51bmlmb3JtczIgPSB7XG4gICAgICB1X3RpbWU6IHtcbiAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgfSxcbiAgICAgIHVfZHVyYXRpb246IHtcbiAgICAgICAgdmFsdWU6IDAuN1xuICAgICAgfSxcbiAgICAgIHVfdHdpcmxzOiB7XG4gICAgICAgIHZhbHVlOiA0XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm1hdGVyaWFsMiA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG4gICAgICB1bmlmb3JtczogdGhpcy51bmlmb3JtczIsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZzaGFkZXIsXG4gICAgICAvLyBOb3JtYWwgdGV4dFxuICAgICAgLy8gZnJhZ21lbnRTaGFkZXI6IHRleHRGcmFnU2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IHRleHRGcmFnU2hhZGVyMixcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgZm9udDogJ0pvc2VmaW4gU2FucycsXG4gICAgICBzaXplOiAxNixcbiAgICAgIGgxc2l6ZTogMzAsXG4gICAgICBwYWRkaW5nOiAxMCxcbiAgICAgIGNvbG91cjogJyNmZmYnLFxuICAgICAgd2lkdGg6IDUxMixcbiAgICAgIGhlaWdodDogMjU2LFxuICAgICAgenBvczogMC4wMDUsXG4gICAgICBwbGFuZXNpemU6IHtcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIGhlaWdodDogMC41XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmNhbnZhc1RleHQgPSBuZXcgQ2FudmFzVGV4dCh0aGlzLnNjZW5lLCB0aGlzLnRleHRbMV0sIGNvbmZpZywgdGhpcy5tYXRlcmlhbDIpO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAxO1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICAgIHRoaXMuc2xpZGVJbmRleCA9IDA7XG4gICAgdGhpcy50ZXh0dXJlcyA9IFtuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoJy4vcHVibGljL3JhbmRvbS5qcGcnKSwgbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKCcuL3B1YmxpYy9yYW5kb20yLmpwZycpLCBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoJy4vcHVibGljL3JhbmRvbTMuanBnJyldOyAvLyBGYWtlIGEgc2xpZGVzaG93IGZvciBub3cuXG5cbiAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aGlzLnNsaWRlSW5kZXgrKztcbiAgICAgIHRoaXMuZGlzcGxheUluZGV4KCk7XG4gICAgfSwgMzAwMCk7XG4gICAgdGhpcy5kaXNwbGF5SW5kZXgoKTtcbiAgfVxuXG4gIGRpc3BsYXlJbmRleCgpIHtcbiAgICAvLyBSZXNldCB0aGUgdGltZSB2YWx1ZS5cbiAgICB0aGlzLnVuaWZvcm1zLnVfdGltZS52YWx1ZSA9IDA7XG4gICAgdGhpcy51bmlmb3JtczIudV90aW1lLnZhbHVlID0gMDtcbiAgICB0aGlzLmNhbnZhc1RleHQudXBkYXRlKHRoaXMudGV4dFt0aGlzLnNsaWRlSW5kZXhdKTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfdGV4dHVyZTEudmFsdWUgPSB0aGlzLnRleHR1cmVzW3RoaXMuc2xpZGVJbmRleF07XG4gICAgdGhpcy51bmlmb3Jtcy51X3RleHR1cmUyLnZhbHVlID0gdGhpcy50ZXh0dXJlc1t0aGlzLnNsaWRlSW5kZXggKyAxXTtcblxuICAgIGlmICh0aGlzLnNsaWRlSW5kZXggPj0gdGhpcy50ZXh0dXJlcy5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLnVfdGV4dHVyZTEudmFsdWUgPSB0aGlzLnRleHR1cmVzW3RoaXMuc2xpZGVJbmRleF07XG4gICAgICB0aGlzLnVuaWZvcm1zLnVfdGV4dHVyZTIudmFsdWUgPSB0aGlzLnRleHR1cmVzWzBdO1xuICAgICAgdGhpcy5zbGlkZUluZGV4ID0gLTE7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2codGhpcy5zbGlkZUluZGV4KTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnVuaWZvcm1zLnVfdGV4dHVyZTEudmFsdWUpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMudW5pZm9ybXMudV90ZXh0dXJlMi52YWx1ZSk7XG4gIH1cblxuICBvblJlc2l6ZSgpIHtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgaWYgKGFzcGVjdFJhdGlvID49IDEpIHtcbiAgICAgIHdpZHRoID0gMTtcbiAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAvIHdpbmRvdy5pbm5lcldpZHRoICogd2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gYXNwZWN0UmF0aW87XG4gICAgICBoZWlnaHQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuY2FtZXJhLmxlZnQgPSAtd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEucmlnaHQgPSB3aWR0aDtcbiAgICB0aGlzLmNhbWVyYS50b3AgPSBoZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEuYm90dG9tID0gLWhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS55ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIHRoaXMuY2FudmFzVGV4dC5wb3NpdGlvblRleHQodGhpcy5jYW1lcmEsIHtcbiAgICAgIGJvdHRvbTogMC4xXG4gICAgfSk7XG4gIH1cblxuICBvbk1vdXNlTW92ZShldnQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WCA6IGV2dC5jbGllbnRYO1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS55ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRZIDogZXZ0LmNsaWVudFk7XG4gIH1cblxuICBvblJhZigpIHtcbiAgICBjb25zdCBkZWx0YSA9IHRoaXMucmFmLmdldERlbHRhKHRydWUpO1xuXG4gICAgaWYgKHRoaXMudW5pZm9ybXMudV90aW1lLnZhbHVlIDwgdGhpcy51bmlmb3Jtcy51X2R1cmF0aW9uLnZhbHVlKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLnVfdGltZS52YWx1ZSArPSBkZWx0YTtcbiAgICAgIHRoaXMudW5pZm9ybXMyLnVfdGltZS52YWx1ZSArPSBkZWx0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmlmb3Jtcy51X3RpbWUudmFsdWUgPSB0aGlzLnVuaWZvcm1zLnVfZHVyYXRpb24udmFsdWU7XG4gICAgICB0aGlzLnVuaWZvcm1zMi51X3RpbWUudmFsdWUgPSB0aGlzLnVuaWZvcm1zMi51X2R1cmF0aW9uLnZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdsc2xQbGF5Z3JvdW5kMjM7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/glsl-playground23.js\n");

/***/ }),

/***/ "./examples/glsl-playground24.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground24.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _OrbitControls = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _deguMathf = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/degu-mathf */ \"./lib/shaders/three-shader-chunks/degu-mathf.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//\n//https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739152#questions/8753186\n//\n// Import shader chunks\n(0, _deguMathf.deguMathf)(THREE);\nconst vshader = `\n#include <deguMathf>\nuniform float u_time;\nuniform float u_radius;\n\nvoid main() {\n  // Normalize time with sin.\n  float delta = normalizedSin(u_time);\n\n  // Sphere positions.\n  vec3 sphere = normalize(position) * u_radius;\n\n  // Mix between square box and sphere.\n  vec3 pos = mix(position, sphere, delta);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n}\n`;\nconst fshader = `\nvoid main()\n{\n  vec3 color = vec3(0.5);\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\nwindow.THREE = THREE;\n\nclass GlslPlayground24 {\n  constructor() {\n    this.scene = new THREE.Scene();\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);\n    this.camera.position.z = 100;\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_time: {\n        value: 0.0\n      },\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      },\n      u_radius: {\n        value: 20.0\n      }\n    };\n    this.geometry = new THREE.BoxGeometry(30, 30, 30, 10, 10, 10);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader,\n      wireframe: true\n    });\n    this.ball = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.ball);\n    this.controls = new _OrbitControls.OrbitControls(this.camera, this.renderer.domElement);\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground24;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQyNC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDI0LmpzPzNhZDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfT3JiaXRDb250cm9scyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9sc1wiKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS13YXRjaGVyXCIpO1xuXG52YXIgX2RlZ3VNYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvc2hhZGVycy90aHJlZS1zaGFkZXItY2h1bmtzL2RlZ3UtbWF0aGZcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLy9cbi8vXG4vL2h0dHBzOi8vd3d3LnVkZW15LmNvbS9jb3Vyc2UvbGVhcm4tZ2xzbC1zaGFkZXJzLWZyb20tc2NyYXRjaC9sZWFybi9sZWN0dXJlLzEzNzM5MTUyI3F1ZXN0aW9ucy84NzUzMTg2XG4vL1xuLy8gSW1wb3J0IHNoYWRlciBjaHVua3NcbigwLCBfZGVndU1hdGhmLmRlZ3VNYXRoZikoVEhSRUUpO1xuY29uc3QgdnNoYWRlciA9IGBcbiNpbmNsdWRlIDxkZWd1TWF0aGY+XG51bmlmb3JtIGZsb2F0IHVfdGltZTtcbnVuaWZvcm0gZmxvYXQgdV9yYWRpdXM7XG5cbnZvaWQgbWFpbigpIHtcbiAgLy8gTm9ybWFsaXplIHRpbWUgd2l0aCBzaW4uXG4gIGZsb2F0IGRlbHRhID0gbm9ybWFsaXplZFNpbih1X3RpbWUpO1xuXG4gIC8vIFNwaGVyZSBwb3NpdGlvbnMuXG4gIHZlYzMgc3BoZXJlID0gbm9ybWFsaXplKHBvc2l0aW9uKSAqIHVfcmFkaXVzO1xuXG4gIC8vIE1peCBiZXR3ZWVuIHNxdWFyZSBib3ggYW5kIHNwaGVyZS5cbiAgdmVjMyBwb3MgPSBtaXgocG9zaXRpb24sIHNwaGVyZSwgZGVsdGEpO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3MsIDEuMCApO1xufVxuYDtcbmNvbnN0IGZzaGFkZXIgPSBgXG52b2lkIG1haW4oKVxue1xuICB2ZWMzIGNvbG9yID0gdmVjMygwLjUpO1xuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1xufVxuYDtcbndpbmRvdy5USFJFRSA9IFRIUkVFO1xuXG5jbGFzcyBHbHNsUGxheWdyb3VuZDI0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgtMSwgMSwgMSwgLTEsIDAuMSwgMTApO1xuICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDQ1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMSwgMTAwMCk7XG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiA9IDEwMDtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgIHRoaXMucmFmID0gbmV3IF9yYWYuUmFmKHRoaXMub25SYWYuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAncmVzaXplJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyksXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdtb3VzZW1vdmUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICB1X3RpbWU6IHtcbiAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgfSxcbiAgICAgIHVfbW91c2U6IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB4OiAwLjAsXG4gICAgICAgICAgeTogMC4wXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1X3Jlc29sdXRpb246IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVfcmFkaXVzOiB7XG4gICAgICAgIHZhbHVlOiAyMC4wXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDMwLCAzMCwgMzAsIDEwLCAxMCwgMTApO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZzaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZnNoYWRlcixcbiAgICAgIHdpcmVmcmFtZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuYmFsbCA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMuYmFsbCk7XG4gICAgdGhpcy5jb250cm9scyA9IG5ldyBfT3JiaXRDb250cm9scy5PcmJpdENvbnRyb2xzKHRoaXMuY2FtZXJhLCB0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGlmIChhc3BlY3RSYXRpbyA+PSAxKSB7XG4gICAgICB3aWR0aCA9IDE7XG4gICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB3aW5kb3cuaW5uZXJXaWR0aCAqIHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdFJhdGlvO1xuICAgICAgaGVpZ2h0ID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbWVyYS5sZWZ0ID0gLXdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnJpZ2h0ID0gd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEudG9wID0gaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLmJvdHRvbSA9IC1oZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS54ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGV2dCkge1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS54ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRYIDogZXZ0LmNsaWVudFg7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnkgPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFkgOiBldnQuY2xpZW50WTtcbiAgfVxuXG4gIG9uUmFmKGRlbHRhKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X3RpbWUudmFsdWUgKz0gdGhpcy5yYWYuZ2V0RGVsdGEodHJ1ZSk7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gR2xzbFBsYXlncm91bmQyNDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/glsl-playground24.js\n");

/***/ }),

/***/ "./examples/glsl-playground25.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground25.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _OrbitControls = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _deguMathf = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/degu-mathf */ \"./lib/shaders/three-shader-chunks/degu-mathf.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739206#questions/8753186\n//\n// Import shader chunks\n(0, _deguMathf.deguMathf)(THREE);\nconst vshader = `\n#include <deguMathf>\n// PI\n#include <common>\n// uniform\n#include <lights_pars_begin>\n\nuniform float u_time;\nuniform float u_radius;\n\nvarying vec3 vPosition;\nvarying vec3 vLightIntensity;\n\n\nvoid main() {\n  float delta = normalizedSin(u_time) * 3.0;\n  vec3 vLightFront;\n  vec3 vLightBack;\n  vec3 vIndirectFront;\n  vec3 objectNormal = delta * normal + (1.0 - delta) * normalize(position);\n\n  #include <defaultnormal_vertex>\n  #include <begin_vertex>\n  #include <project_vertex>\n  #include <lights_lambert_vertex>\n\n\n\n  // Get a varying light color for each pixel.\n  vLightIntensity = vLightFront + ambientLightColor;\n  vPosition = position;\n\n  vec3 v = normalize(position) * u_radius;\n  vec3 pos = delta * position + (1.0 - delta) * v;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n}\n`;\nconst fshader = `\nvarying vec3 vLightIntensity;\nvoid main()\n{\n  vec3 color = vec3(0.5);\n  gl_FragColor = vec4(vLightIntensity * color, 1.0);\n}\n`;\n\nclass GlslPlayground24 {\n  constructor() {\n    this.scene = new THREE.Scene();\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);\n    this.camera.position.z = 100; // Add some lights.\n\n    const ambient = new THREE.HemisphereLight(0xFFFFFF, 0xFFFFFF, 1);\n    const light = new THREE.DirectionalLight(0xFFFFFF, 1);\n    light.position.set(0, 6, 2);\n    this.scene.add(ambient);\n    this.scene.add(light);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.geometry = new THREE.BoxGeometry(30, 30, 30, 10, 10, 10);\n    this.uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib[\"common\"], THREE.UniformsLib[\"lights\"]]);\n    this.uniforms.u_time = {\n      value: 0.0\n    };\n    this.uniforms.u_mouse = {\n      value: {\n        x: 0.0,\n        y: 0.0\n      }\n    };\n    this.uniforms.u_resolution = {\n      value: {\n        x: 0,\n        y: 0\n      }\n    };\n    this.uniforms.u_radius = {\n      value: 20.0\n    };\n    console.log('uniforms');\n    console.log(this.uniforms);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader,\n      lights: true\n    });\n    const material1 = new THREE.MeshBasicMaterial({\n      color: 0xb7ff00,\n      wireframe: true\n    });\n    this.ball = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.ball);\n    this.controls = new _OrbitControls.OrbitControls(this.camera, this.renderer.domElement);\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground24;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQyNS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDI1LmpzPzQ4YWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfT3JiaXRDb250cm9scyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9sc1wiKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS13YXRjaGVyXCIpO1xuXG52YXIgX2RlZ3VNYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvc2hhZGVycy90aHJlZS1zaGFkZXItY2h1bmtzL2RlZ3UtbWF0aGZcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLy9cbi8vXG4vLyBodHRwczovL3d3dy51ZGVteS5jb20vY291cnNlL2xlYXJuLWdsc2wtc2hhZGVycy1mcm9tLXNjcmF0Y2gvbGVhcm4vbGVjdHVyZS8xMzczOTIwNiNxdWVzdGlvbnMvODc1MzE4NlxuLy9cbi8vIEltcG9ydCBzaGFkZXIgY2h1bmtzXG4oMCwgX2RlZ3VNYXRoZi5kZWd1TWF0aGYpKFRIUkVFKTtcbmNvbnN0IHZzaGFkZXIgPSBgXG4jaW5jbHVkZSA8ZGVndU1hdGhmPlxuLy8gUEnjga7lrprnvqnjgarjganjgYzjgYLjgorjgIHjg6njgqTjg4jmg4XloLHjgpLkvb/jgYbjga7jgavlv4XopoFcbiNpbmNsdWRlIDxjb21tb24+XG4vLyDjg6njgqTjg4jjga7mp4vpgKDkvZPjgIF1bmlmb3Jt5aSJ5pWw44Gq44Gp44GM5a6a576p44GV44KM44Gm44GE44KLXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XG5cbnVuaWZvcm0gZmxvYXQgdV90aW1lO1xudW5pZm9ybSBmbG9hdCB1X3JhZGl1cztcblxudmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcbnZhcnlpbmcgdmVjMyB2TGlnaHRJbnRlbnNpdHk7XG5cblxudm9pZCBtYWluKCkge1xuICBmbG9hdCBkZWx0YSA9IG5vcm1hbGl6ZWRTaW4odV90aW1lKSAqIDMuMDtcbiAgdmVjMyB2TGlnaHRGcm9udDtcbiAgdmVjMyB2TGlnaHRCYWNrO1xuICB2ZWMzIHZJbmRpcmVjdEZyb250O1xuICB2ZWMzIG9iamVjdE5vcm1hbCA9IGRlbHRhICogbm9ybWFsICsgKDEuMCAtIGRlbHRhKSAqIG5vcm1hbGl6ZShwb3NpdGlvbik7XG5cbiAgI2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxuICAjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxuICAjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XG4gICNpbmNsdWRlIDxsaWdodHNfbGFtYmVydF92ZXJ0ZXg+XG5cblxuXG4gIC8vIEdldCBhIHZhcnlpbmcgbGlnaHQgY29sb3IgZm9yIGVhY2ggcGl4ZWwuXG4gIHZMaWdodEludGVuc2l0eSA9IHZMaWdodEZyb250ICsgYW1iaWVudExpZ2h0Q29sb3I7XG4gIHZQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXG4gIHZlYzMgdiA9IG5vcm1hbGl6ZShwb3NpdGlvbikgKiB1X3JhZGl1cztcbiAgdmVjMyBwb3MgPSBkZWx0YSAqIHBvc2l0aW9uICsgKDEuMCAtIGRlbHRhKSAqIHY7XG5cbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zLCAxLjAgKTtcbn1cbmA7XG5jb25zdCBmc2hhZGVyID0gYFxudmFyeWluZyB2ZWMzIHZMaWdodEludGVuc2l0eTtcbnZvaWQgbWFpbigpXG57XG4gIHZlYzMgY29sb3IgPSB2ZWMzKDAuNSk7XG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQodkxpZ2h0SW50ZW5zaXR5ICogY29sb3IsIDEuMCk7XG59XG5gO1xuXG5jbGFzcyBHbHNsUGxheWdyb3VuZDI0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgtMSwgMSwgMSwgLTEsIDAuMSwgMTApO1xuICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDQ1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMSwgMTAwMDApO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAxMDA7IC8vIEFkZCBzb21lIGxpZ2h0cy5cblxuICAgIGNvbnN0IGFtYmllbnQgPSBuZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0KDB4RkZGRkZGLCAweEZGRkZGRiwgMSk7XG4gICAgY29uc3QgbGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweEZGRkZGRiwgMSk7XG4gICAgbGlnaHQucG9zaXRpb24uc2V0KDAsIDYsIDIpO1xuICAgIHRoaXMuc2NlbmUuYWRkKGFtYmllbnQpO1xuICAgIHRoaXMuc2NlbmUuYWRkKGxpZ2h0KTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgIHRoaXMucmFmID0gbmV3IF9yYWYuUmFmKHRoaXMub25SYWYuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAncmVzaXplJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyksXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdtb3VzZW1vdmUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkoMzAsIDMwLCAzMCwgMTAsIDEwLCAxMCk7XG4gICAgdGhpcy51bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoW1RIUkVFLlVuaWZvcm1zTGliW1wiY29tbW9uXCJdLCBUSFJFRS5Vbmlmb3Jtc0xpYltcImxpZ2h0c1wiXV0pO1xuICAgIHRoaXMudW5pZm9ybXMudV90aW1lID0ge1xuICAgICAgdmFsdWU6IDAuMFxuICAgIH07XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlID0ge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgeDogMC4wLFxuICAgICAgICB5OiAwLjBcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uID0ge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy51bmlmb3Jtcy51X3JhZGl1cyA9IHtcbiAgICAgIHZhbHVlOiAyMC4wXG4gICAgfTtcbiAgICBjb25zb2xlLmxvZygndW5pZm9ybXMnKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnVuaWZvcm1zKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgdmVydGV4U2hhZGVyOiB2c2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzaGFkZXIsXG4gICAgICBsaWdodHM6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBtYXRlcmlhbDEgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6IDB4YjdmZjAwLFxuICAgICAgd2lyZWZyYW1lOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5iYWxsID0gbmV3IFRIUkVFLk1lc2godGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5iYWxsKTtcbiAgICB0aGlzLmNvbnRyb2xzID0gbmV3IF9PcmJpdENvbnRyb2xzLk9yYml0Q29udHJvbHModGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgIHRoaXMucmFmLnN0YXJ0KCk7XG4gIH1cblxuICBvblJlc2l6ZSgpIHtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgaWYgKGFzcGVjdFJhdGlvID49IDEpIHtcbiAgICAgIHdpZHRoID0gMTtcbiAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAvIHdpbmRvdy5pbm5lcldpZHRoICogd2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gYXNwZWN0UmF0aW87XG4gICAgICBoZWlnaHQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuY2FtZXJhLmxlZnQgPSAtd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEucmlnaHQgPSB3aWR0aDtcbiAgICB0aGlzLmNhbWVyYS50b3AgPSBoZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEuYm90dG9tID0gLWhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS55ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZXZ0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnggPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFggOiBldnQuY2xpZW50WDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueSA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WSA6IGV2dC5jbGllbnRZO1xuICB9XG5cbiAgb25SYWYoZGVsdGEpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfdGltZS52YWx1ZSArPSB0aGlzLnJhZi5nZXREZWx0YSh0cnVlKTtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBHbHNsUGxheWdyb3VuZDI0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/glsl-playground25.js\n");

/***/ }),

/***/ "./examples/glsl-playground26.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground26.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _OrbitControls = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _deguMathf = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/degu-mathf */ \"./lib/shaders/three-shader-chunks/degu-mathf.js\");\n\nvar _noise = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/noise */ \"./lib/shaders/three-shader-chunks/noise.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739196#questions/8753186\n// https://www.clicktorelease.com/blog/vertex-displacement-noise-3d-webgl-glsl-three-js/\n// https://codepen.io/nik-lever/pen/PLYRWm\n// Import shader chunks\n(0, _deguMathf.deguMathf)(THREE);\n(0, _noise.noise)(THREE);\nconst vshader = `\n#include <noise>\n#include <deguMathf>\nuniform float u_time;\n\nvarying float v_noise;\nvarying vec2 vUv;\nvoid main() {\n\n\n    // \n    // Uneune ball poi\n    // float arms = 0.05;\n    // float b = 5.0 * pnoise (arms * position + u_time, vec3(100.0));\n\n    // Spike\n    // float b = pnoise (position + u_time, vec3(100.0)) * 5.0;\n\n    // Breathing\n    float arms = 0.032;\n    v_noise = 5.0 * -0.1 * turbulence(0.5 * normal + u_time * 0.2);\n    float b = pnoise (arms * position + u_time, vec3(100.0)) * ((normalizedSin(u_time * 0.5) + 1.0) * 10.0);\n    float displacement = b - 10.0 * v_noise;\n\n    // Calculate a displancement amount with normal.\n    // https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739196#questions/8753186\n    // v_noise = 10.0 * -0.1 * turbulence(0.5 * normal + u_time);\n    // float b = 5.0 * pnoise (0.05 * position, vec3(100.0));\n    // float displacement = b - 10.0 * v_noise;\n\n    vec3 pos = position + normal * displacement;\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n}\n`;\nconst fshader = `\n#define PI 3.141592653589\n#define PI2 6.28318530718\n\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform float u_time;\nuniform vec3 u_color;\n\nvarying vec2 vUv;\nvarying float v_noise;\nvoid main()\n{\n  // We use the varying v_noise to cange the colors.\n  vec3 color = vec3(vUv * (1.0 - 2.0 * v_noise), 0.0);\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground26 {\n  constructor() {\n    this.scene = new THREE.Scene();\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);\n    this.camera.position.z = 100; // Add some lights.\n\n    const ambient = new THREE.HemisphereLight(0xFFFFFF, 0xFFFFFF, 1);\n    const light = new THREE.DirectionalLight(0xFFFFFF, 1);\n    light.position.set(0, 6, 2);\n    this.scene.add(ambient);\n    this.scene.add(light);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.geometry = new THREE.IcosahedronGeometry(20, 4);\n    this.uniforms = {\n      u_time: {\n        value: 0.0\n      },\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      },\n      u_color: {\n        value: new THREE.Color(0xb7ff00)\n      }\n    };\n    console.log('uniforms');\n    console.log(this.uniforms);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader // wireframe: true\n\n    });\n    this.ball = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.ball);\n    this.controls = new _OrbitControls.OrbitControls(this.camera, this.renderer.domElement);\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    if (this.uniforms) {\n      this.uniforms.u_time.value += this.raf.getDelta(true);\n    }\n\n    if (this.renderer) {\n      this.renderer.render(this.scene, this.camera);\n    }\n  }\n\n}\n\nexports.default = GlslPlayground26;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQyNi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDI2LmpzPzcyNzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfT3JiaXRDb250cm9scyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9sc1wiKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS13YXRjaGVyXCIpO1xuXG52YXIgX2RlZ3VNYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvc2hhZGVycy90aHJlZS1zaGFkZXItY2h1bmtzL2RlZ3UtbWF0aGZcIik7XG5cbnZhciBfbm9pc2UgPSByZXF1aXJlKFwiLi4vbGliL3NoYWRlcnMvdGhyZWUtc2hhZGVyLWNodW5rcy9ub2lzZVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vL1xuLy8gaHR0cHM6Ly93d3cudWRlbXkuY29tL2NvdXJzZS9sZWFybi1nbHNsLXNoYWRlcnMtZnJvbS1zY3JhdGNoL2xlYXJuL2xlY3R1cmUvMTM3MzkxOTYjcXVlc3Rpb25zLzg3NTMxODZcbi8vIGh0dHBzOi8vd3d3LmNsaWNrdG9yZWxlYXNlLmNvbS9ibG9nL3ZlcnRleC1kaXNwbGFjZW1lbnQtbm9pc2UtM2Qtd2ViZ2wtZ2xzbC10aHJlZS1qcy9cbi8vIGh0dHBzOi8vY29kZXBlbi5pby9uaWstbGV2ZXIvcGVuL1BMWVJXbVxuLy8gSW1wb3J0IHNoYWRlciBjaHVua3NcbigwLCBfZGVndU1hdGhmLmRlZ3VNYXRoZikoVEhSRUUpO1xuKDAsIF9ub2lzZS5ub2lzZSkoVEhSRUUpO1xuY29uc3QgdnNoYWRlciA9IGBcbiNpbmNsdWRlIDxub2lzZT5cbiNpbmNsdWRlIDxkZWd1TWF0aGY+XG51bmlmb3JtIGZsb2F0IHVfdGltZTtcblxudmFyeWluZyBmbG9hdCB2X25vaXNlO1xudmFyeWluZyB2ZWMyIHZVdjtcbnZvaWQgbWFpbigpIHtcblxuXG4gICAgLy8g5pmu6YCa44Gr44GT44KM44Gn44KC44GE44GE44GM44K144Oz44OX44Or55So44Gr44OO44O844Oe44Or44KS5LiL6KiY44Gn44GX44KI44GGXG4gICAgLy8gVW5ldW5lIGJhbGwgcG9pXG4gICAgLy8gZmxvYXQgYXJtcyA9IDAuMDU7XG4gICAgLy8gZmxvYXQgYiA9IDUuMCAqIHBub2lzZSAoYXJtcyAqIHBvc2l0aW9uICsgdV90aW1lLCB2ZWMzKDEwMC4wKSk7XG5cbiAgICAvLyBTcGlrZVxuICAgIC8vIGZsb2F0IGIgPSBwbm9pc2UgKHBvc2l0aW9uICsgdV90aW1lLCB2ZWMzKDEwMC4wKSkgKiA1LjA7XG5cbiAgICAvLyBCcmVhdGhpbmdcbiAgICBmbG9hdCBhcm1zID0gMC4wMzI7XG4gICAgdl9ub2lzZSA9IDUuMCAqIC0wLjEgKiB0dXJidWxlbmNlKDAuNSAqIG5vcm1hbCArIHVfdGltZSAqIDAuMik7XG4gICAgZmxvYXQgYiA9IHBub2lzZSAoYXJtcyAqIHBvc2l0aW9uICsgdV90aW1lLCB2ZWMzKDEwMC4wKSkgKiAoKG5vcm1hbGl6ZWRTaW4odV90aW1lICogMC41KSArIDEuMCkgKiAxMC4wKTtcbiAgICBmbG9hdCBkaXNwbGFjZW1lbnQgPSBiIC0gMTAuMCAqIHZfbm9pc2U7XG5cbiAgICAvLyBDYWxjdWxhdGUgYSBkaXNwbGFuY2VtZW50IGFtb3VudCB3aXRoIG5vcm1hbC5cbiAgICAvLyBodHRwczovL3d3dy51ZGVteS5jb20vY291cnNlL2xlYXJuLWdsc2wtc2hhZGVycy1mcm9tLXNjcmF0Y2gvbGVhcm4vbGVjdHVyZS8xMzczOTE5NiNxdWVzdGlvbnMvODc1MzE4NlxuICAgIC8vIHZfbm9pc2UgPSAxMC4wICogLTAuMSAqIHR1cmJ1bGVuY2UoMC41ICogbm9ybWFsICsgdV90aW1lKTtcbiAgICAvLyBmbG9hdCBiID0gNS4wICogcG5vaXNlICgwLjA1ICogcG9zaXRpb24sIHZlYzMoMTAwLjApKTtcbiAgICAvLyBmbG9hdCBkaXNwbGFjZW1lbnQgPSBiIC0gMTAuMCAqIHZfbm9pc2U7XG5cbiAgICB2ZWMzIHBvcyA9IHBvc2l0aW9uICsgbm9ybWFsICogZGlzcGxhY2VtZW50O1xuICAgIHZVdiA9IHV2O1xuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvcywgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODlcbiNkZWZpbmUgUEkyIDYuMjgzMTg1MzA3MThcblxudW5pZm9ybSB2ZWMyIHVfbW91c2U7XG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG51bmlmb3JtIHZlYzMgdV9jb2xvcjtcblxudmFyeWluZyB2ZWMyIHZVdjtcbnZhcnlpbmcgZmxvYXQgdl9ub2lzZTtcbnZvaWQgbWFpbigpXG57XG4gIC8vIFdlIHVzZSB0aGUgdmFyeWluZyB2X25vaXNlIHRvIGNhbmdlIHRoZSBjb2xvcnMuXG4gIHZlYzMgY29sb3IgPSB2ZWMzKHZVdiAqICgxLjAgLSAyLjAgKiB2X25vaXNlKSwgMC4wKTtcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcbn1cbmA7XG5cbmNsYXNzIEdsc2xQbGF5Z3JvdW5kMjYge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMC4xLCAxMCk7XG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNDUsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAxLCAxMDAwMCk7XG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiA9IDEwMDsgLy8gQWRkIHNvbWUgbGlnaHRzLlxuXG4gICAgY29uc3QgYW1iaWVudCA9IG5ldyBUSFJFRS5IZW1pc3BoZXJlTGlnaHQoMHhGRkZGRkYsIDB4RkZGRkZGLCAxKTtcbiAgICBjb25zdCBsaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4RkZGRkZGLCAxKTtcbiAgICBsaWdodC5wb3NpdGlvbi5zZXQoMCwgNiwgMik7XG4gICAgdGhpcy5zY2VuZS5hZGQoYW1iaWVudCk7XG4gICAgdGhpcy5zY2VuZS5hZGQobGlnaHQpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgdGhpcy5yYWYgPSBuZXcgX3JhZi5SYWYodGhpcy5vblJhZi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIgPSBuZXcgX2RvbVdhdGNoZXIuRG9tV2F0Y2hlcigpO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdyZXNpemUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25SZXNpemUuYmluZCh0aGlzKSxcbiAgICAgIGV2ZW50T3B0aW9uczoge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ21vdXNlbW92ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KDIwLCA0KTtcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgdV90aW1lOiB7XG4gICAgICAgIHZhbHVlOiAwLjBcbiAgICAgIH0sXG4gICAgICB1X21vdXNlOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMC4wLFxuICAgICAgICAgIHk6IDAuMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdV9yZXNvbHV0aW9uOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1X2NvbG9yOiB7XG4gICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoMHhiN2ZmMDApXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zb2xlLmxvZygndW5pZm9ybXMnKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnVuaWZvcm1zKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgdmVydGV4U2hhZGVyOiB2c2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzaGFkZXIgLy8gd2lyZWZyYW1lOiB0cnVlXG5cbiAgICB9KTtcbiAgICB0aGlzLmJhbGwgPSBuZXcgVEhSRUUuTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLmJhbGwpO1xuICAgIHRoaXMuY29udHJvbHMgPSBuZXcgX09yYml0Q29udHJvbHMuT3JiaXRDb250cm9scyh0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgfVxuXG4gIG9uUmVzaXplKCkge1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBpZiAoYXNwZWN0UmF0aW8gPj0gMSkge1xuICAgICAgd2lkdGggPSAxO1xuICAgICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC8gd2luZG93LmlubmVyV2lkdGggKiB3aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBhc3BlY3RSYXRpbztcbiAgICAgIGhlaWdodCA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5jYW1lcmEubGVmdCA9IC13aWR0aDtcbiAgICB0aGlzLmNhbWVyYS5yaWdodCA9IHdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnRvcCA9IGhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS5ib3R0b20gPSAtaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnkgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIH1cblxuICBvbk1vdXNlTW92ZShldnQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WCA6IGV2dC5jbGllbnRYO1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS55ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRZIDogZXZ0LmNsaWVudFk7XG4gIH1cblxuICBvblJhZihkZWx0YSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm1zKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLnVfdGltZS52YWx1ZSArPSB0aGlzLnJhZi5nZXREZWx0YSh0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdsc2xQbGF5Z3JvdW5kMjY7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/glsl-playground26.js\n");

/***/ }),

/***/ "./examples/glsl-playground27.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground27.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _OrbitControls = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _deguMathf = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/degu-mathf */ \"./lib/shaders/three-shader-chunks/degu-mathf.js\");\n\nvar _noise = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/noise */ \"./lib/shaders/three-shader-chunks/noise.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739196#questions/8753186\n// https://www.clicktorelease.com/blog/vertex-displacement-noise-3d-webgl-glsl-three-js/\n// https://codepen.io/nik-lever/pen/PLYRWm\n// Import shader chunks\n(0, _deguMathf.deguMathf)(THREE);\n(0, _noise.noise)(THREE);\nconst vshader = `\n#include <noise>\n#include <deguMathf>\nuniform float u_time;\n\nvarying float v_noise;\nvarying vec2 vUv;\nvoid main() {\n\n\n    // \n    // Uneune ball poi\n    // float arms = 0.05;\n    // float b = 5.0 * pnoise (arms * position + u_time, vec3(100.0));\n\n    // Spike\n    // float b = pnoise (position + u_time, vec3(100.0)) * 5.0;\n\n    // Breathing\n    float arms = 0.032;\n    v_noise = 10.0 * -0.1 * turbulence(0.5 * normal + u_time * 0.2);\n    float b = pnoise (arms * position + u_time, vec3(100.0)) * ((normalizedSin(u_time * 0.5) + 1.0) * 10.0);\n    float displacement = b - 10.0 * v_noise;\n\n    // Calculate a displancement amount with normal.\n    // https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739196#questions/8753186\n    // v_noise = 10.0 * -0.1 * turbulence(0.5 * normal + u_time);\n    // float b = 5.0 * pnoise (0.05 * position, vec3(100.0));\n    // float displacement = b - 10.0 * v_noise;\n\n    vec3 pos = position + normal * displacement;\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n}\n`;\nconst fshader = `\n#include <noise>\n#include <deguMathf>\n#define PI 3.141592653589\n#define PI2 6.28318530718\n\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform float u_time;\nuniform vec3 u_color;\nuniform sampler2D u_tex;\n\n\nvarying vec2 vUv;\nvarying float v_noise;\nvoid main()\n{\n  // get a random offset\n  float r = .01 * random( gl_FragCoord.xyz, 0.0 );\n  // lookup vertically in the texture, using noise and offset\n  // to get the right RGB colour\n  // So really only consider the Y value in the texture.\n//   vec2 uv = vec2( 0, 1.3 * v_noise + r );\n\n  // Simple version.\n  // Using a v_noise, look up a specific y point in the texture\n  // and display that out to the current pixel.\n  vec2 uv = vec2(0, 1.2 * v_noise);\n  vec3 color = texture2D( u_tex, uv ).rgb;\n\n  gl_FragColor = vec4( color, 1.0 );\n}\n`;\n\nclass GlslPlayground27 {\n  constructor() {\n    this.scene = new THREE.Scene();\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);\n    this.camera.position.z = 100; // Add some lights.\n\n    const ambient = new THREE.HemisphereLight(0xFFFFFF, 0xFFFFFF, 1);\n    const light = new THREE.DirectionalLight(0xFFFFFF, 1);\n    light.position.set(0, 6, 2);\n    this.scene.add(ambient);\n    this.scene.add(light);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.geometry = new THREE.IcosahedronGeometry(20, 4);\n    this.uniforms = {\n      u_time: {\n        value: 0.0\n      },\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      },\n      u_color: {\n        value: new THREE.Color(0xb7ff00)\n      },\n      u_tex: {\n        value: new THREE.TextureLoader().load(\"/public/explosion.png\")\n      }\n    };\n    console.log('uniforms');\n    console.log(this.uniforms);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader // wireframe: true\n\n    });\n    this.ball = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.ball);\n    this.controls = new _OrbitControls.OrbitControls(this.camera, this.renderer.domElement);\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    if (this.uniforms) {\n      this.uniforms.u_time.value += this.raf.getDelta(true);\n    }\n\n    if (this.renderer) {\n      this.renderer.render(this.scene, this.camera);\n    }\n  }\n\n}\n\nexports.default = GlslPlayground27;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQyNy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDI3LmpzPzUxYTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfT3JiaXRDb250cm9scyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9sc1wiKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS13YXRjaGVyXCIpO1xuXG52YXIgX2RlZ3VNYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvc2hhZGVycy90aHJlZS1zaGFkZXItY2h1bmtzL2RlZ3UtbWF0aGZcIik7XG5cbnZhciBfbm9pc2UgPSByZXF1aXJlKFwiLi4vbGliL3NoYWRlcnMvdGhyZWUtc2hhZGVyLWNodW5rcy9ub2lzZVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vL1xuLy8gaHR0cHM6Ly93d3cudWRlbXkuY29tL2NvdXJzZS9sZWFybi1nbHNsLXNoYWRlcnMtZnJvbS1zY3JhdGNoL2xlYXJuL2xlY3R1cmUvMTM3MzkxOTYjcXVlc3Rpb25zLzg3NTMxODZcbi8vIGh0dHBzOi8vd3d3LmNsaWNrdG9yZWxlYXNlLmNvbS9ibG9nL3ZlcnRleC1kaXNwbGFjZW1lbnQtbm9pc2UtM2Qtd2ViZ2wtZ2xzbC10aHJlZS1qcy9cbi8vIGh0dHBzOi8vY29kZXBlbi5pby9uaWstbGV2ZXIvcGVuL1BMWVJXbVxuLy8gSW1wb3J0IHNoYWRlciBjaHVua3NcbigwLCBfZGVndU1hdGhmLmRlZ3VNYXRoZikoVEhSRUUpO1xuKDAsIF9ub2lzZS5ub2lzZSkoVEhSRUUpO1xuY29uc3QgdnNoYWRlciA9IGBcbiNpbmNsdWRlIDxub2lzZT5cbiNpbmNsdWRlIDxkZWd1TWF0aGY+XG51bmlmb3JtIGZsb2F0IHVfdGltZTtcblxudmFyeWluZyBmbG9hdCB2X25vaXNlO1xudmFyeWluZyB2ZWMyIHZVdjtcbnZvaWQgbWFpbigpIHtcblxuXG4gICAgLy8g5pmu6YCa44Gr44GT44KM44Gn44KC44GE44GE44GM44K144Oz44OX44Or55So44Gr44OO44O844Oe44Or44KS5LiL6KiY44Gn44GX44KI44GGXG4gICAgLy8gVW5ldW5lIGJhbGwgcG9pXG4gICAgLy8gZmxvYXQgYXJtcyA9IDAuMDU7XG4gICAgLy8gZmxvYXQgYiA9IDUuMCAqIHBub2lzZSAoYXJtcyAqIHBvc2l0aW9uICsgdV90aW1lLCB2ZWMzKDEwMC4wKSk7XG5cbiAgICAvLyBTcGlrZVxuICAgIC8vIGZsb2F0IGIgPSBwbm9pc2UgKHBvc2l0aW9uICsgdV90aW1lLCB2ZWMzKDEwMC4wKSkgKiA1LjA7XG5cbiAgICAvLyBCcmVhdGhpbmdcbiAgICBmbG9hdCBhcm1zID0gMC4wMzI7XG4gICAgdl9ub2lzZSA9IDEwLjAgKiAtMC4xICogdHVyYnVsZW5jZSgwLjUgKiBub3JtYWwgKyB1X3RpbWUgKiAwLjIpO1xuICAgIGZsb2F0IGIgPSBwbm9pc2UgKGFybXMgKiBwb3NpdGlvbiArIHVfdGltZSwgdmVjMygxMDAuMCkpICogKChub3JtYWxpemVkU2luKHVfdGltZSAqIDAuNSkgKyAxLjApICogMTAuMCk7XG4gICAgZmxvYXQgZGlzcGxhY2VtZW50ID0gYiAtIDEwLjAgKiB2X25vaXNlO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGEgZGlzcGxhbmNlbWVudCBhbW91bnQgd2l0aCBub3JtYWwuXG4gICAgLy8gaHR0cHM6Ly93d3cudWRlbXkuY29tL2NvdXJzZS9sZWFybi1nbHNsLXNoYWRlcnMtZnJvbS1zY3JhdGNoL2xlYXJuL2xlY3R1cmUvMTM3MzkxOTYjcXVlc3Rpb25zLzg3NTMxODZcbiAgICAvLyB2X25vaXNlID0gMTAuMCAqIC0wLjEgKiB0dXJidWxlbmNlKDAuNSAqIG5vcm1hbCArIHVfdGltZSk7XG4gICAgLy8gZmxvYXQgYiA9IDUuMCAqIHBub2lzZSAoMC4wNSAqIHBvc2l0aW9uLCB2ZWMzKDEwMC4wKSk7XG4gICAgLy8gZmxvYXQgZGlzcGxhY2VtZW50ID0gYiAtIDEwLjAgKiB2X25vaXNlO1xuXG4gICAgdmVjMyBwb3MgPSBwb3NpdGlvbiArIG5vcm1hbCAqIGRpc3BsYWNlbWVudDtcbiAgICB2VXYgPSB1djtcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3MsIDEuMCApO1xufVxuYDtcbmNvbnN0IGZzaGFkZXIgPSBgXG4jaW5jbHVkZSA8bm9pc2U+XG4jaW5jbHVkZSA8ZGVndU1hdGhmPlxuI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU4OVxuI2RlZmluZSBQSTIgNi4yODMxODUzMDcxOFxuXG51bmlmb3JtIHZlYzIgdV9tb3VzZTtcbnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XG51bmlmb3JtIGZsb2F0IHVfdGltZTtcbnVuaWZvcm0gdmVjMyB1X2NvbG9yO1xudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXg7XG5cblxudmFyeWluZyB2ZWMyIHZVdjtcbnZhcnlpbmcgZmxvYXQgdl9ub2lzZTtcbnZvaWQgbWFpbigpXG57XG4gIC8vIGdldCBhIHJhbmRvbSBvZmZzZXRcbiAgZmxvYXQgciA9IC4wMSAqIHJhbmRvbSggZ2xfRnJhZ0Nvb3JkLnh5eiwgMC4wICk7XG4gIC8vIGxvb2t1cCB2ZXJ0aWNhbGx5IGluIHRoZSB0ZXh0dXJlLCB1c2luZyBub2lzZSBhbmQgb2Zmc2V0XG4gIC8vIHRvIGdldCB0aGUgcmlnaHQgUkdCIGNvbG91clxuICAvLyBTbyByZWFsbHkgb25seSBjb25zaWRlciB0aGUgWSB2YWx1ZSBpbiB0aGUgdGV4dHVyZS5cbi8vICAgdmVjMiB1diA9IHZlYzIoIDAsIDEuMyAqIHZfbm9pc2UgKyByICk7XG5cbiAgLy8gU2ltcGxlIHZlcnNpb24uXG4gIC8vIFVzaW5nIGEgdl9ub2lzZSwgbG9vayB1cCBhIHNwZWNpZmljIHkgcG9pbnQgaW4gdGhlIHRleHR1cmVcbiAgLy8gYW5kIGRpc3BsYXkgdGhhdCBvdXQgdG8gdGhlIGN1cnJlbnQgcGl4ZWwuXG4gIHZlYzIgdXYgPSB2ZWMyKDAsIDEuMiAqIHZfbm9pc2UpO1xuICB2ZWMzIGNvbG9yID0gdGV4dHVyZTJEKCB1X3RleCwgdXYgKS5yZ2I7XG5cbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IsIDEuMCApO1xufVxuYDtcblxuY2xhc3MgR2xzbFBsYXlncm91bmQyNyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoLTEsIDEsIDEsIC0xLCAwLjEsIDEwKTtcbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg0NSwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDEsIDEwMDAwKTtcbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gMTAwOyAvLyBBZGQgc29tZSBsaWdodHMuXG5cbiAgICBjb25zdCBhbWJpZW50ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCgweEZGRkZGRiwgMHhGRkZGRkYsIDEpO1xuICAgIGNvbnN0IGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhGRkZGRkYsIDEpO1xuICAgIGxpZ2h0LnBvc2l0aW9uLnNldCgwLCA2LCAyKTtcbiAgICB0aGlzLnNjZW5lLmFkZChhbWJpZW50KTtcbiAgICB0aGlzLnNjZW5lLmFkZChsaWdodCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLmdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoMjAsIDQpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICB1X3RpbWU6IHtcbiAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgfSxcbiAgICAgIHVfbW91c2U6IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB4OiAwLjAsXG4gICAgICAgICAgeTogMC4wXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1X3Jlc29sdXRpb246IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVfY29sb3I6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweGI3ZmYwMClcbiAgICAgIH0sXG4gICAgICB1X3RleDoge1xuICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKFwiL3B1YmxpYy9leHBsb3Npb24ucG5nXCIpXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zb2xlLmxvZygndW5pZm9ybXMnKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnVuaWZvcm1zKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgdmVydGV4U2hhZGVyOiB2c2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzaGFkZXIgLy8gd2lyZWZyYW1lOiB0cnVlXG5cbiAgICB9KTtcbiAgICB0aGlzLmJhbGwgPSBuZXcgVEhSRUUuTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLmJhbGwpO1xuICAgIHRoaXMuY29udHJvbHMgPSBuZXcgX09yYml0Q29udHJvbHMuT3JiaXRDb250cm9scyh0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgfVxuXG4gIG9uUmVzaXplKCkge1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBpZiAoYXNwZWN0UmF0aW8gPj0gMSkge1xuICAgICAgd2lkdGggPSAxO1xuICAgICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC8gd2luZG93LmlubmVyV2lkdGggKiB3aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBhc3BlY3RSYXRpbztcbiAgICAgIGhlaWdodCA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5jYW1lcmEubGVmdCA9IC13aWR0aDtcbiAgICB0aGlzLmNhbWVyYS5yaWdodCA9IHdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnRvcCA9IGhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS5ib3R0b20gPSAtaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnkgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIH1cblxuICBvbk1vdXNlTW92ZShldnQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WCA6IGV2dC5jbGllbnRYO1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS55ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRZIDogZXZ0LmNsaWVudFk7XG4gIH1cblxuICBvblJhZihkZWx0YSkge1xuICAgIGlmICh0aGlzLnVuaWZvcm1zKSB7XG4gICAgICB0aGlzLnVuaWZvcm1zLnVfdGltZS52YWx1ZSArPSB0aGlzLnJhZi5nZXREZWx0YSh0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdsc2xQbGF5Z3JvdW5kMjc7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/glsl-playground27.js\n");

/***/ }),

/***/ "./examples/glsl-playground28.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground28.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _OrbitControls = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _deguMathf = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/degu-mathf */ \"./lib/shaders/three-shader-chunks/degu-mathf.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739214\n//\n// Import shader chunks\n(0, _deguMathf.deguMathf)(THREE); // Extends: https://github.com/mrdoob/three.js/blob/master/src/renderers/shaders/ShaderLib/meshlambert_vert.glsl.js\n\nconst vshader = `\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n\n\nvarying vec3 vPosition;\nvarying mat4 vModelMatrix;\nvarying vec3 vWorldNormal;\nvarying vec3 vLightIntensity;\n\nvoid main() {\n    vec3 vLightFront;\n    vec3 vIndirectFront;\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n    // Save light intenity.\n    vLightIntensity = vLightFront + ambientLightColor;\n\n    vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);\n    vPosition = position;\n    vModelMatrix = modelMatrix;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\n#include <deguMathf>\nuniform vec3 u_color;\nuniform vec3 u_light_position;\nuniform vec3 u_rim_color;\nuniform float u_rim_strength;\nuniform float u_rim_width;\nuniform float u_time;\n\n// Example varyings passed from the vertex shader\nvarying vec3 vPosition;\nvarying vec3 vWorldNormal;\nvarying mat4 vModelMatrix;\nvarying vec3 vLightIntensity;\n\nvoid main()\n{\n\n  // Get the world position (not model)\n  vec3 worldPosition = ( vModelMatrix * vec4( vPosition, 1.0 )).xyz;\n\n  // Get the normalized light vector since we want direction not distance.\n  vec3 lightVector = normalize( u_light_position - worldPosition );\n\n  // Get the normalized view vector since we want direction not distance.\n\n  vec3 viewVector = normalize(cameraPosition - worldPosition);\n\n  // dot(a,b) = cos(theta)\n\n  // cos of 90 degrees. cos(PI/2) = 0.0.\n  float rightAngle = 0.0;\n\n  // Change the angle based on time so that we get a glow going in and out\n  float pulseRate = 5.0;\n  rightAngle += normalizedSin(u_time * pulseRate);\n\n  float rimndotv =  max(0.0, u_rim_width - clamp(dot(vWorldNormal, viewVector), rightAngle, 1.0));\n\n  vec3 rimLight = rimndotv * u_rim_color * u_rim_strength;\n  vec3 color = vLightIntensity * u_color + rimLight;\n\n  gl_FragColor = vec4( color, 1.0 );\n\n}\n`;\n\nclass GlslPlayground28 {\n  constructor() {\n    this.scene = new THREE.Scene();\n    this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);\n    this.camera.position.z = 10; // Add some lights.\n\n    const light = new THREE.DirectionalLight(0xffda6f, 0.1);\n    light.position.set(0, 1.25, 1.25);\n    this.scene.add(light);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.geometry = new THREE.TorusKnotGeometry(1, 0.5, 100, 16);\n    this.uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib[\"common\"], THREE.UniformsLib[\"lights\"]]);\n    this.uniforms.u_color = {\n      value: new THREE.Color(0xa6e4fa)\n    };\n    this.uniforms.u_light_position = {\n      value: light.position.clone()\n    };\n    this.uniforms.u_rim_color = {\n      value: new THREE.Color(0xffffff)\n    };\n    this.uniforms.u_rim_strength = {\n      value: 3.6\n    };\n    this.uniforms.u_rim_width = {\n      value: 0.6\n    };\n    this.uniforms.u_resolution = {\n      value: {\n        x: 0.0,\n        y: 0.0\n      }\n    };\n    this.uniforms.u_time = {\n      value: 0.0\n    };\n    console.log('uniforms');\n    console.log(this.uniforms);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader,\n      lights: true,\n      wireframe: false\n    });\n    this.knot = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.knot);\n    this.controls = new _OrbitControls.OrbitControls(this.camera, this.renderer.domElement);\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground28;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQyOC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDI4LmpzPzE3NDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfT3JiaXRDb250cm9scyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9sc1wiKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS13YXRjaGVyXCIpO1xuXG52YXIgX2RlZ3VNYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvc2hhZGVycy90aHJlZS1zaGFkZXItY2h1bmtzL2RlZ3UtbWF0aGZcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLy9cbi8vXG4vLyBodHRwczovL3d3dy51ZGVteS5jb20vY291cnNlL2xlYXJuLWdsc2wtc2hhZGVycy1mcm9tLXNjcmF0Y2gvbGVhcm4vbGVjdHVyZS8xMzczOTIxNFxuLy9cbi8vIEltcG9ydCBzaGFkZXIgY2h1bmtzXG4oMCwgX2RlZ3VNYXRoZi5kZWd1TWF0aGYpKFRIUkVFKTsgLy8gRXh0ZW5kczogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iL21hc3Rlci9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyTGliL21lc2hsYW1iZXJ0X3ZlcnQuZ2xzbC5qc1xuXG5jb25zdCB2c2hhZGVyID0gYFxuI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGJzZGZzPlxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxuXG5cblxudmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcbnZhcnlpbmcgbWF0NCB2TW9kZWxNYXRyaXg7XG52YXJ5aW5nIHZlYzMgdldvcmxkTm9ybWFsO1xudmFyeWluZyB2ZWMzIHZMaWdodEludGVuc2l0eTtcblxudm9pZCBtYWluKCkge1xuICAgIHZlYzMgdkxpZ2h0RnJvbnQ7XG4gICAgdmVjMyB2SW5kaXJlY3RGcm9udDtcblx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cblx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cblx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxuXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxuXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxuXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxuXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxuXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxuXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cblx0I2luY2x1ZGUgPGxpZ2h0c19sYW1iZXJ0X3ZlcnRleD5cblx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxuXG4gICAgLy8gU2F2ZSBsaWdodCBpbnRlbml0eS5cbiAgICB2TGlnaHRJbnRlbnNpdHkgPSB2TGlnaHRGcm9udCArIGFtYmllbnRMaWdodENvbG9yO1xuXG4gICAgdldvcmxkTm9ybWFsID0gbm9ybWFsaXplKChtb2RlbE1hdHJpeCAqIHZlYzQobm9ybWFsLCAwLjApKS54eXopO1xuICAgIHZQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHZNb2RlbE1hdHJpeCA9IG1vZGVsTWF0cml4O1xuXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xufVxuYDtcbmNvbnN0IGZzaGFkZXIgPSBgXG4jaW5jbHVkZSA8ZGVndU1hdGhmPlxudW5pZm9ybSB2ZWMzIHVfY29sb3I7XG51bmlmb3JtIHZlYzMgdV9saWdodF9wb3NpdGlvbjtcbnVuaWZvcm0gdmVjMyB1X3JpbV9jb2xvcjtcbnVuaWZvcm0gZmxvYXQgdV9yaW1fc3RyZW5ndGg7XG51bmlmb3JtIGZsb2F0IHVfcmltX3dpZHRoO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG5cbi8vIEV4YW1wbGUgdmFyeWluZ3MgcGFzc2VkIGZyb20gdGhlIHZlcnRleCBzaGFkZXJcbnZhcnlpbmcgdmVjMyB2UG9zaXRpb247XG52YXJ5aW5nIHZlYzMgdldvcmxkTm9ybWFsO1xudmFyeWluZyBtYXQ0IHZNb2RlbE1hdHJpeDtcbnZhcnlpbmcgdmVjMyB2TGlnaHRJbnRlbnNpdHk7XG5cbnZvaWQgbWFpbigpXG57XG5cbiAgLy8gR2V0IHRoZSB3b3JsZCBwb3NpdGlvbiAobm90IG1vZGVsKVxuICB2ZWMzIHdvcmxkUG9zaXRpb24gPSAoIHZNb2RlbE1hdHJpeCAqIHZlYzQoIHZQb3NpdGlvbiwgMS4wICkpLnh5ejtcblxuICAvLyBHZXQgdGhlIG5vcm1hbGl6ZWQgbGlnaHQgdmVjdG9yIHNpbmNlIHdlIHdhbnQgZGlyZWN0aW9uIG5vdCBkaXN0YW5jZS5cbiAgdmVjMyBsaWdodFZlY3RvciA9IG5vcm1hbGl6ZSggdV9saWdodF9wb3NpdGlvbiAtIHdvcmxkUG9zaXRpb24gKTtcblxuICAvLyBHZXQgdGhlIG5vcm1hbGl6ZWQgdmlldyB2ZWN0b3Igc2luY2Ugd2Ugd2FudCBkaXJlY3Rpb24gbm90IGRpc3RhbmNlLlxuXG4gIHZlYzMgdmlld1ZlY3RvciA9IG5vcm1hbGl6ZShjYW1lcmFQb3NpdGlvbiAtIHdvcmxkUG9zaXRpb24pO1xuXG4gIC8vIGRvdChhLGIpID0gY29zKHRoZXRhKVxuXG4gIC8vIGNvcyBvZiA5MCBkZWdyZWVzLiBjb3MoUEkvMikgPSAwLjAuXG4gIGZsb2F0IHJpZ2h0QW5nbGUgPSAwLjA7XG5cbiAgLy8gQ2hhbmdlIHRoZSBhbmdsZSBiYXNlZCBvbiB0aW1lIHNvIHRoYXQgd2UgZ2V0IGEgZ2xvdyBnb2luZyBpbiBhbmQgb3V0XG4gIGZsb2F0IHB1bHNlUmF0ZSA9IDUuMDtcbiAgcmlnaHRBbmdsZSArPSBub3JtYWxpemVkU2luKHVfdGltZSAqIHB1bHNlUmF0ZSk7XG5cbiAgZmxvYXQgcmltbmRvdHYgPSAgbWF4KDAuMCwgdV9yaW1fd2lkdGggLSBjbGFtcChkb3QodldvcmxkTm9ybWFsLCB2aWV3VmVjdG9yKSwgcmlnaHRBbmdsZSwgMS4wKSk7XG5cbiAgdmVjMyByaW1MaWdodCA9IHJpbW5kb3R2ICogdV9yaW1fY29sb3IgKiB1X3JpbV9zdHJlbmd0aDtcbiAgdmVjMyBjb2xvciA9IHZMaWdodEludGVuc2l0eSAqIHVfY29sb3IgKyByaW1MaWdodDtcblxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciwgMS4wICk7XG5cbn1cbmA7XG5cbmNsYXNzIEdsc2xQbGF5Z3JvdW5kMjgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNjAsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjEsIDEwMDApO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAxMDsgLy8gQWRkIHNvbWUgbGlnaHRzLlxuXG4gICAgY29uc3QgbGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweGZmZGE2ZiwgMC4xKTtcbiAgICBsaWdodC5wb3NpdGlvbi5zZXQoMCwgMS4yNSwgMS4yNSk7XG4gICAgdGhpcy5zY2VuZS5hZGQobGlnaHQpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgdGhpcy5yYWYgPSBuZXcgX3JhZi5SYWYodGhpcy5vblJhZi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIgPSBuZXcgX2RvbVdhdGNoZXIuRG9tV2F0Y2hlcigpO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdyZXNpemUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25SZXNpemUuYmluZCh0aGlzKSxcbiAgICAgIGV2ZW50T3B0aW9uczoge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeSgxLCAwLjUsIDEwMCwgMTYpO1xuICAgIHRoaXMudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKFtUSFJFRS5Vbmlmb3Jtc0xpYltcImNvbW1vblwiXSwgVEhSRUUuVW5pZm9ybXNMaWJbXCJsaWdodHNcIl1dKTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfY29sb3IgPSB7XG4gICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKDB4YTZlNGZhKVxuICAgIH07XG4gICAgdGhpcy51bmlmb3Jtcy51X2xpZ2h0X3Bvc2l0aW9uID0ge1xuICAgICAgdmFsdWU6IGxpZ2h0LnBvc2l0aW9uLmNsb25lKClcbiAgICB9O1xuICAgIHRoaXMudW5pZm9ybXMudV9yaW1fY29sb3IgPSB7XG4gICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKDB4ZmZmZmZmKVxuICAgIH07XG4gICAgdGhpcy51bmlmb3Jtcy51X3JpbV9zdHJlbmd0aCA9IHtcbiAgICAgIHZhbHVlOiAzLjZcbiAgICB9O1xuICAgIHRoaXMudW5pZm9ybXMudV9yaW1fd2lkdGggPSB7XG4gICAgICB2YWx1ZTogMC42XG4gICAgfTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbiA9IHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHg6IDAuMCxcbiAgICAgICAgeTogMC4wXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfdGltZSA9IHtcbiAgICAgIHZhbHVlOiAwLjBcbiAgICB9O1xuICAgIGNvbnNvbGUubG9nKCd1bmlmb3JtcycpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMudW5pZm9ybXMpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZzaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZnNoYWRlcixcbiAgICAgIGxpZ2h0czogdHJ1ZSxcbiAgICAgIHdpcmVmcmFtZTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLmtub3QgPSBuZXcgVEhSRUUuTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLmtub3QpO1xuICAgIHRoaXMuY29udHJvbHMgPSBuZXcgX09yYml0Q29udHJvbHMuT3JiaXRDb250cm9scyh0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgfVxuXG4gIG9uUmVzaXplKCkge1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBpZiAoYXNwZWN0UmF0aW8gPj0gMSkge1xuICAgICAgd2lkdGggPSAxO1xuICAgICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC8gd2luZG93LmlubmVyV2lkdGggKiB3aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBhc3BlY3RSYXRpbztcbiAgICAgIGhlaWdodCA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5jYW1lcmEubGVmdCA9IC13aWR0aDtcbiAgICB0aGlzLmNhbWVyYS5yaWdodCA9IHdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnRvcCA9IGhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS5ib3R0b20gPSAtaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnkgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIH1cblxuICBvblJhZihkZWx0YSkge1xuICAgIHRoaXMudW5pZm9ybXMudV90aW1lLnZhbHVlICs9IHRoaXMucmFmLmdldERlbHRhKHRydWUpO1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdsc2xQbGF5Z3JvdW5kMjg7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/glsl-playground28.js\n");

/***/ }),

/***/ "./examples/glsl-playground29.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground29.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _OrbitControls = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _deguMathf = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/degu-mathf */ \"./lib/shaders/three-shader-chunks/degu-mathf.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n//\n//\n// https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739244\n//\n// Import shader chunks\n(0, _deguMathf.deguMathf)(THREE); // Extends: https://github.com/mrdoob/three.js/blob/master/src/renderers/shaders/ShaderLib/meshlambert_vert.glsl.js\n\nconst vshader = `\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n\n\nvarying vec3 vPosition;\nvarying mat4 vModelMatrix;\nvarying vec3 vWorldNormal;\nvarying vec3 vLightIntensity;\n\nvoid main() {\n    vec3 vLightFront;\n    vec3 vIndirectFront;\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n    // Save light intenity.\n    vLightIntensity = vLightFront + ambientLightColor;\n\n    vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);\n    vPosition = position;\n    vModelMatrix = modelMatrix;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\n#include <deguMathf>\nuniform vec3 u_color;\nuniform vec3 u_light_position;\nuniform vec3 u_rim_color;\nuniform float u_rim_strength;\nuniform float u_rim_width;\nuniform float u_time;\n\n\nuniform samplerCube u_envmap_cube;\n// How much the envmap should affect the calculations.\nuniform float u_envmap_strength;\n\n// Example varyings passed from the vertex shader\nvarying vec3 vPosition;\nvarying vec3 vWorldNormal;\nvarying mat4 vModelMatrix;\nvarying vec3 vLightIntensity;\n\nvoid main()\n{\n\n  // Get the world position (not model)\n  vec3 worldPosition = ( vModelMatrix * vec4( vPosition, 1.0 )).xyz;\n\n  // Get the normalized light vector since we want direction not distance.\n  vec3 lightVector = normalize( u_light_position - worldPosition );\n\n  // Get the normalized view vector since we want direction not distance.\n\n  vec3 viewVector = normalize(cameraPosition - worldPosition);\n\n  // dot(a,b) = cos(theta)\n\n  // cos of 90 degrees. cos(PI/2) = 0.0.\n  float rightAngle = 0.0;\n\n  // Change the angle based on time so that we get a glow going in and out\n  float pulseRate = 5.0;\n  rightAngle += normalizedSin(u_time * pulseRate);\n\n  float rimndotv =  max(0.0, u_rim_width - clamp(dot(vWorldNormal, viewVector), rightAngle, 1.0));\n\n  vec3 rimLight = rimndotv * u_rim_color * u_rim_strength;\n\n\n  // Calculate the effects of the env map.\n  vec3 reflection = reflect(-viewVector, vWorldNormal);\n  vec3 envmapLight = textureCube(u_envmap_cube, reflection).rgb * u_envmap_strength;\n  // Pulse env map light strength.\n  envmapLight *= normalizedSin(u_time);\n\n\n  vec3 color = vLightIntensity * u_color + envmapLight + rimLight;\n\n  gl_FragColor = vec4( color, 1.0 );\n\n}\n`;\n\nclass GlslPlayground29 {\n  constructor() {\n    this.scene = new THREE.Scene();\n    this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);\n    this.camera.position.z = 10; // Add some lights.\n\n    const light = new THREE.DirectionalLight(0xffda6f, 0.1);\n    light.position.set(0, 1.25, 1.25);\n    this.scene.add(light);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.geometry = new THREE.TorusKnotGeometry(1, 0.5, 100, 16);\n    this.uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib[\"common\"], THREE.UniformsLib[\"lights\"]]);\n    this.uniforms.u_color = {\n      value: new THREE.Color(0xa6e4fa)\n    };\n    this.uniforms.u_light_position = {\n      value: light.position.clone()\n    };\n    this.uniforms.u_rim_color = {\n      value: new THREE.Color(0xffffff)\n    };\n    this.uniforms.u_rim_strength = {\n      value: 3.6\n    };\n    this.uniforms.u_rim_width = {\n      value: 0.6\n    };\n    this.uniforms.u_resolution = {\n      value: {\n        x: 0.0,\n        y: 0.0\n      }\n    };\n    this.uniforms.u_time = {\n      value: 0.0\n    }; // Add env\n\n    const envCube = new THREE.CubeTextureLoader().setPath('./public/').load(['skybox2_px.jpg', 'skybox2_nx.jpg', 'skybox2_py.jpg', 'skybox2_ny.jpg', 'skybox2_pz.jpg', 'skybox2_nz.jpg']);\n    this.uniforms.u_envmap_cube = {\n      value: envCube\n    };\n    this.uniforms.u_envmap_strength = {\n      value: 1.0\n    };\n    console.log('uniforms');\n    console.log(this.uniforms);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader,\n      lights: true,\n      wireframe: false\n    });\n    this.knot = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.knot);\n    this.controls = new _OrbitControls.OrbitControls(this.camera, this.renderer.domElement);\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground29;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQyOS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDI5LmpzP2M1MDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfT3JiaXRDb250cm9scyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9sc1wiKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS13YXRjaGVyXCIpO1xuXG52YXIgX2RlZ3VNYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvc2hhZGVycy90aHJlZS1zaGFkZXItY2h1bmtzL2RlZ3UtbWF0aGZcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLy9cbi8vXG4vLyBodHRwczovL3d3dy51ZGVteS5jb20vY291cnNlL2xlYXJuLWdsc2wtc2hhZGVycy1mcm9tLXNjcmF0Y2gvbGVhcm4vbGVjdHVyZS8xMzczOTI0NFxuLy9cbi8vIEltcG9ydCBzaGFkZXIgY2h1bmtzXG4oMCwgX2RlZ3VNYXRoZi5kZWd1TWF0aGYpKFRIUkVFKTsgLy8gRXh0ZW5kczogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iL21hc3Rlci9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyTGliL21lc2hsYW1iZXJ0X3ZlcnQuZ2xzbC5qc1xuXG5jb25zdCB2c2hhZGVyID0gYFxuI2luY2x1ZGUgPGNvbW1vbj5cbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGJzZGZzPlxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxuXG5cblxudmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcbnZhcnlpbmcgbWF0NCB2TW9kZWxNYXRyaXg7XG52YXJ5aW5nIHZlYzMgdldvcmxkTm9ybWFsO1xudmFyeWluZyB2ZWMzIHZMaWdodEludGVuc2l0eTtcblxudm9pZCBtYWluKCkge1xuICAgIHZlYzMgdkxpZ2h0RnJvbnQ7XG4gICAgdmVjMyB2SW5kaXJlY3RGcm9udDtcblx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cblx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cblx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxuXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxuXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxuXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxuXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxuXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxuXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cblx0I2luY2x1ZGUgPGxpZ2h0c19sYW1iZXJ0X3ZlcnRleD5cblx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XG5cdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxuXG4gICAgLy8gU2F2ZSBsaWdodCBpbnRlbml0eS5cbiAgICB2TGlnaHRJbnRlbnNpdHkgPSB2TGlnaHRGcm9udCArIGFtYmllbnRMaWdodENvbG9yO1xuXG4gICAgdldvcmxkTm9ybWFsID0gbm9ybWFsaXplKChtb2RlbE1hdHJpeCAqIHZlYzQobm9ybWFsLCAwLjApKS54eXopO1xuICAgIHZQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIHZNb2RlbE1hdHJpeCA9IG1vZGVsTWF0cml4O1xuXG4gICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xufVxuYDtcbmNvbnN0IGZzaGFkZXIgPSBgXG4jaW5jbHVkZSA8ZGVndU1hdGhmPlxudW5pZm9ybSB2ZWMzIHVfY29sb3I7XG51bmlmb3JtIHZlYzMgdV9saWdodF9wb3NpdGlvbjtcbnVuaWZvcm0gdmVjMyB1X3JpbV9jb2xvcjtcbnVuaWZvcm0gZmxvYXQgdV9yaW1fc3RyZW5ndGg7XG51bmlmb3JtIGZsb2F0IHVfcmltX3dpZHRoO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG5cblxudW5pZm9ybSBzYW1wbGVyQ3ViZSB1X2Vudm1hcF9jdWJlO1xuLy8gSG93IG11Y2ggdGhlIGVudm1hcCBzaG91bGQgYWZmZWN0IHRoZSBjYWxjdWxhdGlvbnMuXG51bmlmb3JtIGZsb2F0IHVfZW52bWFwX3N0cmVuZ3RoO1xuXG4vLyBFeGFtcGxlIHZhcnlpbmdzIHBhc3NlZCBmcm9tIHRoZSB2ZXJ0ZXggc2hhZGVyXG52YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xudmFyeWluZyB2ZWMzIHZXb3JsZE5vcm1hbDtcbnZhcnlpbmcgbWF0NCB2TW9kZWxNYXRyaXg7XG52YXJ5aW5nIHZlYzMgdkxpZ2h0SW50ZW5zaXR5O1xuXG52b2lkIG1haW4oKVxue1xuXG4gIC8vIEdldCB0aGUgd29ybGQgcG9zaXRpb24gKG5vdCBtb2RlbClcbiAgdmVjMyB3b3JsZFBvc2l0aW9uID0gKCB2TW9kZWxNYXRyaXggKiB2ZWM0KCB2UG9zaXRpb24sIDEuMCApKS54eXo7XG5cbiAgLy8gR2V0IHRoZSBub3JtYWxpemVkIGxpZ2h0IHZlY3RvciBzaW5jZSB3ZSB3YW50IGRpcmVjdGlvbiBub3QgZGlzdGFuY2UuXG4gIHZlYzMgbGlnaHRWZWN0b3IgPSBub3JtYWxpemUoIHVfbGlnaHRfcG9zaXRpb24gLSB3b3JsZFBvc2l0aW9uICk7XG5cbiAgLy8gR2V0IHRoZSBub3JtYWxpemVkIHZpZXcgdmVjdG9yIHNpbmNlIHdlIHdhbnQgZGlyZWN0aW9uIG5vdCBkaXN0YW5jZS5cblxuICB2ZWMzIHZpZXdWZWN0b3IgPSBub3JtYWxpemUoY2FtZXJhUG9zaXRpb24gLSB3b3JsZFBvc2l0aW9uKTtcblxuICAvLyBkb3QoYSxiKSA9IGNvcyh0aGV0YSlcblxuICAvLyBjb3Mgb2YgOTAgZGVncmVlcy4gY29zKFBJLzIpID0gMC4wLlxuICBmbG9hdCByaWdodEFuZ2xlID0gMC4wO1xuXG4gIC8vIENoYW5nZSB0aGUgYW5nbGUgYmFzZWQgb24gdGltZSBzbyB0aGF0IHdlIGdldCBhIGdsb3cgZ29pbmcgaW4gYW5kIG91dFxuICBmbG9hdCBwdWxzZVJhdGUgPSA1LjA7XG4gIHJpZ2h0QW5nbGUgKz0gbm9ybWFsaXplZFNpbih1X3RpbWUgKiBwdWxzZVJhdGUpO1xuXG4gIGZsb2F0IHJpbW5kb3R2ID0gIG1heCgwLjAsIHVfcmltX3dpZHRoIC0gY2xhbXAoZG90KHZXb3JsZE5vcm1hbCwgdmlld1ZlY3RvciksIHJpZ2h0QW5nbGUsIDEuMCkpO1xuXG4gIHZlYzMgcmltTGlnaHQgPSByaW1uZG90diAqIHVfcmltX2NvbG9yICogdV9yaW1fc3RyZW5ndGg7XG5cblxuICAvLyBDYWxjdWxhdGUgdGhlIGVmZmVjdHMgb2YgdGhlIGVudiBtYXAuXG4gIHZlYzMgcmVmbGVjdGlvbiA9IHJlZmxlY3QoLXZpZXdWZWN0b3IsIHZXb3JsZE5vcm1hbCk7XG4gIHZlYzMgZW52bWFwTGlnaHQgPSB0ZXh0dXJlQ3ViZSh1X2Vudm1hcF9jdWJlLCByZWZsZWN0aW9uKS5yZ2IgKiB1X2Vudm1hcF9zdHJlbmd0aDtcbiAgLy8gUHVsc2UgZW52IG1hcCBsaWdodCBzdHJlbmd0aC5cbiAgZW52bWFwTGlnaHQgKj0gbm9ybWFsaXplZFNpbih1X3RpbWUpO1xuXG5cbiAgdmVjMyBjb2xvciA9IHZMaWdodEludGVuc2l0eSAqIHVfY29sb3IgKyBlbnZtYXBMaWdodCArIHJpbUxpZ2h0O1xuXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLCAxLjAgKTtcblxufVxuYDtcblxuY2xhc3MgR2xzbFBsYXlncm91bmQyOSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg2MCwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDAuMSwgMTAwMCk7XG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiA9IDEwOyAvLyBBZGQgc29tZSBsaWdodHMuXG5cbiAgICBjb25zdCBsaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZkYTZmLCAwLjEpO1xuICAgIGxpZ2h0LnBvc2l0aW9uLnNldCgwLCAxLjI1LCAxLjI1KTtcbiAgICB0aGlzLnNjZW5lLmFkZChsaWdodCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KDEsIDAuNSwgMTAwLCAxNik7XG4gICAgdGhpcy51bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoW1RIUkVFLlVuaWZvcm1zTGliW1wiY29tbW9uXCJdLCBUSFJFRS5Vbmlmb3Jtc0xpYltcImxpZ2h0c1wiXV0pO1xuICAgIHRoaXMudW5pZm9ybXMudV9jb2xvciA9IHtcbiAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoMHhhNmU0ZmEpXG4gICAgfTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbGlnaHRfcG9zaXRpb24gPSB7XG4gICAgICB2YWx1ZTogbGlnaHQucG9zaXRpb24uY2xvbmUoKVxuICAgIH07XG4gICAgdGhpcy51bmlmb3Jtcy51X3JpbV9jb2xvciA9IHtcbiAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoMHhmZmZmZmYpXG4gICAgfTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmltX3N0cmVuZ3RoID0ge1xuICAgICAgdmFsdWU6IDMuNlxuICAgIH07XG4gICAgdGhpcy51bmlmb3Jtcy51X3JpbV93aWR0aCA9IHtcbiAgICAgIHZhbHVlOiAwLjZcbiAgICB9O1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uID0ge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgeDogMC4wLFxuICAgICAgICB5OiAwLjBcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudW5pZm9ybXMudV90aW1lID0ge1xuICAgICAgdmFsdWU6IDAuMFxuICAgIH07IC8vIEFkZCBlbnZcblxuICAgIGNvbnN0IGVudkN1YmUgPSBuZXcgVEhSRUUuQ3ViZVRleHR1cmVMb2FkZXIoKS5zZXRQYXRoKCcuL3B1YmxpYy8nKS5sb2FkKFsnc2t5Ym94Ml9weC5qcGcnLCAnc2t5Ym94Ml9ueC5qcGcnLCAnc2t5Ym94Ml9weS5qcGcnLCAnc2t5Ym94Ml9ueS5qcGcnLCAnc2t5Ym94Ml9wei5qcGcnLCAnc2t5Ym94Ml9uei5qcGcnXSk7XG4gICAgdGhpcy51bmlmb3Jtcy51X2Vudm1hcF9jdWJlID0ge1xuICAgICAgdmFsdWU6IGVudkN1YmVcbiAgICB9O1xuICAgIHRoaXMudW5pZm9ybXMudV9lbnZtYXBfc3RyZW5ndGggPSB7XG4gICAgICB2YWx1ZTogMS4wXG4gICAgfTtcbiAgICBjb25zb2xlLmxvZygndW5pZm9ybXMnKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnVuaWZvcm1zKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgdmVydGV4U2hhZGVyOiB2c2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzaGFkZXIsXG4gICAgICBsaWdodHM6IHRydWUsXG4gICAgICB3aXJlZnJhbWU6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5rbm90ID0gbmV3IFRIUkVFLk1lc2godGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5rbm90KTtcbiAgICB0aGlzLmNvbnRyb2xzID0gbmV3IF9PcmJpdENvbnRyb2xzLk9yYml0Q29udHJvbHModGhpcy5jYW1lcmEsIHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgIHRoaXMucmFmLnN0YXJ0KCk7XG4gIH1cblxuICBvblJlc2l6ZSgpIHtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgaWYgKGFzcGVjdFJhdGlvID49IDEpIHtcbiAgICAgIHdpZHRoID0gMTtcbiAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAvIHdpbmRvdy5pbm5lcldpZHRoICogd2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gYXNwZWN0UmF0aW87XG4gICAgICBoZWlnaHQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuY2FtZXJhLmxlZnQgPSAtd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEucmlnaHQgPSB3aWR0aDtcbiAgICB0aGlzLmNhbWVyYS50b3AgPSBoZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEuYm90dG9tID0gLWhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS55ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICB9XG5cbiAgb25SYWYoZGVsdGEpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfdGltZS52YWx1ZSArPSB0aGlzLnJhZi5nZXREZWx0YSh0cnVlKTtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBHbHNsUGxheWdyb3VuZDI5OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/glsl-playground29.js\n");

/***/ }),

/***/ "./examples/glsl-playground3.js":
/*!**************************************!*\
  !*** ./examples/glsl-playground3.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n/**\n * https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram\n * https://gist.github.com/uxder/cc02c445c2f7b4679e48e91d2920c832\n */\nconst vshader = `\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nvoid main (void)\n{\n  vec3 color = vec3(\n      // Sin returns values between -1 and 1 and we want 0-1.\n      // So we first do sin(time) + 1.0 which gives us a value between 0 and 2.\n      // We divide that by 2 (half it) so that it normalizes to 0-1.\n      (sin(u_time) + 1.0) / 2.0,\n      (sin(u_time) + 1.0) / 2.0,\n      (cos(u_time) + 1.0) / 2.0\n  );\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground3 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color: {\n        value: new THREE.Color(0xff0000)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground3;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvZ2xzbC1wbGF5Z3JvdW5kMy5qcz8zMjU4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX3JhZiA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZlwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLyoqXG4gKiBodHRwczovL3RocmVlanMub3JnL2RvY3MvI2FwaS9lbi9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9ncmFtXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS91eGRlci9jYzAyYzQ0NWMyZjdiNDY3OWU0OGU5MWQyOTIwYzgzMlxuICovXG5jb25zdCB2c2hhZGVyID0gYFxudm9pZCBtYWluKCkge1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbnVuaWZvcm0gdmVjMiB1X21vdXNlO1xudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gdmVjMyB1X2NvbG9yO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG5cbnZvaWQgbWFpbiAodm9pZClcbntcbiAgdmVjMyBjb2xvciA9IHZlYzMoXG4gICAgICAvLyBTaW4gcmV0dXJucyB2YWx1ZXMgYmV0d2VlbiAtMSBhbmQgMSBhbmQgd2Ugd2FudCAwLTEuXG4gICAgICAvLyBTbyB3ZSBmaXJzdCBkbyBzaW4odGltZSkgKyAxLjAgd2hpY2ggZ2l2ZXMgdXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDIuXG4gICAgICAvLyBXZSBkaXZpZGUgdGhhdCBieSAyIChoYWxmIGl0KSBzbyB0aGF0IGl0IG5vcm1hbGl6ZXMgdG8gMC0xLlxuICAgICAgKHNpbih1X3RpbWUpICsgMS4wKSAvIDIuMCxcbiAgICAgIChzaW4odV90aW1lKSArIDEuMCkgLyAyLjAsXG4gICAgICAoY29zKHVfdGltZSkgKyAxLjApIC8gMi4wXG4gICk7XG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuMCk7XG59XG5gO1xuXG5jbGFzcyBHbHNsUGxheWdyb3VuZDMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vIDJ4MlxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMC4xLCAxMCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgdV9jb2xvcjoge1xuICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKDB4ZmYwMDAwKVxuICAgICAgfSxcbiAgICAgIC8vIEZsb2F0XG4gICAgICB1X3RpbWU6IHtcbiAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgfSxcbiAgICAgIC8vIFZlYzIgMCwwIGF0IHRvcCwgbGVmdCBhbmQgd2luZG93LmlubmVyV2lkdGggYW5kIHdpbmRvdy5pbm5lckhlaWdodCBhdCBib3R0b20gcmlnaHQuXG4gICAgICB1X21vdXNlOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMC4wLFxuICAgICAgICAgIHk6IDAuMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVmVjMiBTY3JlZW4gcmVzb2x1dGlvblxuICAgICAgdV9yZXNvbHV0aW9uOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvLyAyeDIgc28gaXQgZmlsbCB0aGUgc2NyZWVuLlxuXG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDIsIDIpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZzaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZnNoYWRlclxuICAgIH0pOyAvLyBDcmVhdGUgbWVzaCAoZ2VvbSArIG1hdGVyaWFsKVxuXG4gICAgdGhpcy5wbGFuZSA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMucGxhbmUpO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAxO1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGlmIChhc3BlY3RSYXRpbyA+PSAxKSB7XG4gICAgICB3aWR0aCA9IDE7XG4gICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB3aW5kb3cuaW5uZXJXaWR0aCAqIHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdFJhdGlvO1xuICAgICAgaGVpZ2h0ID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbWVyYS5sZWZ0ID0gLXdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnJpZ2h0ID0gd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEudG9wID0gaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLmJvdHRvbSA9IC1oZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS54ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGV2dCkge1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS54ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRYIDogZXZ0LmNsaWVudFg7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnkgPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFkgOiBldnQuY2xpZW50WTtcbiAgfVxuXG4gIG9uUmFmKGRlbHRhKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X3RpbWUudmFsdWUgKz0gdGhpcy5yYWYuZ2V0RGVsdGEodHJ1ZSk7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gR2xzbFBsYXlncm91bmQzOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/glsl-playground3.js\n");

/***/ }),

/***/ "./examples/glsl-playground30.js":
/*!***************************************!*\
  !*** ./examples/glsl-playground30.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _OrbitControls = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _deguMathf = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/degu-mathf */ \"./lib/shaders/three-shader-chunks/degu-mathf.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n/**\n *\n * https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739236#questions/8753186\n *\n * - normals are importing in lightin calcs\n * - three js does this but this sample is of doing a manual bump map.\n * - use the dot product of the normal and light vectors to determine the light intensity.\n * - We use directional light, the ligth position is unimportant.\n *\n *\n *\n */\n// Import shader chunks\n(0, _deguMathf.deguMathf)(THREE); // Extends: https://github.com/mrdoob/three.js/blob/master/src/renderers/shaders/ShaderLib/meshlambert_vert.glsl.js\n\nconst vshader = `\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying mat4 vModelMatrix;\n\nvoid main() {\n    vUv = uv;\n    vNormal = normal;\n    vModelMatrix = modelMatrix;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\n#include <deguMathf>\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying mat4 vModelMatrix;\n\nuniform vec3 u_light;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\nuniform sampler2D u_diffuse_map;\nuniform sampler2D u_normal_map;\n\nvoid main(){\n  // Normalize light vecture.\n  vec3 lightVector = normalize(u_light);\n\n  // Normal map.\n  vec4 normal = texture2D(u_normal_map, vUv);\n\n  // Get the normal vector from the modelMatrix.\n  vec3 normalVector = normalize((vModelMatrix * (normal + vec4(vNormal, 1.0))).xyz);\n\n  // Get the dot product, clmap it so it ranges from 0-1.\n  float lightIntensity = clamp(0.0, 1.0, dot(lightVector, normalVector)) + 0.2;\n\n  // Add some pulsing to the light intensity.\n  lightIntensity *= (normalizedSin(u_time) * 2.0);\n\n  // Get the texel (current pixel color from the diffuse map)\n  vec3 texel = texture2D(u_diffuse_map, vUv).rgb;\n\n  // Set the light intensity.\n  vec3 color = lightIntensity * texel;\n\n  // Output\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground30 {\n  constructor() {\n    this.scene = new THREE.Scene();\n    this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);\n    this.camera.position.z = 2; // Add some lights.\n\n    const light = new THREE.DirectionalLight(0xffda6f, 0.1);\n    light.position.set(0, 1.25, 1.25);\n    this.scene.add(light);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.geometry = new THREE.BoxGeometry(1, 1, 1);\n    this.uniforms = {};\n    this.uniforms.u_light = {\n      value: new THREE.Vector3(0.5, 0.8, 0.1)\n    };\n    this.uniforms.u_resolution = {\n      value: new THREE.Vector2(1.0, 1.0)\n    };\n    this.uniforms.u_color = {\n      value: new THREE.Color(0xaa6611)\n    };\n    this.uniforms.u_diffuse_map = {\n      value: new THREE.TextureLoader().load('./public/bricks-diffuse3.png')\n    };\n    this.uniforms.u_normal_map = {\n      value: new THREE.TextureLoader().load('./public/bricks-normal3.png')\n    };\n    this.uniforms.u_time = {\n      value: 0.0\n    };\n    this.uniforms.u_resolution = {\n      value: {\n        x: 0.0,\n        y: 0.0\n      }\n    };\n    console.log('uniforms');\n    console.log(this.uniforms);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader,\n      lights: false,\n      wireframe: false\n    });\n    this.box = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.box);\n    this.controls = new _OrbitControls.OrbitControls(this.camera, this.renderer.domElement);\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onRaf() {\n    if (this.uniforms) {\n      this.uniforms.u_time.value += this.raf.getDelta(true);\n    }\n\n    if (this.renderer) {\n      this.renderer.render(this.scene, this.camera);\n    }\n  }\n\n}\n\nexports.default = GlslPlayground30;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQzMC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2dsc2wtcGxheWdyb3VuZDMwLmpzP2NjZjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfT3JiaXRDb250cm9scyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9sc1wiKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS13YXRjaGVyXCIpO1xuXG52YXIgX2RlZ3VNYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvc2hhZGVycy90aHJlZS1zaGFkZXItY2h1bmtzL2RlZ3UtbWF0aGZcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLyoqXG4gKlxuICogaHR0cHM6Ly93d3cudWRlbXkuY29tL2NvdXJzZS9sZWFybi1nbHNsLXNoYWRlcnMtZnJvbS1zY3JhdGNoL2xlYXJuL2xlY3R1cmUvMTM3MzkyMzYjcXVlc3Rpb25zLzg3NTMxODZcbiAqXG4gKiAtIG5vcm1hbHMgYXJlIGltcG9ydGluZyBpbiBsaWdodGluIGNhbGNzXG4gKiAtIHRocmVlIGpzIGRvZXMgdGhpcyBidXQgdGhpcyBzYW1wbGUgaXMgb2YgZG9pbmcgYSBtYW51YWwgYnVtcCBtYXAuXG4gKiAtIHVzZSB0aGUgZG90IHByb2R1Y3Qgb2YgdGhlIG5vcm1hbCBhbmQgbGlnaHQgdmVjdG9ycyB0byBkZXRlcm1pbmUgdGhlIGxpZ2h0IGludGVuc2l0eS5cbiAqIC0gV2UgdXNlIGRpcmVjdGlvbmFsIGxpZ2h0LCB0aGUgbGlndGggcG9zaXRpb24gaXMgdW5pbXBvcnRhbnQuXG4gKlxuICpcbiAqXG4gKi9cbi8vIEltcG9ydCBzaGFkZXIgY2h1bmtzXG4oMCwgX2RlZ3VNYXRoZi5kZWd1TWF0aGYpKFRIUkVFKTsgLy8gRXh0ZW5kczogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iL21hc3Rlci9zcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyTGliL21lc2hsYW1iZXJ0X3ZlcnQuZ2xzbC5qc1xuXG5jb25zdCB2c2hhZGVyID0gYFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XG52YXJ5aW5nIHZlYzIgdlV2O1xudmFyeWluZyBtYXQ0IHZNb2RlbE1hdHJpeDtcblxudm9pZCBtYWluKCkge1xuICAgIHZVdiA9IHV2O1xuICAgIHZOb3JtYWwgPSBub3JtYWw7XG4gICAgdk1vZGVsTWF0cml4ID0gbW9kZWxNYXRyaXg7XG5cbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbiNpbmNsdWRlIDxkZWd1TWF0aGY+XG52YXJ5aW5nIHZlYzIgdlV2O1xudmFyeWluZyB2ZWMzIHZOb3JtYWw7XG52YXJ5aW5nIG1hdDQgdk1vZGVsTWF0cml4O1xuXG51bmlmb3JtIHZlYzMgdV9saWdodDtcbnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XG51bmlmb3JtIHZlYzMgdV9jb2xvcjtcbnVuaWZvcm0gZmxvYXQgdV90aW1lO1xudW5pZm9ybSBzYW1wbGVyMkQgdV9kaWZmdXNlX21hcDtcbnVuaWZvcm0gc2FtcGxlcjJEIHVfbm9ybWFsX21hcDtcblxudm9pZCBtYWluKCl7XG4gIC8vIE5vcm1hbGl6ZSBsaWdodCB2ZWN0dXJlLlxuICB2ZWMzIGxpZ2h0VmVjdG9yID0gbm9ybWFsaXplKHVfbGlnaHQpO1xuXG4gIC8vIE5vcm1hbCBtYXAuXG4gIHZlYzQgbm9ybWFsID0gdGV4dHVyZTJEKHVfbm9ybWFsX21hcCwgdlV2KTtcblxuICAvLyBHZXQgdGhlIG5vcm1hbCB2ZWN0b3IgZnJvbSB0aGUgbW9kZWxNYXRyaXguXG4gIHZlYzMgbm9ybWFsVmVjdG9yID0gbm9ybWFsaXplKCh2TW9kZWxNYXRyaXggKiAobm9ybWFsICsgdmVjNCh2Tm9ybWFsLCAxLjApKSkueHl6KTtcblxuICAvLyBHZXQgdGhlIGRvdCBwcm9kdWN0LCBjbG1hcCBpdCBzbyBpdCByYW5nZXMgZnJvbSAwLTEuXG4gIGZsb2F0IGxpZ2h0SW50ZW5zaXR5ID0gY2xhbXAoMC4wLCAxLjAsIGRvdChsaWdodFZlY3Rvciwgbm9ybWFsVmVjdG9yKSkgKyAwLjI7XG5cbiAgLy8gQWRkIHNvbWUgcHVsc2luZyB0byB0aGUgbGlnaHQgaW50ZW5zaXR5LlxuICBsaWdodEludGVuc2l0eSAqPSAobm9ybWFsaXplZFNpbih1X3RpbWUpICogMi4wKTtcblxuICAvLyBHZXQgdGhlIHRleGVsIChjdXJyZW50IHBpeGVsIGNvbG9yIGZyb20gdGhlIGRpZmZ1c2UgbWFwKVxuICB2ZWMzIHRleGVsID0gdGV4dHVyZTJEKHVfZGlmZnVzZV9tYXAsIHZVdikucmdiO1xuXG4gIC8vIFNldCB0aGUgbGlnaHQgaW50ZW5zaXR5LlxuICB2ZWMzIGNvbG9yID0gbGlnaHRJbnRlbnNpdHkgKiB0ZXhlbDtcblxuICAvLyBPdXRwdXRcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcbn1cbmA7XG5cbmNsYXNzIEdsc2xQbGF5Z3JvdW5kMzAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNjAsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjEsIDEwMDApO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAyOyAvLyBBZGQgc29tZSBsaWdodHMuXG5cbiAgICBjb25zdCBsaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZkYTZmLCAwLjEpO1xuICAgIGxpZ2h0LnBvc2l0aW9uLnNldCgwLCAxLjI1LCAxLjI1KTtcbiAgICB0aGlzLnNjZW5lLmFkZChsaWdodCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDEsIDEsIDEpO1xuICAgIHRoaXMudW5pZm9ybXMgPSB7fTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbGlnaHQgPSB7XG4gICAgICB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjMoMC41LCAwLjgsIDAuMSlcbiAgICB9O1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uID0ge1xuICAgICAgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKDEuMCwgMS4wKVxuICAgIH07XG4gICAgdGhpcy51bmlmb3Jtcy51X2NvbG9yID0ge1xuICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweGFhNjYxMSlcbiAgICB9O1xuICAgIHRoaXMudW5pZm9ybXMudV9kaWZmdXNlX21hcCA9IHtcbiAgICAgIHZhbHVlOiBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoJy4vcHVibGljL2JyaWNrcy1kaWZmdXNlMy5wbmcnKVxuICAgIH07XG4gICAgdGhpcy51bmlmb3Jtcy51X25vcm1hbF9tYXAgPSB7XG4gICAgICB2YWx1ZTogbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKCcuL3B1YmxpYy9icmlja3Mtbm9ybWFsMy5wbmcnKVxuICAgIH07XG4gICAgdGhpcy51bmlmb3Jtcy51X3RpbWUgPSB7XG4gICAgICB2YWx1ZTogMC4wXG4gICAgfTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbiA9IHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHg6IDAuMCxcbiAgICAgICAgeTogMC4wXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zb2xlLmxvZygndW5pZm9ybXMnKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnVuaWZvcm1zKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgdmVydGV4U2hhZGVyOiB2c2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzaGFkZXIsXG4gICAgICBsaWdodHM6IGZhbHNlLFxuICAgICAgd2lyZWZyYW1lOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuYm94ID0gbmV3IFRIUkVFLk1lc2godGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5ib3gpO1xuICAgIHRoaXMuY29udHJvbHMgPSBuZXcgX09yYml0Q29udHJvbHMuT3JiaXRDb250cm9scyh0aGlzLmNhbWVyYSwgdGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgfVxuXG4gIG9uUmVzaXplKCkge1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBpZiAoYXNwZWN0UmF0aW8gPj0gMSkge1xuICAgICAgd2lkdGggPSAxO1xuICAgICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC8gd2luZG93LmlubmVyV2lkdGggKiB3aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBhc3BlY3RSYXRpbztcbiAgICAgIGhlaWdodCA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5jYW1lcmEubGVmdCA9IC13aWR0aDtcbiAgICB0aGlzLmNhbWVyYS5yaWdodCA9IHdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnRvcCA9IGhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS5ib3R0b20gPSAtaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnkgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIH1cblxuICBvblJhZigpIHtcbiAgICBpZiAodGhpcy51bmlmb3Jtcykge1xuICAgICAgdGhpcy51bmlmb3Jtcy51X3RpbWUudmFsdWUgKz0gdGhpcy5yYWYuZ2V0RGVsdGEodHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBHbHNsUGxheWdyb3VuZDMwOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/glsl-playground30.js\n");

/***/ }),

/***/ "./examples/glsl-playground4.js":
/*!**************************************!*\
  !*** ./examples/glsl-playground4.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n/**\n * https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram\n * https://gist.github.com/uxder/cc02c445c2f7b4679e48e91d2920c832\n */\nconst vshader = `\nvoid main() {\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\n/**\n * Based on the normalized screen coordinates (uv), mix between red and blue based\n * on the current Y pixel position.\n */\n\nconst fshader = `\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nvoid main (void)\n{\n  vec2 uv = gl_FragCoord.xy / u_resolution;\n  vec3 color = mix(\n      vec3(1.0, 0.0, 0.0), // Red\n      vec3(0.0, 0.0, 1.0), // Blue,\n      uv.y // Use normalized y value as the blend progress.\n  );\n\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground4 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color: {\n        value: new THREE.Color(0xff0000)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground4;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQ0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvZ2xzbC1wbGF5Z3JvdW5kNC5qcz9lZjE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX3JhZiA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZlwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLyoqXG4gKiBodHRwczovL3RocmVlanMub3JnL2RvY3MvI2FwaS9lbi9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xQcm9ncmFtXG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS91eGRlci9jYzAyYzQ0NWMyZjdiNDY3OWU0OGU5MWQyOTIwYzgzMlxuICovXG5jb25zdCB2c2hhZGVyID0gYFxudm9pZCBtYWluKCkge1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuLyoqXG4gKiBCYXNlZCBvbiB0aGUgbm9ybWFsaXplZCBzY3JlZW4gY29vcmRpbmF0ZXMgKHV2KSwgbWl4IGJldHdlZW4gcmVkIGFuZCBibHVlIGJhc2VkXG4gKiBvbiB0aGUgY3VycmVudCBZIHBpeGVsIHBvc2l0aW9uLlxuICovXG5cbmNvbnN0IGZzaGFkZXIgPSBgXG51bmlmb3JtIHZlYzIgdV9tb3VzZTtcbnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XG51bmlmb3JtIHZlYzMgdV9jb2xvcjtcbnVuaWZvcm0gZmxvYXQgdV90aW1lO1xuXG52b2lkIG1haW4gKHZvaWQpXG57XG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyB1X3Jlc29sdXRpb247XG4gIHZlYzMgY29sb3IgPSBtaXgoXG4gICAgICB2ZWMzKDEuMCwgMC4wLCAwLjApLCAvLyBSZWRcbiAgICAgIHZlYzMoMC4wLCAwLjAsIDEuMCksIC8vIEJsdWUsXG4gICAgICB1di55IC8vIFVzZSBub3JtYWxpemVkIHkgdmFsdWUgYXMgdGhlIGJsZW5kIHByb2dyZXNzLlxuICApO1xuXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuMCk7XG59XG5gO1xuXG5jbGFzcyBHbHNsUGxheWdyb3VuZDQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vIDJ4MlxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMC4xLCAxMCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgdV9jb2xvcjoge1xuICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKDB4ZmYwMDAwKVxuICAgICAgfSxcbiAgICAgIC8vIEZsb2F0XG4gICAgICB1X3RpbWU6IHtcbiAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgfSxcbiAgICAgIC8vIFZlYzIgMCwwIGF0IHRvcCwgbGVmdCBhbmQgd2luZG93LmlubmVyV2lkdGggYW5kIHdpbmRvdy5pbm5lckhlaWdodCBhdCBib3R0b20gcmlnaHQuXG4gICAgICB1X21vdXNlOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMC4wLFxuICAgICAgICAgIHk6IDAuMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVmVjMiBTY3JlZW4gcmVzb2x1dGlvblxuICAgICAgdV9yZXNvbHV0aW9uOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvLyAyeDIgc28gaXQgZmlsbCB0aGUgc2NyZWVuLlxuXG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDIsIDIpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZzaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZnNoYWRlclxuICAgIH0pOyAvLyBDcmVhdGUgbWVzaCAoZ2VvbSArIG1hdGVyaWFsKVxuXG4gICAgdGhpcy5wbGFuZSA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMucGxhbmUpO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAxO1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGlmIChhc3BlY3RSYXRpbyA+PSAxKSB7XG4gICAgICB3aWR0aCA9IDE7XG4gICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB3aW5kb3cuaW5uZXJXaWR0aCAqIHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdFJhdGlvO1xuICAgICAgaGVpZ2h0ID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbWVyYS5sZWZ0ID0gLXdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnJpZ2h0ID0gd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEudG9wID0gaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLmJvdHRvbSA9IC1oZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS54ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGV2dCkge1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS54ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRYIDogZXZ0LmNsaWVudFg7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnkgPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFkgOiBldnQuY2xpZW50WTtcbiAgfVxuXG4gIG9uUmFmKGRlbHRhKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X3RpbWUudmFsdWUgKz0gdGhpcy5yYWYuZ2V0RGVsdGEodHJ1ZSk7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gR2xzbFBsYXlncm91bmQ0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/glsl-playground4.js\n");

/***/ }),

/***/ "./examples/glsl-playground5.js":
/*!**************************************!*\
  !*** ./examples/glsl-playground5.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n/**\n *\n * Varying UV sample\n * https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram\n * https://gist.github.com/uxder/cc02c445c2f7b4679e48e91d2920c832\n */\nconst vshader = `\nvarying vec2 v_uv; // Declare v_uv\nvarying vec3 v_position; // Declare v_position\nvoid main() {\n  // Set the uv value.  Three.js passes the uv value by default of the current vertices.\n  v_uv = uv;\n  v_position = position;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nvarying vec2 v_uv;\nvarying vec3 v_position;\n\nvoid main (void)\n{\n\n//   vec3 color = vec3(\n//       v_uv.x, v_uv.y, 0.0\n//   );\n\n  // Different results as above because, v_position is the position of\n  // the model as opposed to UV is a 0,0 - 1,1 spread of the model.\n  vec3 color = vec3(\n      v_position.x, v_position.y, 0.0\n  );\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground5 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color: {\n        value: new THREE.Color(0xff0000)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground5;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQ1LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvZ2xzbC1wbGF5Z3JvdW5kNS5qcz84Y2M0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX3JhZiA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZlwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLyoqXG4gKlxuICogVmFyeWluZyBVViBzYW1wbGVcbiAqIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb2dyYW1cbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3V4ZGVyL2NjMDJjNDQ1YzJmN2I0Njc5ZTQ4ZTkxZDI5MjBjODMyXG4gKi9cbmNvbnN0IHZzaGFkZXIgPSBgXG52YXJ5aW5nIHZlYzIgdl91djsgLy8gRGVjbGFyZSB2X3V2XG52YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbjsgLy8gRGVjbGFyZSB2X3Bvc2l0aW9uXG52b2lkIG1haW4oKSB7XG4gIC8vIFNldCB0aGUgdXYgdmFsdWUuICBUaHJlZS5qcyBwYXNzZXMgdGhlIHV2IHZhbHVlIGJ5IGRlZmF1bHQgb2YgdGhlIGN1cnJlbnQgdmVydGljZXMuXG4gIHZfdXYgPSB1djtcbiAgdl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbnVuaWZvcm0gdmVjMiB1X21vdXNlO1xudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gdmVjMyB1X2NvbG9yO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG5cbnZhcnlpbmcgdmVjMiB2X3V2O1xudmFyeWluZyB2ZWMzIHZfcG9zaXRpb247XG5cbnZvaWQgbWFpbiAodm9pZClcbntcblxuLy8gICB2ZWMzIGNvbG9yID0gdmVjMyhcbi8vICAgICAgIHZfdXYueCwgdl91di55LCAwLjBcbi8vICAgKTtcblxuICAvLyBEaWZmZXJlbnQgcmVzdWx0cyBhcyBhYm92ZSBiZWNhdXNlLCB2X3Bvc2l0aW9uIGlzIHRoZSBwb3NpdGlvbiBvZlxuICAvLyB0aGUgbW9kZWwgYXMgb3Bwb3NlZCB0byBVViBpcyBhIDAsMCAtIDEsMSBzcHJlYWQgb2YgdGhlIG1vZGVsLlxuICB2ZWMzIGNvbG9yID0gdmVjMyhcbiAgICAgIHZfcG9zaXRpb24ueCwgdl9wb3NpdGlvbi55LCAwLjBcbiAgKTtcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcbn1cbmA7XG5cbmNsYXNzIEdsc2xQbGF5Z3JvdW5kNSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTsgLy8gMngyXG5cbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoLTEsIDEsIDEsIC0xLCAwLjEsIDEwKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgIHRoaXMucmFmID0gbmV3IF9yYWYuUmFmKHRoaXMub25SYWYuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAncmVzaXplJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyksXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdtb3VzZW1vdmUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICB1X2NvbG9yOiB7XG4gICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoMHhmZjAwMDApXG4gICAgICB9LFxuICAgICAgLy8gRmxvYXRcbiAgICAgIHVfdGltZToge1xuICAgICAgICB2YWx1ZTogMC4wXG4gICAgICB9LFxuICAgICAgLy8gVmVjMiAwLDAgYXQgdG9wLCBsZWZ0IGFuZCB3aW5kb3cuaW5uZXJXaWR0aCBhbmQgd2luZG93LmlubmVySGVpZ2h0IGF0IGJvdHRvbSByaWdodC5cbiAgICAgIHVfbW91c2U6IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB4OiAwLjAsXG4gICAgICAgICAgeTogMC4wXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBWZWMyIFNjcmVlbiByZXNvbHV0aW9uXG4gICAgICB1X3Jlc29sdXRpb246IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07IC8vIDJ4MiBzbyBpdCBmaWxsIHRoZSBzY3JlZW4uXG5cbiAgICB0aGlzLmdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoMiwgMik7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG4gICAgICB1bmlmb3JtczogdGhpcy51bmlmb3JtcyxcbiAgICAgIHZlcnRleFNoYWRlcjogdnNoYWRlcixcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBmc2hhZGVyXG4gICAgfSk7IC8vIENyZWF0ZSBtZXNoIChnZW9tICsgbWF0ZXJpYWwpXG5cbiAgICB0aGlzLnBsYW5lID0gbmV3IFRIUkVFLk1lc2godGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5wbGFuZSk7XG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiA9IDE7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgIHRoaXMucmFmLnN0YXJ0KCk7XG4gIH1cblxuICBvblJlc2l6ZSgpIHtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgaWYgKGFzcGVjdFJhdGlvID49IDEpIHtcbiAgICAgIHdpZHRoID0gMTtcbiAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAvIHdpbmRvdy5pbm5lcldpZHRoICogd2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gYXNwZWN0UmF0aW87XG4gICAgICBoZWlnaHQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuY2FtZXJhLmxlZnQgPSAtd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEucmlnaHQgPSB3aWR0aDtcbiAgICB0aGlzLmNhbWVyYS50b3AgPSBoZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEuYm90dG9tID0gLWhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS55ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZXZ0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnggPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFggOiBldnQuY2xpZW50WDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueSA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WSA6IGV2dC5jbGllbnRZO1xuICB9XG5cbiAgb25SYWYoZGVsdGEpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfdGltZS52YWx1ZSArPSB0aGlzLnJhZi5nZXREZWx0YSh0cnVlKTtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBHbHNsUGxheWdyb3VuZDU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/glsl-playground5.js\n");

/***/ }),

/***/ "./examples/glsl-playground6.js":
/*!**************************************!*\
  !*** ./examples/glsl-playground6.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nconst vshader = `\nvarying vec3 v_position; // Declare v_position\nvoid main() {\n  // Set the uv value.  Three.js passes the uv value by default of the current vertices.\n  v_position = position;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nvarying vec3 v_position;\n\nvoid main (void)\n{\n\n  // Normalization of v_position since 0,0 is the center and we know that\n  // this plane is 2 wide with -1 at the egdes.\n  //   vec2 pos = (v_position.xy + 1.0) / 2.0;\n  vec3 color = vec3(0.0);\n\n  // v_position ranges from -1, 1 (as defined in our plane) so clamp the values.\n  color.r = clamp(v_position.x, 0.0, 1.0);\n  color.g = clamp(v_position.y, 0.0, 1.0);\n\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground6 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color: {\n        value: new THREE.Color(0xff0000)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground6;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQ2LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvZ2xzbC1wbGF5Z3JvdW5kNi5qcz9lZGI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX3JhZiA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZlwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY29uc3QgdnNoYWRlciA9IGBcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uOyAvLyBEZWNsYXJlIHZfcG9zaXRpb25cbnZvaWQgbWFpbigpIHtcbiAgLy8gU2V0IHRoZSB1diB2YWx1ZS4gIFRocmVlLmpzIHBhc3NlcyB0aGUgdXYgdmFsdWUgYnkgZGVmYXVsdCBvZiB0aGUgY3VycmVudCB2ZXJ0aWNlcy5cbiAgdl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbnVuaWZvcm0gdmVjMiB1X21vdXNlO1xudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gdmVjMyB1X2NvbG9yO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG5cbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xuXG52b2lkIG1haW4gKHZvaWQpXG57XG5cbiAgLy8gTm9ybWFsaXphdGlvbiBvZiB2X3Bvc2l0aW9uIHNpbmNlIDAsMCBpcyB0aGUgY2VudGVyIGFuZCB3ZSBrbm93IHRoYXRcbiAgLy8gdGhpcyBwbGFuZSBpcyAyIHdpZGUgd2l0aCAtMSBhdCB0aGUgZWdkZXMuXG4gIC8vICAgdmVjMiBwb3MgPSAodl9wb3NpdGlvbi54eSArIDEuMCkgLyAyLjA7XG4gIHZlYzMgY29sb3IgPSB2ZWMzKDAuMCk7XG5cbiAgLy8gdl9wb3NpdGlvbiByYW5nZXMgZnJvbSAtMSwgMSAoYXMgZGVmaW5lZCBpbiBvdXIgcGxhbmUpIHNvIGNsYW1wIHRoZSB2YWx1ZXMuXG4gIGNvbG9yLnIgPSBjbGFtcCh2X3Bvc2l0aW9uLngsIDAuMCwgMS4wKTtcbiAgY29sb3IuZyA9IGNsYW1wKHZfcG9zaXRpb24ueSwgMC4wLCAxLjApO1xuXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIDEuMCk7XG59XG5gO1xuXG5jbGFzcyBHbHNsUGxheWdyb3VuZDYge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vIDJ4MlxuXG4gICAgdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKC0xLCAxLCAxLCAtMSwgMC4xLCAxMCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgdV9jb2xvcjoge1xuICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKDB4ZmYwMDAwKVxuICAgICAgfSxcbiAgICAgIC8vIEZsb2F0XG4gICAgICB1X3RpbWU6IHtcbiAgICAgICAgdmFsdWU6IDAuMFxuICAgICAgfSxcbiAgICAgIC8vIFZlYzIgMCwwIGF0IHRvcCwgbGVmdCBhbmQgd2luZG93LmlubmVyV2lkdGggYW5kIHdpbmRvdy5pbm5lckhlaWdodCBhdCBib3R0b20gcmlnaHQuXG4gICAgICB1X21vdXNlOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMC4wLFxuICAgICAgICAgIHk6IDAuMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gVmVjMiBTY3JlZW4gcmVzb2x1dGlvblxuICAgICAgdV9yZXNvbHV0aW9uOiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvLyAyeDIgc28gaXQgZmlsbCB0aGUgc2NyZWVuLlxuXG4gICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KDIsIDIpO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXM6IHRoaXMudW5pZm9ybXMsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IHZzaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZnNoYWRlclxuICAgIH0pOyAvLyBDcmVhdGUgbWVzaCAoZ2VvbSArIG1hdGVyaWFsKVxuXG4gICAgdGhpcy5wbGFuZSA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMucGxhbmUpO1xuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnogPSAxO1xuICAgIHRoaXMub25SZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGlmIChhc3BlY3RSYXRpbyA+PSAxKSB7XG4gICAgICB3aWR0aCA9IDE7XG4gICAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB3aW5kb3cuaW5uZXJXaWR0aCAqIHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IGFzcGVjdFJhdGlvO1xuICAgICAgaGVpZ2h0ID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbWVyYS5sZWZ0ID0gLXdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnJpZ2h0ID0gd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEudG9wID0gaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLmJvdHRvbSA9IC1oZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS54ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgfVxuXG4gIG9uTW91c2VNb3ZlKGV2dCkge1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS54ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRYIDogZXZ0LmNsaWVudFg7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnkgPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFkgOiBldnQuY2xpZW50WTtcbiAgfVxuXG4gIG9uUmFmKGRlbHRhKSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X3RpbWUudmFsdWUgKz0gdGhpcy5yYWYuZ2V0RGVsdGEodHJ1ZSk7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gR2xzbFBsYXlncm91bmQ2OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/glsl-playground6.js\n");

/***/ }),

/***/ "./examples/glsl-playground7.js":
/*!**************************************!*\
  !*** ./examples/glsl-playground7.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nconst vshader = `\nvarying vec3 v_position; // Declare v_position\nvoid main() {\n  // Set the uv value.  Three.js passes the uv value by default of the current vertices.\n  v_position = position;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nvarying vec3 v_position;\n\nvoid main (void)\n{\n\n  // Normalization of v_position since 0,0 is the center and we know that\n  // this plane is 2 wide with -1 at the egdes.\n  //   vec2 pos = (v_position.xy + 1.0) / 2.0;\n  vec3 color = vec3(0.0);\n\n  // v_position ranges from -1, 1 (as defined in our plane) so clamp the values.\n  // By using step we get sharp edges.\n  //color.r = step(0.0, v_position.x);\n  //color.g = step(0.0, v_position.y);\n\n  // Returns a full yellow screeen because the position.xy\n  // are always greater than -1.0\n//   color.r = step(-1.0, v_position.x);\n//   color.g = step(-1.0, v_position.y);\n\n\n  // Smooth step example.\n  // Compare to step above, it smooths out the steps and edges.\n  color.r = smoothstep(0.0, 0.1, v_position.x);\n  color.g = smoothstep(0.0, 0.1, v_position.y);\n\n\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground7 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color: {\n        value: new THREE.Color(0xff0000)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground7;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQ3LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvZ2xzbC1wbGF5Z3JvdW5kNy5qcz9kNWQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX3JhZiA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZlwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY29uc3QgdnNoYWRlciA9IGBcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uOyAvLyBEZWNsYXJlIHZfcG9zaXRpb25cbnZvaWQgbWFpbigpIHtcbiAgLy8gU2V0IHRoZSB1diB2YWx1ZS4gIFRocmVlLmpzIHBhc3NlcyB0aGUgdXYgdmFsdWUgYnkgZGVmYXVsdCBvZiB0aGUgY3VycmVudCB2ZXJ0aWNlcy5cbiAgdl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbnVuaWZvcm0gdmVjMiB1X21vdXNlO1xudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gdmVjMyB1X2NvbG9yO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG5cbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xuXG52b2lkIG1haW4gKHZvaWQpXG57XG5cbiAgLy8gTm9ybWFsaXphdGlvbiBvZiB2X3Bvc2l0aW9uIHNpbmNlIDAsMCBpcyB0aGUgY2VudGVyIGFuZCB3ZSBrbm93IHRoYXRcbiAgLy8gdGhpcyBwbGFuZSBpcyAyIHdpZGUgd2l0aCAtMSBhdCB0aGUgZWdkZXMuXG4gIC8vICAgdmVjMiBwb3MgPSAodl9wb3NpdGlvbi54eSArIDEuMCkgLyAyLjA7XG4gIHZlYzMgY29sb3IgPSB2ZWMzKDAuMCk7XG5cbiAgLy8gdl9wb3NpdGlvbiByYW5nZXMgZnJvbSAtMSwgMSAoYXMgZGVmaW5lZCBpbiBvdXIgcGxhbmUpIHNvIGNsYW1wIHRoZSB2YWx1ZXMuXG4gIC8vIEJ5IHVzaW5nIHN0ZXAgd2UgZ2V0IHNoYXJwIGVkZ2VzLlxuICAvL2NvbG9yLnIgPSBzdGVwKDAuMCwgdl9wb3NpdGlvbi54KTtcbiAgLy9jb2xvci5nID0gc3RlcCgwLjAsIHZfcG9zaXRpb24ueSk7XG5cbiAgLy8gUmV0dXJucyBhIGZ1bGwgeWVsbG93IHNjcmVlZW4gYmVjYXVzZSB0aGUgcG9zaXRpb24ueHlcbiAgLy8gYXJlIGFsd2F5cyBncmVhdGVyIHRoYW4gLTEuMFxuLy8gICBjb2xvci5yID0gc3RlcCgtMS4wLCB2X3Bvc2l0aW9uLngpO1xuLy8gICBjb2xvci5nID0gc3RlcCgtMS4wLCB2X3Bvc2l0aW9uLnkpO1xuXG5cbiAgLy8gU21vb3RoIHN0ZXAgZXhhbXBsZS5cbiAgLy8gQ29tcGFyZSB0byBzdGVwIGFib3ZlLCBpdCBzbW9vdGhzIG91dCB0aGUgc3RlcHMgYW5kIGVkZ2VzLlxuICBjb2xvci5yID0gc21vb3Roc3RlcCgwLjAsIDAuMSwgdl9wb3NpdGlvbi54KTtcbiAgY29sb3IuZyA9IHNtb290aHN0ZXAoMC4wLCAwLjEsIHZfcG9zaXRpb24ueSk7XG5cblxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1xufVxuYDtcblxuY2xhc3MgR2xzbFBsYXlncm91bmQ3IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpOyAvLyAyeDJcblxuICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgtMSwgMSwgMSwgLTEsIDAuMSwgMTApO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgdGhpcy5yYWYgPSBuZXcgX3JhZi5SYWYodGhpcy5vblJhZi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIgPSBuZXcgX2RvbVdhdGNoZXIuRG9tV2F0Y2hlcigpO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdyZXNpemUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25SZXNpemUuYmluZCh0aGlzKSxcbiAgICAgIGV2ZW50T3B0aW9uczoge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ21vdXNlbW92ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgIHVfY29sb3I6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweGZmMDAwMClcbiAgICAgIH0sXG4gICAgICAvLyBGbG9hdFxuICAgICAgdV90aW1lOiB7XG4gICAgICAgIHZhbHVlOiAwLjBcbiAgICAgIH0sXG4gICAgICAvLyBWZWMyIDAsMCBhdCB0b3AsIGxlZnQgYW5kIHdpbmRvdy5pbm5lcldpZHRoIGFuZCB3aW5kb3cuaW5uZXJIZWlnaHQgYXQgYm90dG9tIHJpZ2h0LlxuICAgICAgdV9tb3VzZToge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAuMCxcbiAgICAgICAgICB5OiAwLjBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFZlYzIgU2NyZWVuIHJlc29sdXRpb25cbiAgICAgIHVfcmVzb2x1dGlvbjoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgLy8gMngyIHNvIGl0IGZpbGwgdGhlIHNjcmVlbi5cblxuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSgyLCAyKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgdmVydGV4U2hhZGVyOiB2c2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzaGFkZXJcbiAgICB9KTsgLy8gQ3JlYXRlIG1lc2ggKGdlb20gKyBtYXRlcmlhbClcblxuICAgIHRoaXMucGxhbmUgPSBuZXcgVEhSRUUuTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLnBsYW5lKTtcbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gMTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgfVxuXG4gIG9uUmVzaXplKCkge1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBpZiAoYXNwZWN0UmF0aW8gPj0gMSkge1xuICAgICAgd2lkdGggPSAxO1xuICAgICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC8gd2luZG93LmlubmVyV2lkdGggKiB3aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBhc3BlY3RSYXRpbztcbiAgICAgIGhlaWdodCA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5jYW1lcmEubGVmdCA9IC13aWR0aDtcbiAgICB0aGlzLmNhbWVyYS5yaWdodCA9IHdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnRvcCA9IGhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS5ib3R0b20gPSAtaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnkgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIH1cblxuICBvbk1vdXNlTW92ZShldnQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WCA6IGV2dC5jbGllbnRYO1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS55ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRZIDogZXZ0LmNsaWVudFk7XG4gIH1cblxuICBvblJhZihkZWx0YSkge1xuICAgIHRoaXMudW5pZm9ybXMudV90aW1lLnZhbHVlICs9IHRoaXMucmFmLmdldERlbHRhKHRydWUpO1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdsc2xQbGF5Z3JvdW5kNzsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/glsl-playground7.js\n");

/***/ }),

/***/ "./examples/glsl-playground8.js":
/*!**************************************!*\
  !*** ./examples/glsl-playground8.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nconst vshader = `\nvarying vec3 v_position; // Declare v_position\nvoid main() {\n  // Set the uv value.  Three.js passes the uv value by default of the current vertices.\n  v_position = position;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nvarying vec3 v_position;\n\nvoid main (void)\n{\n\n  // inCirlce is 0.0 when length is less than 0.5 and 1 when it's greater than 0.5.\n  float inCircle = step(0.5, length(v_position.xy));\n  // Invert it the result.\n  inCircle = 1.0 - inCircle;\n\n\n//   float inCircle = 1.0 - step(0.5, length(v_position.xy));\n\n  // Multiply the color by 1.0 (resulting in yellow)\n  // or 0.0 = 0.0 (resulting in black)\n  vec3 color = vec3(1.0, 1.0, 0.0) * inCircle;\n\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground8 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color: {\n        value: new THREE.Color(0xff0000)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground8;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQ4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvZ2xzbC1wbGF5Z3JvdW5kOC5qcz9iNGY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX3JhZiA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZlwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY29uc3QgdnNoYWRlciA9IGBcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uOyAvLyBEZWNsYXJlIHZfcG9zaXRpb25cbnZvaWQgbWFpbigpIHtcbiAgLy8gU2V0IHRoZSB1diB2YWx1ZS4gIFRocmVlLmpzIHBhc3NlcyB0aGUgdXYgdmFsdWUgYnkgZGVmYXVsdCBvZiB0aGUgY3VycmVudCB2ZXJ0aWNlcy5cbiAgdl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbnVuaWZvcm0gdmVjMiB1X21vdXNlO1xudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gdmVjMyB1X2NvbG9yO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG5cbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xuXG52b2lkIG1haW4gKHZvaWQpXG57XG5cbiAgLy8gaW5DaXJsY2UgaXMgMC4wIHdoZW4gbGVuZ3RoIGlzIGxlc3MgdGhhbiAwLjUgYW5kIDEgd2hlbiBpdCdzIGdyZWF0ZXIgdGhhbiAwLjUuXG4gIGZsb2F0IGluQ2lyY2xlID0gc3RlcCgwLjUsIGxlbmd0aCh2X3Bvc2l0aW9uLnh5KSk7XG4gIC8vIEludmVydCBpdCB0aGUgcmVzdWx0LlxuICBpbkNpcmNsZSA9IDEuMCAtIGluQ2lyY2xlO1xuXG5cbi8vICAgZmxvYXQgaW5DaXJjbGUgPSAxLjAgLSBzdGVwKDAuNSwgbGVuZ3RoKHZfcG9zaXRpb24ueHkpKTtcblxuICAvLyBNdWx0aXBseSB0aGUgY29sb3IgYnkgMS4wIChyZXN1bHRpbmcgaW4geWVsbG93KVxuICAvLyBvciAwLjAgPSAwLjAgKHJlc3VsdGluZyBpbiBibGFjaylcbiAgdmVjMyBjb2xvciA9IHZlYzMoMS4wLCAxLjAsIDAuMCkgKiBpbkNpcmNsZTtcblxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1xufVxuYDtcblxuY2xhc3MgR2xzbFBsYXlncm91bmQ4IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpOyAvLyAyeDJcblxuICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgtMSwgMSwgMSwgLTEsIDAuMSwgMTApO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgdGhpcy5yYWYgPSBuZXcgX3JhZi5SYWYodGhpcy5vblJhZi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIgPSBuZXcgX2RvbVdhdGNoZXIuRG9tV2F0Y2hlcigpO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdyZXNpemUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25SZXNpemUuYmluZCh0aGlzKSxcbiAgICAgIGV2ZW50T3B0aW9uczoge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ21vdXNlbW92ZScsXG4gICAgICBjYWxsYmFjazogdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgdGhpcy51bmlmb3JtcyA9IHtcbiAgICAgIHVfY29sb3I6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweGZmMDAwMClcbiAgICAgIH0sXG4gICAgICAvLyBGbG9hdFxuICAgICAgdV90aW1lOiB7XG4gICAgICAgIHZhbHVlOiAwLjBcbiAgICAgIH0sXG4gICAgICAvLyBWZWMyIDAsMCBhdCB0b3AsIGxlZnQgYW5kIHdpbmRvdy5pbm5lcldpZHRoIGFuZCB3aW5kb3cuaW5uZXJIZWlnaHQgYXQgYm90dG9tIHJpZ2h0LlxuICAgICAgdV9tb3VzZToge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAuMCxcbiAgICAgICAgICB5OiAwLjBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFZlYzIgU2NyZWVuIHJlc29sdXRpb25cbiAgICAgIHVfcmVzb2x1dGlvbjoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgLy8gMngyIHNvIGl0IGZpbGwgdGhlIHNjcmVlbi5cblxuICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuUGxhbmVHZW9tZXRyeSgyLCAyKTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgdmVydGV4U2hhZGVyOiB2c2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzaGFkZXJcbiAgICB9KTsgLy8gQ3JlYXRlIG1lc2ggKGdlb20gKyBtYXRlcmlhbClcblxuICAgIHRoaXMucGxhbmUgPSBuZXcgVEhSRUUuTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICB0aGlzLnNjZW5lLmFkZCh0aGlzLnBsYW5lKTtcbiAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gMTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgfVxuXG4gIG9uUmVzaXplKCkge1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBpZiAoYXNwZWN0UmF0aW8gPj0gMSkge1xuICAgICAgd2lkdGggPSAxO1xuICAgICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC8gd2luZG93LmlubmVyV2lkdGggKiB3aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGggPSBhc3BlY3RSYXRpbztcbiAgICAgIGhlaWdodCA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5jYW1lcmEubGVmdCA9IC13aWR0aDtcbiAgICB0aGlzLmNhbWVyYS5yaWdodCA9IHdpZHRoO1xuICAgIHRoaXMuY2FtZXJhLnRvcCA9IGhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS5ib3R0b20gPSAtaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy51bmlmb3Jtcy51X3Jlc29sdXRpb24udmFsdWUueCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnkgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gIH1cblxuICBvbk1vdXNlTW92ZShldnQpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueCA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WCA6IGV2dC5jbGllbnRYO1xuICAgIHRoaXMudW5pZm9ybXMudV9tb3VzZS52YWx1ZS55ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5jbGllbnRZIDogZXZ0LmNsaWVudFk7XG4gIH1cblxuICBvblJhZihkZWx0YSkge1xuICAgIHRoaXMudW5pZm9ybXMudV90aW1lLnZhbHVlICs9IHRoaXMucmFmLmdldERlbHRhKHRydWUpO1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdsc2xQbGF5Z3JvdW5kODsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/glsl-playground8.js\n");

/***/ }),

/***/ "./examples/glsl-playground9.js":
/*!**************************************!*\
  !*** ./examples/glsl-playground9.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nconst vshader = `\nvarying vec3 v_position; // Declare v_position\nvoid main() {\n  // Set the uv value.  Three.js passes the uv value by default of the current vertices.\n  v_position = position;\n  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );\n}\n`;\nconst fshader = `\nuniform vec2 u_mouse;\nuniform vec2 u_resolution;\nuniform vec3 u_color;\nuniform float u_time;\n\nvarying vec3 v_position;\n\n// Determine if a particular pixel is within the boundaries of a rectangle box.\n// Returns 1.0 when point pt,  is inside a rectangle defined by size and center.\nfloat rect(vec2 pt, vec2 size, vec2 center) {\n    // We need to offset the position of the virtual box to do a hit test.\n    vec2 p = pt - center;\n    vec2 halfsize = size * 0.5; // Half the size since we just need\n\n    // Now do a hit test of this rectangle and see if pt falls within it.\n    // float horz = (v_position.x > -halfsize.x && v_position.x < halfsize.x) ?\n    float horz = step(-halfsize.x, p.x) - step(halfsize.x, p.x);\n    float vert = step(-halfsize.y, p.y) - step(halfsize.y, p.y);\n    return horz * vert;\n}\n\nvoid main (void)\n{\n\n\n// Example 1: Just a square\n//   float inRect = rect(v_position.xy, vec2(0.5), vec2(0.0));\n//   vec3 color = vec3(1.0, 1.0, 0.0) * inRect;\n\n// Example 2: Some movement\n// Add movement over time.\n//   float s = ((sin(u_time) + 1.0) / 2.0); // Normalize sin.\n//   s = s - 0.5; // Offset it.\n//   float inRect = rect(v_position.xy, vec2(s, s), vec2(s, -s));\n//   vec3 color = vec3(1.0, 1.0, 0.0) * inRect;\n\n// // Example 3: Two squares\n//   float square1 = rect(v_position.xy, vec2(0.3), vec2(0.0));\n//   float square2 = rect(v_position.xy, vec2(0.3), vec2(-0.5));\n//   vec3 color =\n//     (vec3(1.0, 1.0, 0.0) * square1) + // square 1\n//     (vec3(0.0, 1.0, 0.0) * square2) // square2\n//    ;\n\n\n// Example 4: Go around in a circle.\n  float radius = 0.2;\n  float time = u_time * 2.0;\n  // Get the center point for going around in a circle over time.\n  vec2 center = vec2( cos(time) * radius, sin(time) * radius);\n  float inRect = rect(v_position.xy, vec2(0.4), center);\n  vec3 color = vec3(1.0, 1.0, 0.0) * inRect;\n\n\n\n  gl_FragColor = vec4(color, 1.0);\n}\n`;\n\nclass GlslPlayground9 {\n  constructor() {\n    this.scene = new THREE.Scene(); // 2x2\n\n    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);\n    this.renderer = new THREE.WebGLRenderer();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(this.renderer.domElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.domWatcher.add({\n      element: window,\n      on: 'resize',\n      callback: this.onResize.bind(this),\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.domWatcher.add({\n      element: window,\n      on: 'mousemove',\n      callback: this.onMouseMove.bind(this)\n    });\n    this.uniforms = {\n      u_color: {\n        value: new THREE.Color(0xff0000)\n      },\n      // Float\n      u_time: {\n        value: 0.0\n      },\n      // Vec2 0,0 at top, left and window.innerWidth and window.innerHeight at bottom right.\n      u_mouse: {\n        value: {\n          x: 0.0,\n          y: 0.0\n        }\n      },\n      // Vec2 Screen resolution\n      u_resolution: {\n        value: {\n          x: 0,\n          y: 0\n        }\n      }\n    }; // 2x2 so it fill the screen.\n\n    this.geometry = new THREE.PlaneGeometry(2, 2);\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader\n    }); // Create mesh (geom + material)\n\n    this.plane = new THREE.Mesh(this.geometry, this.material);\n    this.scene.add(this.plane);\n    this.camera.position.z = 1;\n    this.onResize();\n    this.raf.start();\n  }\n\n  onResize() {\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    let width, height;\n\n    if (aspectRatio >= 1) {\n      width = 1;\n      height = window.innerHeight / window.innerWidth * width;\n    } else {\n      width = aspectRatio;\n      height = 1;\n    }\n\n    this.camera.left = -width;\n    this.camera.right = width;\n    this.camera.top = height;\n    this.camera.bottom = -height;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.uniforms.u_resolution.value.x = window.innerWidth;\n    this.uniforms.u_resolution.value.y = window.innerHeight;\n  }\n\n  onMouseMove(evt) {\n    this.uniforms.u_mouse.value.x = evt.touches ? evt.touches[0].clientX : evt.clientX;\n    this.uniforms.u_mouse.value.y = evt.touches ? evt.touches[0].clientY : evt.clientY;\n  }\n\n  onRaf(delta) {\n    this.uniforms.u_time.value += this.raf.getDelta(true);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = GlslPlayground9;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9nbHNsLXBsYXlncm91bmQ5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvZ2xzbC1wbGF5Z3JvdW5kOS5qcz82YThkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX3JhZiA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZlwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY29uc3QgdnNoYWRlciA9IGBcbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uOyAvLyBEZWNsYXJlIHZfcG9zaXRpb25cbnZvaWQgbWFpbigpIHtcbiAgLy8gU2V0IHRoZSB1diB2YWx1ZS4gIFRocmVlLmpzIHBhc3NlcyB0aGUgdXYgdmFsdWUgYnkgZGVmYXVsdCBvZiB0aGUgY3VycmVudCB2ZXJ0aWNlcy5cbiAgdl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG59XG5gO1xuY29uc3QgZnNoYWRlciA9IGBcbnVuaWZvcm0gdmVjMiB1X21vdXNlO1xudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnVuaWZvcm0gdmVjMyB1X2NvbG9yO1xudW5pZm9ybSBmbG9hdCB1X3RpbWU7XG5cbnZhcnlpbmcgdmVjMyB2X3Bvc2l0aW9uO1xuXG4vLyBEZXRlcm1pbmUgaWYgYSBwYXJ0aWN1bGFyIHBpeGVsIGlzIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiBhIHJlY3RhbmdsZSBib3guXG4vLyBSZXR1cm5zIDEuMCB3aGVuIHBvaW50IHB0LCAgaXMgaW5zaWRlIGEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgc2l6ZSBhbmQgY2VudGVyLlxuZmxvYXQgcmVjdCh2ZWMyIHB0LCB2ZWMyIHNpemUsIHZlYzIgY2VudGVyKSB7XG4gICAgLy8gV2UgbmVlZCB0byBvZmZzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSB2aXJ0dWFsIGJveCB0byBkbyBhIGhpdCB0ZXN0LlxuICAgIHZlYzIgcCA9IHB0IC0gY2VudGVyO1xuICAgIHZlYzIgaGFsZnNpemUgPSBzaXplICogMC41OyAvLyBIYWxmIHRoZSBzaXplIHNpbmNlIHdlIGp1c3QgbmVlZFxuXG4gICAgLy8gTm93IGRvIGEgaGl0IHRlc3Qgb2YgdGhpcyByZWN0YW5nbGUgYW5kIHNlZSBpZiBwdCBmYWxscyB3aXRoaW4gaXQuXG4gICAgLy8gZmxvYXQgaG9yeiA9ICh2X3Bvc2l0aW9uLnggPiAtaGFsZnNpemUueCAmJiB2X3Bvc2l0aW9uLnggPCBoYWxmc2l6ZS54KSA/XG4gICAgZmxvYXQgaG9yeiA9IHN0ZXAoLWhhbGZzaXplLngsIHAueCkgLSBzdGVwKGhhbGZzaXplLngsIHAueCk7XG4gICAgZmxvYXQgdmVydCA9IHN0ZXAoLWhhbGZzaXplLnksIHAueSkgLSBzdGVwKGhhbGZzaXplLnksIHAueSk7XG4gICAgcmV0dXJuIGhvcnogKiB2ZXJ0O1xufVxuXG52b2lkIG1haW4gKHZvaWQpXG57XG5cblxuLy8gRXhhbXBsZSAxOiBKdXN0IGEgc3F1YXJlXG4vLyAgIGZsb2F0IGluUmVjdCA9IHJlY3Qodl9wb3NpdGlvbi54eSwgdmVjMigwLjUpLCB2ZWMyKDAuMCkpO1xuLy8gICB2ZWMzIGNvbG9yID0gdmVjMygxLjAsIDEuMCwgMC4wKSAqIGluUmVjdDtcblxuLy8gRXhhbXBsZSAyOiBTb21lIG1vdmVtZW50XG4vLyBBZGQgbW92ZW1lbnQgb3ZlciB0aW1lLlxuLy8gICBmbG9hdCBzID0gKChzaW4odV90aW1lKSArIDEuMCkgLyAyLjApOyAvLyBOb3JtYWxpemUgc2luLlxuLy8gICBzID0gcyAtIDAuNTsgLy8gT2Zmc2V0IGl0LlxuLy8gICBmbG9hdCBpblJlY3QgPSByZWN0KHZfcG9zaXRpb24ueHksIHZlYzIocywgcyksIHZlYzIocywgLXMpKTtcbi8vICAgdmVjMyBjb2xvciA9IHZlYzMoMS4wLCAxLjAsIDAuMCkgKiBpblJlY3Q7XG5cbi8vIC8vIEV4YW1wbGUgMzogVHdvIHNxdWFyZXNcbi8vICAgZmxvYXQgc3F1YXJlMSA9IHJlY3Qodl9wb3NpdGlvbi54eSwgdmVjMigwLjMpLCB2ZWMyKDAuMCkpO1xuLy8gICBmbG9hdCBzcXVhcmUyID0gcmVjdCh2X3Bvc2l0aW9uLnh5LCB2ZWMyKDAuMyksIHZlYzIoLTAuNSkpO1xuLy8gICB2ZWMzIGNvbG9yID1cbi8vICAgICAodmVjMygxLjAsIDEuMCwgMC4wKSAqIHNxdWFyZTEpICsgLy8gc3F1YXJlIDFcbi8vICAgICAodmVjMygwLjAsIDEuMCwgMC4wKSAqIHNxdWFyZTIpIC8vIHNxdWFyZTJcbi8vICAgIDtcblxuXG4vLyBFeGFtcGxlIDQ6IEdvIGFyb3VuZCBpbiBhIGNpcmNsZS5cbiAgZmxvYXQgcmFkaXVzID0gMC4yO1xuICBmbG9hdCB0aW1lID0gdV90aW1lICogMi4wO1xuICAvLyBHZXQgdGhlIGNlbnRlciBwb2ludCBmb3IgZ29pbmcgYXJvdW5kIGluIGEgY2lyY2xlIG92ZXIgdGltZS5cbiAgdmVjMiBjZW50ZXIgPSB2ZWMyKCBjb3ModGltZSkgKiByYWRpdXMsIHNpbih0aW1lKSAqIHJhZGl1cyk7XG4gIGZsb2F0IGluUmVjdCA9IHJlY3Qodl9wb3NpdGlvbi54eSwgdmVjMigwLjQpLCBjZW50ZXIpO1xuICB2ZWMzIGNvbG9yID0gdmVjMygxLjAsIDEuMCwgMC4wKSAqIGluUmVjdDtcblxuXG5cbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcbn1cbmA7XG5cbmNsYXNzIEdsc2xQbGF5Z3JvdW5kOSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTsgLy8gMngyXG5cbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoLTEsIDEsIDEsIC0xLCAwLjEsIDEwKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgIHRoaXMucmFmID0gbmV3IF9yYWYuUmFmKHRoaXMub25SYWYuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAncmVzaXplJyxcbiAgICAgIGNhbGxiYWNrOiB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyksXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdtb3VzZW1vdmUnLFxuICAgICAgY2FsbGJhY2s6IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICB1X2NvbG9yOiB7XG4gICAgICAgIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoMHhmZjAwMDApXG4gICAgICB9LFxuICAgICAgLy8gRmxvYXRcbiAgICAgIHVfdGltZToge1xuICAgICAgICB2YWx1ZTogMC4wXG4gICAgICB9LFxuICAgICAgLy8gVmVjMiAwLDAgYXQgdG9wLCBsZWZ0IGFuZCB3aW5kb3cuaW5uZXJXaWR0aCBhbmQgd2luZG93LmlubmVySGVpZ2h0IGF0IGJvdHRvbSByaWdodC5cbiAgICAgIHVfbW91c2U6IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB4OiAwLjAsXG4gICAgICAgICAgeTogMC4wXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBWZWMyIFNjcmVlbiByZXNvbHV0aW9uXG4gICAgICB1X3Jlc29sdXRpb246IHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07IC8vIDJ4MiBzbyBpdCBmaWxsIHRoZSBzY3JlZW4uXG5cbiAgICB0aGlzLmdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoMiwgMik7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG4gICAgICB1bmlmb3JtczogdGhpcy51bmlmb3JtcyxcbiAgICAgIHZlcnRleFNoYWRlcjogdnNoYWRlcixcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBmc2hhZGVyXG4gICAgfSk7IC8vIENyZWF0ZSBtZXNoIChnZW9tICsgbWF0ZXJpYWwpXG5cbiAgICB0aGlzLnBsYW5lID0gbmV3IFRIUkVFLk1lc2godGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCk7XG4gICAgdGhpcy5zY2VuZS5hZGQodGhpcy5wbGFuZSk7XG4gICAgdGhpcy5jYW1lcmEucG9zaXRpb24ueiA9IDE7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgIHRoaXMucmFmLnN0YXJ0KCk7XG4gIH1cblxuICBvblJlc2l6ZSgpIHtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgaWYgKGFzcGVjdFJhdGlvID49IDEpIHtcbiAgICAgIHdpZHRoID0gMTtcbiAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAvIHdpbmRvdy5pbm5lcldpZHRoICogd2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gYXNwZWN0UmF0aW87XG4gICAgICBoZWlnaHQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuY2FtZXJhLmxlZnQgPSAtd2lkdGg7XG4gICAgdGhpcy5jYW1lcmEucmlnaHQgPSB3aWR0aDtcbiAgICB0aGlzLmNhbWVyYS50b3AgPSBoZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEuYm90dG9tID0gLWhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS55ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZXZ0KSB7XG4gICAgdGhpcy51bmlmb3Jtcy51X21vdXNlLnZhbHVlLnggPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdLmNsaWVudFggOiBldnQuY2xpZW50WDtcbiAgICB0aGlzLnVuaWZvcm1zLnVfbW91c2UudmFsdWUueSA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WSA6IGV2dC5jbGllbnRZO1xuICB9XG5cbiAgb25SYWYoZGVsdGEpIHtcbiAgICB0aGlzLnVuaWZvcm1zLnVfdGltZS52YWx1ZSArPSB0aGlzLnJhZi5nZXREZWx0YSh0cnVlKTtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBHbHNsUGxheWdyb3VuZDk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/glsl-playground9.js\n");

/***/ }),

/***/ "./examples/hermite-curve.js":
/*!***********************************!*\
  !*** ./examples/hermite-curve.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _domCanvas = __webpack_require__(/*! ../lib/dom/dom-canvas */ \"./lib/dom/dom-canvas.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _hermiteCurve = __webpack_require__(/*! ../lib/mathf/hermite-curve */ \"./lib/mathf/hermite-curve.js\");\n\n/**\n * Demonstrates basic usage of Hermite Curve\n */\nclass HermiteCurveSample {\n  constructor() {\n    this.canvas = document.getElementById('canvas');\n    this.canvas.width = this.canvas.offsetWidth;\n    this.canvas.height = this.canvas.offsetHeight;\n    this.context = this.canvas.getContext('2d');\n    let p0 = new _vector.Vector(50, 400);\n    let m0 = new _vector.Vector(100, 200);\n    let p1 = new _vector.Vector(300, 300);\n    let m1 = new _vector.Vector(400, 400); // Set the number of points we want to draw.\n\n    let drawPoints = 500; // The amount of progress to per dot.\n\n    let progressSpan = 1 / drawPoints;\n\n    for (let step = 0; step < drawPoints; step++) {\n      // Draw a dot along the curve.  The progress value goes from 0-1.\n      let progress = step * progressSpan;\n\n      _domCanvas.domCanvas.setFillColor(this.context, 'orange');\n\n      _domCanvas.domCanvas.setStrokeColor(this.context, 'orange');\n\n      const vector = _hermiteCurve.HermiteCurve.getPoint(progress, p0, m0, p1, m1);\n\n      _domCanvas.domCanvas.vectorPoint(this.context, vector, 2);\n    } // Now draw out a large dot for each point.\n\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'red');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'red');\n\n    _domCanvas.domCanvas.vectorPoint(this.context, p0);\n\n    _domCanvas.domCanvas.quickText(this.context, 'p0', p0.x, p0.y - 4);\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'blue');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'blue');\n\n    _domCanvas.domCanvas.quickText(this.context, 'm0', m0.x, m0.y - 4);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, m0);\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'green');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'green');\n\n    _domCanvas.domCanvas.quickText(this.context, 'p1', p1.x, p1.y - 4);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, p1);\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'purple');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'purple');\n\n    _domCanvas.domCanvas.quickText(this.context, 'm1', m1.x, m1.y - 4);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, m1);\n  }\n\n}\n\nexports.default = HermiteCurveSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9oZXJtaXRlLWN1cnZlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvaGVybWl0ZS1jdXJ2ZS5qcz9hYmVmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2RvbUNhbnZhcyA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS1jYW52YXNcIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi92ZWN0b3JcIik7XG5cbnZhciBfaGVybWl0ZUN1cnZlID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9oZXJtaXRlLWN1cnZlXCIpO1xuXG4vKipcbiAqIERlbW9uc3RyYXRlcyBiYXNpYyB1c2FnZSBvZiBIZXJtaXRlIEN1cnZlXG4gKi9cbmNsYXNzIEhlcm1pdGVDdXJ2ZVNhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpO1xuICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMub2Zmc2V0SGVpZ2h0O1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgbGV0IHAwID0gbmV3IF92ZWN0b3IuVmVjdG9yKDUwLCA0MDApO1xuICAgIGxldCBtMCA9IG5ldyBfdmVjdG9yLlZlY3RvcigxMDAsIDIwMCk7XG4gICAgbGV0IHAxID0gbmV3IF92ZWN0b3IuVmVjdG9yKDMwMCwgMzAwKTtcbiAgICBsZXQgbTEgPSBuZXcgX3ZlY3Rvci5WZWN0b3IoNDAwLCA0MDApOyAvLyBTZXQgdGhlIG51bWJlciBvZiBwb2ludHMgd2Ugd2FudCB0byBkcmF3LlxuXG4gICAgbGV0IGRyYXdQb2ludHMgPSA1MDA7IC8vIFRoZSBhbW91bnQgb2YgcHJvZ3Jlc3MgdG8gcGVyIGRvdC5cblxuICAgIGxldCBwcm9ncmVzc1NwYW4gPSAxIC8gZHJhd1BvaW50cztcblxuICAgIGZvciAobGV0IHN0ZXAgPSAwOyBzdGVwIDwgZHJhd1BvaW50czsgc3RlcCsrKSB7XG4gICAgICAvLyBEcmF3IGEgZG90IGFsb25nIHRoZSBjdXJ2ZS4gIFRoZSBwcm9ncmVzcyB2YWx1ZSBnb2VzIGZyb20gMC0xLlxuICAgICAgbGV0IHByb2dyZXNzID0gc3RlcCAqIHByb2dyZXNzU3BhbjtcblxuICAgICAgX2RvbUNhbnZhcy5kb21DYW52YXMuc2V0RmlsbENvbG9yKHRoaXMuY29udGV4dCwgJ29yYW5nZScpO1xuXG4gICAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRTdHJva2VDb2xvcih0aGlzLmNvbnRleHQsICdvcmFuZ2UnKTtcblxuICAgICAgY29uc3QgdmVjdG9yID0gX2hlcm1pdGVDdXJ2ZS5IZXJtaXRlQ3VydmUuZ2V0UG9pbnQocHJvZ3Jlc3MsIHAwLCBtMCwgcDEsIG0xKTtcblxuICAgICAgX2RvbUNhbnZhcy5kb21DYW52YXMudmVjdG9yUG9pbnQodGhpcy5jb250ZXh0LCB2ZWN0b3IsIDIpO1xuICAgIH0gLy8gTm93IGRyYXcgb3V0IGEgbGFyZ2UgZG90IGZvciBlYWNoIHBvaW50LlxuXG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRGaWxsQ29sb3IodGhpcy5jb250ZXh0LCAncmVkJyk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRTdHJva2VDb2xvcih0aGlzLmNvbnRleHQsICdyZWQnKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnZlY3RvclBvaW50KHRoaXMuY29udGV4dCwgcDApO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMucXVpY2tUZXh0KHRoaXMuY29udGV4dCwgJ3AwJywgcDAueCwgcDAueSAtIDQpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMuc2V0RmlsbENvbG9yKHRoaXMuY29udGV4dCwgJ2JsdWUnKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnNldFN0cm9rZUNvbG9yKHRoaXMuY29udGV4dCwgJ2JsdWUnKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnF1aWNrVGV4dCh0aGlzLmNvbnRleHQsICdtMCcsIG0wLngsIG0wLnkgLSA0KTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnZlY3RvclBvaW50KHRoaXMuY29udGV4dCwgbTApO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMuc2V0RmlsbENvbG9yKHRoaXMuY29udGV4dCwgJ2dyZWVuJyk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRTdHJva2VDb2xvcih0aGlzLmNvbnRleHQsICdncmVlbicpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMucXVpY2tUZXh0KHRoaXMuY29udGV4dCwgJ3AxJywgcDEueCwgcDEueSAtIDQpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMudmVjdG9yUG9pbnQodGhpcy5jb250ZXh0LCBwMSk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRGaWxsQ29sb3IodGhpcy5jb250ZXh0LCAncHVycGxlJyk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRTdHJva2VDb2xvcih0aGlzLmNvbnRleHQsICdwdXJwbGUnKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnF1aWNrVGV4dCh0aGlzLmNvbnRleHQsICdtMScsIG0xLngsIG0xLnkgLSA0KTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnZlY3RvclBvaW50KHRoaXMuY29udGV4dCwgbTEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gSGVybWl0ZUN1cnZlU2FtcGxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/hermite-curve.js\n");

/***/ }),

/***/ "./examples/interpolate.js":
/*!*********************************!*\
  !*** ./examples/interpolate.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _interpolate = __webpack_require__(/*! ../lib/interpolate/interpolate */ \"./lib/interpolate/interpolate.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nclass InterpolateSample {\n  constructor() {\n    console.log('running raf timer sample'); //\n    // Here is an example of updating the ball x, y positions\n    // based on progress (a value between 0-1).\n    //\n    // Here progress is represented by the range input.\n    //\n    // See mathf.ease example as well.\n    //\n\n    this.ball = document.getElementById('ball');\n    this.range = document.getElementById('range');\n    this.progress = +this.range.value;\n    let ballXInter = new _interpolate.Interpolate({\n      from: 0,\n      to: 500,\n      easeFunction: _ease.EASE.easeOutSine\n    });\n    let ballYInter = new _interpolate.Interpolate({\n      from: 0,\n      to: 500,\n      easeFunction: _ease.EASE.easeInCubic\n    }); // Note we are using Raf for demo purposes.  Use [[RafProgress]] to\n    // ease progress and avoid layout thrashing.\n\n    const raf = new _raf.Raf(() => {\n      let progress = +this.range.value; // Add a lerp to the progress itself.\n      // This creates a ease, delayed motion when scrolling.\n      // Note, it's usually recommended to apply only EASE.linear\n      // for progress lerping.\n      // See mathf.ease example as well.\n\n      this.progress = _mathf.mathf.ease(this.progress, progress, 0.25, _ease.EASE.easeInOutQuad); // Uncomment me to see the difference without progress lerping.\n      // this.progress = progress;\n\n      let x = ballXInter.calculate(this.progress);\n      let y = ballYInter.calculate(this.progress);\n      this.updateBallPosition(x, y);\n    }); // raf.setFps(1);\n\n    raf.start();\n  }\n\n  updateBallPosition(x, y) {\n    this.ball.style.transform = `translateX(${x}px) translateY(${y}px)`;\n  }\n\n}\n\nexports.default = InterpolateSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9pbnRlcnBvbGF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL2ludGVycG9sYXRlLmpzPzY2NjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfaW50ZXJwb2xhdGUgPSByZXF1aXJlKFwiLi4vbGliL2ludGVycG9sYXRlL2ludGVycG9sYXRlXCIpO1xuXG52YXIgX21hdGhmID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9tYXRoZlwiKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG5jbGFzcyBJbnRlcnBvbGF0ZVNhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdydW5uaW5nIHJhZiB0aW1lciBzYW1wbGUnKTsgLy9cbiAgICAvLyBIZXJlIGlzIGFuIGV4YW1wbGUgb2YgdXBkYXRpbmcgdGhlIGJhbGwgeCwgeSBwb3NpdGlvbnNcbiAgICAvLyBiYXNlZCBvbiBwcm9ncmVzcyAoYSB2YWx1ZSBiZXR3ZWVuIDAtMSkuXG4gICAgLy9cbiAgICAvLyBIZXJlIHByb2dyZXNzIGlzIHJlcHJlc2VudGVkIGJ5IHRoZSByYW5nZSBpbnB1dC5cbiAgICAvL1xuICAgIC8vIFNlZSBtYXRoZi5lYXNlIGV4YW1wbGUgYXMgd2VsbC5cbiAgICAvL1xuXG4gICAgdGhpcy5iYWxsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhbGwnKTtcbiAgICB0aGlzLnJhbmdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JhbmdlJyk7XG4gICAgdGhpcy5wcm9ncmVzcyA9ICt0aGlzLnJhbmdlLnZhbHVlO1xuICAgIGxldCBiYWxsWEludGVyID0gbmV3IF9pbnRlcnBvbGF0ZS5JbnRlcnBvbGF0ZSh7XG4gICAgICBmcm9tOiAwLFxuICAgICAgdG86IDUwMCxcbiAgICAgIGVhc2VGdW5jdGlvbjogX2Vhc2UuRUFTRS5lYXNlT3V0U2luZVxuICAgIH0pO1xuICAgIGxldCBiYWxsWUludGVyID0gbmV3IF9pbnRlcnBvbGF0ZS5JbnRlcnBvbGF0ZSh7XG4gICAgICBmcm9tOiAwLFxuICAgICAgdG86IDUwMCxcbiAgICAgIGVhc2VGdW5jdGlvbjogX2Vhc2UuRUFTRS5lYXNlSW5DdWJpY1xuICAgIH0pOyAvLyBOb3RlIHdlIGFyZSB1c2luZyBSYWYgZm9yIGRlbW8gcHVycG9zZXMuICBVc2UgW1tSYWZQcm9ncmVzc11dIHRvXG4gICAgLy8gZWFzZSBwcm9ncmVzcyBhbmQgYXZvaWQgbGF5b3V0IHRocmFzaGluZy5cblxuICAgIGNvbnN0IHJhZiA9IG5ldyBfcmFmLlJhZigoKSA9PiB7XG4gICAgICBsZXQgcHJvZ3Jlc3MgPSArdGhpcy5yYW5nZS52YWx1ZTsgLy8gQWRkIGEgbGVycCB0byB0aGUgcHJvZ3Jlc3MgaXRzZWxmLlxuICAgICAgLy8gVGhpcyBjcmVhdGVzIGEgZWFzZSwgZGVsYXllZCBtb3Rpb24gd2hlbiBzY3JvbGxpbmcuXG4gICAgICAvLyBOb3RlLCBpdCdzIHVzdWFsbHkgcmVjb21tZW5kZWQgdG8gYXBwbHkgb25seSBFQVNFLmxpbmVhclxuICAgICAgLy8gZm9yIHByb2dyZXNzIGxlcnBpbmcuXG4gICAgICAvLyBTZWUgbWF0aGYuZWFzZSBleGFtcGxlIGFzIHdlbGwuXG5cbiAgICAgIHRoaXMucHJvZ3Jlc3MgPSBfbWF0aGYubWF0aGYuZWFzZSh0aGlzLnByb2dyZXNzLCBwcm9ncmVzcywgMC4yNSwgX2Vhc2UuRUFTRS5lYXNlSW5PdXRRdWFkKTsgLy8gVW5jb21tZW50IG1lIHRvIHNlZSB0aGUgZGlmZmVyZW5jZSB3aXRob3V0IHByb2dyZXNzIGxlcnBpbmcuXG4gICAgICAvLyB0aGlzLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5cbiAgICAgIGxldCB4ID0gYmFsbFhJbnRlci5jYWxjdWxhdGUodGhpcy5wcm9ncmVzcyk7XG4gICAgICBsZXQgeSA9IGJhbGxZSW50ZXIuY2FsY3VsYXRlKHRoaXMucHJvZ3Jlc3MpO1xuICAgICAgdGhpcy51cGRhdGVCYWxsUG9zaXRpb24oeCwgeSk7XG4gICAgfSk7IC8vIHJhZi5zZXRGcHMoMSk7XG5cbiAgICByYWYuc3RhcnQoKTtcbiAgfVxuXG4gIHVwZGF0ZUJhbGxQb3NpdGlvbih4LCB5KSB7XG4gICAgdGhpcy5iYWxsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7eH1weCkgdHJhbnNsYXRlWSgke3l9cHgpYDtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEludGVycG9sYXRlU2FtcGxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/interpolate.js\n");

/***/ }),

/***/ "./examples/inview.js":
/*!****************************!*\
  !*** ./examples/inview.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _inview = __webpack_require__(/*! ../lib/dom/inview */ \"./lib/dom/inview.js\");\n\nclass InviewSample {\n  constructor() {\n    console.log(\"inview sample\");\n    new _inview.Inview({\n      element: document.getElementById('test0'),\n      elementBaseline: 0,\n      viewportOffset: 0.2\n    });\n    new _inview.Inview({\n      element: document.getElementById('test'),\n      elementBaseline: 0,\n      viewportOffset: 0.2,\n      outviewOnlyOnElementExit: true\n    });\n    new _inview.Inview({\n      element: document.getElementById('test2'),\n      elementBaseline: 0,\n      viewportOffset: 0.2,\n      // outviewOnlyOnElementExit: true\n      downOnlyMode: true\n    });\n  }\n\n}\n\nexports.default = InviewSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9pbnZpZXcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9pbnZpZXcuanM/ZjkxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9pbnZpZXcgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9pbnZpZXdcIik7XG5cbmNsYXNzIEludmlld1NhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKFwiaW52aWV3IHNhbXBsZVwiKTtcbiAgICBuZXcgX2ludmlldy5JbnZpZXcoe1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rlc3QwJyksXG4gICAgICBlbGVtZW50QmFzZWxpbmU6IDAsXG4gICAgICB2aWV3cG9ydE9mZnNldDogMC4yXG4gICAgfSk7XG4gICAgbmV3IF9pbnZpZXcuSW52aWV3KHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXN0JyksXG4gICAgICBlbGVtZW50QmFzZWxpbmU6IDAsXG4gICAgICB2aWV3cG9ydE9mZnNldDogMC4yLFxuICAgICAgb3V0dmlld09ubHlPbkVsZW1lbnRFeGl0OiB0cnVlXG4gICAgfSk7XG4gICAgbmV3IF9pbnZpZXcuSW52aWV3KHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXN0MicpLFxuICAgICAgZWxlbWVudEJhc2VsaW5lOiAwLFxuICAgICAgdmlld3BvcnRPZmZzZXQ6IDAuMixcbiAgICAgIC8vIG91dHZpZXdPbmx5T25FbGVtZW50RXhpdDogdHJ1ZVxuICAgICAgZG93bk9ubHlNb2RlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBJbnZpZXdTYW1wbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/inview.js\n");

/***/ }),

/***/ "./examples/mathf-ease.js":
/*!********************************!*\
  !*** ./examples/mathf-ease.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _cubicBezier = __webpack_require__(/*! ../lib/mathf/cubic-bezier */ \"./lib/mathf/cubic-bezier.js\");\n\nvar _catmullRom = __webpack_require__(/*! ../lib/mathf/catmull-rom */ \"./lib/mathf/catmull-rom.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nclass MathfEaseSample {\n  constructor() {\n    console.log('Mathf Ease Sample'); //\n    // Here is an example of updating the ball x, y positions\n    // based on progress (a value between 0-1).\n    //\n    // Moving the range input, will change the progress from 0-1.\n    //\n    // It is important to note that there are two levels of easing.\n    // The first level of ease is to the x, y POSITIONS of the ball.\n    // This is not easing of the animations (smoothing out interactions),\n    // but is easing calculations of the PATH that the ball should\n    // follow.\n    //\n    // This is calculated with:\n    //    x = mathf.ease(0, 500, this.progress, EASE.easeOutSine);\n    //    y = mathf.ease(0, 500, this.progress, EASE.easeInCubic);\n    //\n    //\n    // In order to smooth out the interaction (create a slight delay,\n    // smoothness),we add a second level of easing to the progress itself.\n    // This is adding EASE to the timeline rather than the path so there is\n    // a distinction.\n    //\n    //    this.progress = mathf.ease(this.progress, progress, 0.25, EASE.easeInOutQuad);\n    //\n    // Applying ease to progression works nicely in cases like this or\n    // in cases like where you are using the window scroll as a input\n    // for progression.\n    //\n    // Below is a demo but for a more performance way to ease progress,\n    // see [[RafProgress]].\n    //\n    // Try applying around with the demo.\n    //\n\n    this.ball = document.getElementById('ball');\n    this.checkbox = document.getElementById('checkbox');\n    this.range = document.getElementById('range');\n    this.progress = +this.range.value; // Note we are using Raf for demo purposes.  Use [[RafProgress]] to\n    // ease progress and avoid layout thrashing.\n\n    const raf = new _raf.Raf(() => {\n      let progress = +this.range.value; // Add a lerp to the progress itself.\n      // This creates a ease, delayed motion when scrolling.\n      // Note, it's usually recommended to apply only EASE.linear\n      // for progress lerping.\n\n      if (this.checkbox.checked) {\n        // this.progress = mathf.ease(this.progress, progress, 0.25, EASE.easeInOutQuad);\n        // this.progress = mathf.ease(this.progress, progress, 0.02, EASE.linear);\n        this.progress = _mathf.mathf.damp(this.progress, progress, 0.25, 0.3);\n      } else {\n        // No easing on progress.\n        this.progress = progress;\n      } // EASE Example\n      // let x = mathf.ease(0, 500, this.progress, EASE.easeOutSine);\n      // let y = mathf.ease(0, 500, this.progress, EASE.easeInCubic);\n      // Cubic Bezier  Example\n      // Keep X as linear so you can see the bezier on the y.\n      // https://cubic-bezier.com/\n      // let x = mathf.ease(0, 500, this.progress,\n      //     EASE.linear);\n      // let y = mathf.ease(500, 0, this.progress,\n      //     CubicBezier.makeEasingFunction(0.17, 0.67, 0.93, -0.12));\n      // Catmull-Rom example.\n\n\n      let catmullEasing = _catmullRom.CatmullRom.interpolate([new _vector.Vector(0, 500), new _vector.Vector(100, 300), new _vector.Vector(200, 200), new _vector.Vector(300, 400), new _vector.Vector(400, 200), new _vector.Vector(500, 300)], 0.5, 0.5); // let x = mathf.ease(0, 500, this.progress,\n      //     EASE.linear);\n      // console.log('x');\n\n\n      let x = catmullEasing(this.progress).x;\n      let y = catmullEasing(this.progress).y; // console.log(y);\n      // console.log(y);\n\n      this.updateBallPosition(x, y);\n    }); // raf.setFps(1);\n\n    raf.start();\n  }\n\n  updateBallPosition(x, y) {\n    this.ball.style.transform = `translateX(${x}px) translateY(${y}px)`;\n  }\n\n}\n\nexports.default = MathfEaseSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9tYXRoZi1lYXNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvbWF0aGYtZWFzZS5qcz9iYzJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGhmID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9tYXRoZlwiKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG52YXIgX2N1YmljQmV6aWVyID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9jdWJpYy1iZXppZXJcIik7XG5cbnZhciBfY2F0bXVsbFJvbSA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvY2F0bXVsbC1yb21cIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi92ZWN0b3JcIik7XG5cbmNsYXNzIE1hdGhmRWFzZVNhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdNYXRoZiBFYXNlIFNhbXBsZScpOyAvL1xuICAgIC8vIEhlcmUgaXMgYW4gZXhhbXBsZSBvZiB1cGRhdGluZyB0aGUgYmFsbCB4LCB5IHBvc2l0aW9uc1xuICAgIC8vIGJhc2VkIG9uIHByb2dyZXNzIChhIHZhbHVlIGJldHdlZW4gMC0xKS5cbiAgICAvL1xuICAgIC8vIE1vdmluZyB0aGUgcmFuZ2UgaW5wdXQsIHdpbGwgY2hhbmdlIHRoZSBwcm9ncmVzcyBmcm9tIDAtMS5cbiAgICAvL1xuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBub3RlIHRoYXQgdGhlcmUgYXJlIHR3byBsZXZlbHMgb2YgZWFzaW5nLlxuICAgIC8vIFRoZSBmaXJzdCBsZXZlbCBvZiBlYXNlIGlzIHRvIHRoZSB4LCB5IFBPU0lUSU9OUyBvZiB0aGUgYmFsbC5cbiAgICAvLyBUaGlzIGlzIG5vdCBlYXNpbmcgb2YgdGhlIGFuaW1hdGlvbnMgKHNtb290aGluZyBvdXQgaW50ZXJhY3Rpb25zKSxcbiAgICAvLyBidXQgaXMgZWFzaW5nIGNhbGN1bGF0aW9ucyBvZiB0aGUgUEFUSCB0aGF0IHRoZSBiYWxsIHNob3VsZFxuICAgIC8vIGZvbGxvdy5cbiAgICAvL1xuICAgIC8vIFRoaXMgaXMgY2FsY3VsYXRlZCB3aXRoOlxuICAgIC8vICAgIHggPSBtYXRoZi5lYXNlKDAsIDUwMCwgdGhpcy5wcm9ncmVzcywgRUFTRS5lYXNlT3V0U2luZSk7XG4gICAgLy8gICAgeSA9IG1hdGhmLmVhc2UoMCwgNTAwLCB0aGlzLnByb2dyZXNzLCBFQVNFLmVhc2VJbkN1YmljKTtcbiAgICAvL1xuICAgIC8vXG4gICAgLy8gSW4gb3JkZXIgdG8gc21vb3RoIG91dCB0aGUgaW50ZXJhY3Rpb24gKGNyZWF0ZSBhIHNsaWdodCBkZWxheSxcbiAgICAvLyBzbW9vdGhuZXNzKSx3ZSBhZGQgYSBzZWNvbmQgbGV2ZWwgb2YgZWFzaW5nIHRvIHRoZSBwcm9ncmVzcyBpdHNlbGYuXG4gICAgLy8gVGhpcyBpcyBhZGRpbmcgRUFTRSB0byB0aGUgdGltZWxpbmUgcmF0aGVyIHRoYW4gdGhlIHBhdGggc28gdGhlcmUgaXNcbiAgICAvLyBhIGRpc3RpbmN0aW9uLlxuICAgIC8vXG4gICAgLy8gICAgdGhpcy5wcm9ncmVzcyA9IG1hdGhmLmVhc2UodGhpcy5wcm9ncmVzcywgcHJvZ3Jlc3MsIDAuMjUsIEVBU0UuZWFzZUluT3V0UXVhZCk7XG4gICAgLy9cbiAgICAvLyBBcHBseWluZyBlYXNlIHRvIHByb2dyZXNzaW9uIHdvcmtzIG5pY2VseSBpbiBjYXNlcyBsaWtlIHRoaXMgb3JcbiAgICAvLyBpbiBjYXNlcyBsaWtlIHdoZXJlIHlvdSBhcmUgdXNpbmcgdGhlIHdpbmRvdyBzY3JvbGwgYXMgYSBpbnB1dFxuICAgIC8vIGZvciBwcm9ncmVzc2lvbi5cbiAgICAvL1xuICAgIC8vIEJlbG93IGlzIGEgZGVtbyBidXQgZm9yIGEgbW9yZSBwZXJmb3JtYW5jZSB3YXkgdG8gZWFzZSBwcm9ncmVzcyxcbiAgICAvLyBzZWUgW1tSYWZQcm9ncmVzc11dLlxuICAgIC8vXG4gICAgLy8gVHJ5IGFwcGx5aW5nIGFyb3VuZCB3aXRoIHRoZSBkZW1vLlxuICAgIC8vXG5cbiAgICB0aGlzLmJhbGwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmFsbCcpO1xuICAgIHRoaXMuY2hlY2tib3ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hlY2tib3gnKTtcbiAgICB0aGlzLnJhbmdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JhbmdlJyk7XG4gICAgdGhpcy5wcm9ncmVzcyA9ICt0aGlzLnJhbmdlLnZhbHVlOyAvLyBOb3RlIHdlIGFyZSB1c2luZyBSYWYgZm9yIGRlbW8gcHVycG9zZXMuICBVc2UgW1tSYWZQcm9ncmVzc11dIHRvXG4gICAgLy8gZWFzZSBwcm9ncmVzcyBhbmQgYXZvaWQgbGF5b3V0IHRocmFzaGluZy5cblxuICAgIGNvbnN0IHJhZiA9IG5ldyBfcmFmLlJhZigoKSA9PiB7XG4gICAgICBsZXQgcHJvZ3Jlc3MgPSArdGhpcy5yYW5nZS52YWx1ZTsgLy8gQWRkIGEgbGVycCB0byB0aGUgcHJvZ3Jlc3MgaXRzZWxmLlxuICAgICAgLy8gVGhpcyBjcmVhdGVzIGEgZWFzZSwgZGVsYXllZCBtb3Rpb24gd2hlbiBzY3JvbGxpbmcuXG4gICAgICAvLyBOb3RlLCBpdCdzIHVzdWFsbHkgcmVjb21tZW5kZWQgdG8gYXBwbHkgb25seSBFQVNFLmxpbmVhclxuICAgICAgLy8gZm9yIHByb2dyZXNzIGxlcnBpbmcuXG5cbiAgICAgIGlmICh0aGlzLmNoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgLy8gdGhpcy5wcm9ncmVzcyA9IG1hdGhmLmVhc2UodGhpcy5wcm9ncmVzcywgcHJvZ3Jlc3MsIDAuMjUsIEVBU0UuZWFzZUluT3V0UXVhZCk7XG4gICAgICAgIC8vIHRoaXMucHJvZ3Jlc3MgPSBtYXRoZi5lYXNlKHRoaXMucHJvZ3Jlc3MsIHByb2dyZXNzLCAwLjAyLCBFQVNFLmxpbmVhcik7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBfbWF0aGYubWF0aGYuZGFtcCh0aGlzLnByb2dyZXNzLCBwcm9ncmVzcywgMC4yNSwgMC4zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIGVhc2luZyBvbiBwcm9ncmVzcy5cbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgfSAvLyBFQVNFIEV4YW1wbGVcbiAgICAgIC8vIGxldCB4ID0gbWF0aGYuZWFzZSgwLCA1MDAsIHRoaXMucHJvZ3Jlc3MsIEVBU0UuZWFzZU91dFNpbmUpO1xuICAgICAgLy8gbGV0IHkgPSBtYXRoZi5lYXNlKDAsIDUwMCwgdGhpcy5wcm9ncmVzcywgRUFTRS5lYXNlSW5DdWJpYyk7XG4gICAgICAvLyBDdWJpYyBCZXppZXIgIEV4YW1wbGVcbiAgICAgIC8vIEtlZXAgWCBhcyBsaW5lYXIgc28geW91IGNhbiBzZWUgdGhlIGJlemllciBvbiB0aGUgeS5cbiAgICAgIC8vIGh0dHBzOi8vY3ViaWMtYmV6aWVyLmNvbS9cbiAgICAgIC8vIGxldCB4ID0gbWF0aGYuZWFzZSgwLCA1MDAsIHRoaXMucHJvZ3Jlc3MsXG4gICAgICAvLyAgICAgRUFTRS5saW5lYXIpO1xuICAgICAgLy8gbGV0IHkgPSBtYXRoZi5lYXNlKDUwMCwgMCwgdGhpcy5wcm9ncmVzcyxcbiAgICAgIC8vICAgICBDdWJpY0Jlemllci5tYWtlRWFzaW5nRnVuY3Rpb24oMC4xNywgMC42NywgMC45MywgLTAuMTIpKTtcbiAgICAgIC8vIENhdG11bGwtUm9tIGV4YW1wbGUuXG5cblxuICAgICAgbGV0IGNhdG11bGxFYXNpbmcgPSBfY2F0bXVsbFJvbS5DYXRtdWxsUm9tLmludGVycG9sYXRlKFtuZXcgX3ZlY3Rvci5WZWN0b3IoMCwgNTAwKSwgbmV3IF92ZWN0b3IuVmVjdG9yKDEwMCwgMzAwKSwgbmV3IF92ZWN0b3IuVmVjdG9yKDIwMCwgMjAwKSwgbmV3IF92ZWN0b3IuVmVjdG9yKDMwMCwgNDAwKSwgbmV3IF92ZWN0b3IuVmVjdG9yKDQwMCwgMjAwKSwgbmV3IF92ZWN0b3IuVmVjdG9yKDUwMCwgMzAwKV0sIDAuNSwgMC41KTsgLy8gbGV0IHggPSBtYXRoZi5lYXNlKDAsIDUwMCwgdGhpcy5wcm9ncmVzcyxcbiAgICAgIC8vICAgICBFQVNFLmxpbmVhcik7XG4gICAgICAvLyBjb25zb2xlLmxvZygneCcpO1xuXG5cbiAgICAgIGxldCB4ID0gY2F0bXVsbEVhc2luZyh0aGlzLnByb2dyZXNzKS54O1xuICAgICAgbGV0IHkgPSBjYXRtdWxsRWFzaW5nKHRoaXMucHJvZ3Jlc3MpLnk7IC8vIGNvbnNvbGUubG9nKHkpO1xuICAgICAgLy8gY29uc29sZS5sb2coeSk7XG5cbiAgICAgIHRoaXMudXBkYXRlQmFsbFBvc2l0aW9uKHgsIHkpO1xuICAgIH0pOyAvLyByYWYuc2V0RnBzKDEpO1xuXG4gICAgcmFmLnN0YXJ0KCk7XG4gIH1cblxuICB1cGRhdGVCYWxsUG9zaXRpb24oeCwgeSkge1xuICAgIHRoaXMuYmFsbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke3h9cHgpIHRyYW5zbGF0ZVkoJHt5fXB4KWA7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBNYXRoZkVhc2VTYW1wbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/mathf-ease.js\n");

/***/ }),

/***/ "./examples/matrixIV.js":
/*!******************************!*\
  !*** ./examples/matrixIV.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _domCanvas = __webpack_require__(/*! ../lib/dom/dom-canvas */ \"./lib/dom/dom-canvas.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _matrixIV = __webpack_require__(/*! ../lib/mathf/matrixIV */ \"./lib/mathf/matrixIV.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _func = __webpack_require__(/*! ../lib/func/func */ \"./lib/func/func.js\");\n\nclass MatrixIVSample {\n  constructor() {\n    console.log('matrixIV sample');\n    this.canvas = document.getElementById('canvas');\n    this.canvas.width = this.canvas.offsetWidth;\n    this.canvas.height = this.canvas.offsetHeight;\n    this.context = this.canvas.getContext('2d'); // First plot out a basic vector\n\n    let c1 = new _vector.Vector(250, 250);\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'purple');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'purple');\n\n    _domCanvas.domCanvas.quickText(this.context, 'c1', c1.x, c1.y - 4);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, c1); // Now we apply a translation.\n\n\n    let c2 = c1.clone().transformWithMatrixIV(new _matrixIV.MatrixIV().translateXyz(10, 10, 0));\n\n    _domCanvas.domCanvas.quickText(this.context, 'c1 translate', c2.x, c2.y - 4);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, c2); // A basic scaling.\n\n\n    let c3 = new _vector.Vector(400, 400);\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'green');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'green');\n\n    _domCanvas.domCanvas.vectorPoint(this.context, c3);\n\n    let c4 = c3.clone().transformWithMatrixIV(new _matrixIV.MatrixIV().scaleXyz(0.8, 0.8, 0));\n\n    _domCanvas.domCanvas.quickText(this.context, 'c4 scale', c4.x, c4.y - 4);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, c4); // Translate multiple points.\n\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'orange');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'orange');\n\n    let c6 = new _vector.Vector(300, 50, 0);\n\n    _func.func.times(180, i => {\n      const point = c6.clone().transformWithMatrixIV(_matrixIV.MatrixIV._.translateXyz(-1.2 * i, 1.5 * i, 0));\n\n      _domCanvas.domCanvas.vectorPoint(this.context, point);\n\n      console.log(point);\n    });\n  }\n\n}\n\nexports.default = MatrixIVSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9tYXRyaXhJVi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL21hdHJpeElWLmpzP2JmZDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZG9tQ2FudmFzID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLWNhbnZhc1wiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL3ZlY3RvclwiKTtcblxudmFyIF9tYXRyaXhJViA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvbWF0cml4SVZcIik7XG5cbnZhciBfbWF0aGYgPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL21hdGhmXCIpO1xuXG52YXIgX2Z1bmMgPSByZXF1aXJlKFwiLi4vbGliL2Z1bmMvZnVuY1wiKTtcblxuY2xhc3MgTWF0cml4SVZTYW1wbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygnbWF0cml4SVYgc2FtcGxlJyk7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzJyk7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsgLy8gRmlyc3QgcGxvdCBvdXQgYSBiYXNpYyB2ZWN0b3JcblxuICAgIGxldCBjMSA9IG5ldyBfdmVjdG9yLlZlY3RvcigyNTAsIDI1MCk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRGaWxsQ29sb3IodGhpcy5jb250ZXh0LCAncHVycGxlJyk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRTdHJva2VDb2xvcih0aGlzLmNvbnRleHQsICdwdXJwbGUnKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnF1aWNrVGV4dCh0aGlzLmNvbnRleHQsICdjMScsIGMxLngsIGMxLnkgLSA0KTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnZlY3RvclBvaW50KHRoaXMuY29udGV4dCwgYzEpOyAvLyBOb3cgd2UgYXBwbHkgYSB0cmFuc2xhdGlvbi5cblxuXG4gICAgbGV0IGMyID0gYzEuY2xvbmUoKS50cmFuc2Zvcm1XaXRoTWF0cml4SVYobmV3IF9tYXRyaXhJVi5NYXRyaXhJVigpLnRyYW5zbGF0ZVh5eigxMCwgMTAsIDApKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnF1aWNrVGV4dCh0aGlzLmNvbnRleHQsICdjMSB0cmFuc2xhdGUnLCBjMi54LCBjMi55IC0gNCk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy52ZWN0b3JQb2ludCh0aGlzLmNvbnRleHQsIGMyKTsgLy8gQSBiYXNpYyBzY2FsaW5nLlxuXG5cbiAgICBsZXQgYzMgPSBuZXcgX3ZlY3Rvci5WZWN0b3IoNDAwLCA0MDApO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMuc2V0RmlsbENvbG9yKHRoaXMuY29udGV4dCwgJ2dyZWVuJyk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRTdHJva2VDb2xvcih0aGlzLmNvbnRleHQsICdncmVlbicpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMudmVjdG9yUG9pbnQodGhpcy5jb250ZXh0LCBjMyk7XG5cbiAgICBsZXQgYzQgPSBjMy5jbG9uZSgpLnRyYW5zZm9ybVdpdGhNYXRyaXhJVihuZXcgX21hdHJpeElWLk1hdHJpeElWKCkuc2NhbGVYeXooMC44LCAwLjgsIDApKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnF1aWNrVGV4dCh0aGlzLmNvbnRleHQsICdjNCBzY2FsZScsIGM0LngsIGM0LnkgLSA0KTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnZlY3RvclBvaW50KHRoaXMuY29udGV4dCwgYzQpOyAvLyBUcmFuc2xhdGUgbXVsdGlwbGUgcG9pbnRzLlxuXG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRGaWxsQ29sb3IodGhpcy5jb250ZXh0LCAnb3JhbmdlJyk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRTdHJva2VDb2xvcih0aGlzLmNvbnRleHQsICdvcmFuZ2UnKTtcblxuICAgIGxldCBjNiA9IG5ldyBfdmVjdG9yLlZlY3RvcigzMDAsIDUwLCAwKTtcblxuICAgIF9mdW5jLmZ1bmMudGltZXMoMTgwLCBpID0+IHtcbiAgICAgIGNvbnN0IHBvaW50ID0gYzYuY2xvbmUoKS50cmFuc2Zvcm1XaXRoTWF0cml4SVYoX21hdHJpeElWLk1hdHJpeElWLl8udHJhbnNsYXRlWHl6KC0xLjIgKiBpLCAxLjUgKiBpLCAwKSk7XG5cbiAgICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnZlY3RvclBvaW50KHRoaXMuY29udGV4dCwgcG9pbnQpO1xuXG4gICAgICBjb25zb2xlLmxvZyhwb2ludCk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBNYXRyaXhJVlNhbXBsZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/matrixIV.js\n");

/***/ }),

/***/ "./examples/matrixIV2.js":
/*!*******************************!*\
  !*** ./examples/matrixIV2.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _domCanvas = __webpack_require__(/*! ../lib/dom/dom-canvas */ \"./lib/dom/dom-canvas.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _matrixIV = __webpack_require__(/*! ../lib/mathf/matrixIV */ \"./lib/mathf/matrixIV.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _func = __webpack_require__(/*! ../lib/func/func */ \"./lib/func/func.js\");\n\n/**\n * An example of applying matrix transforms to a basis polygon.\n * Note that this example, is a very MANUAL way to do things\n * just to do a gentle intro to matrix.\n *\n * See MatrixIV3Sample for a quicker way to do this.\n */\nclass MatrixIV2Sample {\n  constructor() {\n    console.log('matrixIV2 sample');\n    this.canvas = document.getElementById('canvas');\n    this.canvas.width = this.canvas.offsetWidth;\n    this.canvas.height = this.canvas.offsetHeight;\n    this.context = this.canvas.getContext('2d'); // Create a basic polygon.\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'green');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'green'); // Given an up and right vector,\n    // We create a square shape with four points.\n    //\n    //\n    //  p0-------------------------p1\n    //   |           ^             |\n    //   |           |             |\n    //   |           up            |\n    //   |           |             |\n    //   |           x---right-->  |\n    //   |                         |\n    //   |                         |\n    //   |                         |\n    //  p3------------------------p2\n    //\n    //\n    // X is the center of the square/ polygon.\n    // From x we have up (vector) going up and\n    // we also have right (vector) going right.\n    //\n    // From this we can calculate our basis.\n    // p0 = up - right\n    // p1 = up + right\n    // p2 = -up + right\n    // p3 = -up + -right\n    //\n    //\n\n\n    let up = new _vector.Vector(0, 50);\n    let right = new _vector.Vector(50, 0);\n\n    let p0 = _vector.Vector.subtract(up, right);\n\n    let p1 = _vector.Vector.add(up, right);\n\n    let p2 = _vector.Vector.add(_vector.Vector.negate(up), right);\n\n    let p3 = _vector.Vector.add(_vector.Vector.negate(up), _vector.Vector.negate(right)); // We are going to place this in the middle of the screen.\n\n\n    let basePositionVector = new _vector.Vector(250, 250); // Now create the points on the screen (without transformations)\n\n    let t0 = _vector.Vector.add(p0, basePositionVector);\n\n    let t1 = _vector.Vector.add(p1, basePositionVector);\n\n    let t2 = _vector.Vector.add(p2, basePositionVector);\n\n    let t3 = _vector.Vector.add(p3, basePositionVector); // Draw out the points without transformations\n\n\n    _domCanvas.domCanvas.vectorQuadrilateral(this.context, t0, t1, t2, t3); // // Now apply transformation.\n\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'orange');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'orange'); // Let's first create rotation matrix along the Z plan to rotate the\n    // square by 45 degrees.\n\n\n    let angle = 45 * Math.PI / 180;\n    let rotationMatrix = new _matrixIV.MatrixIV().rotate(angle, new _vector.Vector(0, 0, 1)); // Let's also add a scaling matrix to decrease the size of the\n    // whole square.\n\n    let scaleMatrix = new _matrixIV.MatrixIV().scaleXyz(0.5, 0.5, 0.5); // We apply this transformation to the up and right vectors.\n    // Now these are going to be rotated by 45 degress.\n\n    up = up.clone() // This first rotation matrix will rotate the up vector 45 degrees.\n    .transformWithMatrixIV(rotationMatrix) // Now we scale it.\n    .transformWithMatrixIV(scaleMatrix);\n    right = right.clone() // This first rotation matrix will rotate the right vector 45 degrees.\n    .transformWithMatrixIV(rotationMatrix) // Now we scale it.\n    .transformWithMatrixIV(scaleMatrix); // At this point, we still have up and right vectors except they are now\n    // rotated 45 degrees (but are still perpendicular).\n    // Based on this, we calculate the p0-p3 points.\n    // This is shaped more like a diamond where p0 is the top and p2 is the bottom.\n\n    p0 = _vector.Vector.subtract(up, right);\n    p1 = _vector.Vector.add(up, right);\n    p2 = _vector.Vector.add(_vector.Vector.negate(up), right);\n    p3 = _vector.Vector.add(_vector.Vector.negate(up), _vector.Vector.negate(right)); // Let's also add a translation to the base position\n    // to draw this slighly to the side.\n\n    let translateMatrix = new _matrixIV.MatrixIV().translateXyz(-100, -100, 0);\n    basePositionVector.transformWithMatrixIV(translateMatrix); // Now we shift each point to where we are suppose to draw it.\n\n    t0 = _vector.Vector.add(p0, basePositionVector);\n    t1 = _vector.Vector.add(p1, basePositionVector);\n    t2 = _vector.Vector.add(p2, basePositionVector);\n    t3 = _vector.Vector.add(p3, basePositionVector);\n\n    _domCanvas.domCanvas.vectorQuadrilateral(this.context, t0, t1, t2, t3);\n  }\n\n}\n\nexports.default = MatrixIV2Sample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9tYXRyaXhJVjIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9tYXRyaXhJVjIuanM/NGM1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9kb21DYW52YXMgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20tY2FudmFzXCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvdmVjdG9yXCIpO1xuXG52YXIgX21hdHJpeElWID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9tYXRyaXhJVlwiKTtcblxudmFyIF9tYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvbWF0aGZcIik7XG5cbnZhciBfZnVuYyA9IHJlcXVpcmUoXCIuLi9saWIvZnVuYy9mdW5jXCIpO1xuXG4vKipcbiAqIEFuIGV4YW1wbGUgb2YgYXBwbHlpbmcgbWF0cml4IHRyYW5zZm9ybXMgdG8gYSBiYXNpcyBwb2x5Z29uLlxuICogTm90ZSB0aGF0IHRoaXMgZXhhbXBsZSwgaXMgYSB2ZXJ5IE1BTlVBTCB3YXkgdG8gZG8gdGhpbmdzXG4gKiBqdXN0IHRvIGRvIGEgZ2VudGxlIGludHJvIHRvIG1hdHJpeC5cbiAqXG4gKiBTZWUgTWF0cml4SVYzU2FtcGxlIGZvciBhIHF1aWNrZXIgd2F5IHRvIGRvIHRoaXMuXG4gKi9cbmNsYXNzIE1hdHJpeElWMlNhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdtYXRyaXhJVjIgc2FtcGxlJyk7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzJyk7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsgLy8gQ3JlYXRlIGEgYmFzaWMgcG9seWdvbi5cblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnNldEZpbGxDb2xvcih0aGlzLmNvbnRleHQsICdncmVlbicpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMuc2V0U3Ryb2tlQ29sb3IodGhpcy5jb250ZXh0LCAnZ3JlZW4nKTsgLy8gR2l2ZW4gYW4gdXAgYW5kIHJpZ2h0IHZlY3RvcixcbiAgICAvLyBXZSBjcmVhdGUgYSBzcXVhcmUgc2hhcGUgd2l0aCBmb3VyIHBvaW50cy5cbiAgICAvL1xuICAgIC8vXG4gICAgLy8gIHAwLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXAxXG4gICAgLy8gICB8ICAgICAgICAgICBeICAgICAgICAgICAgIHxcbiAgICAvLyAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgfFxuICAgIC8vICAgfCAgICAgICAgICAgdXAgICAgICAgICAgICB8XG4gICAgLy8gICB8ICAgICAgICAgICB8ICAgICAgICAgICAgIHxcbiAgICAvLyAgIHwgICAgICAgICAgIHgtLS1yaWdodC0tPiAgfFxuICAgIC8vICAgfCAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICB8ICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICBwMy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXAyXG4gICAgLy9cbiAgICAvL1xuICAgIC8vIFggaXMgdGhlIGNlbnRlciBvZiB0aGUgc3F1YXJlLyBwb2x5Z29uLlxuICAgIC8vIEZyb20geCB3ZSBoYXZlIHVwICh2ZWN0b3IpIGdvaW5nIHVwIGFuZFxuICAgIC8vIHdlIGFsc28gaGF2ZSByaWdodCAodmVjdG9yKSBnb2luZyByaWdodC5cbiAgICAvL1xuICAgIC8vIEZyb20gdGhpcyB3ZSBjYW4gY2FsY3VsYXRlIG91ciBiYXNpcy5cbiAgICAvLyBwMCA9IHVwIC0gcmlnaHRcbiAgICAvLyBwMSA9IHVwICsgcmlnaHRcbiAgICAvLyBwMiA9IC11cCArIHJpZ2h0XG4gICAgLy8gcDMgPSAtdXAgKyAtcmlnaHRcbiAgICAvL1xuICAgIC8vXG5cblxuICAgIGxldCB1cCA9IG5ldyBfdmVjdG9yLlZlY3RvcigwLCA1MCk7XG4gICAgbGV0IHJpZ2h0ID0gbmV3IF92ZWN0b3IuVmVjdG9yKDUwLCAwKTtcblxuICAgIGxldCBwMCA9IF92ZWN0b3IuVmVjdG9yLnN1YnRyYWN0KHVwLCByaWdodCk7XG5cbiAgICBsZXQgcDEgPSBfdmVjdG9yLlZlY3Rvci5hZGQodXAsIHJpZ2h0KTtcblxuICAgIGxldCBwMiA9IF92ZWN0b3IuVmVjdG9yLmFkZChfdmVjdG9yLlZlY3Rvci5uZWdhdGUodXApLCByaWdodCk7XG5cbiAgICBsZXQgcDMgPSBfdmVjdG9yLlZlY3Rvci5hZGQoX3ZlY3Rvci5WZWN0b3IubmVnYXRlKHVwKSwgX3ZlY3Rvci5WZWN0b3IubmVnYXRlKHJpZ2h0KSk7IC8vIFdlIGFyZSBnb2luZyB0byBwbGFjZSB0aGlzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbi5cblxuXG4gICAgbGV0IGJhc2VQb3NpdGlvblZlY3RvciA9IG5ldyBfdmVjdG9yLlZlY3RvcigyNTAsIDI1MCk7IC8vIE5vdyBjcmVhdGUgdGhlIHBvaW50cyBvbiB0aGUgc2NyZWVuICh3aXRob3V0IHRyYW5zZm9ybWF0aW9ucylcblxuICAgIGxldCB0MCA9IF92ZWN0b3IuVmVjdG9yLmFkZChwMCwgYmFzZVBvc2l0aW9uVmVjdG9yKTtcblxuICAgIGxldCB0MSA9IF92ZWN0b3IuVmVjdG9yLmFkZChwMSwgYmFzZVBvc2l0aW9uVmVjdG9yKTtcblxuICAgIGxldCB0MiA9IF92ZWN0b3IuVmVjdG9yLmFkZChwMiwgYmFzZVBvc2l0aW9uVmVjdG9yKTtcblxuICAgIGxldCB0MyA9IF92ZWN0b3IuVmVjdG9yLmFkZChwMywgYmFzZVBvc2l0aW9uVmVjdG9yKTsgLy8gRHJhdyBvdXQgdGhlIHBvaW50cyB3aXRob3V0IHRyYW5zZm9ybWF0aW9uc1xuXG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy52ZWN0b3JRdWFkcmlsYXRlcmFsKHRoaXMuY29udGV4dCwgdDAsIHQxLCB0MiwgdDMpOyAvLyAvLyBOb3cgYXBwbHkgdHJhbnNmb3JtYXRpb24uXG5cblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnNldEZpbGxDb2xvcih0aGlzLmNvbnRleHQsICdvcmFuZ2UnKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnNldFN0cm9rZUNvbG9yKHRoaXMuY29udGV4dCwgJ29yYW5nZScpOyAvLyBMZXQncyBmaXJzdCBjcmVhdGUgcm90YXRpb24gbWF0cml4IGFsb25nIHRoZSBaIHBsYW4gdG8gcm90YXRlIHRoZVxuICAgIC8vIHNxdWFyZSBieSA0NSBkZWdyZWVzLlxuXG5cbiAgICBsZXQgYW5nbGUgPSA0NSAqIE1hdGguUEkgLyAxODA7XG4gICAgbGV0IHJvdGF0aW9uTWF0cml4ID0gbmV3IF9tYXRyaXhJVi5NYXRyaXhJVigpLnJvdGF0ZShhbmdsZSwgbmV3IF92ZWN0b3IuVmVjdG9yKDAsIDAsIDEpKTsgLy8gTGV0J3MgYWxzbyBhZGQgYSBzY2FsaW5nIG1hdHJpeCB0byBkZWNyZWFzZSB0aGUgc2l6ZSBvZiB0aGVcbiAgICAvLyB3aG9sZSBzcXVhcmUuXG5cbiAgICBsZXQgc2NhbGVNYXRyaXggPSBuZXcgX21hdHJpeElWLk1hdHJpeElWKCkuc2NhbGVYeXooMC41LCAwLjUsIDAuNSk7IC8vIFdlIGFwcGx5IHRoaXMgdHJhbnNmb3JtYXRpb24gdG8gdGhlIHVwIGFuZCByaWdodCB2ZWN0b3JzLlxuICAgIC8vIE5vdyB0aGVzZSBhcmUgZ29pbmcgdG8gYmUgcm90YXRlZCBieSA0NSBkZWdyZXNzLlxuXG4gICAgdXAgPSB1cC5jbG9uZSgpIC8vIFRoaXMgZmlyc3Qgcm90YXRpb24gbWF0cml4IHdpbGwgcm90YXRlIHRoZSB1cCB2ZWN0b3IgNDUgZGVncmVlcy5cbiAgICAudHJhbnNmb3JtV2l0aE1hdHJpeElWKHJvdGF0aW9uTWF0cml4KSAvLyBOb3cgd2Ugc2NhbGUgaXQuXG4gICAgLnRyYW5zZm9ybVdpdGhNYXRyaXhJVihzY2FsZU1hdHJpeCk7XG4gICAgcmlnaHQgPSByaWdodC5jbG9uZSgpIC8vIFRoaXMgZmlyc3Qgcm90YXRpb24gbWF0cml4IHdpbGwgcm90YXRlIHRoZSByaWdodCB2ZWN0b3IgNDUgZGVncmVlcy5cbiAgICAudHJhbnNmb3JtV2l0aE1hdHJpeElWKHJvdGF0aW9uTWF0cml4KSAvLyBOb3cgd2Ugc2NhbGUgaXQuXG4gICAgLnRyYW5zZm9ybVdpdGhNYXRyaXhJVihzY2FsZU1hdHJpeCk7IC8vIEF0IHRoaXMgcG9pbnQsIHdlIHN0aWxsIGhhdmUgdXAgYW5kIHJpZ2h0IHZlY3RvcnMgZXhjZXB0IHRoZXkgYXJlIG5vd1xuICAgIC8vIHJvdGF0ZWQgNDUgZGVncmVlcyAoYnV0IGFyZSBzdGlsbCBwZXJwZW5kaWN1bGFyKS5cbiAgICAvLyBCYXNlZCBvbiB0aGlzLCB3ZSBjYWxjdWxhdGUgdGhlIHAwLXAzIHBvaW50cy5cbiAgICAvLyBUaGlzIGlzIHNoYXBlZCBtb3JlIGxpa2UgYSBkaWFtb25kIHdoZXJlIHAwIGlzIHRoZSB0b3AgYW5kIHAyIGlzIHRoZSBib3R0b20uXG5cbiAgICBwMCA9IF92ZWN0b3IuVmVjdG9yLnN1YnRyYWN0KHVwLCByaWdodCk7XG4gICAgcDEgPSBfdmVjdG9yLlZlY3Rvci5hZGQodXAsIHJpZ2h0KTtcbiAgICBwMiA9IF92ZWN0b3IuVmVjdG9yLmFkZChfdmVjdG9yLlZlY3Rvci5uZWdhdGUodXApLCByaWdodCk7XG4gICAgcDMgPSBfdmVjdG9yLlZlY3Rvci5hZGQoX3ZlY3Rvci5WZWN0b3IubmVnYXRlKHVwKSwgX3ZlY3Rvci5WZWN0b3IubmVnYXRlKHJpZ2h0KSk7IC8vIExldCdzIGFsc28gYWRkIGEgdHJhbnNsYXRpb24gdG8gdGhlIGJhc2UgcG9zaXRpb25cbiAgICAvLyB0byBkcmF3IHRoaXMgc2xpZ2hseSB0byB0aGUgc2lkZS5cblxuICAgIGxldCB0cmFuc2xhdGVNYXRyaXggPSBuZXcgX21hdHJpeElWLk1hdHJpeElWKCkudHJhbnNsYXRlWHl6KC0xMDAsIC0xMDAsIDApO1xuICAgIGJhc2VQb3NpdGlvblZlY3Rvci50cmFuc2Zvcm1XaXRoTWF0cml4SVYodHJhbnNsYXRlTWF0cml4KTsgLy8gTm93IHdlIHNoaWZ0IGVhY2ggcG9pbnQgdG8gd2hlcmUgd2UgYXJlIHN1cHBvc2UgdG8gZHJhdyBpdC5cblxuICAgIHQwID0gX3ZlY3Rvci5WZWN0b3IuYWRkKHAwLCBiYXNlUG9zaXRpb25WZWN0b3IpO1xuICAgIHQxID0gX3ZlY3Rvci5WZWN0b3IuYWRkKHAxLCBiYXNlUG9zaXRpb25WZWN0b3IpO1xuICAgIHQyID0gX3ZlY3Rvci5WZWN0b3IuYWRkKHAyLCBiYXNlUG9zaXRpb25WZWN0b3IpO1xuICAgIHQzID0gX3ZlY3Rvci5WZWN0b3IuYWRkKHAzLCBiYXNlUG9zaXRpb25WZWN0b3IpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMudmVjdG9yUXVhZHJpbGF0ZXJhbCh0aGlzLmNvbnRleHQsIHQwLCB0MSwgdDIsIHQzKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1hdHJpeElWMlNhbXBsZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/matrixIV2.js\n");

/***/ }),

/***/ "./examples/matrixIV3.js":
/*!*******************************!*\
  !*** ./examples/matrixIV3.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _domCanvas = __webpack_require__(/*! ../lib/dom/dom-canvas */ \"./lib/dom/dom-canvas.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _matrixIV = __webpack_require__(/*! ../lib/mathf/matrixIV */ \"./lib/mathf/matrixIV.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _func = __webpack_require__(/*! ../lib/func/func */ \"./lib/func/func.js\");\n\n/**\n * An example of applying matrix transforms to a basis polygon.\n * @see https://www.youtube.com/watch?v=8sqv11x10lc&feature=youtu.be\n */\nclass MatrixIV3Sample {\n  constructor() {\n    console.log('matrixIV3 sample');\n    this.canvas = document.getElementById('canvas');\n    this.canvas.width = this.canvas.offsetWidth;\n    this.canvas.height = this.canvas.offsetHeight;\n    this.context = this.canvas.getContext('2d');\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'green');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'green'); // Out goal is to layout a 100x100 square in the middle of the screen.\n    // We will then rotate that square by 45 degrees and scale it 0.5.\n    //\n    //\n    // To begin, we want to think of a basisMatrix to formulate the square.\n    //\n    //  p0-------------------------p1\n    //   |           ^             |\n    //   |           |             |\n    //   |           up            |\n    //   |           |             |\n    //   |           x---right-->  |\n    //   |                         |\n    //   |                         |\n    //   |                         |\n    //  p3------------------------p2\n    //\n    //\n    // X is the center of the square/ polygon.\n    // From x we have up (vector) going up and\n    // we also have right (vector) going right.\n    // We will so have a forward (vector) going\n    // in the z plane which is a cross product of up.\n    //\n    // You can see that each of the points, can also be\n    // expressed as a vector from the center X.\n    // p0 = Vector(-1, -1)\n    // p1 = Vector(1, -1)\n    // p2 = Vector(1, 1)\n    // p3 = Vector(-1, 1)\n    // We define our vectors.  Since we want 100x100 pixels, we set the\n    // vectors from the x point.\n\n\n    let up = new _vector.Vector(0, 50);\n    let right = new _vector.Vector(50, 0); // To make this work, we are also going to\n    // need a forward vector (going in 3D space)\n    // which is the cross product of up vector.\n\n    let forward = _vector.Vector.ONE.cross(up); //\n    // Let's create out basisMatrix.\n    // We create a 4x4 matrix with the right, up and foward vectors as\n    // columns.\n    //\n    // This is visualized as:\n    // Basic Matrix =\n    // [\n    //   Rx, Ux, Fx, 0\n    //   Ry, Uy, Fy, 0\n    //   Rz, Uz, Fz, 0\n    //    0,  0,  0, 1\n    // ]\n    //\n    // From here, we will then multiply that by a matrix\n    // of each point of corner we want.\n    //\n    //     Basis Matrix         4x1 (Vector)\n    //   Rx, Ux, Fx, 0               x\n    //   Ry, Uy, Fy, 0     x         y\n    //   Rz, Uz, Fz, 0               z\n    //    0,  0,  0, 1               1\n    //\n    // The resulting 4x1 matrix will give us the x,y,z coordinates of\n    // each point relative to the center point.\n\n\n    let basisMatrix = new _matrixIV.MatrixIV();\n    basisMatrix.setVectorColumn(0, right);\n    basisMatrix.setVectorColumn(1, up);\n    basisMatrix.setVectorColumn(2, forward); //\n    // Now we want to get the coordinates of each of the 4 corners of\n    // the square as mentioned above.  First we create vectors for each point.\n\n    let p0 = new _vector.Vector(-1, -1);\n    let p1 = new _vector.Vector(1, -1);\n    let p2 = new _vector.Vector(1, 1);\n    let p3 = new _vector.Vector(-1, 1); // Now we are multiply this corner point vector by the 4x4 basis matrix.\n    // Under the hood, multiplyByVector converts the vector to a 4x1\n    // matrix and that is multiplied by the basisMatrix.\n    // We get a new vector returns which is the product of multiplying the\n    // vector and the basis matrix.\n    // In short, we are multiplying the basisMatrix by the values of the\n    // point vectors to calculate the relative x,y,z coordinates.\n\n    let t0 = basisMatrix.clone().multiplyByVector(p0);\n    let t1 = basisMatrix.clone().multiplyByVector(p1);\n    let t2 = basisMatrix.clone().multiplyByVector(p2);\n    let t3 = basisMatrix.clone().multiplyByVector(p3); // We are going to place this in the middle of the screen so let's\n    // shift over each point.\n\n    let basePositionVector = new _vector.Vector(250, 250);\n    t0.add(basePositionVector);\n    t1.add(basePositionVector);\n    t2.add(basePositionVector);\n    t3.add(basePositionVector);\n\n    _domCanvas.domCanvas.quickText(this.context, 't0', t0.x, t0.y - 4);\n\n    _domCanvas.domCanvas.quickText(this.context, 't1', t1.x, t1.y - 4);\n\n    _domCanvas.domCanvas.quickText(this.context, 't2', t2.x, t2.y - 4);\n\n    _domCanvas.domCanvas.quickText(this.context, 't3', t3.x, t3.y - 4); // Add this point, we have laid out four dots as a square.\n\n\n    _domCanvas.domCanvas.vectorPoint(this.context, t0);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, t1);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, t2);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, t3);\n\n    _domCanvas.domCanvas.setFillColor(this.context, 'orange');\n\n    _domCanvas.domCanvas.setStrokeColor(this.context, 'orange'); // Now let's draw another set of dots but this time, transform\n    // the basisMatrix.\n\n\n    basisMatrix.scaleXyz(0.5, 0.5, 0.5).rotateZ(45 * Math.PI / 180); // Now that the basis Matrix is rotated, let's make the new square.\n    // Again we are going to calculate the corners by multiplying the\n    // the corner vectors.\n\n    t0 = basisMatrix.clone().multiplyByVector(p0);\n    t1 = basisMatrix.clone().multiplyByVector(p1);\n    t2 = basisMatrix.clone().multiplyByVector(p2);\n    t3 = basisMatrix.clone().multiplyByVector(p3); // Move the points to the center of the screen.\n\n    t0.add(basePositionVector);\n    t1.add(basePositionVector);\n    t2.add(basePositionVector);\n    t3.add(basePositionVector); // Draw the points.\n\n    _domCanvas.domCanvas.vectorPoint(this.context, t0);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, t1);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, t2);\n\n    _domCanvas.domCanvas.vectorPoint(this.context, t3);\n  }\n\n}\n\nexports.default = MatrixIV3Sample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9tYXRyaXhJVjMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9tYXRyaXhJVjMuanM/NTA0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9kb21DYW52YXMgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20tY2FudmFzXCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvdmVjdG9yXCIpO1xuXG52YXIgX21hdHJpeElWID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9tYXRyaXhJVlwiKTtcblxudmFyIF9tYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvbWF0aGZcIik7XG5cbnZhciBfZnVuYyA9IHJlcXVpcmUoXCIuLi9saWIvZnVuYy9mdW5jXCIpO1xuXG4vKipcbiAqIEFuIGV4YW1wbGUgb2YgYXBwbHlpbmcgbWF0cml4IHRyYW5zZm9ybXMgdG8gYSBiYXNpcyBwb2x5Z29uLlxuICogQHNlZSBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PThzcXYxMXgxMGxjJmZlYXR1cmU9eW91dHUuYmVcbiAqL1xuY2xhc3MgTWF0cml4SVYzU2FtcGxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coJ21hdHJpeElWMyBzYW1wbGUnKTtcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTtcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLm9mZnNldFdpZHRoO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuY2FudmFzLm9mZnNldEhlaWdodDtcbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMuc2V0RmlsbENvbG9yKHRoaXMuY29udGV4dCwgJ2dyZWVuJyk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy5zZXRTdHJva2VDb2xvcih0aGlzLmNvbnRleHQsICdncmVlbicpOyAvLyBPdXQgZ29hbCBpcyB0byBsYXlvdXQgYSAxMDB4MTAwIHNxdWFyZSBpbiB0aGUgbWlkZGxlIG9mIHRoZSBzY3JlZW4uXG4gICAgLy8gV2Ugd2lsbCB0aGVuIHJvdGF0ZSB0aGF0IHNxdWFyZSBieSA0NSBkZWdyZWVzIGFuZCBzY2FsZSBpdCAwLjUuXG4gICAgLy9cbiAgICAvL1xuICAgIC8vIFRvIGJlZ2luLCB3ZSB3YW50IHRvIHRoaW5rIG9mIGEgYmFzaXNNYXRyaXggdG8gZm9ybXVsYXRlIHRoZSBzcXVhcmUuXG4gICAgLy9cbiAgICAvLyAgcDAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tcDFcbiAgICAvLyAgIHwgICAgICAgICAgIF4gICAgICAgICAgICAgfFxuICAgIC8vICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICB8XG4gICAgLy8gICB8ICAgICAgICAgICB1cCAgICAgICAgICAgIHxcbiAgICAvLyAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgfFxuICAgIC8vICAgfCAgICAgICAgICAgeC0tLXJpZ2h0LS0+ICB8XG4gICAgLy8gICB8ICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgfCAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gIHAzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tcDJcbiAgICAvL1xuICAgIC8vXG4gICAgLy8gWCBpcyB0aGUgY2VudGVyIG9mIHRoZSBzcXVhcmUvIHBvbHlnb24uXG4gICAgLy8gRnJvbSB4IHdlIGhhdmUgdXAgKHZlY3RvcikgZ29pbmcgdXAgYW5kXG4gICAgLy8gd2UgYWxzbyBoYXZlIHJpZ2h0ICh2ZWN0b3IpIGdvaW5nIHJpZ2h0LlxuICAgIC8vIFdlIHdpbGwgc28gaGF2ZSBhIGZvcndhcmQgKHZlY3RvcikgZ29pbmdcbiAgICAvLyBpbiB0aGUgeiBwbGFuZSB3aGljaCBpcyBhIGNyb3NzIHByb2R1Y3Qgb2YgdXAuXG4gICAgLy9cbiAgICAvLyBZb3UgY2FuIHNlZSB0aGF0IGVhY2ggb2YgdGhlIHBvaW50cywgY2FuIGFsc28gYmVcbiAgICAvLyBleHByZXNzZWQgYXMgYSB2ZWN0b3IgZnJvbSB0aGUgY2VudGVyIFguXG4gICAgLy8gcDAgPSBWZWN0b3IoLTEsIC0xKVxuICAgIC8vIHAxID0gVmVjdG9yKDEsIC0xKVxuICAgIC8vIHAyID0gVmVjdG9yKDEsIDEpXG4gICAgLy8gcDMgPSBWZWN0b3IoLTEsIDEpXG4gICAgLy8gV2UgZGVmaW5lIG91ciB2ZWN0b3JzLiAgU2luY2Ugd2Ugd2FudCAxMDB4MTAwIHBpeGVscywgd2Ugc2V0IHRoZVxuICAgIC8vIHZlY3RvcnMgZnJvbSB0aGUgeCBwb2ludC5cblxuXG4gICAgbGV0IHVwID0gbmV3IF92ZWN0b3IuVmVjdG9yKDAsIDUwKTtcbiAgICBsZXQgcmlnaHQgPSBuZXcgX3ZlY3Rvci5WZWN0b3IoNTAsIDApOyAvLyBUbyBtYWtlIHRoaXMgd29yaywgd2UgYXJlIGFsc28gZ29pbmcgdG9cbiAgICAvLyBuZWVkIGEgZm9yd2FyZCB2ZWN0b3IgKGdvaW5nIGluIDNEIHNwYWNlKVxuICAgIC8vIHdoaWNoIGlzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHVwIHZlY3Rvci5cblxuICAgIGxldCBmb3J3YXJkID0gX3ZlY3Rvci5WZWN0b3IuT05FLmNyb3NzKHVwKTsgLy9cbiAgICAvLyBMZXQncyBjcmVhdGUgb3V0IGJhc2lzTWF0cml4LlxuICAgIC8vIFdlIGNyZWF0ZSBhIDR4NCBtYXRyaXggd2l0aCB0aGUgcmlnaHQsIHVwIGFuZCBmb3dhcmQgdmVjdG9ycyBhc1xuICAgIC8vIGNvbHVtbnMuXG4gICAgLy9cbiAgICAvLyBUaGlzIGlzIHZpc3VhbGl6ZWQgYXM6XG4gICAgLy8gQmFzaWMgTWF0cml4ID1cbiAgICAvLyBbXG4gICAgLy8gICBSeCwgVXgsIEZ4LCAwXG4gICAgLy8gICBSeSwgVXksIEZ5LCAwXG4gICAgLy8gICBSeiwgVXosIEZ6LCAwXG4gICAgLy8gICAgMCwgIDAsICAwLCAxXG4gICAgLy8gXVxuICAgIC8vXG4gICAgLy8gRnJvbSBoZXJlLCB3ZSB3aWxsIHRoZW4gbXVsdGlwbHkgdGhhdCBieSBhIG1hdHJpeFxuICAgIC8vIG9mIGVhY2ggcG9pbnQgb2YgY29ybmVyIHdlIHdhbnQuXG4gICAgLy9cbiAgICAvLyAgICAgQmFzaXMgTWF0cml4ICAgICAgICAgNHgxIChWZWN0b3IpXG4gICAgLy8gICBSeCwgVXgsIEZ4LCAwICAgICAgICAgICAgICAgeFxuICAgIC8vICAgUnksIFV5LCBGeSwgMCAgICAgeCAgICAgICAgIHlcbiAgICAvLyAgIFJ6LCBVeiwgRnosIDAgICAgICAgICAgICAgICB6XG4gICAgLy8gICAgMCwgIDAsICAwLCAxICAgICAgICAgICAgICAgMVxuICAgIC8vXG4gICAgLy8gVGhlIHJlc3VsdGluZyA0eDEgbWF0cml4IHdpbGwgZ2l2ZSB1cyB0aGUgeCx5LHogY29vcmRpbmF0ZXMgb2ZcbiAgICAvLyBlYWNoIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgcG9pbnQuXG5cblxuICAgIGxldCBiYXNpc01hdHJpeCA9IG5ldyBfbWF0cml4SVYuTWF0cml4SVYoKTtcbiAgICBiYXNpc01hdHJpeC5zZXRWZWN0b3JDb2x1bW4oMCwgcmlnaHQpO1xuICAgIGJhc2lzTWF0cml4LnNldFZlY3RvckNvbHVtbigxLCB1cCk7XG4gICAgYmFzaXNNYXRyaXguc2V0VmVjdG9yQ29sdW1uKDIsIGZvcndhcmQpOyAvL1xuICAgIC8vIE5vdyB3ZSB3YW50IHRvIGdldCB0aGUgY29vcmRpbmF0ZXMgb2YgZWFjaCBvZiB0aGUgNCBjb3JuZXJzIG9mXG4gICAgLy8gdGhlIHNxdWFyZSBhcyBtZW50aW9uZWQgYWJvdmUuICBGaXJzdCB3ZSBjcmVhdGUgdmVjdG9ycyBmb3IgZWFjaCBwb2ludC5cblxuICAgIGxldCBwMCA9IG5ldyBfdmVjdG9yLlZlY3RvcigtMSwgLTEpO1xuICAgIGxldCBwMSA9IG5ldyBfdmVjdG9yLlZlY3RvcigxLCAtMSk7XG4gICAgbGV0IHAyID0gbmV3IF92ZWN0b3IuVmVjdG9yKDEsIDEpO1xuICAgIGxldCBwMyA9IG5ldyBfdmVjdG9yLlZlY3RvcigtMSwgMSk7IC8vIE5vdyB3ZSBhcmUgbXVsdGlwbHkgdGhpcyBjb3JuZXIgcG9pbnQgdmVjdG9yIGJ5IHRoZSA0eDQgYmFzaXMgbWF0cml4LlxuICAgIC8vIFVuZGVyIHRoZSBob29kLCBtdWx0aXBseUJ5VmVjdG9yIGNvbnZlcnRzIHRoZSB2ZWN0b3IgdG8gYSA0eDFcbiAgICAvLyBtYXRyaXggYW5kIHRoYXQgaXMgbXVsdGlwbGllZCBieSB0aGUgYmFzaXNNYXRyaXguXG4gICAgLy8gV2UgZ2V0IGEgbmV3IHZlY3RvciByZXR1cm5zIHdoaWNoIGlzIHRoZSBwcm9kdWN0IG9mIG11bHRpcGx5aW5nIHRoZVxuICAgIC8vIHZlY3RvciBhbmQgdGhlIGJhc2lzIG1hdHJpeC5cbiAgICAvLyBJbiBzaG9ydCwgd2UgYXJlIG11bHRpcGx5aW5nIHRoZSBiYXNpc01hdHJpeCBieSB0aGUgdmFsdWVzIG9mIHRoZVxuICAgIC8vIHBvaW50IHZlY3RvcnMgdG8gY2FsY3VsYXRlIHRoZSByZWxhdGl2ZSB4LHkseiBjb29yZGluYXRlcy5cblxuICAgIGxldCB0MCA9IGJhc2lzTWF0cml4LmNsb25lKCkubXVsdGlwbHlCeVZlY3RvcihwMCk7XG4gICAgbGV0IHQxID0gYmFzaXNNYXRyaXguY2xvbmUoKS5tdWx0aXBseUJ5VmVjdG9yKHAxKTtcbiAgICBsZXQgdDIgPSBiYXNpc01hdHJpeC5jbG9uZSgpLm11bHRpcGx5QnlWZWN0b3IocDIpO1xuICAgIGxldCB0MyA9IGJhc2lzTWF0cml4LmNsb25lKCkubXVsdGlwbHlCeVZlY3RvcihwMyk7IC8vIFdlIGFyZSBnb2luZyB0byBwbGFjZSB0aGlzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbiBzbyBsZXQnc1xuICAgIC8vIHNoaWZ0IG92ZXIgZWFjaCBwb2ludC5cblxuICAgIGxldCBiYXNlUG9zaXRpb25WZWN0b3IgPSBuZXcgX3ZlY3Rvci5WZWN0b3IoMjUwLCAyNTApO1xuICAgIHQwLmFkZChiYXNlUG9zaXRpb25WZWN0b3IpO1xuICAgIHQxLmFkZChiYXNlUG9zaXRpb25WZWN0b3IpO1xuICAgIHQyLmFkZChiYXNlUG9zaXRpb25WZWN0b3IpO1xuICAgIHQzLmFkZChiYXNlUG9zaXRpb25WZWN0b3IpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMucXVpY2tUZXh0KHRoaXMuY29udGV4dCwgJ3QwJywgdDAueCwgdDAueSAtIDQpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMucXVpY2tUZXh0KHRoaXMuY29udGV4dCwgJ3QxJywgdDEueCwgdDEueSAtIDQpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMucXVpY2tUZXh0KHRoaXMuY29udGV4dCwgJ3QyJywgdDIueCwgdDIueSAtIDQpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMucXVpY2tUZXh0KHRoaXMuY29udGV4dCwgJ3QzJywgdDMueCwgdDMueSAtIDQpOyAvLyBBZGQgdGhpcyBwb2ludCwgd2UgaGF2ZSBsYWlkIG91dCBmb3VyIGRvdHMgYXMgYSBzcXVhcmUuXG5cblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnZlY3RvclBvaW50KHRoaXMuY29udGV4dCwgdDApO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMudmVjdG9yUG9pbnQodGhpcy5jb250ZXh0LCB0MSk7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy52ZWN0b3JQb2ludCh0aGlzLmNvbnRleHQsIHQyKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnZlY3RvclBvaW50KHRoaXMuY29udGV4dCwgdDMpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMuc2V0RmlsbENvbG9yKHRoaXMuY29udGV4dCwgJ29yYW5nZScpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMuc2V0U3Ryb2tlQ29sb3IodGhpcy5jb250ZXh0LCAnb3JhbmdlJyk7IC8vIE5vdyBsZXQncyBkcmF3IGFub3RoZXIgc2V0IG9mIGRvdHMgYnV0IHRoaXMgdGltZSwgdHJhbnNmb3JtXG4gICAgLy8gdGhlIGJhc2lzTWF0cml4LlxuXG5cbiAgICBiYXNpc01hdHJpeC5zY2FsZVh5eigwLjUsIDAuNSwgMC41KS5yb3RhdGVaKDQ1ICogTWF0aC5QSSAvIDE4MCk7IC8vIE5vdyB0aGF0IHRoZSBiYXNpcyBNYXRyaXggaXMgcm90YXRlZCwgbGV0J3MgbWFrZSB0aGUgbmV3IHNxdWFyZS5cbiAgICAvLyBBZ2FpbiB3ZSBhcmUgZ29pbmcgdG8gY2FsY3VsYXRlIHRoZSBjb3JuZXJzIGJ5IG11bHRpcGx5aW5nIHRoZVxuICAgIC8vIHRoZSBjb3JuZXIgdmVjdG9ycy5cblxuICAgIHQwID0gYmFzaXNNYXRyaXguY2xvbmUoKS5tdWx0aXBseUJ5VmVjdG9yKHAwKTtcbiAgICB0MSA9IGJhc2lzTWF0cml4LmNsb25lKCkubXVsdGlwbHlCeVZlY3RvcihwMSk7XG4gICAgdDIgPSBiYXNpc01hdHJpeC5jbG9uZSgpLm11bHRpcGx5QnlWZWN0b3IocDIpO1xuICAgIHQzID0gYmFzaXNNYXRyaXguY2xvbmUoKS5tdWx0aXBseUJ5VmVjdG9yKHAzKTsgLy8gTW92ZSB0aGUgcG9pbnRzIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHNjcmVlbi5cblxuICAgIHQwLmFkZChiYXNlUG9zaXRpb25WZWN0b3IpO1xuICAgIHQxLmFkZChiYXNlUG9zaXRpb25WZWN0b3IpO1xuICAgIHQyLmFkZChiYXNlUG9zaXRpb25WZWN0b3IpO1xuICAgIHQzLmFkZChiYXNlUG9zaXRpb25WZWN0b3IpOyAvLyBEcmF3IHRoZSBwb2ludHMuXG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy52ZWN0b3JQb2ludCh0aGlzLmNvbnRleHQsIHQwKTtcblxuICAgIF9kb21DYW52YXMuZG9tQ2FudmFzLnZlY3RvclBvaW50KHRoaXMuY29udGV4dCwgdDEpO1xuXG4gICAgX2RvbUNhbnZhcy5kb21DYW52YXMudmVjdG9yUG9pbnQodGhpcy5jb250ZXh0LCB0Mik7XG5cbiAgICBfZG9tQ2FudmFzLmRvbUNhbnZhcy52ZWN0b3JQb2ludCh0aGlzLmNvbnRleHQsIHQzKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE1hdHJpeElWM1NhbXBsZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/matrixIV3.js\n");

/***/ }),

/***/ "./examples/multi-interpolate.js":
/*!***************************************!*\
  !*** ./examples/multi-interpolate.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _multiInterpolate = __webpack_require__(/*! ../lib/interpolate/multi-interpolate */ \"./lib/interpolate/multi-interpolate.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nclass MultiInterpolateSample {\n  constructor() {\n    console.log('Running MultiInterpolate Sample'); // This is a demo of using multi-interpolate to shift the position\n    // of the ball.\n\n    this.ball = document.getElementById('ball');\n    this.range = document.getElementById('range');\n    this.progress = +this.range.value;\n    this.multiInterpolate = new _multiInterpolate.MultiInterpolate({\n      interpolations: [{\n        progress: [{\n          from: 0,\n          to: 1,\n          start: 0,\n          end: 500\n        }],\n        id: 'x'\n      }, {\n        progress: [{\n          from: 0,\n          to: 0.2,\n          start: 0,\n          end: 100,\n          easingFunction: _ease.EASE.easeOutSine\n        }, {\n          from: 0.2,\n          to: 0.3,\n          start: 100,\n          end: 300,\n          easingFunction: _ease.EASE.easeOutSine\n        }, {\n          from: 0.3,\n          to: 0.5,\n          start: 300,\n          end: 0,\n          easingFunction: _ease.EASE.easeOutSine\n        }, {\n          from: 0.5,\n          to: 1,\n          start: 0,\n          end: 500,\n          easingFunction: _ease.EASE.easeInQuad\n        }],\n        id: 'y'\n      }]\n    }); // Note here we are using raf for demo purposes but not that this is\n    // constantly updating the ball position even when the previous values\n    // were unchanged.\n\n    const raf = new _raf.Raf(() => {\n      // Set the progress to the current range value.\n      let progress = +this.range.value; // Add easing to progress itself to smooth out animations.\n\n      this.progress = _mathf.mathf.ease(this.progress, progress, 0.25, _ease.EASE.easeInOutQuad); // Interpolate values based on current progress.\n\n      let interpolationResults = this.multiInterpolate.calculate(this.progress);\n      let x = interpolationResults['x'];\n      let y = interpolationResults['y'];\n      this.updateBallPosition(x, y);\n    });\n    raf.start();\n  }\n\n  updateBallPosition(x, y) {\n    this.ball.style.transform = `translateX(${x}px) translateY(${y}px)`;\n  }\n\n}\n\nexports.default = MultiInterpolateSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9tdWx0aS1pbnRlcnBvbGF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL211bHRpLWludGVycG9sYXRlLmpzPzcyYjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbXVsdGlJbnRlcnBvbGF0ZSA9IHJlcXVpcmUoXCIuLi9saWIvaW50ZXJwb2xhdGUvbXVsdGktaW50ZXJwb2xhdGVcIik7XG5cbnZhciBfbWF0aGYgPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL21hdGhmXCIpO1xuXG52YXIgX3JhZiA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZlwiKTtcblxudmFyIF9lYXNlID0gcmVxdWlyZShcIi4uL2xpYi9lYXNlL2Vhc2VcIik7XG5cbmNsYXNzIE11bHRpSW50ZXJwb2xhdGVTYW1wbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygnUnVubmluZyBNdWx0aUludGVycG9sYXRlIFNhbXBsZScpOyAvLyBUaGlzIGlzIGEgZGVtbyBvZiB1c2luZyBtdWx0aS1pbnRlcnBvbGF0ZSB0byBzaGlmdCB0aGUgcG9zaXRpb25cbiAgICAvLyBvZiB0aGUgYmFsbC5cblxuICAgIHRoaXMuYmFsbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiYWxsJyk7XG4gICAgdGhpcy5yYW5nZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyYW5nZScpO1xuICAgIHRoaXMucHJvZ3Jlc3MgPSArdGhpcy5yYW5nZS52YWx1ZTtcbiAgICB0aGlzLm11bHRpSW50ZXJwb2xhdGUgPSBuZXcgX211bHRpSW50ZXJwb2xhdGUuTXVsdGlJbnRlcnBvbGF0ZSh7XG4gICAgICBpbnRlcnBvbGF0aW9uczogW3tcbiAgICAgICAgcHJvZ3Jlc3M6IFt7XG4gICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICB0bzogMSxcbiAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICBlbmQ6IDUwMFxuICAgICAgICB9XSxcbiAgICAgICAgaWQ6ICd4J1xuICAgICAgfSwge1xuICAgICAgICBwcm9ncmVzczogW3tcbiAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgIHRvOiAwLjIsXG4gICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgZW5kOiAxMDAsXG4gICAgICAgICAgZWFzaW5nRnVuY3Rpb246IF9lYXNlLkVBU0UuZWFzZU91dFNpbmVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGZyb206IDAuMixcbiAgICAgICAgICB0bzogMC4zLFxuICAgICAgICAgIHN0YXJ0OiAxMDAsXG4gICAgICAgICAgZW5kOiAzMDAsXG4gICAgICAgICAgZWFzaW5nRnVuY3Rpb246IF9lYXNlLkVBU0UuZWFzZU91dFNpbmVcbiAgICAgICAgfSwge1xuICAgICAgICAgIGZyb206IDAuMyxcbiAgICAgICAgICB0bzogMC41LFxuICAgICAgICAgIHN0YXJ0OiAzMDAsXG4gICAgICAgICAgZW5kOiAwLFxuICAgICAgICAgIGVhc2luZ0Z1bmN0aW9uOiBfZWFzZS5FQVNFLmVhc2VPdXRTaW5lXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBmcm9tOiAwLjUsXG4gICAgICAgICAgdG86IDEsXG4gICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgZW5kOiA1MDAsXG4gICAgICAgICAgZWFzaW5nRnVuY3Rpb246IF9lYXNlLkVBU0UuZWFzZUluUXVhZFxuICAgICAgICB9XSxcbiAgICAgICAgaWQ6ICd5J1xuICAgICAgfV1cbiAgICB9KTsgLy8gTm90ZSBoZXJlIHdlIGFyZSB1c2luZyByYWYgZm9yIGRlbW8gcHVycG9zZXMgYnV0IG5vdCB0aGF0IHRoaXMgaXNcbiAgICAvLyBjb25zdGFudGx5IHVwZGF0aW5nIHRoZSBiYWxsIHBvc2l0aW9uIGV2ZW4gd2hlbiB0aGUgcHJldmlvdXMgdmFsdWVzXG4gICAgLy8gd2VyZSB1bmNoYW5nZWQuXG5cbiAgICBjb25zdCByYWYgPSBuZXcgX3JhZi5SYWYoKCkgPT4ge1xuICAgICAgLy8gU2V0IHRoZSBwcm9ncmVzcyB0byB0aGUgY3VycmVudCByYW5nZSB2YWx1ZS5cbiAgICAgIGxldCBwcm9ncmVzcyA9ICt0aGlzLnJhbmdlLnZhbHVlOyAvLyBBZGQgZWFzaW5nIHRvIHByb2dyZXNzIGl0c2VsZiB0byBzbW9vdGggb3V0IGFuaW1hdGlvbnMuXG5cbiAgICAgIHRoaXMucHJvZ3Jlc3MgPSBfbWF0aGYubWF0aGYuZWFzZSh0aGlzLnByb2dyZXNzLCBwcm9ncmVzcywgMC4yNSwgX2Vhc2UuRUFTRS5lYXNlSW5PdXRRdWFkKTsgLy8gSW50ZXJwb2xhdGUgdmFsdWVzIGJhc2VkIG9uIGN1cnJlbnQgcHJvZ3Jlc3MuXG5cbiAgICAgIGxldCBpbnRlcnBvbGF0aW9uUmVzdWx0cyA9IHRoaXMubXVsdGlJbnRlcnBvbGF0ZS5jYWxjdWxhdGUodGhpcy5wcm9ncmVzcyk7XG4gICAgICBsZXQgeCA9IGludGVycG9sYXRpb25SZXN1bHRzWyd4J107XG4gICAgICBsZXQgeSA9IGludGVycG9sYXRpb25SZXN1bHRzWyd5J107XG4gICAgICB0aGlzLnVwZGF0ZUJhbGxQb3NpdGlvbih4LCB5KTtcbiAgICB9KTtcbiAgICByYWYuc3RhcnQoKTtcbiAgfVxuXG4gIHVwZGF0ZUJhbGxQb3NpdGlvbih4LCB5KSB7XG4gICAgdGhpcy5iYWxsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7eH1weCkgdHJhbnNsYXRlWSgke3l9cHgpYDtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE11bHRpSW50ZXJwb2xhdGVTYW1wbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/multi-interpolate.js\n");

/***/ }),

/***/ "./examples/off-screen-canvas.js":
/*!***************************************!*\
  !*** ./examples/off-screen-canvas.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _offScreenCanvas = __webpack_require__(/*! ../lib/dom/off-screen-canvas */ \"./lib/dom/off-screen-canvas.js\");\n\nvar _is = __webpack_require__(/*! ../lib/is/is */ \"./lib/is/is.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nclass OffScreenCanvasSample {\n  constructor() {\n    if (!_is.is.supportingOffScreenCanvas()) {\n      throw new Error('Sorry your browser is not suppported');\n    }\n\n    const offScreenCanvas = new _offScreenCanvas.OffScreenCanvas();\n    const canvas = document.getElementById('canvas');\n    offScreenCanvas.setCanvas(canvas); // The contents of the tasks live inside the webworker.\n    // Normal imports don't work athte moment.\n\n    const task = params => {\n      if (params.command == 'init') {\n        self.canvas = params.canvas;\n        console.log('Hello', params.name);\n        self.ctx = canvas.getContext('2d');\n      }\n\n      let getRandomInt = (min, max) => {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n      };\n\n      var animate = () => {\n        let random = getRandomInt(0, 500);\n        let random2 = getRandomInt(0, 500);\n        let random3 = getRandomInt(0, 500);\n        let random4 = getRandomInt(0, 500);\n        ctx.fillRect(random, random2, random3, random4);\n        setTimeout(() => {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          animate();\n        }, 1); // You could use this.\n        // requestAnimationFrame(animate);\n      };\n\n      if (params.command == 'animate') {\n        console.log('Hello', params.name);\n        animate();\n        return {\n          data: 'started animation'\n        };\n      }\n\n      if (params.command == 'init') {\n        ctx.fillRect(0, 0, 150, 75);\n        return {\n          data: 'initialized'\n        };\n      }\n    };\n\n    offScreenCanvas.setCanvasTask(task);\n    offScreenCanvas.init({\n      command: 'init',\n      name: 'Scott'\n    }).then(message => {\n      console.log(message.data);\n      offScreenCanvas.sendMessageToCanvas({\n        command: 'animate',\n        name: 'John'\n      }).then(message => {\n        console.log(message.data);\n      });\n    });\n  }\n\n}\n\nexports.default = OffScreenCanvasSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9vZmYtc2NyZWVuLWNhbnZhcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL29mZi1zY3JlZW4tY2FudmFzLmpzP2IyY2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfb2ZmU2NyZWVuQ2FudmFzID0gcmVxdWlyZShcIi4uL2xpYi9kb20vb2ZmLXNjcmVlbi1jYW52YXNcIik7XG5cbnZhciBfaXMgPSByZXF1aXJlKFwiLi4vbGliL2lzL2lzXCIpO1xuXG52YXIgX21hdGhmID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9tYXRoZlwiKTtcblxuY2xhc3MgT2ZmU2NyZWVuQ2FudmFzU2FtcGxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgaWYgKCFfaXMuaXMuc3VwcG9ydGluZ09mZlNjcmVlbkNhbnZhcygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvcnJ5IHlvdXIgYnJvd3NlciBpcyBub3Qgc3VwcHBvcnRlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG9mZlNjcmVlbkNhbnZhcyA9IG5ldyBfb2ZmU2NyZWVuQ2FudmFzLk9mZlNjcmVlbkNhbnZhcygpO1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTtcbiAgICBvZmZTY3JlZW5DYW52YXMuc2V0Q2FudmFzKGNhbnZhcyk7IC8vIFRoZSBjb250ZW50cyBvZiB0aGUgdGFza3MgbGl2ZSBpbnNpZGUgdGhlIHdlYndvcmtlci5cbiAgICAvLyBOb3JtYWwgaW1wb3J0cyBkb24ndCB3b3JrIGF0aHRlIG1vbWVudC5cblxuICAgIGNvbnN0IHRhc2sgPSBwYXJhbXMgPT4ge1xuICAgICAgaWYgKHBhcmFtcy5jb21tYW5kID09ICdpbml0Jykge1xuICAgICAgICBzZWxmLmNhbnZhcyA9IHBhcmFtcy5jYW52YXM7XG4gICAgICAgIGNvbnNvbGUubG9nKCdIZWxsbycsIHBhcmFtcy5uYW1lKTtcbiAgICAgICAgc2VsZi5jdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGdldFJhbmRvbUludCA9IChtaW4sIG1heCkgPT4ge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbiAgICAgIH07XG5cbiAgICAgIHZhciBhbmltYXRlID0gKCkgPT4ge1xuICAgICAgICBsZXQgcmFuZG9tID0gZ2V0UmFuZG9tSW50KDAsIDUwMCk7XG4gICAgICAgIGxldCByYW5kb20yID0gZ2V0UmFuZG9tSW50KDAsIDUwMCk7XG4gICAgICAgIGxldCByYW5kb20zID0gZ2V0UmFuZG9tSW50KDAsIDUwMCk7XG4gICAgICAgIGxldCByYW5kb200ID0gZ2V0UmFuZG9tSW50KDAsIDUwMCk7XG4gICAgICAgIGN0eC5maWxsUmVjdChyYW5kb20sIHJhbmRvbTIsIHJhbmRvbTMsIHJhbmRvbTQpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgYW5pbWF0ZSgpO1xuICAgICAgICB9LCAxKTsgLy8gWW91IGNvdWxkIHVzZSB0aGlzLlxuICAgICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAocGFyYW1zLmNvbW1hbmQgPT0gJ2FuaW1hdGUnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdIZWxsbycsIHBhcmFtcy5uYW1lKTtcbiAgICAgICAgYW5pbWF0ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6ICdzdGFydGVkIGFuaW1hdGlvbidcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtcy5jb21tYW5kID09ICdpbml0Jykge1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgMTUwLCA3NSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogJ2luaXRpYWxpemVkJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBvZmZTY3JlZW5DYW52YXMuc2V0Q2FudmFzVGFzayh0YXNrKTtcbiAgICBvZmZTY3JlZW5DYW52YXMuaW5pdCh7XG4gICAgICBjb21tYW5kOiAnaW5pdCcsXG4gICAgICBuYW1lOiAnU2NvdHQnXG4gICAgfSkudGhlbihtZXNzYWdlID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UuZGF0YSk7XG4gICAgICBvZmZTY3JlZW5DYW52YXMuc2VuZE1lc3NhZ2VUb0NhbnZhcyh7XG4gICAgICAgIGNvbW1hbmQ6ICdhbmltYXRlJyxcbiAgICAgICAgbmFtZTogJ0pvaG4nXG4gICAgICB9KS50aGVuKG1lc3NhZ2UgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlLmRhdGEpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBPZmZTY3JlZW5DYW52YXNTYW1wbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/off-screen-canvas.js\n");

/***/ }),

/***/ "./examples/perlin-noise.js":
/*!**********************************!*\
  !*** ./examples/perlin-noise.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _perlinNoise = __webpack_require__(/*! ../lib/mathf/perlin-noise */ \"./lib/mathf/perlin-noise.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nclass PerlinNoiseSample {\n  constructor() {\n    console.log('perlin noise');\n    const canvas = document.getElementById('canvas');\n    canvas.width = canvas.offsetWidth;\n    canvas.height = canvas.offsetHeight;\n    this.context = canvas.getContext('2d');\n    this.offset = 0;\n    this.offsetZ = 0;\n    this.y = 0;\n    this.z = 0;\n    this.draw();\n  } // Draws one line.\n\n\n  oneline(amplitude) {\n    let frequency = 8;\n    this.context.beginPath();\n\n    for (let i = 0; i < canvas.width; i += 50) {\n      let x = i / canvas.width;\n      let y = this.y / canvas.height;\n      let z = this.z / canvas.height;\n\n      let n = _perlinNoise.PerlinNoise.noise3(x * frequency, y * frequency, z * frequency);\n\n      this.context.lineTo(i, -(n * amplitude) + canvas.height);\n      this.context.stroke();\n    }\n  }\n\n  draw() {\n    this.context.clearRect(0, 0, canvas.width, canvas.height);\n    this.context.save();\n\n    for (let i = 2; i < 10; i += 1) {\n      let color = 'green';\n\n      if (i % 2 == 0) {\n        color = 'red';\n      }\n\n      if (i % 3 == 0) {\n        color = 'orange';\n      }\n\n      this.context.strokeStyle = color;\n      this.oneline((i + 1) * 100);\n    } // this.y = mathf.sinNormalized(this.offset) * canvas.height;\n    // this.z = mathf.sinNormalized(this.offsetZ) * canvas.height;\n    // this.offset += 0.02;\n    // this.offsetZ += 0.02;\n\n\n    this.y += this.offset;\n    this.z += this.offset;\n    this.offset = 0.9;\n    this.offsetZ = 0.8;\n    requestAnimationFrame(() => {\n      this.draw();\n    });\n  }\n\n}\n\nexports.default = PerlinNoiseSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9wZXJsaW4tbm9pc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9wZXJsaW4tbm9pc2UuanM/OWY3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9wZXJsaW5Ob2lzZSA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvcGVybGluLW5vaXNlXCIpO1xuXG52YXIgX21hdGhmID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9tYXRoZlwiKTtcblxuY2xhc3MgUGVybGluTm9pc2VTYW1wbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygncGVybGluIG5vaXNlJyk7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLm9mZnNldEhlaWdodDtcbiAgICB0aGlzLmNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgdGhpcy5vZmZzZXRaID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMueiA9IDA7XG4gICAgdGhpcy5kcmF3KCk7XG4gIH0gLy8gRHJhd3Mgb25lIGxpbmUuXG5cblxuICBvbmVsaW5lKGFtcGxpdHVkZSkge1xuICAgIGxldCBmcmVxdWVuY3kgPSA4O1xuICAgIHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FudmFzLndpZHRoOyBpICs9IDUwKSB7XG4gICAgICBsZXQgeCA9IGkgLyBjYW52YXMud2lkdGg7XG4gICAgICBsZXQgeSA9IHRoaXMueSAvIGNhbnZhcy5oZWlnaHQ7XG4gICAgICBsZXQgeiA9IHRoaXMueiAvIGNhbnZhcy5oZWlnaHQ7XG5cbiAgICAgIGxldCBuID0gX3Blcmxpbk5vaXNlLlBlcmxpbk5vaXNlLm5vaXNlMyh4ICogZnJlcXVlbmN5LCB5ICogZnJlcXVlbmN5LCB6ICogZnJlcXVlbmN5KTtcblxuICAgICAgdGhpcy5jb250ZXh0LmxpbmVUbyhpLCAtKG4gKiBhbXBsaXR1ZGUpICsgY2FudmFzLmhlaWdodCk7XG4gICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICB9XG5cbiAgZHJhdygpIHtcbiAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcblxuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgMTA7IGkgKz0gMSkge1xuICAgICAgbGV0IGNvbG9yID0gJ2dyZWVuJztcblxuICAgICAgaWYgKGkgJSAyID09IDApIHtcbiAgICAgICAgY29sb3IgPSAncmVkJztcbiAgICAgIH1cblxuICAgICAgaWYgKGkgJSAzID09IDApIHtcbiAgICAgICAgY29sb3IgPSAnb3JhbmdlJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICB0aGlzLm9uZWxpbmUoKGkgKyAxKSAqIDEwMCk7XG4gICAgfSAvLyB0aGlzLnkgPSBtYXRoZi5zaW5Ob3JtYWxpemVkKHRoaXMub2Zmc2V0KSAqIGNhbnZhcy5oZWlnaHQ7XG4gICAgLy8gdGhpcy56ID0gbWF0aGYuc2luTm9ybWFsaXplZCh0aGlzLm9mZnNldFopICogY2FudmFzLmhlaWdodDtcbiAgICAvLyB0aGlzLm9mZnNldCArPSAwLjAyO1xuICAgIC8vIHRoaXMub2Zmc2V0WiArPSAwLjAyO1xuXG5cbiAgICB0aGlzLnkgKz0gdGhpcy5vZmZzZXQ7XG4gICAgdGhpcy56ICs9IHRoaXMub2Zmc2V0O1xuICAgIHRoaXMub2Zmc2V0ID0gMC45O1xuICAgIHRoaXMub2Zmc2V0WiA9IDAuODtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBQZXJsaW5Ob2lzZVNhbXBsZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/perlin-noise.js\n");

/***/ }),

/***/ "./examples/playground.js":
/*!********************************!*\
  !*** ./examples/playground.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _webWorker = __webpack_require__(/*! ../lib/dom/web-worker */ \"./lib/dom/web-worker.js\");\n\nvar _func = __webpack_require__(/*! ../lib/func/func */ \"./lib/func/func.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nclass Playgroundsmaple {\n  constructor() {\n    console.log('play ground'); // TIME Stuff\n    // this.testFuncDebouncer();\n    // this.testFuncThrottler();\n    // this.testFuncWaitUntil();\n    // this.testFuncWait();\n    // this.testFuncMemoizeSimple();\n    // this.testFuncMemoize();\n    // this.testFuncRunOnceOnChange();\n    // this.testDomRunAfterNotTopOfScreen();\n    // this.testDomForceFocus();\n    // DOM Stuff\n    // this.testWebWorker();\n  }\n\n  testDomForceFocus() {\n    _dom.dom.forceFocus(document.getElementById('hello'));\n\n    window.setTimeout(() => {\n      _dom.dom.forceFocus(document.getElementById('hello2'));\n\n      window.setTimeout(() => {\n        _dom.dom.forceFocus(document.getElementById('hello3'));\n\n        window.setTimeout(() => {\n          _dom.dom.forceFocus(document.getElementById('hello4'));\n\n          window.setTimeout(() => {\n            _dom.dom.forceFocus(document.getElementById('hello5'));\n\n            window.setTimeout(() => {\n              this.testDomForceFocus();\n            }, 2000);\n          }, 2000);\n        }, 2000);\n      }, 2000);\n    }, 2000);\n  }\n\n  testDomRunAfterNotTopOfScreen() {\n    _dom.dom.runAfterNotTopOfScreen(() => {\n      console.log('running');\n    });\n  }\n\n  testFuncDebouncer() {\n    let debouncer = _func.func.debounce(event => {\n      console.log('debounced', event);\n    }, 1000);\n\n    window.addEventListener('resize', debouncer);\n  }\n\n  testFuncThrottler() {\n    let throttler = _func.func.throttle(event => {\n      console.log('throttled', event);\n    }, 1000);\n\n    window.addEventListener('resize', event => {\n      console.log('resize called');\n      throttler(event);\n    });\n  }\n\n  testFuncWaitUntil() {\n    let someValue = 0;\n\n    _func.func.waitUntil(() => someValue == 5).then(() => {\n      console.log('some value is 5!!!');\n    });\n\n    setTimeout(() => {\n      someValue = 5;\n    }, 1000);\n  }\n\n  testFuncWait() {\n    console.log('hohoho');\n\n    _func.func.wait(500).then(() => {\n      console.log('hohoho after 500ms');\n    });\n  }\n\n  testFuncMemoizeSimple() {\n    let showName = _func.func.memoizeSimple(name => {\n      return name;\n    });\n\n    console.log(showName('John'));\n    console.log(showName('John'));\n    console.log(showName('John'));\n    console.log(showName('John'));\n    console.log(showName('Scott'));\n  }\n\n  testFuncRunOnceOnChange() {\n    let expensiveOperation = _func.func.runOnceOnChange(name => {\n      console.log(name);\n    });\n\n    expensiveOperation('Scott');\n    expensiveOperation('Scott');\n    expensiveOperation('Scott');\n    expensiveOperation('Scott');\n    expensiveOperation('Scott');\n    expensiveOperation('John');\n    expensiveOperation('John');\n    expensiveOperation('Aya');\n    expensiveOperation('Aya');\n  }\n\n  testFuncMemoize() {\n    let calculate = _func.func.memoize((a, b) => {\n      console.log('calculating');\n      return a + b;\n    });\n\n    console.log(calculate(3, 2));\n    console.log(calculate(2, 2));\n    console.log(calculate(3, 2));\n    console.log(calculate(2, 2));\n    console.log(calculate(3, 2));\n  }\n\n  testWebWorker() {\n    let worker = new _webWorker.WebWorker(params => {\n      return params.a + params.b;\n    });\n    let params = {\n      a: 4,\n      b: 3\n    };\n    worker.runOneTimeThrowAwayWorker(params).then(result => {\n      console.log('one time worker');\n    });\n    worker.runOneTimeThrowAwayWorker(params).then(result => {\n      console.log('one time worker');\n    }); // Run once.  Run uses the same worker.\n\n    worker.run(params).then(result => {\n      console.log('result', result); // Make another call.\n\n      worker.run({\n        a: 4,\n        b: 6\n      }).then(result => {\n        console.log('result2', result);\n        worker.terminate();\n      });\n    });\n  }\n\n}\n\nexports.default = Playgroundsmaple;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9wbGF5Z3JvdW5kLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvcGxheWdyb3VuZC5qcz8yYzM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2RvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbVwiKTtcblxudmFyIF93ZWJXb3JrZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS93ZWItd29ya2VyXCIpO1xuXG52YXIgX2Z1bmMgPSByZXF1aXJlKFwiLi4vbGliL2Z1bmMvZnVuY1wiKTtcblxudmFyIF9tYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvbWF0aGZcIik7XG5cbmNsYXNzIFBsYXlncm91bmRzbWFwbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygncGxheSBncm91bmQnKTsgLy8gVElNRSBTdHVmZlxuICAgIC8vIHRoaXMudGVzdEZ1bmNEZWJvdW5jZXIoKTtcbiAgICAvLyB0aGlzLnRlc3RGdW5jVGhyb3R0bGVyKCk7XG4gICAgLy8gdGhpcy50ZXN0RnVuY1dhaXRVbnRpbCgpO1xuICAgIC8vIHRoaXMudGVzdEZ1bmNXYWl0KCk7XG4gICAgLy8gdGhpcy50ZXN0RnVuY01lbW9pemVTaW1wbGUoKTtcbiAgICAvLyB0aGlzLnRlc3RGdW5jTWVtb2l6ZSgpO1xuICAgIC8vIHRoaXMudGVzdEZ1bmNSdW5PbmNlT25DaGFuZ2UoKTtcbiAgICAvLyB0aGlzLnRlc3REb21SdW5BZnRlck5vdFRvcE9mU2NyZWVuKCk7XG4gICAgLy8gdGhpcy50ZXN0RG9tRm9yY2VGb2N1cygpO1xuICAgIC8vIERPTSBTdHVmZlxuICAgIC8vIHRoaXMudGVzdFdlYldvcmtlcigpO1xuICB9XG5cbiAgdGVzdERvbUZvcmNlRm9jdXMoKSB7XG4gICAgX2RvbS5kb20uZm9yY2VGb2N1cyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGVsbG8nKSk7XG5cbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBfZG9tLmRvbS5mb3JjZUZvY3VzKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWxsbzInKSk7XG5cbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgX2RvbS5kb20uZm9yY2VGb2N1cyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGVsbG8zJykpO1xuXG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBfZG9tLmRvbS5mb3JjZUZvY3VzKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWxsbzQnKSk7XG5cbiAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBfZG9tLmRvbS5mb3JjZUZvY3VzKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWxsbzUnKSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy50ZXN0RG9tRm9yY2VGb2N1cygpO1xuICAgICAgICAgICAgfSwgMjAwMCk7XG4gICAgICAgICAgfSwgMjAwMCk7XG4gICAgICAgIH0sIDIwMDApO1xuICAgICAgfSwgMjAwMCk7XG4gICAgfSwgMjAwMCk7XG4gIH1cblxuICB0ZXN0RG9tUnVuQWZ0ZXJOb3RUb3BPZlNjcmVlbigpIHtcbiAgICBfZG9tLmRvbS5ydW5BZnRlck5vdFRvcE9mU2NyZWVuKCgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdydW5uaW5nJyk7XG4gICAgfSk7XG4gIH1cblxuICB0ZXN0RnVuY0RlYm91bmNlcigpIHtcbiAgICBsZXQgZGVib3VuY2VyID0gX2Z1bmMuZnVuYy5kZWJvdW5jZShldmVudCA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnZGVib3VuY2VkJywgZXZlbnQpO1xuICAgIH0sIDEwMDApO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGRlYm91bmNlcik7XG4gIH1cblxuICB0ZXN0RnVuY1Rocm90dGxlcigpIHtcbiAgICBsZXQgdGhyb3R0bGVyID0gX2Z1bmMuZnVuYy50aHJvdHRsZShldmVudCA9PiB7XG4gICAgICBjb25zb2xlLmxvZygndGhyb3R0bGVkJywgZXZlbnQpO1xuICAgIH0sIDEwMDApO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdyZXNpemUgY2FsbGVkJyk7XG4gICAgICB0aHJvdHRsZXIoZXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgdGVzdEZ1bmNXYWl0VW50aWwoKSB7XG4gICAgbGV0IHNvbWVWYWx1ZSA9IDA7XG5cbiAgICBfZnVuYy5mdW5jLndhaXRVbnRpbCgoKSA9PiBzb21lVmFsdWUgPT0gNSkudGhlbigoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnc29tZSB2YWx1ZSBpcyA1ISEhJyk7XG4gICAgfSk7XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNvbWVWYWx1ZSA9IDU7XG4gICAgfSwgMTAwMCk7XG4gIH1cblxuICB0ZXN0RnVuY1dhaXQoKSB7XG4gICAgY29uc29sZS5sb2coJ2hvaG9obycpO1xuXG4gICAgX2Z1bmMuZnVuYy53YWl0KDUwMCkudGhlbigoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnaG9ob2hvIGFmdGVyIDUwMG1zJyk7XG4gICAgfSk7XG4gIH1cblxuICB0ZXN0RnVuY01lbW9pemVTaW1wbGUoKSB7XG4gICAgbGV0IHNob3dOYW1lID0gX2Z1bmMuZnVuYy5tZW1vaXplU2ltcGxlKG5hbWUgPT4ge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfSk7XG5cbiAgICBjb25zb2xlLmxvZyhzaG93TmFtZSgnSm9obicpKTtcbiAgICBjb25zb2xlLmxvZyhzaG93TmFtZSgnSm9obicpKTtcbiAgICBjb25zb2xlLmxvZyhzaG93TmFtZSgnSm9obicpKTtcbiAgICBjb25zb2xlLmxvZyhzaG93TmFtZSgnSm9obicpKTtcbiAgICBjb25zb2xlLmxvZyhzaG93TmFtZSgnU2NvdHQnKSk7XG4gIH1cblxuICB0ZXN0RnVuY1J1bk9uY2VPbkNoYW5nZSgpIHtcbiAgICBsZXQgZXhwZW5zaXZlT3BlcmF0aW9uID0gX2Z1bmMuZnVuYy5ydW5PbmNlT25DaGFuZ2UobmFtZSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhuYW1lKTtcbiAgICB9KTtcblxuICAgIGV4cGVuc2l2ZU9wZXJhdGlvbignU2NvdHQnKTtcbiAgICBleHBlbnNpdmVPcGVyYXRpb24oJ1Njb3R0Jyk7XG4gICAgZXhwZW5zaXZlT3BlcmF0aW9uKCdTY290dCcpO1xuICAgIGV4cGVuc2l2ZU9wZXJhdGlvbignU2NvdHQnKTtcbiAgICBleHBlbnNpdmVPcGVyYXRpb24oJ1Njb3R0Jyk7XG4gICAgZXhwZW5zaXZlT3BlcmF0aW9uKCdKb2huJyk7XG4gICAgZXhwZW5zaXZlT3BlcmF0aW9uKCdKb2huJyk7XG4gICAgZXhwZW5zaXZlT3BlcmF0aW9uKCdBeWEnKTtcbiAgICBleHBlbnNpdmVPcGVyYXRpb24oJ0F5YScpO1xuICB9XG5cbiAgdGVzdEZ1bmNNZW1vaXplKCkge1xuICAgIGxldCBjYWxjdWxhdGUgPSBfZnVuYy5mdW5jLm1lbW9pemUoKGEsIGIpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdjYWxjdWxhdGluZycpO1xuICAgICAgcmV0dXJuIGEgKyBiO1xuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coY2FsY3VsYXRlKDMsIDIpKTtcbiAgICBjb25zb2xlLmxvZyhjYWxjdWxhdGUoMiwgMikpO1xuICAgIGNvbnNvbGUubG9nKGNhbGN1bGF0ZSgzLCAyKSk7XG4gICAgY29uc29sZS5sb2coY2FsY3VsYXRlKDIsIDIpKTtcbiAgICBjb25zb2xlLmxvZyhjYWxjdWxhdGUoMywgMikpO1xuICB9XG5cbiAgdGVzdFdlYldvcmtlcigpIHtcbiAgICBsZXQgd29ya2VyID0gbmV3IF93ZWJXb3JrZXIuV2ViV29ya2VyKHBhcmFtcyA9PiB7XG4gICAgICByZXR1cm4gcGFyYW1zLmEgKyBwYXJhbXMuYjtcbiAgICB9KTtcbiAgICBsZXQgcGFyYW1zID0ge1xuICAgICAgYTogNCxcbiAgICAgIGI6IDNcbiAgICB9O1xuICAgIHdvcmtlci5ydW5PbmVUaW1lVGhyb3dBd2F5V29ya2VyKHBhcmFtcykudGhlbihyZXN1bHQgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ29uZSB0aW1lIHdvcmtlcicpO1xuICAgIH0pO1xuICAgIHdvcmtlci5ydW5PbmVUaW1lVGhyb3dBd2F5V29ya2VyKHBhcmFtcykudGhlbihyZXN1bHQgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ29uZSB0aW1lIHdvcmtlcicpO1xuICAgIH0pOyAvLyBSdW4gb25jZS4gIFJ1biB1c2VzIHRoZSBzYW1lIHdvcmtlci5cblxuICAgIHdvcmtlci5ydW4ocGFyYW1zKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICBjb25zb2xlLmxvZygncmVzdWx0JywgcmVzdWx0KTsgLy8gTWFrZSBhbm90aGVyIGNhbGwuXG5cbiAgICAgIHdvcmtlci5ydW4oe1xuICAgICAgICBhOiA0LFxuICAgICAgICBiOiA2XG4gICAgICB9KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdyZXN1bHQyJywgcmVzdWx0KTtcbiAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBQbGF5Z3JvdW5kc21hcGxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/playground.js\n");

/***/ }),

/***/ "./examples/pseudo-3d-canvas.js":
/*!**************************************!*\
  !*** ./examples/pseudo-3d-canvas.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _dat = __webpack_require__(/*! dat.gui */ \"./node_modules/dat.gui/build/dat.gui.module.js\");\n\nvar dat = _interopRequireWildcard(_dat);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _pseudo3dCanvas = __webpack_require__(/*! ../lib/pseudo-3d-canvas/pseudo-3d-canvas */ \"./lib/pseudo-3d-canvas/pseudo-3d-canvas.js\");\n\nvar _mesh = __webpack_require__(/*! ../lib/pseudo-3d-canvas/mesh */ \"./lib/pseudo-3d-canvas/mesh.js\");\n\nvar _camera = __webpack_require__(/*! ../lib/pseudo-3d-canvas/camera */ \"./lib/pseudo-3d-canvas/camera.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n/**\n * Demonstrates pseudo3dCanvas.  This is more an experimentation\n * and demonstration of how to project 3d into 2d space.\n *\n * The pseudo3dCanvas is responsible for creating a translationMatrix\n * that then transforms the positoin of each vertices to project\n * 3d into 2d space.\n */\nclass pseudo3dCanvasSample {\n  constructor() {\n    this.gui = new dat.GUI();\n    this.raf = new _raf.Raf();\n    this.raf.watch(this.renderLoop.bind(this));\n    let canvasElement = document.getElementById('canvas');\n    this.pseudo3dCanvas = new _pseudo3dCanvas.Pseudo3dCanvas({\n      canvasElement: canvasElement\n    });\n    this.camera = new _camera.Camera();\n    let cubeMesh = new _mesh.CubeMesh();\n    cubeMesh.position.x = 0;\n    cubeMesh.position.y = 0;\n    cubeMesh.position.z = 100;\n    cubeMesh.originalPosition = cubeMesh.position.clone();\n    cubeMesh.rotation = new _vector.Vector(-1, -1, -1);\n    cubeMesh.color = 'green';\n    cubeMesh.size(3, 3, 3);\n    let cubeMesh2 = new _mesh.CubeMesh();\n    cubeMesh2.position.x = 0;\n    cubeMesh2.position.y = 10;\n    cubeMesh2.position.z = 100;\n    cubeMesh2.originalPosition = cubeMesh2.position.clone();\n    cubeMesh2.rotation = new _vector.Vector(-1, -1, -1);\n    cubeMesh2.size(1, 1, 1);\n    cubeMesh2.color = 'orange';\n    console.log('c1', cubeMesh);\n    console.log('c2', cubeMesh2); // Update the camera position.\n\n    this.camera.position = new _vector.Vector(0, 0, 5);\n    this.camera.target = new _vector.Vector(0, 0, 0); // this.camera.position = new Vector(0, 0, 1);\n    // this.camera.target = new Vector(0, 0, 0);\n\n    this.meshes = [cubeMesh, cubeMesh2];\n    let projection = this.gui.addFolder('Projection');\n    projection.add(this.pseudo3dCanvas, 'fov', -180, 180);\n    projection.add(this.pseudo3dCanvas, 'aspect', 0, 2);\n    projection.add(this.pseudo3dCanvas, 'near', -100, 100);\n    projection.add(this.pseudo3dCanvas, 'far', -10000, 10000);\n    let cameraFolder = this.gui.addFolder('camera position');\n    cameraFolder.add(this.camera.position, 'x', -1, 1);\n    cameraFolder.add(this.camera.position, 'y', -1, 1);\n    cameraFolder.add(this.camera.position, 'z', -100, 1000);\n    let cameraTargetFolder = this.gui.addFolder('camera target');\n    cameraTargetFolder.add(this.camera.target, 'x', -10, 10);\n    cameraTargetFolder.add(this.camera.target, 'y', -10, 10);\n    cameraTargetFolder.add(this.camera.target, 'z', -100, 1000); // let meshFolder = this.gui.addFolder('mesh');\n    // meshFolder.add(cubeMesh.rotation, 'x', 0.001, 0.9);\n    // meshFolder.add(cubeMesh.rotation, 'y', 0.001, 0.9);\n    // meshFolder.add(cubeMesh.rotation, 'z', 0.001, 0.9);\n\n    this.wave = 0;\n    this.wave2 = 0;\n    console.log(this.pseudo3dCanvas);\n    console.log(cubeMesh); // console.log(cubeMesh2);\n    // // Start raf loop.\n\n    this.raf.start(); // this.renderLoop();\n  }\n  /**\n     * Handles each raf loop.\n     */\n\n\n  renderLoop(delta) {\n    this.wave += 0.03;\n    this.wave2 += 0.02;\n    this.meshes[0].rotation.x += 0.05;\n    this.meshes[0].rotation.y += 0.05;\n    this.meshes[0].rotation.z += 0.05;\n    this.meshes[0].position.z = _mathf.mathf.lerp(this.meshes[0].position.z, this.meshes[0].originalPosition.z + -Math.sin(this.wave2) * 60, 0.3);\n    this.meshes[1].rotation.x += 0.02;\n    this.meshes[1].rotation.y += 0.01;\n    this.meshes[1].rotation.z += 0.02; // Update the cubeMesh2 position.\n\n    this.meshes[1].position.x = _mathf.mathf.lerp(this.meshes[1].position.x, this.meshes[1].originalPosition.x + Math.sin(this.wave) * 5, 0.2);\n    this.meshes[1].position.y = _mathf.mathf.lerp(this.meshes[1].position.y, this.meshes[1].originalPosition.y + Math.sin(this.wave2) * 5, 0.2);\n    this.meshes[1].position.z = _mathf.mathf.lerp(this.meshes[1].position.z, this.meshes[1].originalPosition.z + Math.sin(this.wave2) * 60, 0.3); // this.meshes.forEach((mesh) => {\n    //     mesh.rotation.x += 0.01;\n    //     mesh.rotation.y += 0.01;\n    //     // mesh.rotation.z += 0.01;\n    // });\n\n    this.pseudo3dCanvas.render(this.camera, this.meshes); // console.log(this.pseudo3dCanvas);\n  }\n\n}\n\nexports.default = pseudo3dCanvasSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9wc2V1ZG8tM2QtY2FudmFzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvcHNldWRvLTNkLWNhbnZhcy5qcz80YWE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2RhdCA9IHJlcXVpcmUoXCJkYXQuZ3VpXCIpO1xuXG52YXIgZGF0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2RhdCk7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX3BzZXVkbzNkQ2FudmFzID0gcmVxdWlyZShcIi4uL2xpYi9wc2V1ZG8tM2QtY2FudmFzL3BzZXVkby0zZC1jYW52YXNcIik7XG5cbnZhciBfbWVzaCA9IHJlcXVpcmUoXCIuLi9saWIvcHNldWRvLTNkLWNhbnZhcy9tZXNoXCIpO1xuXG52YXIgX2NhbWVyYSA9IHJlcXVpcmUoXCIuLi9saWIvcHNldWRvLTNkLWNhbnZhcy9jYW1lcmFcIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi92ZWN0b3JcIik7XG5cbnZhciBfbWF0aGYgPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL21hdGhmXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8qKlxuICogRGVtb25zdHJhdGVzIHBzZXVkbzNkQ2FudmFzLiAgVGhpcyBpcyBtb3JlIGFuIGV4cGVyaW1lbnRhdGlvblxuICogYW5kIGRlbW9uc3RyYXRpb24gb2YgaG93IHRvIHByb2plY3QgM2QgaW50byAyZCBzcGFjZS5cbiAqXG4gKiBUaGUgcHNldWRvM2RDYW52YXMgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIGEgdHJhbnNsYXRpb25NYXRyaXhcbiAqIHRoYXQgdGhlbiB0cmFuc2Zvcm1zIHRoZSBwb3NpdG9pbiBvZiBlYWNoIHZlcnRpY2VzIHRvIHByb2plY3RcbiAqIDNkIGludG8gMmQgc3BhY2UuXG4gKi9cbmNsYXNzIHBzZXVkbzNkQ2FudmFzU2FtcGxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ndWkgPSBuZXcgZGF0LkdVSSgpO1xuICAgIHRoaXMucmFmID0gbmV3IF9yYWYuUmFmKCk7XG4gICAgdGhpcy5yYWYud2F0Y2godGhpcy5yZW5kZXJMb29wLmJpbmQodGhpcykpO1xuICAgIGxldCBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpO1xuICAgIHRoaXMucHNldWRvM2RDYW52YXMgPSBuZXcgX3BzZXVkbzNkQ2FudmFzLlBzZXVkbzNkQ2FudmFzKHtcbiAgICAgIGNhbnZhc0VsZW1lbnQ6IGNhbnZhc0VsZW1lbnRcbiAgICB9KTtcbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBfY2FtZXJhLkNhbWVyYSgpO1xuICAgIGxldCBjdWJlTWVzaCA9IG5ldyBfbWVzaC5DdWJlTWVzaCgpO1xuICAgIGN1YmVNZXNoLnBvc2l0aW9uLnggPSAwO1xuICAgIGN1YmVNZXNoLnBvc2l0aW9uLnkgPSAwO1xuICAgIGN1YmVNZXNoLnBvc2l0aW9uLnogPSAxMDA7XG4gICAgY3ViZU1lc2gub3JpZ2luYWxQb3NpdGlvbiA9IGN1YmVNZXNoLnBvc2l0aW9uLmNsb25lKCk7XG4gICAgY3ViZU1lc2gucm90YXRpb24gPSBuZXcgX3ZlY3Rvci5WZWN0b3IoLTEsIC0xLCAtMSk7XG4gICAgY3ViZU1lc2guY29sb3IgPSAnZ3JlZW4nO1xuICAgIGN1YmVNZXNoLnNpemUoMywgMywgMyk7XG4gICAgbGV0IGN1YmVNZXNoMiA9IG5ldyBfbWVzaC5DdWJlTWVzaCgpO1xuICAgIGN1YmVNZXNoMi5wb3NpdGlvbi54ID0gMDtcbiAgICBjdWJlTWVzaDIucG9zaXRpb24ueSA9IDEwO1xuICAgIGN1YmVNZXNoMi5wb3NpdGlvbi56ID0gMTAwO1xuICAgIGN1YmVNZXNoMi5vcmlnaW5hbFBvc2l0aW9uID0gY3ViZU1lc2gyLnBvc2l0aW9uLmNsb25lKCk7XG4gICAgY3ViZU1lc2gyLnJvdGF0aW9uID0gbmV3IF92ZWN0b3IuVmVjdG9yKC0xLCAtMSwgLTEpO1xuICAgIGN1YmVNZXNoMi5zaXplKDEsIDEsIDEpO1xuICAgIGN1YmVNZXNoMi5jb2xvciA9ICdvcmFuZ2UnO1xuICAgIGNvbnNvbGUubG9nKCdjMScsIGN1YmVNZXNoKTtcbiAgICBjb25zb2xlLmxvZygnYzInLCBjdWJlTWVzaDIpOyAvLyBVcGRhdGUgdGhlIGNhbWVyYSBwb3NpdGlvbi5cblxuICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uID0gbmV3IF92ZWN0b3IuVmVjdG9yKDAsIDAsIDUpO1xuICAgIHRoaXMuY2FtZXJhLnRhcmdldCA9IG5ldyBfdmVjdG9yLlZlY3RvcigwLCAwLCAwKTsgLy8gdGhpcy5jYW1lcmEucG9zaXRpb24gPSBuZXcgVmVjdG9yKDAsIDAsIDEpO1xuICAgIC8vIHRoaXMuY2FtZXJhLnRhcmdldCA9IG5ldyBWZWN0b3IoMCwgMCwgMCk7XG5cbiAgICB0aGlzLm1lc2hlcyA9IFtjdWJlTWVzaCwgY3ViZU1lc2gyXTtcbiAgICBsZXQgcHJvamVjdGlvbiA9IHRoaXMuZ3VpLmFkZEZvbGRlcignUHJvamVjdGlvbicpO1xuICAgIHByb2plY3Rpb24uYWRkKHRoaXMucHNldWRvM2RDYW52YXMsICdmb3YnLCAtMTgwLCAxODApO1xuICAgIHByb2plY3Rpb24uYWRkKHRoaXMucHNldWRvM2RDYW52YXMsICdhc3BlY3QnLCAwLCAyKTtcbiAgICBwcm9qZWN0aW9uLmFkZCh0aGlzLnBzZXVkbzNkQ2FudmFzLCAnbmVhcicsIC0xMDAsIDEwMCk7XG4gICAgcHJvamVjdGlvbi5hZGQodGhpcy5wc2V1ZG8zZENhbnZhcywgJ2ZhcicsIC0xMDAwMCwgMTAwMDApO1xuICAgIGxldCBjYW1lcmFGb2xkZXIgPSB0aGlzLmd1aS5hZGRGb2xkZXIoJ2NhbWVyYSBwb3NpdGlvbicpO1xuICAgIGNhbWVyYUZvbGRlci5hZGQodGhpcy5jYW1lcmEucG9zaXRpb24sICd4JywgLTEsIDEpO1xuICAgIGNhbWVyYUZvbGRlci5hZGQodGhpcy5jYW1lcmEucG9zaXRpb24sICd5JywgLTEsIDEpO1xuICAgIGNhbWVyYUZvbGRlci5hZGQodGhpcy5jYW1lcmEucG9zaXRpb24sICd6JywgLTEwMCwgMTAwMCk7XG4gICAgbGV0IGNhbWVyYVRhcmdldEZvbGRlciA9IHRoaXMuZ3VpLmFkZEZvbGRlcignY2FtZXJhIHRhcmdldCcpO1xuICAgIGNhbWVyYVRhcmdldEZvbGRlci5hZGQodGhpcy5jYW1lcmEudGFyZ2V0LCAneCcsIC0xMCwgMTApO1xuICAgIGNhbWVyYVRhcmdldEZvbGRlci5hZGQodGhpcy5jYW1lcmEudGFyZ2V0LCAneScsIC0xMCwgMTApO1xuICAgIGNhbWVyYVRhcmdldEZvbGRlci5hZGQodGhpcy5jYW1lcmEudGFyZ2V0LCAneicsIC0xMDAsIDEwMDApOyAvLyBsZXQgbWVzaEZvbGRlciA9IHRoaXMuZ3VpLmFkZEZvbGRlcignbWVzaCcpO1xuICAgIC8vIG1lc2hGb2xkZXIuYWRkKGN1YmVNZXNoLnJvdGF0aW9uLCAneCcsIDAuMDAxLCAwLjkpO1xuICAgIC8vIG1lc2hGb2xkZXIuYWRkKGN1YmVNZXNoLnJvdGF0aW9uLCAneScsIDAuMDAxLCAwLjkpO1xuICAgIC8vIG1lc2hGb2xkZXIuYWRkKGN1YmVNZXNoLnJvdGF0aW9uLCAneicsIDAuMDAxLCAwLjkpO1xuXG4gICAgdGhpcy53YXZlID0gMDtcbiAgICB0aGlzLndhdmUyID0gMDtcbiAgICBjb25zb2xlLmxvZyh0aGlzLnBzZXVkbzNkQ2FudmFzKTtcbiAgICBjb25zb2xlLmxvZyhjdWJlTWVzaCk7IC8vIGNvbnNvbGUubG9nKGN1YmVNZXNoMik7XG4gICAgLy8gLy8gU3RhcnQgcmFmIGxvb3AuXG5cbiAgICB0aGlzLnJhZi5zdGFydCgpOyAvLyB0aGlzLnJlbmRlckxvb3AoKTtcbiAgfVxuICAvKipcbiAgICAgKiBIYW5kbGVzIGVhY2ggcmFmIGxvb3AuXG4gICAgICovXG5cblxuICByZW5kZXJMb29wKGRlbHRhKSB7XG4gICAgdGhpcy53YXZlICs9IDAuMDM7XG4gICAgdGhpcy53YXZlMiArPSAwLjAyO1xuICAgIHRoaXMubWVzaGVzWzBdLnJvdGF0aW9uLnggKz0gMC4wNTtcbiAgICB0aGlzLm1lc2hlc1swXS5yb3RhdGlvbi55ICs9IDAuMDU7XG4gICAgdGhpcy5tZXNoZXNbMF0ucm90YXRpb24ueiArPSAwLjA1O1xuICAgIHRoaXMubWVzaGVzWzBdLnBvc2l0aW9uLnogPSBfbWF0aGYubWF0aGYubGVycCh0aGlzLm1lc2hlc1swXS5wb3NpdGlvbi56LCB0aGlzLm1lc2hlc1swXS5vcmlnaW5hbFBvc2l0aW9uLnogKyAtTWF0aC5zaW4odGhpcy53YXZlMikgKiA2MCwgMC4zKTtcbiAgICB0aGlzLm1lc2hlc1sxXS5yb3RhdGlvbi54ICs9IDAuMDI7XG4gICAgdGhpcy5tZXNoZXNbMV0ucm90YXRpb24ueSArPSAwLjAxO1xuICAgIHRoaXMubWVzaGVzWzFdLnJvdGF0aW9uLnogKz0gMC4wMjsgLy8gVXBkYXRlIHRoZSBjdWJlTWVzaDIgcG9zaXRpb24uXG5cbiAgICB0aGlzLm1lc2hlc1sxXS5wb3NpdGlvbi54ID0gX21hdGhmLm1hdGhmLmxlcnAodGhpcy5tZXNoZXNbMV0ucG9zaXRpb24ueCwgdGhpcy5tZXNoZXNbMV0ub3JpZ2luYWxQb3NpdGlvbi54ICsgTWF0aC5zaW4odGhpcy53YXZlKSAqIDUsIDAuMik7XG4gICAgdGhpcy5tZXNoZXNbMV0ucG9zaXRpb24ueSA9IF9tYXRoZi5tYXRoZi5sZXJwKHRoaXMubWVzaGVzWzFdLnBvc2l0aW9uLnksIHRoaXMubWVzaGVzWzFdLm9yaWdpbmFsUG9zaXRpb24ueSArIE1hdGguc2luKHRoaXMud2F2ZTIpICogNSwgMC4yKTtcbiAgICB0aGlzLm1lc2hlc1sxXS5wb3NpdGlvbi56ID0gX21hdGhmLm1hdGhmLmxlcnAodGhpcy5tZXNoZXNbMV0ucG9zaXRpb24ueiwgdGhpcy5tZXNoZXNbMV0ub3JpZ2luYWxQb3NpdGlvbi56ICsgTWF0aC5zaW4odGhpcy53YXZlMikgKiA2MCwgMC4zKTsgLy8gdGhpcy5tZXNoZXMuZm9yRWFjaCgobWVzaCkgPT4ge1xuICAgIC8vICAgICBtZXNoLnJvdGF0aW9uLnggKz0gMC4wMTtcbiAgICAvLyAgICAgbWVzaC5yb3RhdGlvbi55ICs9IDAuMDE7XG4gICAgLy8gICAgIC8vIG1lc2gucm90YXRpb24ueiArPSAwLjAxO1xuICAgIC8vIH0pO1xuXG4gICAgdGhpcy5wc2V1ZG8zZENhbnZhcy5yZW5kZXIodGhpcy5jYW1lcmEsIHRoaXMubWVzaGVzKTsgLy8gY29uc29sZS5sb2codGhpcy5wc2V1ZG8zZENhbnZhcyk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBwc2V1ZG8zZENhbnZhc1NhbXBsZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/pseudo-3d-canvas.js\n");

/***/ }),

/***/ "./examples/quaternion.js":
/*!********************************!*\
  !*** ./examples/quaternion.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _dat = __webpack_require__(/*! dat.gui */ \"./node_modules/dat.gui/build/dat.gui.module.js\");\n\nvar dat = _interopRequireWildcard(_dat);\n\nvar _vectorDom = __webpack_require__(/*! ../lib/dom/vector-dom */ \"./lib/dom/vector-dom.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _pixi = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/lib/index.js\");\n\nvar _quaternion = __webpack_require__(/*! ../lib/mathf/quaternion */ \"./lib/mathf/quaternion.js\");\n\nvar _matrixIV = __webpack_require__(/*! ../lib/mathf/matrixIV */ \"./lib/mathf/matrixIV.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nclass QuaternionSample {\n  constructor() {\n    console.log('test');\n    this.gui = new dat.GUI(); // Create targets.\n\n    this.targets = {};\n\n    const createTarget = (id, x, y, z) => {\n      let el = document.getElementById(id);\n      let t = new _vectorDom.VectorDom(el);\n      t.anchorX = 0.5;\n      t.anchorY = 0.5;\n      t.setPosition(new _vector.Vector(x, y, z));\n      t.init(); // Add the coordinates so we can see them.\n      // el.innerHTML = `${x} ${y} ${z}`;\n\n      el.innerHTML = id;\n      this.targets[id] = t;\n      t.render();\n    };\n\n    createTarget('target1', 100, 200, 1 - 1);\n    createTarget('target2', 700, 500, 1 - 1);\n    createTarget('target3', 100, 400, 1 - 1);\n    createTarget('target4', 700, -100, 1 - 1);\n    createTarget('target5', 400, -200, 1 - 1);\n    this.cube = new _vectorDom.VectorDom(document.getElementById('ball'));\n    this.cube.setPosition(new _vector.Vector(0, 0, 1 - 1)); // We are going to offset the entire element position to the center\n    // of the container.\n\n    this.cube.setOffset(new _vector.Vector(800 / 2, 800 / 2, 0));\n    this.cube.init();\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.raf.start(); // Setup DAT GUI radio options\n\n    const setChecked = prop => {\n      for (let param in this.parameters) {\n        this.parameters[param] = false;\n      }\n\n      this.parameters[prop] = true;\n    };\n\n    const addRadio = (folder, prop) => {\n      folder.add(this.parameters, prop).listen().onChange(() => {\n        setChecked(prop);\n      });\n    };\n\n    this.parameters = {\n      lookAtTarget1: false,\n      lookAtTarget2: false,\n      lookAtTarget3: false,\n      lookAtTarget4: false,\n      lookAtTarget5: false\n    };\n    let folder = this.gui.addFolder('Options');\n    addRadio(folder, 'lookAtTarget1');\n    addRadio(folder, 'lookAtTarget2');\n    addRadio(folder, 'lookAtTarget3');\n    addRadio(folder, 'lookAtTarget4');\n    addRadio(folder, 'lookAtTarget5');\n  }\n\n  onRaf() {\n    if (this.parameters.lookAtTarget1) {\n      this.lookAt3('target1');\n    }\n\n    if (this.parameters.lookAtTarget2) {\n      this.lookAt3('target2');\n    }\n\n    if (this.parameters.lookAtTarget3) {\n      this.lookAt3('target3');\n    }\n\n    if (this.parameters.lookAtTarget4) {\n      this.lookAt3('target4');\n    }\n\n    if (this.parameters.lookAtTarget5) {\n      this.lookAt3('target5');\n    }\n\n    this.cube.render();\n  }\n\n  lookAt3(targetId) {\n    let target = this.targets[targetId];\n    let eye = this.cube;\n    target = target.position.clone().add(target.offset).add(target.anchorOffsetVector);\n    eye = eye.position.clone().add(eye.offset).add(eye.anchorOffsetVector);\n\n    let q = _quaternion.Quaternion.rotateTo(eye.normalize(), target.normalize(), _vector.Vector.UP);\n\n    this.cube.rotation.slerp(q, 0.2);\n  }\n\n  lookAt2(targetId) {\n    let target = this.targets[targetId];\n    let eye = this.cube;\n    target = target.position.clone().add(target.offset).add(target.anchorOffsetVector);\n    eye = eye.position.clone().add(eye.offset).add(eye.anchorOffsetVector); // target = target.globalElementCenterPosition;\n    // eye = eye.globalElementCenterPosition;\n\n    let tc = target.clone();\n    let ec = eye.clone();\n\n    let eularDifference = _vector.Vector.getEularRotationTo(eye.normalize(), target.normalize());\n\n    let m1 = new _matrixIV.MatrixIV().ypr(eularDifference.z, eularDifference.y, eularDifference.x);\n\n    let q = _quaternion.Quaternion.fromRotationMatrixIV(m1); // let q = Quaternion.fromEulerVector(eularDifference);\n\n\n    this.cube.rotation.slerp(q, 0.2);\n  }\n\n  lookAt(targetId) {\n    this.cube.useBoundsForGlobalCalculation = false;\n    this.targets[targetId].useBoundsForGlobalCalculation = true; // This work.\n\n    let target = this.targets[targetId];\n    target = target.position.clone().add(target.offset).add(target.anchorOffsetVector);\n    let eye = this.cube;\n    eye = eye.position.clone().add(eye.offset).add(eye.anchorOffsetVector); // doesnt work because it's tied to window scroll.\n    // let target = this.targets[targetId].globalElementCenterPosition.clone();\n    // let eye = this.cube.globalElementCenterPosition.clone();\n    // target.z = 1 - target.z;\n    // eye.z = 1 - target.z;\n\n    console.log('t', target.clone().normalize());\n    console.log('e', eye); // target.y *= 1;\n    // eye.y *= -1;\n\n    let tc = target.clone();\n    let ec = eye.clone(); // target.y = tc.x;\n    // target.x = tc.z;\n    // target.z = tc.y;\n    // eye.y = ec.x;\n    // eye.x = ec.z;\n    // eye.z = ec.y;\n\n    target.x = tc.z;\n    target.y = tc.y;\n    target.z = tc.x;\n    eye.x = ec.z;\n    eye.y = ec.y;\n    eye.z = ec.x;\n    target.z *= 1;\n    eye.z *= 1; // let m1 = new MatrixIV().lookAt(\n    //     // new Vector(0, 0, 1),\n    //     eye,\n    //     target,\n    //     // Vector.UP\n    //     new Vector(0, 1, 0)\n    // );\n\n    let m1 = new _matrixIV.MatrixIV().lookAt( // new Vector(0, 0, 1),\n    eye.clone().normalize(), target.clone().normalize(), _vector.Vector.FORWARD // eye.cross(Vector.FORWARD)\n    );\n\n    let q = _quaternion.Quaternion.fromRotationMatrixIV(m1); // console.log(Quaternion.toEulerVector(q));\n\n\n    this.cube.rotation.slerp(q, 0.2);\n  }\n\n}\n\nexports.default = QuaternionSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9xdWF0ZXJuaW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvcXVhdGVybmlvbi5qcz9hODY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2RhdCA9IHJlcXVpcmUoXCJkYXQuZ3VpXCIpO1xuXG52YXIgZGF0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2RhdCk7XG5cbnZhciBfdmVjdG9yRG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vdmVjdG9yLWRvbVwiKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi92ZWN0b3JcIik7XG5cbnZhciBfcGl4aSA9IHJlcXVpcmUoXCJwaXhpLmpzXCIpO1xuXG52YXIgX3F1YXRlcm5pb24gPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL3F1YXRlcm5pb25cIik7XG5cbnZhciBfbWF0cml4SVYgPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL21hdHJpeElWXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmNsYXNzIFF1YXRlcm5pb25TYW1wbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygndGVzdCcpO1xuICAgIHRoaXMuZ3VpID0gbmV3IGRhdC5HVUkoKTsgLy8gQ3JlYXRlIHRhcmdldHMuXG5cbiAgICB0aGlzLnRhcmdldHMgPSB7fTtcblxuICAgIGNvbnN0IGNyZWF0ZVRhcmdldCA9IChpZCwgeCwgeSwgeikgPT4ge1xuICAgICAgbGV0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgbGV0IHQgPSBuZXcgX3ZlY3RvckRvbS5WZWN0b3JEb20oZWwpO1xuICAgICAgdC5hbmNob3JYID0gMC41O1xuICAgICAgdC5hbmNob3JZID0gMC41O1xuICAgICAgdC5zZXRQb3NpdGlvbihuZXcgX3ZlY3Rvci5WZWN0b3IoeCwgeSwgeikpO1xuICAgICAgdC5pbml0KCk7IC8vIEFkZCB0aGUgY29vcmRpbmF0ZXMgc28gd2UgY2FuIHNlZSB0aGVtLlxuICAgICAgLy8gZWwuaW5uZXJIVE1MID0gYCR7eH0gJHt5fSAke3p9YDtcblxuICAgICAgZWwuaW5uZXJIVE1MID0gaWQ7XG4gICAgICB0aGlzLnRhcmdldHNbaWRdID0gdDtcbiAgICAgIHQucmVuZGVyKCk7XG4gICAgfTtcblxuICAgIGNyZWF0ZVRhcmdldCgndGFyZ2V0MScsIDEwMCwgMjAwLCAxIC0gMSk7XG4gICAgY3JlYXRlVGFyZ2V0KCd0YXJnZXQyJywgNzAwLCA1MDAsIDEgLSAxKTtcbiAgICBjcmVhdGVUYXJnZXQoJ3RhcmdldDMnLCAxMDAsIDQwMCwgMSAtIDEpO1xuICAgIGNyZWF0ZVRhcmdldCgndGFyZ2V0NCcsIDcwMCwgLTEwMCwgMSAtIDEpO1xuICAgIGNyZWF0ZVRhcmdldCgndGFyZ2V0NScsIDQwMCwgLTIwMCwgMSAtIDEpO1xuICAgIHRoaXMuY3ViZSA9IG5ldyBfdmVjdG9yRG9tLlZlY3RvckRvbShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmFsbCcpKTtcbiAgICB0aGlzLmN1YmUuc2V0UG9zaXRpb24obmV3IF92ZWN0b3IuVmVjdG9yKDAsIDAsIDEgLSAxKSk7IC8vIFdlIGFyZSBnb2luZyB0byBvZmZzZXQgdGhlIGVudGlyZSBlbGVtZW50IHBvc2l0aW9uIHRvIHRoZSBjZW50ZXJcbiAgICAvLyBvZiB0aGUgY29udGFpbmVyLlxuXG4gICAgdGhpcy5jdWJlLnNldE9mZnNldChuZXcgX3ZlY3Rvci5WZWN0b3IoODAwIC8gMiwgODAwIC8gMiwgMCkpO1xuICAgIHRoaXMuY3ViZS5pbml0KCk7XG4gICAgdGhpcy5yYWYgPSBuZXcgX3JhZi5SYWYodGhpcy5vblJhZi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpOyAvLyBTZXR1cCBEQVQgR1VJIHJhZGlvIG9wdGlvbnNcblxuICAgIGNvbnN0IHNldENoZWNrZWQgPSBwcm9wID0+IHtcbiAgICAgIGZvciAobGV0IHBhcmFtIGluIHRoaXMucGFyYW1ldGVycykge1xuICAgICAgICB0aGlzLnBhcmFtZXRlcnNbcGFyYW1dID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFyYW1ldGVyc1twcm9wXSA9IHRydWU7XG4gICAgfTtcblxuICAgIGNvbnN0IGFkZFJhZGlvID0gKGZvbGRlciwgcHJvcCkgPT4ge1xuICAgICAgZm9sZGVyLmFkZCh0aGlzLnBhcmFtZXRlcnMsIHByb3ApLmxpc3RlbigpLm9uQ2hhbmdlKCgpID0+IHtcbiAgICAgICAgc2V0Q2hlY2tlZChwcm9wKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgICBsb29rQXRUYXJnZXQxOiBmYWxzZSxcbiAgICAgIGxvb2tBdFRhcmdldDI6IGZhbHNlLFxuICAgICAgbG9va0F0VGFyZ2V0MzogZmFsc2UsXG4gICAgICBsb29rQXRUYXJnZXQ0OiBmYWxzZSxcbiAgICAgIGxvb2tBdFRhcmdldDU6IGZhbHNlXG4gICAgfTtcbiAgICBsZXQgZm9sZGVyID0gdGhpcy5ndWkuYWRkRm9sZGVyKCdPcHRpb25zJyk7XG4gICAgYWRkUmFkaW8oZm9sZGVyLCAnbG9va0F0VGFyZ2V0MScpO1xuICAgIGFkZFJhZGlvKGZvbGRlciwgJ2xvb2tBdFRhcmdldDInKTtcbiAgICBhZGRSYWRpbyhmb2xkZXIsICdsb29rQXRUYXJnZXQzJyk7XG4gICAgYWRkUmFkaW8oZm9sZGVyLCAnbG9va0F0VGFyZ2V0NCcpO1xuICAgIGFkZFJhZGlvKGZvbGRlciwgJ2xvb2tBdFRhcmdldDUnKTtcbiAgfVxuXG4gIG9uUmFmKCkge1xuICAgIGlmICh0aGlzLnBhcmFtZXRlcnMubG9va0F0VGFyZ2V0MSkge1xuICAgICAgdGhpcy5sb29rQXQzKCd0YXJnZXQxJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyYW1ldGVycy5sb29rQXRUYXJnZXQyKSB7XG4gICAgICB0aGlzLmxvb2tBdDMoJ3RhcmdldDInKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmxvb2tBdFRhcmdldDMpIHtcbiAgICAgIHRoaXMubG9va0F0MygndGFyZ2V0MycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmFtZXRlcnMubG9va0F0VGFyZ2V0NCkge1xuICAgICAgdGhpcy5sb29rQXQzKCd0YXJnZXQ0Jyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyYW1ldGVycy5sb29rQXRUYXJnZXQ1KSB7XG4gICAgICB0aGlzLmxvb2tBdDMoJ3RhcmdldDUnKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1YmUucmVuZGVyKCk7XG4gIH1cblxuICBsb29rQXQzKHRhcmdldElkKSB7XG4gICAgbGV0IHRhcmdldCA9IHRoaXMudGFyZ2V0c1t0YXJnZXRJZF07XG4gICAgbGV0IGV5ZSA9IHRoaXMuY3ViZTtcbiAgICB0YXJnZXQgPSB0YXJnZXQucG9zaXRpb24uY2xvbmUoKS5hZGQodGFyZ2V0Lm9mZnNldCkuYWRkKHRhcmdldC5hbmNob3JPZmZzZXRWZWN0b3IpO1xuICAgIGV5ZSA9IGV5ZS5wb3NpdGlvbi5jbG9uZSgpLmFkZChleWUub2Zmc2V0KS5hZGQoZXllLmFuY2hvck9mZnNldFZlY3Rvcik7XG5cbiAgICBsZXQgcSA9IF9xdWF0ZXJuaW9uLlF1YXRlcm5pb24ucm90YXRlVG8oZXllLm5vcm1hbGl6ZSgpLCB0YXJnZXQubm9ybWFsaXplKCksIF92ZWN0b3IuVmVjdG9yLlVQKTtcblxuICAgIHRoaXMuY3ViZS5yb3RhdGlvbi5zbGVycChxLCAwLjIpO1xuICB9XG5cbiAgbG9va0F0Mih0YXJnZXRJZCkge1xuICAgIGxldCB0YXJnZXQgPSB0aGlzLnRhcmdldHNbdGFyZ2V0SWRdO1xuICAgIGxldCBleWUgPSB0aGlzLmN1YmU7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnBvc2l0aW9uLmNsb25lKCkuYWRkKHRhcmdldC5vZmZzZXQpLmFkZCh0YXJnZXQuYW5jaG9yT2Zmc2V0VmVjdG9yKTtcbiAgICBleWUgPSBleWUucG9zaXRpb24uY2xvbmUoKS5hZGQoZXllLm9mZnNldCkuYWRkKGV5ZS5hbmNob3JPZmZzZXRWZWN0b3IpOyAvLyB0YXJnZXQgPSB0YXJnZXQuZ2xvYmFsRWxlbWVudENlbnRlclBvc2l0aW9uO1xuICAgIC8vIGV5ZSA9IGV5ZS5nbG9iYWxFbGVtZW50Q2VudGVyUG9zaXRpb247XG5cbiAgICBsZXQgdGMgPSB0YXJnZXQuY2xvbmUoKTtcbiAgICBsZXQgZWMgPSBleWUuY2xvbmUoKTtcblxuICAgIGxldCBldWxhckRpZmZlcmVuY2UgPSBfdmVjdG9yLlZlY3Rvci5nZXRFdWxhclJvdGF0aW9uVG8oZXllLm5vcm1hbGl6ZSgpLCB0YXJnZXQubm9ybWFsaXplKCkpO1xuXG4gICAgbGV0IG0xID0gbmV3IF9tYXRyaXhJVi5NYXRyaXhJVigpLnlwcihldWxhckRpZmZlcmVuY2UueiwgZXVsYXJEaWZmZXJlbmNlLnksIGV1bGFyRGlmZmVyZW5jZS54KTtcblxuICAgIGxldCBxID0gX3F1YXRlcm5pb24uUXVhdGVybmlvbi5mcm9tUm90YXRpb25NYXRyaXhJVihtMSk7IC8vIGxldCBxID0gUXVhdGVybmlvbi5mcm9tRXVsZXJWZWN0b3IoZXVsYXJEaWZmZXJlbmNlKTtcblxuXG4gICAgdGhpcy5jdWJlLnJvdGF0aW9uLnNsZXJwKHEsIDAuMik7XG4gIH1cblxuICBsb29rQXQodGFyZ2V0SWQpIHtcbiAgICB0aGlzLmN1YmUudXNlQm91bmRzRm9yR2xvYmFsQ2FsY3VsYXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLnRhcmdldHNbdGFyZ2V0SWRdLnVzZUJvdW5kc0Zvckdsb2JhbENhbGN1bGF0aW9uID0gdHJ1ZTsgLy8gVGhpcyB3b3JrLlxuXG4gICAgbGV0IHRhcmdldCA9IHRoaXMudGFyZ2V0c1t0YXJnZXRJZF07XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnBvc2l0aW9uLmNsb25lKCkuYWRkKHRhcmdldC5vZmZzZXQpLmFkZCh0YXJnZXQuYW5jaG9yT2Zmc2V0VmVjdG9yKTtcbiAgICBsZXQgZXllID0gdGhpcy5jdWJlO1xuICAgIGV5ZSA9IGV5ZS5wb3NpdGlvbi5jbG9uZSgpLmFkZChleWUub2Zmc2V0KS5hZGQoZXllLmFuY2hvck9mZnNldFZlY3Rvcik7IC8vIGRvZXNudCB3b3JrIGJlY2F1c2UgaXQncyB0aWVkIHRvIHdpbmRvdyBzY3JvbGwuXG4gICAgLy8gbGV0IHRhcmdldCA9IHRoaXMudGFyZ2V0c1t0YXJnZXRJZF0uZ2xvYmFsRWxlbWVudENlbnRlclBvc2l0aW9uLmNsb25lKCk7XG4gICAgLy8gbGV0IGV5ZSA9IHRoaXMuY3ViZS5nbG9iYWxFbGVtZW50Q2VudGVyUG9zaXRpb24uY2xvbmUoKTtcbiAgICAvLyB0YXJnZXQueiA9IDEgLSB0YXJnZXQuejtcbiAgICAvLyBleWUueiA9IDEgLSB0YXJnZXQuejtcblxuICAgIGNvbnNvbGUubG9nKCd0JywgdGFyZ2V0LmNsb25lKCkubm9ybWFsaXplKCkpO1xuICAgIGNvbnNvbGUubG9nKCdlJywgZXllKTsgLy8gdGFyZ2V0LnkgKj0gMTtcbiAgICAvLyBleWUueSAqPSAtMTtcblxuICAgIGxldCB0YyA9IHRhcmdldC5jbG9uZSgpO1xuICAgIGxldCBlYyA9IGV5ZS5jbG9uZSgpOyAvLyB0YXJnZXQueSA9IHRjLng7XG4gICAgLy8gdGFyZ2V0LnggPSB0Yy56O1xuICAgIC8vIHRhcmdldC56ID0gdGMueTtcbiAgICAvLyBleWUueSA9IGVjLng7XG4gICAgLy8gZXllLnggPSBlYy56O1xuICAgIC8vIGV5ZS56ID0gZWMueTtcblxuICAgIHRhcmdldC54ID0gdGMuejtcbiAgICB0YXJnZXQueSA9IHRjLnk7XG4gICAgdGFyZ2V0LnogPSB0Yy54O1xuICAgIGV5ZS54ID0gZWMuejtcbiAgICBleWUueSA9IGVjLnk7XG4gICAgZXllLnogPSBlYy54O1xuICAgIHRhcmdldC56ICo9IDE7XG4gICAgZXllLnogKj0gMTsgLy8gbGV0IG0xID0gbmV3IE1hdHJpeElWKCkubG9va0F0KFxuICAgIC8vICAgICAvLyBuZXcgVmVjdG9yKDAsIDAsIDEpLFxuICAgIC8vICAgICBleWUsXG4gICAgLy8gICAgIHRhcmdldCxcbiAgICAvLyAgICAgLy8gVmVjdG9yLlVQXG4gICAgLy8gICAgIG5ldyBWZWN0b3IoMCwgMSwgMClcbiAgICAvLyApO1xuXG4gICAgbGV0IG0xID0gbmV3IF9tYXRyaXhJVi5NYXRyaXhJVigpLmxvb2tBdCggLy8gbmV3IFZlY3RvcigwLCAwLCAxKSxcbiAgICBleWUuY2xvbmUoKS5ub3JtYWxpemUoKSwgdGFyZ2V0LmNsb25lKCkubm9ybWFsaXplKCksIF92ZWN0b3IuVmVjdG9yLkZPUldBUkQgLy8gZXllLmNyb3NzKFZlY3Rvci5GT1JXQVJEKVxuICAgICk7XG5cbiAgICBsZXQgcSA9IF9xdWF0ZXJuaW9uLlF1YXRlcm5pb24uZnJvbVJvdGF0aW9uTWF0cml4SVYobTEpOyAvLyBjb25zb2xlLmxvZyhRdWF0ZXJuaW9uLnRvRXVsZXJWZWN0b3IocSkpO1xuXG5cbiAgICB0aGlzLmN1YmUucm90YXRpb24uc2xlcnAocSwgMC4yKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFF1YXRlcm5pb25TYW1wbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/quaternion.js\n");

/***/ }),

/***/ "./examples/raf-progress.js":
/*!**********************************!*\
  !*** ./examples/raf-progress.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nclass RafProgressSample {\n  constructor() {\n    console.log('RafProgressSample');\n    this.body = document.getElementById('body');\n    this.range = document.getElementById('range');\n    this.progressElement = document.getElementById('progress');\n    const rafProgress = new _rafProgress.RafProgress();\n    rafProgress.watch((easedProgress, direction) => {\n      // console.log('progress event', easedProgress);\n      this.progressElement.textContent = easedProgress;\n    }); // Watch from 0.5 to 0.6.\n\n    const rangeWatcher = (currentProgress, direction) => {\n      console.log('range watcher', currentProgress, direction);\n    };\n\n    rafProgress.watchFor([0.5, 0.6], rangeWatcher); // rafProgress.unwatchFor(rangeWatcher);\n\n    const rangeWatcher2 = (currentProgress, direction) => {\n      console.log('around 20%!', currentProgress, direction);\n    };\n\n    rafProgress.watchFor(0.2, rangeWatcher2);\n    rafProgress.watchFor(0, () => {\n      this.addClass('blue');\n    });\n    rafProgress.watchFor([0.5, 0.6], () => {\n      console.log('red');\n      this.addClass('red');\n    });\n    rafProgress.watchFor(0.7, () => {\n      console.log('yellow');\n      this.addClass('yellow');\n    });\n    rafProgress.watchFor(1, () => {\n      this.addClass('green');\n    });\n    rafProgress.setPrecision(5);\n    rafProgress.setCurrentProgress(this.range.value); // Update rafProgress each time the value of range changes.\n\n    this.range.addEventListener('input', () => {\n      rafProgress.easeTo(+this.range.value, 0.25, _ease.EASE.easeInOutQuad);\n    });\n  }\n\n  addClass(color) {\n    const previousColor = this.currentColor;\n    this.currentColor = color;\n\n    if (previousColor) {\n      this.body.classList.remove(previousColor);\n    }\n\n    this.body.classList.add(color);\n  }\n\n}\n\nexports.default = RafProgressSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9yYWYtcHJvZ3Jlc3MuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9yYWYtcHJvZ3Jlc3MuanM/NDM1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvbWF0aGZcIik7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWYtcHJvZ3Jlc3NcIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG5jbGFzcyBSYWZQcm9ncmVzc1NhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdSYWZQcm9ncmVzc1NhbXBsZScpO1xuICAgIHRoaXMuYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib2R5Jyk7XG4gICAgdGhpcy5yYW5nZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyYW5nZScpO1xuICAgIHRoaXMucHJvZ3Jlc3NFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2dyZXNzJyk7XG4gICAgY29uc3QgcmFmUHJvZ3Jlc3MgPSBuZXcgX3JhZlByb2dyZXNzLlJhZlByb2dyZXNzKCk7XG4gICAgcmFmUHJvZ3Jlc3Mud2F0Y2goKGVhc2VkUHJvZ3Jlc3MsIGRpcmVjdGlvbikgPT4ge1xuICAgICAgLy8gY29uc29sZS5sb2coJ3Byb2dyZXNzIGV2ZW50JywgZWFzZWRQcm9ncmVzcyk7XG4gICAgICB0aGlzLnByb2dyZXNzRWxlbWVudC50ZXh0Q29udGVudCA9IGVhc2VkUHJvZ3Jlc3M7XG4gICAgfSk7IC8vIFdhdGNoIGZyb20gMC41IHRvIDAuNi5cblxuICAgIGNvbnN0IHJhbmdlV2F0Y2hlciA9IChjdXJyZW50UHJvZ3Jlc3MsIGRpcmVjdGlvbikgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ3JhbmdlIHdhdGNoZXInLCBjdXJyZW50UHJvZ3Jlc3MsIGRpcmVjdGlvbik7XG4gICAgfTtcblxuICAgIHJhZlByb2dyZXNzLndhdGNoRm9yKFswLjUsIDAuNl0sIHJhbmdlV2F0Y2hlcik7IC8vIHJhZlByb2dyZXNzLnVud2F0Y2hGb3IocmFuZ2VXYXRjaGVyKTtcblxuICAgIGNvbnN0IHJhbmdlV2F0Y2hlcjIgPSAoY3VycmVudFByb2dyZXNzLCBkaXJlY3Rpb24pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdhcm91bmQgMjAlIScsIGN1cnJlbnRQcm9ncmVzcywgZGlyZWN0aW9uKTtcbiAgICB9O1xuXG4gICAgcmFmUHJvZ3Jlc3Mud2F0Y2hGb3IoMC4yLCByYW5nZVdhdGNoZXIyKTtcbiAgICByYWZQcm9ncmVzcy53YXRjaEZvcigwLCAoKSA9PiB7XG4gICAgICB0aGlzLmFkZENsYXNzKCdibHVlJyk7XG4gICAgfSk7XG4gICAgcmFmUHJvZ3Jlc3Mud2F0Y2hGb3IoWzAuNSwgMC42XSwgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ3JlZCcpO1xuICAgICAgdGhpcy5hZGRDbGFzcygncmVkJyk7XG4gICAgfSk7XG4gICAgcmFmUHJvZ3Jlc3Mud2F0Y2hGb3IoMC43LCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygneWVsbG93Jyk7XG4gICAgICB0aGlzLmFkZENsYXNzKCd5ZWxsb3cnKTtcbiAgICB9KTtcbiAgICByYWZQcm9ncmVzcy53YXRjaEZvcigxLCAoKSA9PiB7XG4gICAgICB0aGlzLmFkZENsYXNzKCdncmVlbicpO1xuICAgIH0pO1xuICAgIHJhZlByb2dyZXNzLnNldFByZWNpc2lvbig1KTtcbiAgICByYWZQcm9ncmVzcy5zZXRDdXJyZW50UHJvZ3Jlc3ModGhpcy5yYW5nZS52YWx1ZSk7IC8vIFVwZGF0ZSByYWZQcm9ncmVzcyBlYWNoIHRpbWUgdGhlIHZhbHVlIG9mIHJhbmdlIGNoYW5nZXMuXG5cbiAgICB0aGlzLnJhbmdlLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgcmFmUHJvZ3Jlc3MuZWFzZVRvKCt0aGlzLnJhbmdlLnZhbHVlLCAwLjI1LCBfZWFzZS5FQVNFLmVhc2VJbk91dFF1YWQpO1xuICAgIH0pO1xuICB9XG5cbiAgYWRkQ2xhc3MoY29sb3IpIHtcbiAgICBjb25zdCBwcmV2aW91c0NvbG9yID0gdGhpcy5jdXJyZW50Q29sb3I7XG4gICAgdGhpcy5jdXJyZW50Q29sb3IgPSBjb2xvcjtcblxuICAgIGlmIChwcmV2aW91c0NvbG9yKSB7XG4gICAgICB0aGlzLmJvZHkuY2xhc3NMaXN0LnJlbW92ZShwcmV2aW91c0NvbG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLmJvZHkuY2xhc3NMaXN0LmFkZChjb2xvcik7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBSYWZQcm9ncmVzc1NhbXBsZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/raf-progress.js\n");

/***/ }),

/***/ "./examples/raf-timer.js":
/*!*******************************!*\
  !*** ./examples/raf-timer.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafTimer = __webpack_require__(/*! ../lib/raf/raf-timer */ \"./lib/raf/raf-timer.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nclass RafTimerSample {\n  constructor() {\n    console.log('running raf timer sample');\n    this.startElement = document.getElementById('start');\n    this.stopElement = document.getElementById('stop');\n    this.box = document.getElementById('box'); // Start the box at 0.\n\n    this.currentX = 0;\n    this.end = 80; // The end position of the box.\n\n    ball.style.transform = `translateX(${this.currentX}vw)`;\n    this.rafTimer = new _rafTimer.RafTimer(progress => {\n      // Ease the ball position on each raf.\n      ball.style.transform = `translateX(${_mathf.mathf.ease(this.currentX, this.end, progress, _ease.EASE.easeOutExpo)}vw)`;\n    }); // Set it so that the raf stops after 1000ms.\n\n    this.rafTimer.setDuration(1000);\n    this.rafTimer.onComplete(() => {\n      console.log('animation complete');\n    });\n    this.startElement.addEventListener('click', () => {\n      this.rafTimer.play();\n    });\n    this.stopElement.addEventListener('click', () => {\n      this.rafTimer.pause();\n    });\n  }\n\n}\n\nexports.default = RafTimerSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9yYWYtdGltZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9yYWYtdGltZXIuanM/ZTZlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yYWZUaW1lciA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZi10aW1lclwiKTtcblxudmFyIF9tYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvbWF0aGZcIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG5jbGFzcyBSYWZUaW1lclNhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdydW5uaW5nIHJhZiB0aW1lciBzYW1wbGUnKTtcbiAgICB0aGlzLnN0YXJ0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFydCcpO1xuICAgIHRoaXMuc3RvcEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RvcCcpO1xuICAgIHRoaXMuYm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JveCcpOyAvLyBTdGFydCB0aGUgYm94IGF0IDAuXG5cbiAgICB0aGlzLmN1cnJlbnRYID0gMDtcbiAgICB0aGlzLmVuZCA9IDgwOyAvLyBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSBib3guXG5cbiAgICBiYWxsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7dGhpcy5jdXJyZW50WH12dylgO1xuICAgIHRoaXMucmFmVGltZXIgPSBuZXcgX3JhZlRpbWVyLlJhZlRpbWVyKHByb2dyZXNzID0+IHtcbiAgICAgIC8vIEVhc2UgdGhlIGJhbGwgcG9zaXRpb24gb24gZWFjaCByYWYuXG4gICAgICBiYWxsLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7X21hdGhmLm1hdGhmLmVhc2UodGhpcy5jdXJyZW50WCwgdGhpcy5lbmQsIHByb2dyZXNzLCBfZWFzZS5FQVNFLmVhc2VPdXRFeHBvKX12dylgO1xuICAgIH0pOyAvLyBTZXQgaXQgc28gdGhhdCB0aGUgcmFmIHN0b3BzIGFmdGVyIDEwMDBtcy5cblxuICAgIHRoaXMucmFmVGltZXIuc2V0RHVyYXRpb24oMTAwMCk7XG4gICAgdGhpcy5yYWZUaW1lci5vbkNvbXBsZXRlKCgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdhbmltYXRpb24gY29tcGxldGUnKTtcbiAgICB9KTtcbiAgICB0aGlzLnN0YXJ0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIHRoaXMucmFmVGltZXIucGxheSgpO1xuICAgIH0pO1xuICAgIHRoaXMuc3RvcEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICB0aGlzLnJhZlRpbWVyLnBhdXNlKCk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBSYWZUaW1lclNhbXBsZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/raf-timer.js\n");

/***/ }),

/***/ "./examples/raf.js":
/*!*************************!*\
  !*** ./examples/raf.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nclass RafSample {\n  constructor() {\n    console.log('running raf sample');\n    this.startElement = document.getElementById('start');\n    this.stopElement = document.getElementById('stop');\n    this.frameRateElement = document.getElementById('frameRate');\n    this.frameRateUpdateElement = document.getElementById('update');\n    this.frameElement = document.getElementById('frame');\n    this.raf = new _raf.Raf((frame, lastUpdateTime) => {\n      // console.log('this is the raf loop running!');\n      this.frameElement.textContent = frame;\n    });\n    this.displayFrameRate();\n    this.startElement.addEventListener('click', () => {\n      this.raf.start();\n    });\n    this.stopElement.addEventListener('click', () => {\n      this.raf.stop();\n    });\n    this.frameRateUpdateElement.addEventListener('click', () => {\n      this.raf.setFps(this.frameRateElement.value);\n    });\n  }\n\n  displayFrameRate() {\n    this.frameRateElement.value = this.raf.fps;\n  }\n\n}\n\nexports.default = RafSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9yYWYuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9yYWYuanM/OWMzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbmNsYXNzIFJhZlNhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdydW5uaW5nIHJhZiBzYW1wbGUnKTtcbiAgICB0aGlzLnN0YXJ0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFydCcpO1xuICAgIHRoaXMuc3RvcEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RvcCcpO1xuICAgIHRoaXMuZnJhbWVSYXRlRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmcmFtZVJhdGUnKTtcbiAgICB0aGlzLmZyYW1lUmF0ZVVwZGF0ZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXBkYXRlJyk7XG4gICAgdGhpcy5mcmFtZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZnJhbWUnKTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZigoZnJhbWUsIGxhc3RVcGRhdGVUaW1lKSA9PiB7XG4gICAgICAvLyBjb25zb2xlLmxvZygndGhpcyBpcyB0aGUgcmFmIGxvb3AgcnVubmluZyEnKTtcbiAgICAgIHRoaXMuZnJhbWVFbGVtZW50LnRleHRDb250ZW50ID0gZnJhbWU7XG4gICAgfSk7XG4gICAgdGhpcy5kaXNwbGF5RnJhbWVSYXRlKCk7XG4gICAgdGhpcy5zdGFydEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICB0aGlzLnJhZi5zdGFydCgpO1xuICAgIH0pO1xuICAgIHRoaXMuc3RvcEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICB0aGlzLnJhZi5zdG9wKCk7XG4gICAgfSk7XG4gICAgdGhpcy5mcmFtZVJhdGVVcGRhdGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdGhpcy5yYWYuc2V0RnBzKHRoaXMuZnJhbWVSYXRlRWxlbWVudC52YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNwbGF5RnJhbWVSYXRlKCkge1xuICAgIHRoaXMuZnJhbWVSYXRlRWxlbWVudC52YWx1ZSA9IHRoaXMucmFmLmZwcztcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJhZlNhbXBsZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/raf.js\n");

/***/ }),

/***/ "./examples/raf2.js":
/*!**************************!*\
  !*** ./examples/raf2.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _elementVisibility = __webpack_require__(/*! ../lib/dom/element-visibility */ \"./lib/dom/element-visibility.js\");\n\n/**\n * This is a sample of running raf with conditional.\n */\nclass RafSample2 {\n  constructor() {\n    console.log('running raf sample2'); // Create one raf loop that run the screen size is less than 1000px\n\n    this.mobileRaf = new _raf.Raf(() => {\n      console.log('running mobile raf');\n    });\n    this.mobileRaf.runWhen(() => {\n      return window.innerWidth < 1000;\n    });\n    this.mobileRaf.start(); // Runs when the titleElement is in view.\n\n    let ev = _elementVisibility.elementVisibility.inview(document.getElementById('title'));\n\n    ev.readyPromise.then(() => {\n      console.log('ev is ready');\n    });\n    this.titleRaf = new _raf.Raf(() => {\n      console.log('element is in view.');\n    });\n    this.titleRaf.runWhen(() => {\n      return ev.state().inview;\n    });\n    this.titleRaf.start();\n  }\n\n}\n\nexports.default = RafSample2;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9yYWYyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvcmFmMi5qcz9hOGUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3JhZiA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZlwiKTtcblxudmFyIF9lbGVtZW50VmlzaWJpbGl0eSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2VsZW1lbnQtdmlzaWJpbGl0eVwiKTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgc2FtcGxlIG9mIHJ1bm5pbmcgcmFmIHdpdGggY29uZGl0aW9uYWwuXG4gKi9cbmNsYXNzIFJhZlNhbXBsZTIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygncnVubmluZyByYWYgc2FtcGxlMicpOyAvLyBDcmVhdGUgb25lIHJhZiBsb29wIHRoYXQgcnVuIHRoZSBzY3JlZW4gc2l6ZSBpcyBsZXNzIHRoYW4gMTAwMHB4XG5cbiAgICB0aGlzLm1vYmlsZVJhZiA9IG5ldyBfcmFmLlJhZigoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygncnVubmluZyBtb2JpbGUgcmFmJyk7XG4gICAgfSk7XG4gICAgdGhpcy5tb2JpbGVSYWYucnVuV2hlbigoKSA9PiB7XG4gICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggPCAxMDAwO1xuICAgIH0pO1xuICAgIHRoaXMubW9iaWxlUmFmLnN0YXJ0KCk7IC8vIFJ1bnMgd2hlbiB0aGUgdGl0bGVFbGVtZW50IGlzIGluIHZpZXcuXG5cbiAgICBsZXQgZXYgPSBfZWxlbWVudFZpc2liaWxpdHkuZWxlbWVudFZpc2liaWxpdHkuaW52aWV3KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aXRsZScpKTtcblxuICAgIGV2LnJlYWR5UHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdldiBpcyByZWFkeScpO1xuICAgIH0pO1xuICAgIHRoaXMudGl0bGVSYWYgPSBuZXcgX3JhZi5SYWYoKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ2VsZW1lbnQgaXMgaW4gdmlldy4nKTtcbiAgICB9KTtcbiAgICB0aGlzLnRpdGxlUmFmLnJ1bldoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIGV2LnN0YXRlKCkuaW52aWV3O1xuICAgIH0pO1xuICAgIHRoaXMudGl0bGVSYWYuc3RhcnQoKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJhZlNhbXBsZTI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/raf2.js\n");

/***/ }),

/***/ "./examples/raycasting.js":
/*!********************************!*\
  !*** ./examples/raycasting.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _x = __webpack_require__(/*! ../lib/x/x */ \"./lib/x/x.js\");\n\nvar _xLine = __webpack_require__(/*! ../lib/x/x-line */ \"./lib/x/x-line.js\");\n\nvar _xRectangle = __webpack_require__(/*! ../lib/x/x-rectangle */ \"./lib/x/x-rectangle.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _raycast = __webpack_require__(/*! ../lib/mathf/raycast */ \"./lib/mathf/raycast.js\");\n\nvar _matrixIV = __webpack_require__(/*! ../lib/mathf/matrixIV */ \"./lib/mathf/matrixIV.js\");\n\nclass RayCastingSample {\n  constructor() {\n    console.log('raycasting');\n    this.imageTextures = {};\n    this.hitObjects = [];\n    this.rays = [];\n    this.startApp();\n  }\n\n  startApp() {\n    const canvasElement = document.getElementById('mainCanvas');\n    this.X = new _x.X({\n      canvasElement: canvasElement,\n      debugMode: true\n    });\n    this.lines = [];\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 800,\n      startY: 800,\n      endX: 0,\n      endY: 890\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 100,\n      startY: 100,\n      endX: 400,\n      endY: 0\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 400,\n      startY: 100,\n      endX: 200,\n      endY: 400\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 500,\n      startY: 600,\n      endX: 200,\n      endY: 600\n    }));\n    this.lines.forEach(line => {\n      this.X.stage.addChild(line);\n    });\n    this.line = new _xLine.XLine({\n      strokeStyle: 'green',\n      lineWidth: 1,\n      startX: 0,\n      startY: 0,\n      endX: 0,\n      endY: 0\n    });\n    this.X.stage.addChild(this.line); // Get the x-Engine pointer.\n\n    const pointer = this.X.getPointer(); // Start the angle of the origin at 0.\n\n    this.angle = 0;\n    this.X.onTick(() => {\n      // Remove all previous hit object.\n      this.hitObjects.forEach(object => {\n        this.X.stage.removeChild(object);\n      });\n      this.hitObjects = [];\n      this.rays.forEach(ray => {\n        this.X.stage.removeChild(ray);\n      });\n      this.rays = []; // Create a rotational matrix to rotate all the rays on each frame.\n\n      let rotationMatrix = new _matrixIV.MatrixIV().ypr(0, 0, this.angle);\n      this.angle += 0.01; // The origin will always be the mouse poition.\n\n      let origin = pointer.position; // Define the number of rays and the angles we want to generate.\n\n      let rayAngles = [0, 20, 40, 60, 80, 100, 120, 140, 160, 180, 200, 220, 240, 260, 280, 300, 320, 340]; // Create a directional vector from the angles we just defined.\n\n      let directionalVectors = rayAngles.map(angle => {\n        // This creates a basic directional vector.\n        const direction = _vector.Vector.fromAngle(_mathf.mathf.degreeToRadian(angle)); // Now multiply it with the rotationMatrix so that it kind of\n        // spins with an offset every frame.\n\n\n        return direction.transformWithMatrixIV(rotationMatrix);\n      }); // Draw out each ray so they can visually be seen.. All rays start from origin.\n\n      directionalVectors.forEach(direction => {\n        const ray = new _xLine.XLine({\n          strokeStyle: 'grey',\n          lineWidth: 1,\n          startX: origin.x,\n          startY: origin.y,\n          endX: _vector.Vector.add(pointer, direction).x,\n          endY: _vector.Vector.add(pointer, direction).y\n        });\n        this.X.stage.addChild(ray);\n        this.rays.push(ray);\n      }); // Loop through each line object to see if there is a collision.\n\n      this.lines.forEach(line => {\n        // For each ray test to see if there is a collision.\n        directionalVectors.forEach(direction => {\n          const raycast = _raycast.Raycast.cast2d(origin, direction, new _vector.Vector(line.startX, line.startY), new _vector.Vector(line.endX, line.endY));\n\n          if (raycast.hit) {\n            const hitRect = new _xRectangle.XRectangle({\n              fillStyle: 'green',\n              x: raycast.collision.x - 5,\n              y: raycast.collision.y - 5,\n              width: 10,\n              height: 10\n            });\n            this.X.stage.addChild(hitRect);\n            this.hitObjects.push(hitRect);\n          }\n        });\n      });\n    });\n    this.X.start();\n  }\n\n}\n\nexports.default = RayCastingSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9yYXljYXN0aW5nLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvcmF5Y2FzdGluZy5qcz9jMTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3ggPSByZXF1aXJlKFwiLi4vbGliL3gveFwiKTtcblxudmFyIF94TGluZSA9IHJlcXVpcmUoXCIuLi9saWIveC94LWxpbmVcIik7XG5cbnZhciBfeFJlY3RhbmdsZSA9IHJlcXVpcmUoXCIuLi9saWIveC94LXJlY3RhbmdsZVwiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL3ZlY3RvclwiKTtcblxudmFyIF9tYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvbWF0aGZcIik7XG5cbnZhciBfcmF5Y2FzdCA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvcmF5Y2FzdFwiKTtcblxudmFyIF9tYXRyaXhJViA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvbWF0cml4SVZcIik7XG5cbmNsYXNzIFJheUNhc3RpbmdTYW1wbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygncmF5Y2FzdGluZycpO1xuICAgIHRoaXMuaW1hZ2VUZXh0dXJlcyA9IHt9O1xuICAgIHRoaXMuaGl0T2JqZWN0cyA9IFtdO1xuICAgIHRoaXMucmF5cyA9IFtdO1xuICAgIHRoaXMuc3RhcnRBcHAoKTtcbiAgfVxuXG4gIHN0YXJ0QXBwKCkge1xuICAgIGNvbnN0IGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbkNhbnZhcycpO1xuICAgIHRoaXMuWCA9IG5ldyBfeC5YKHtcbiAgICAgIGNhbnZhc0VsZW1lbnQ6IGNhbnZhc0VsZW1lbnQsXG4gICAgICBkZWJ1Z01vZGU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmxpbmVzID0gW107XG4gICAgdGhpcy5saW5lcy5wdXNoKG5ldyBfeExpbmUuWExpbmUoe1xuICAgICAgbGluZVdpZHRoOiA1LFxuICAgICAgc3RhcnRYOiA4MDAsXG4gICAgICBzdGFydFk6IDgwMCxcbiAgICAgIGVuZFg6IDAsXG4gICAgICBlbmRZOiA4OTBcbiAgICB9KSk7XG4gICAgdGhpcy5saW5lcy5wdXNoKG5ldyBfeExpbmUuWExpbmUoe1xuICAgICAgbGluZVdpZHRoOiA1LFxuICAgICAgc3RhcnRYOiAxMDAsXG4gICAgICBzdGFydFk6IDEwMCxcbiAgICAgIGVuZFg6IDQwMCxcbiAgICAgIGVuZFk6IDBcbiAgICB9KSk7XG4gICAgdGhpcy5saW5lcy5wdXNoKG5ldyBfeExpbmUuWExpbmUoe1xuICAgICAgbGluZVdpZHRoOiA1LFxuICAgICAgc3RhcnRYOiA0MDAsXG4gICAgICBzdGFydFk6IDEwMCxcbiAgICAgIGVuZFg6IDIwMCxcbiAgICAgIGVuZFk6IDQwMFxuICAgIH0pKTtcbiAgICB0aGlzLmxpbmVzLnB1c2gobmV3IF94TGluZS5YTGluZSh7XG4gICAgICBsaW5lV2lkdGg6IDUsXG4gICAgICBzdGFydFg6IDUwMCxcbiAgICAgIHN0YXJ0WTogNjAwLFxuICAgICAgZW5kWDogMjAwLFxuICAgICAgZW5kWTogNjAwXG4gICAgfSkpO1xuICAgIHRoaXMubGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgIHRoaXMuWC5zdGFnZS5hZGRDaGlsZChsaW5lKTtcbiAgICB9KTtcbiAgICB0aGlzLmxpbmUgPSBuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgIHN0cm9rZVN0eWxlOiAnZ3JlZW4nLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgc3RhcnRYOiAwLFxuICAgICAgc3RhcnRZOiAwLFxuICAgICAgZW5kWDogMCxcbiAgICAgIGVuZFk6IDBcbiAgICB9KTtcbiAgICB0aGlzLlguc3RhZ2UuYWRkQ2hpbGQodGhpcy5saW5lKTsgLy8gR2V0IHRoZSB4LUVuZ2luZSBwb2ludGVyLlxuXG4gICAgY29uc3QgcG9pbnRlciA9IHRoaXMuWC5nZXRQb2ludGVyKCk7IC8vIFN0YXJ0IHRoZSBhbmdsZSBvZiB0aGUgb3JpZ2luIGF0IDAuXG5cbiAgICB0aGlzLmFuZ2xlID0gMDtcbiAgICB0aGlzLlgub25UaWNrKCgpID0+IHtcbiAgICAgIC8vIFJlbW92ZSBhbGwgcHJldmlvdXMgaGl0IG9iamVjdC5cbiAgICAgIHRoaXMuaGl0T2JqZWN0cy5mb3JFYWNoKG9iamVjdCA9PiB7XG4gICAgICAgIHRoaXMuWC5zdGFnZS5yZW1vdmVDaGlsZChvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhpdE9iamVjdHMgPSBbXTtcbiAgICAgIHRoaXMucmF5cy5mb3JFYWNoKHJheSA9PiB7XG4gICAgICAgIHRoaXMuWC5zdGFnZS5yZW1vdmVDaGlsZChyYXkpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJheXMgPSBbXTsgLy8gQ3JlYXRlIGEgcm90YXRpb25hbCBtYXRyaXggdG8gcm90YXRlIGFsbCB0aGUgcmF5cyBvbiBlYWNoIGZyYW1lLlxuXG4gICAgICBsZXQgcm90YXRpb25NYXRyaXggPSBuZXcgX21hdHJpeElWLk1hdHJpeElWKCkueXByKDAsIDAsIHRoaXMuYW5nbGUpO1xuICAgICAgdGhpcy5hbmdsZSArPSAwLjAxOyAvLyBUaGUgb3JpZ2luIHdpbGwgYWx3YXlzIGJlIHRoZSBtb3VzZSBwb2l0aW9uLlxuXG4gICAgICBsZXQgb3JpZ2luID0gcG9pbnRlci5wb3NpdGlvbjsgLy8gRGVmaW5lIHRoZSBudW1iZXIgb2YgcmF5cyBhbmQgdGhlIGFuZ2xlcyB3ZSB3YW50IHRvIGdlbmVyYXRlLlxuXG4gICAgICBsZXQgcmF5QW5nbGVzID0gWzAsIDIwLCA0MCwgNjAsIDgwLCAxMDAsIDEyMCwgMTQwLCAxNjAsIDE4MCwgMjAwLCAyMjAsIDI0MCwgMjYwLCAyODAsIDMwMCwgMzIwLCAzNDBdOyAvLyBDcmVhdGUgYSBkaXJlY3Rpb25hbCB2ZWN0b3IgZnJvbSB0aGUgYW5nbGVzIHdlIGp1c3QgZGVmaW5lZC5cblxuICAgICAgbGV0IGRpcmVjdGlvbmFsVmVjdG9ycyA9IHJheUFuZ2xlcy5tYXAoYW5nbGUgPT4ge1xuICAgICAgICAvLyBUaGlzIGNyZWF0ZXMgYSBiYXNpYyBkaXJlY3Rpb25hbCB2ZWN0b3IuXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IF92ZWN0b3IuVmVjdG9yLmZyb21BbmdsZShfbWF0aGYubWF0aGYuZGVncmVlVG9SYWRpYW4oYW5nbGUpKTsgLy8gTm93IG11bHRpcGx5IGl0IHdpdGggdGhlIHJvdGF0aW9uTWF0cml4IHNvIHRoYXQgaXQga2luZCBvZlxuICAgICAgICAvLyBzcGlucyB3aXRoIGFuIG9mZnNldCBldmVyeSBmcmFtZS5cblxuXG4gICAgICAgIHJldHVybiBkaXJlY3Rpb24udHJhbnNmb3JtV2l0aE1hdHJpeElWKHJvdGF0aW9uTWF0cml4KTtcbiAgICAgIH0pOyAvLyBEcmF3IG91dCBlYWNoIHJheSBzbyB0aGV5IGNhbiB2aXN1YWxseSBiZSBzZWVuLi4gQWxsIHJheXMgc3RhcnQgZnJvbSBvcmlnaW4uXG5cbiAgICAgIGRpcmVjdGlvbmFsVmVjdG9ycy5mb3JFYWNoKGRpcmVjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHJheSA9IG5ldyBfeExpbmUuWExpbmUoe1xuICAgICAgICAgIHN0cm9rZVN0eWxlOiAnZ3JleScsXG4gICAgICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgICAgIHN0YXJ0WDogb3JpZ2luLngsXG4gICAgICAgICAgc3RhcnRZOiBvcmlnaW4ueSxcbiAgICAgICAgICBlbmRYOiBfdmVjdG9yLlZlY3Rvci5hZGQocG9pbnRlciwgZGlyZWN0aW9uKS54LFxuICAgICAgICAgIGVuZFk6IF92ZWN0b3IuVmVjdG9yLmFkZChwb2ludGVyLCBkaXJlY3Rpb24pLnlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuWC5zdGFnZS5hZGRDaGlsZChyYXkpO1xuICAgICAgICB0aGlzLnJheXMucHVzaChyYXkpO1xuICAgICAgfSk7IC8vIExvb3AgdGhyb3VnaCBlYWNoIGxpbmUgb2JqZWN0IHRvIHNlZSBpZiB0aGVyZSBpcyBhIGNvbGxpc2lvbi5cblxuICAgICAgdGhpcy5saW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAvLyBGb3IgZWFjaCByYXkgdGVzdCB0byBzZWUgaWYgdGhlcmUgaXMgYSBjb2xsaXNpb24uXG4gICAgICAgIGRpcmVjdGlvbmFsVmVjdG9ycy5mb3JFYWNoKGRpcmVjdGlvbiA9PiB7XG4gICAgICAgICAgY29uc3QgcmF5Y2FzdCA9IF9yYXljYXN0LlJheWNhc3QuY2FzdDJkKG9yaWdpbiwgZGlyZWN0aW9uLCBuZXcgX3ZlY3Rvci5WZWN0b3IobGluZS5zdGFydFgsIGxpbmUuc3RhcnRZKSwgbmV3IF92ZWN0b3IuVmVjdG9yKGxpbmUuZW5kWCwgbGluZS5lbmRZKSk7XG5cbiAgICAgICAgICBpZiAocmF5Y2FzdC5oaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGhpdFJlY3QgPSBuZXcgX3hSZWN0YW5nbGUuWFJlY3RhbmdsZSh7XG4gICAgICAgICAgICAgIGZpbGxTdHlsZTogJ2dyZWVuJyxcbiAgICAgICAgICAgICAgeDogcmF5Y2FzdC5jb2xsaXNpb24ueCAtIDUsXG4gICAgICAgICAgICAgIHk6IHJheWNhc3QuY29sbGlzaW9uLnkgLSA1LFxuICAgICAgICAgICAgICB3aWR0aDogMTAsXG4gICAgICAgICAgICAgIGhlaWdodDogMTBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5YLnN0YWdlLmFkZENoaWxkKGhpdFJlY3QpO1xuICAgICAgICAgICAgdGhpcy5oaXRPYmplY3RzLnB1c2goaGl0UmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuWC5zdGFydCgpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gUmF5Q2FzdGluZ1NhbXBsZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/raycasting.js\n");

/***/ }),

/***/ "./examples/raycasting2.js":
/*!*********************************!*\
  !*** ./examples/raycasting2.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _x = __webpack_require__(/*! ../lib/x/x */ \"./lib/x/x.js\");\n\nvar _xLine = __webpack_require__(/*! ../lib/x/x-line */ \"./lib/x/x-line.js\");\n\nvar _xRectangle = __webpack_require__(/*! ../lib/x/x-rectangle */ \"./lib/x/x-rectangle.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _raycast = __webpack_require__(/*! ../lib/mathf/raycast */ \"./lib/mathf/raycast.js\");\n\nclass RayCasting2Sample {\n  constructor() {\n    console.log('raycasting2 sample');\n    this.imageTextures = {};\n    this.hitObjects = [];\n    this.rays = [];\n    this.startApp();\n  }\n\n  startApp() {\n    const canvasElement = document.getElementById('mainCanvas');\n    this.X = new _x.X({\n      canvasElement: canvasElement,\n      debugMode: true\n    });\n    this.X.setStageColor('black');\n    this.lines = [];\n\n    for (let i = 0; i < 6; i += 1) {\n      this.lines.push(new _xLine.XLine({\n        lineWidth: 5,\n        startX: _mathf.mathf.getRandomInt(0, 1000),\n        startY: _mathf.mathf.getRandomInt(0, 1000),\n        endX: _mathf.mathf.getRandomInt(0, 1000),\n        endY: _mathf.mathf.getRandomInt(0, 1000)\n      }));\n    }\n\n    const w = window.innerWidth;\n    const h = window.innerHeight; // Create borders.\n\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 0,\n      startY: 0,\n      endX: w,\n      endY: 0\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: w,\n      startY: 0,\n      endX: w,\n      endY: h\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: w,\n      startY: h,\n      endX: 0,\n      endY: h\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 0,\n      startY: h,\n      endX: 0,\n      endY: 0\n    }));\n    this.lines.forEach(line => {\n      this.X.stage.addChild(line);\n    });\n    this.line = new _xLine.XLine({\n      strokeStyle: 'green',\n      lineWidth: 1,\n      startX: 0,\n      startY: 0,\n      endX: 0,\n      endY: 0\n    });\n    this.X.stage.addChild(this.line); // Get the x-Engine pointer.\n\n    const pointer = this.X.getPointer(); // Start the angle of the origin at 0.\n\n    this.angle = 0;\n    this.X.onTick(() => {\n      // Remove all previous hit object.\n      this.hitObjects.forEach(object => {\n        this.X.stage.removeChild(object);\n      });\n      this.hitObjects = [];\n      this.rays.forEach(ray => {\n        this.X.stage.removeChild(ray);\n      });\n      this.rays = []; // The origin will always be the mouse poition.\n\n      let origin = pointer.position; // Define the number of rays and the angles we want to generate.\n\n      let rayAngles = [];\n\n      for (let i = 0; i < 360; i += 1) {\n        rayAngles.push(i);\n      }\n\n      let hitRaycasts = []; // Loop through each line object to see if there is a collision.\n\n      this.lines.forEach(line => {\n        // For each ray test to see if there is a collision.\n        rayAngles.forEach(angle => {\n          const raycast = _raycast.Raycast.castInfinite2dRay(origin, _mathf.mathf.degreeToRadian(angle), new _vector.Vector(line.startX, line.startY), new _vector.Vector(line.endX, line.endY)); // If the current raycast is hitting.\n\n\n          if (raycast.hit) {\n            hitRaycasts.push(raycast); // Now previously, there might have been other rays\n            // of the same angle.\n            //  In this case, we want the ray\n            // that is of the shortest distance over the longer one.\n            // This creates a visual effect, where a ray appears\n            // to not be able to penetrate walls - merely because\n            // we are filtered out duplicate angle rays that penetrate\n            // walls.\n\n            let shortestCast = raycast;\n            hitRaycasts.forEach(ray => {\n              if (ray.angle == shortestCast.angle) {\n                if (ray == shortestCast) {\n                  return;\n                } else if (ray.distance >= shortestCast.distance) {\n                  hitRaycasts.splice(hitRaycasts.indexOf(ray), 1);\n                } else {\n                  hitRaycasts.splice(hitRaycasts.indexOf(shortestCast), 1);\n                  shortestCast = ray;\n                }\n              }\n            });\n          }\n        });\n      }); // For each raycast, we are going to render it out.\n\n      hitRaycasts.forEach(raycast => {\n        // Add a square for intersection point.\n        const hitRect = new _xRectangle.XRectangle({\n          fillStyle: '#4f0a10',\n          x: raycast.collision.x - 1,\n          y: raycast.collision.y - 1,\n          width: 2,\n          height: 2\n        });\n        this.X.stage.addChild(hitRect);\n        this.hitObjects.push(hitRect); // const endGradientVector = Vector.fromAngle(raycast.angle, 100);\n        // let end = Vector.add(origin, endGradientVector);\n        // const useEnd = end.magnitude() < raycast.distance;\n        // end = useEnd ? end : raycast.collision;\n\n        const ray = new _xLine.XLine({\n          radialGradient: {\n            x0: origin.x,\n            y0: origin.y,\n            r0: 100,\n            x1: raycast.collision.x,\n            y1: raycast.collision.y,\n            r1: 1000\n          },\n          gradientStops: [{\n            stop: 0,\n            color: 'white'\n          }, {\n            stop: 1,\n            color: '#010101'\n          }],\n          lineWidth: 3,\n          startX: origin.x,\n          startY: origin.y,\n          endX: raycast.collision.x,\n          endY: raycast.collision.y\n        });\n        this.X.stage.addChild(ray);\n        this.rays.push(ray);\n      });\n    });\n    this.X.start();\n  }\n\n}\n\nexports.default = RayCasting2Sample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9yYXljYXN0aW5nMi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3JheWNhc3RpbmcyLmpzPzU2MzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfeCA9IHJlcXVpcmUoXCIuLi9saWIveC94XCIpO1xuXG52YXIgX3hMaW5lID0gcmVxdWlyZShcIi4uL2xpYi94L3gtbGluZVwiKTtcblxudmFyIF94UmVjdGFuZ2xlID0gcmVxdWlyZShcIi4uL2xpYi94L3gtcmVjdGFuZ2xlXCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvdmVjdG9yXCIpO1xuXG52YXIgX21hdGhmID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9tYXRoZlwiKTtcblxudmFyIF9yYXljYXN0ID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9yYXljYXN0XCIpO1xuXG5jbGFzcyBSYXlDYXN0aW5nMlNhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdyYXljYXN0aW5nMiBzYW1wbGUnKTtcbiAgICB0aGlzLmltYWdlVGV4dHVyZXMgPSB7fTtcbiAgICB0aGlzLmhpdE9iamVjdHMgPSBbXTtcbiAgICB0aGlzLnJheXMgPSBbXTtcbiAgICB0aGlzLnN0YXJ0QXBwKCk7XG4gIH1cblxuICBzdGFydEFwcCgpIHtcbiAgICBjb25zdCBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW5DYW52YXMnKTtcbiAgICB0aGlzLlggPSBuZXcgX3guWCh7XG4gICAgICBjYW52YXNFbGVtZW50OiBjYW52YXNFbGVtZW50LFxuICAgICAgZGVidWdNb2RlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5YLnNldFN0YWdlQ29sb3IoJ2JsYWNrJyk7XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpICs9IDEpIHtcbiAgICAgIHRoaXMubGluZXMucHVzaChuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgICAgbGluZVdpZHRoOiA1LFxuICAgICAgICBzdGFydFg6IF9tYXRoZi5tYXRoZi5nZXRSYW5kb21JbnQoMCwgMTAwMCksXG4gICAgICAgIHN0YXJ0WTogX21hdGhmLm1hdGhmLmdldFJhbmRvbUludCgwLCAxMDAwKSxcbiAgICAgICAgZW5kWDogX21hdGhmLm1hdGhmLmdldFJhbmRvbUludCgwLCAxMDAwKSxcbiAgICAgICAgZW5kWTogX21hdGhmLm1hdGhmLmdldFJhbmRvbUludCgwLCAxMDAwKVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHcgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBjb25zdCBoID0gd2luZG93LmlubmVySGVpZ2h0OyAvLyBDcmVhdGUgYm9yZGVycy5cblxuICAgIHRoaXMubGluZXMucHVzaChuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgIGxpbmVXaWR0aDogNSxcbiAgICAgIHN0YXJ0WDogMCxcbiAgICAgIHN0YXJ0WTogMCxcbiAgICAgIGVuZFg6IHcsXG4gICAgICBlbmRZOiAwXG4gICAgfSkpO1xuICAgIHRoaXMubGluZXMucHVzaChuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgIGxpbmVXaWR0aDogNSxcbiAgICAgIHN0YXJ0WDogdyxcbiAgICAgIHN0YXJ0WTogMCxcbiAgICAgIGVuZFg6IHcsXG4gICAgICBlbmRZOiBoXG4gICAgfSkpO1xuICAgIHRoaXMubGluZXMucHVzaChuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgIGxpbmVXaWR0aDogNSxcbiAgICAgIHN0YXJ0WDogdyxcbiAgICAgIHN0YXJ0WTogaCxcbiAgICAgIGVuZFg6IDAsXG4gICAgICBlbmRZOiBoXG4gICAgfSkpO1xuICAgIHRoaXMubGluZXMucHVzaChuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgIGxpbmVXaWR0aDogNSxcbiAgICAgIHN0YXJ0WDogMCxcbiAgICAgIHN0YXJ0WTogaCxcbiAgICAgIGVuZFg6IDAsXG4gICAgICBlbmRZOiAwXG4gICAgfSkpO1xuICAgIHRoaXMubGluZXMuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgIHRoaXMuWC5zdGFnZS5hZGRDaGlsZChsaW5lKTtcbiAgICB9KTtcbiAgICB0aGlzLmxpbmUgPSBuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgIHN0cm9rZVN0eWxlOiAnZ3JlZW4nLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgc3RhcnRYOiAwLFxuICAgICAgc3RhcnRZOiAwLFxuICAgICAgZW5kWDogMCxcbiAgICAgIGVuZFk6IDBcbiAgICB9KTtcbiAgICB0aGlzLlguc3RhZ2UuYWRkQ2hpbGQodGhpcy5saW5lKTsgLy8gR2V0IHRoZSB4LUVuZ2luZSBwb2ludGVyLlxuXG4gICAgY29uc3QgcG9pbnRlciA9IHRoaXMuWC5nZXRQb2ludGVyKCk7IC8vIFN0YXJ0IHRoZSBhbmdsZSBvZiB0aGUgb3JpZ2luIGF0IDAuXG5cbiAgICB0aGlzLmFuZ2xlID0gMDtcbiAgICB0aGlzLlgub25UaWNrKCgpID0+IHtcbiAgICAgIC8vIFJlbW92ZSBhbGwgcHJldmlvdXMgaGl0IG9iamVjdC5cbiAgICAgIHRoaXMuaGl0T2JqZWN0cy5mb3JFYWNoKG9iamVjdCA9PiB7XG4gICAgICAgIHRoaXMuWC5zdGFnZS5yZW1vdmVDaGlsZChvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhpdE9iamVjdHMgPSBbXTtcbiAgICAgIHRoaXMucmF5cy5mb3JFYWNoKHJheSA9PiB7XG4gICAgICAgIHRoaXMuWC5zdGFnZS5yZW1vdmVDaGlsZChyYXkpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJheXMgPSBbXTsgLy8gVGhlIG9yaWdpbiB3aWxsIGFsd2F5cyBiZSB0aGUgbW91c2UgcG9pdGlvbi5cblxuICAgICAgbGV0IG9yaWdpbiA9IHBvaW50ZXIucG9zaXRpb247IC8vIERlZmluZSB0aGUgbnVtYmVyIG9mIHJheXMgYW5kIHRoZSBhbmdsZXMgd2Ugd2FudCB0byBnZW5lcmF0ZS5cblxuICAgICAgbGV0IHJheUFuZ2xlcyA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM2MDsgaSArPSAxKSB7XG4gICAgICAgIHJheUFuZ2xlcy5wdXNoKGkpO1xuICAgICAgfVxuXG4gICAgICBsZXQgaGl0UmF5Y2FzdHMgPSBbXTsgLy8gTG9vcCB0aHJvdWdoIGVhY2ggbGluZSBvYmplY3QgdG8gc2VlIGlmIHRoZXJlIGlzIGEgY29sbGlzaW9uLlxuXG4gICAgICB0aGlzLmxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgIC8vIEZvciBlYWNoIHJheSB0ZXN0IHRvIHNlZSBpZiB0aGVyZSBpcyBhIGNvbGxpc2lvbi5cbiAgICAgICAgcmF5QW5nbGVzLmZvckVhY2goYW5nbGUgPT4ge1xuICAgICAgICAgIGNvbnN0IHJheWNhc3QgPSBfcmF5Y2FzdC5SYXljYXN0LmNhc3RJbmZpbml0ZTJkUmF5KG9yaWdpbiwgX21hdGhmLm1hdGhmLmRlZ3JlZVRvUmFkaWFuKGFuZ2xlKSwgbmV3IF92ZWN0b3IuVmVjdG9yKGxpbmUuc3RhcnRYLCBsaW5lLnN0YXJ0WSksIG5ldyBfdmVjdG9yLlZlY3RvcihsaW5lLmVuZFgsIGxpbmUuZW5kWSkpOyAvLyBJZiB0aGUgY3VycmVudCByYXljYXN0IGlzIGhpdHRpbmcuXG5cblxuICAgICAgICAgIGlmIChyYXljYXN0LmhpdCkge1xuICAgICAgICAgICAgaGl0UmF5Y2FzdHMucHVzaChyYXljYXN0KTsgLy8gTm93IHByZXZpb3VzbHksIHRoZXJlIG1pZ2h0IGhhdmUgYmVlbiBvdGhlciByYXlzXG4gICAgICAgICAgICAvLyBvZiB0aGUgc2FtZSBhbmdsZS5cbiAgICAgICAgICAgIC8vICBJbiB0aGlzIGNhc2UsIHdlIHdhbnQgdGhlIHJheVxuICAgICAgICAgICAgLy8gdGhhdCBpcyBvZiB0aGUgc2hvcnRlc3QgZGlzdGFuY2Ugb3ZlciB0aGUgbG9uZ2VyIG9uZS5cbiAgICAgICAgICAgIC8vIFRoaXMgY3JlYXRlcyBhIHZpc3VhbCBlZmZlY3QsIHdoZXJlIGEgcmF5IGFwcGVhcnNcbiAgICAgICAgICAgIC8vIHRvIG5vdCBiZSBhYmxlIHRvIHBlbmV0cmF0ZSB3YWxscyAtIG1lcmVseSBiZWNhdXNlXG4gICAgICAgICAgICAvLyB3ZSBhcmUgZmlsdGVyZWQgb3V0IGR1cGxpY2F0ZSBhbmdsZSByYXlzIHRoYXQgcGVuZXRyYXRlXG4gICAgICAgICAgICAvLyB3YWxscy5cblxuICAgICAgICAgICAgbGV0IHNob3J0ZXN0Q2FzdCA9IHJheWNhc3Q7XG4gICAgICAgICAgICBoaXRSYXljYXN0cy5mb3JFYWNoKHJheSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyYXkuYW5nbGUgPT0gc2hvcnRlc3RDYXN0LmFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJheSA9PSBzaG9ydGVzdENhc3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJheS5kaXN0YW5jZSA+PSBzaG9ydGVzdENhc3QuZGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgIGhpdFJheWNhc3RzLnNwbGljZShoaXRSYXljYXN0cy5pbmRleE9mKHJheSksIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBoaXRSYXljYXN0cy5zcGxpY2UoaGl0UmF5Y2FzdHMuaW5kZXhPZihzaG9ydGVzdENhc3QpLCAxKTtcbiAgICAgICAgICAgICAgICAgIHNob3J0ZXN0Q2FzdCA9IHJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gRm9yIGVhY2ggcmF5Y2FzdCwgd2UgYXJlIGdvaW5nIHRvIHJlbmRlciBpdCBvdXQuXG5cbiAgICAgIGhpdFJheWNhc3RzLmZvckVhY2gocmF5Y2FzdCA9PiB7XG4gICAgICAgIC8vIEFkZCBhIHNxdWFyZSBmb3IgaW50ZXJzZWN0aW9uIHBvaW50LlxuICAgICAgICBjb25zdCBoaXRSZWN0ID0gbmV3IF94UmVjdGFuZ2xlLlhSZWN0YW5nbGUoe1xuICAgICAgICAgIGZpbGxTdHlsZTogJyM0ZjBhMTAnLFxuICAgICAgICAgIHg6IHJheWNhc3QuY29sbGlzaW9uLnggLSAxLFxuICAgICAgICAgIHk6IHJheWNhc3QuY29sbGlzaW9uLnkgLSAxLFxuICAgICAgICAgIHdpZHRoOiAyLFxuICAgICAgICAgIGhlaWdodDogMlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5YLnN0YWdlLmFkZENoaWxkKGhpdFJlY3QpO1xuICAgICAgICB0aGlzLmhpdE9iamVjdHMucHVzaChoaXRSZWN0KTsgLy8gY29uc3QgZW5kR3JhZGllbnRWZWN0b3IgPSBWZWN0b3IuZnJvbUFuZ2xlKHJheWNhc3QuYW5nbGUsIDEwMCk7XG4gICAgICAgIC8vIGxldCBlbmQgPSBWZWN0b3IuYWRkKG9yaWdpbiwgZW5kR3JhZGllbnRWZWN0b3IpO1xuICAgICAgICAvLyBjb25zdCB1c2VFbmQgPSBlbmQubWFnbml0dWRlKCkgPCByYXljYXN0LmRpc3RhbmNlO1xuICAgICAgICAvLyBlbmQgPSB1c2VFbmQgPyBlbmQgOiByYXljYXN0LmNvbGxpc2lvbjtcblxuICAgICAgICBjb25zdCByYXkgPSBuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgICAgICByYWRpYWxHcmFkaWVudDoge1xuICAgICAgICAgICAgeDA6IG9yaWdpbi54LFxuICAgICAgICAgICAgeTA6IG9yaWdpbi55LFxuICAgICAgICAgICAgcjA6IDEwMCxcbiAgICAgICAgICAgIHgxOiByYXljYXN0LmNvbGxpc2lvbi54LFxuICAgICAgICAgICAgeTE6IHJheWNhc3QuY29sbGlzaW9uLnksXG4gICAgICAgICAgICByMTogMTAwMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ3JhZGllbnRTdG9wczogW3tcbiAgICAgICAgICAgIHN0b3A6IDAsXG4gICAgICAgICAgICBjb2xvcjogJ3doaXRlJ1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHN0b3A6IDEsXG4gICAgICAgICAgICBjb2xvcjogJyMwMTAxMDEnXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgbGluZVdpZHRoOiAzLFxuICAgICAgICAgIHN0YXJ0WDogb3JpZ2luLngsXG4gICAgICAgICAgc3RhcnRZOiBvcmlnaW4ueSxcbiAgICAgICAgICBlbmRYOiByYXljYXN0LmNvbGxpc2lvbi54LFxuICAgICAgICAgIGVuZFk6IHJheWNhc3QuY29sbGlzaW9uLnlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuWC5zdGFnZS5hZGRDaGlsZChyYXkpO1xuICAgICAgICB0aGlzLnJheXMucHVzaChyYXkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5YLnN0YXJ0KCk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBSYXlDYXN0aW5nMlNhbXBsZTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/raycasting2.js\n");

/***/ }),

/***/ "./examples/raycasting3.js":
/*!*********************************!*\
  !*** ./examples/raycasting3.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _x = __webpack_require__(/*! ../lib/x/x */ \"./lib/x/x.js\");\n\nvar _xLine = __webpack_require__(/*! ../lib/x/x-line */ \"./lib/x/x-line.js\");\n\nvar _xRectangle = __webpack_require__(/*! ../lib/x/x-rectangle */ \"./lib/x/x-rectangle.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _raycast = __webpack_require__(/*! ../lib/mathf/raycast */ \"./lib/mathf/raycast.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\n/**\n * This is a quick demo of using raycasting to project 3d.\n */\nclass RayCasting3Sample {\n  constructor() {\n    console.log('raycasting3 sample');\n    this.rays = [];\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.forwardKey = false;\n    this.leftKey = false;\n    this.rightKey = false;\n    this.downKey = false;\n    this.domWatcher.add({\n      element: document,\n      on: 'keydown',\n      callback: event => {\n        // up arrow\n        if (event.keyCode == 38) {\n          this.forwardKey = true;\n        } // right arrow\n\n\n        if (event.keyCode == 39) {\n          this.rightKey = true;\n        } // left arrow\n\n\n        if (event.keyCode == 37) {\n          this.leftKey = true;\n        } // Down arrow\n\n\n        if (event.keyCode == 40) {\n          this.backKey = true;\n        }\n      }\n    });\n    this.domWatcher.add({\n      element: document,\n      on: 'keyup',\n      callback: event => {\n        if (event.keyCode == 38) {\n          this.forwardKey = false;\n        }\n\n        if (event.keyCode == 39) {\n          this.rightKey = false;\n        }\n\n        if (event.keyCode == 37) {\n          this.leftKey = false;\n        }\n\n        if (event.keyCode == 40) {\n          this.backKey = false;\n        }\n      }\n    });\n    this.projectionRays = []; // The field of view.\n\n    this.fov = 45;\n    this.rayPerAngle = 0.15;\n    this.startApp();\n  }\n\n  startApp() {\n    const canvasElement = document.getElementById('mainCanvas');\n    const canvas2Element = document.getElementById('projectionCanvas');\n    this.X = new _x.X({\n      canvasElement: canvasElement,\n      debugMode: true\n    });\n    this.projectionX = new _x.X({\n      canvasElement: canvas2Element,\n      debugMode: false\n    });\n    this.X.setStageColor('black');\n    this.projectionX.setStageColor('black'); // Create the player\n\n    this.player = new _xRectangle.XRectangle({\n      fillStyle: 'white',\n      x: window.innerWidth / 2 / 2 - 300,\n      y: window.innerHeight - 100,\n      width: 2,\n      heigth: 2\n    });\n    this.X.stage.addChild(this.player); // Create a bunch of lines in the world.\n\n    this.lines = []; // for (let i = 0; i < 2; i += 1) {\n    //     this.lines.push(new XLine({\n    //         lineWidth: 5,\n    //         startX: mathf.getRandomInt(0, 1000),\n    //         startY: mathf.getRandomInt(0, 1000),\n    //         endX: mathf.getRandomInt(0, 1000),\n    //         endY: mathf.getRandomInt(0, 1000),\n    //     }));\n    // }\n\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 50,\n      startY: 50,\n      endX: 200,\n      endY: 50\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 200,\n      startY: 50,\n      endX: 200,\n      endY: 200\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 200,\n      startY: 200,\n      endX: 50,\n      endY: 200\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 50,\n      startY: 200,\n      endX: 50,\n      endY: 50\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 300,\n      startY: 300,\n      endX: 500,\n      endY: 300\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 500,\n      startY: 300,\n      endX: 500,\n      endY: 500\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 500,\n      startY: 500,\n      endX: 300,\n      endY: 500\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 300,\n      startY: 500,\n      endX: 300,\n      endY: 300\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 650,\n      startY: 650,\n      endX: 800,\n      endY: 650\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 800,\n      startY: 650,\n      endX: 800,\n      endY: 800\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 800,\n      startY: 800,\n      endX: 650,\n      endY: 800\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 650,\n      startY: 800,\n      endX: 650,\n      endY: 650\n    }));\n    const w = window.innerWidth;\n    const h = window.innerHeight; // Create borders on the edge of the world.\n\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 0,\n      startY: 0,\n      endX: w / 2,\n      endY: 0\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: w / 2,\n      startY: 0,\n      endX: w / 2,\n      endY: h\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: w / 2,\n      startY: h,\n      endX: 0,\n      endY: h\n    }));\n    this.lines.push(new _xLine.XLine({\n      lineWidth: 5,\n      startX: 0,\n      startY: h,\n      endX: 0,\n      endY: 0\n    }));\n    this.lines.forEach(line => {\n      this.X.stage.addChild(line);\n    }); // Get the x-Engine pointer.\n\n    const pointer = this.X.getPointer(); // Start the angle of the origin at 0.\n\n    this.angle = 0; // Define the number of rays and the angles we want to generate.\n\n    let rayAngles = [];\n\n    for (let i = 0; i < this.fov; i += this.rayPerAngle) {\n      rayAngles.push(i);\n    }\n\n    this.X.onTick(() => {\n      this.rays.forEach(ray => {\n        this.X.stage.removeChild(ray);\n      });\n      this.rays = [];\n\n      if (this.leftKey) {\n        this.player.rotation -= 3;\n      }\n\n      if (this.rightKey) {\n        this.player.rotation += 3;\n      }\n\n      this.player.rotation = _mathf.mathf.wrap(this.player.rotation, 0, 360); // Origin should center from where the player stands.\n\n      let origin = this.player.position;\n      let rotation = this.player.rotation; // If the player is pressing some key we allow the player to move forward.\n\n      if (this.forwardKey) {\n        // Get the current rotation and add a forwardVector in that direction.\n        let forwardVector = _vector.Vector.fromAngle(_mathf.mathf.degreeToRadian(rotation, 1), 10);\n\n        origin.add(forwardVector);\n      }\n\n      if (this.backKey) {\n        // Get the forward Vector and negate it.\n        let forwardVector = _vector.Vector.fromAngle(_mathf.mathf.degreeToRadian(rotation, 1), 10);\n\n        origin.add(forwardVector.negate());\n      }\n\n      this.hitRaycasts = []; // Loop through each line object to see if there is a collision.\n\n      this.lines.forEach(line => {\n        // For each ray test to see if there is a collision.\n        rayAngles.forEach((angle, i) => {\n          // // Offset the angle so the field of view is centered.\n          angle -= this.fov / 2;\n\n          const raycast = _raycast.Raycast.castInfinite2dRay(origin, _mathf.mathf.degreeToRadian(angle + rotation), new _vector.Vector(line.startX, line.startY), new _vector.Vector(line.endX, line.endY)); // If the current raycast is hitting.\n\n\n          if (raycast.hit) {\n            raycast.originalAngle = angle;\n            raycast.order = i;\n            this.hitRaycasts.push(raycast); // Now previously, there might have been other rays\n            // of the same angle.\n            //  In this case, we want the ray\n            // that is of the shortest distance over the longer one.\n            // This creates a visual effect, where a ray appears\n            // to not be able to penetrate walls - merely because\n            // we are filtered out duplicate angle rays that penetrate\n            // walls.\n\n            let shortestCast = raycast;\n            this.hitRaycasts.forEach(ray => {\n              if (ray.angle == shortestCast.angle) {\n                if (ray == shortestCast) {\n                  return;\n                } else if (ray.distance >= shortestCast.distance) {\n                  this.hitRaycasts.splice(this.hitRaycasts.indexOf(ray), 1);\n                } else {\n                  this.hitRaycasts.splice(this.hitRaycasts.indexOf(shortestCast), 1);\n                  shortestCast = ray;\n                }\n              }\n            });\n          }\n        });\n      }); // For each raycast, we are going to render it out.\n\n      this.hitRaycasts.forEach(raycast => {\n        // const endGradientVector = Vector.fromAngle(raycast.angle, 100);\n        // let end = Vector.add(origin, endGradientVector);\n        // const useEnd = end.magnitude() < raycast.distance;\n        // end = useEnd ? end : raycast.collision;\n        const ray = new _xLine.XLine({\n          strokeStyle: 'white',\n          lineWidth: 3,\n          startX: origin.x,\n          startY: origin.y,\n          endX: raycast.collision.x,\n          endY: raycast.collision.y\n        });\n        this.X.stage.addChild(ray);\n        this.rays.push(ray);\n      }); // Sort the ray casts correctly.\n\n      this.hitRaycasts = this.hitRaycasts.sort((a, b) => {\n        return a.order - b.order;\n      });\n      this.projectionXUpdate(w, h);\n    });\n    this.X.start();\n  }\n\n  projectionXUpdate(w, h) {\n    this.projectionX.clear();\n    this.projectionRays.forEach(ray => {\n      this.projectionX.stage.removeChild(ray);\n    });\n    this.projectionRays = [];\n    let widthPerRay = w * 0.5 / (this.hitRaycasts.length - 1); // Create a rectangle for each ray.  The more distance, the more faded it\n    // should look.\n\n    let depth = 9;\n    let visionDistance = 3000;\n    this.hitRaycasts.forEach((ray, i) => {\n      let distance = ray.distance;\n      let scale = distance / visionDistance;\n      scale = 1 - _mathf.mathf.clamp01(scale); // Avoid fisheye so use square.\n\n      scale = Math.pow(scale, depth);\n      let height = Math.max(h * scale, 1);\n      let halfHeight = height / 2;\n      let centerV = h / 2;\n      const rect = new _xLine.XLine({\n        startX: i * widthPerRay + 1,\n        startY: centerV - halfHeight,\n        lineWidth: widthPerRay + 1,\n        strokeStyle: 'red',\n        endX: i * widthPerRay,\n        endY: centerV + halfHeight,\n        alpha: Math.max(0.1, scale)\n      });\n      const floor = new _xLine.XLine({\n        startX: i * widthPerRay + 1,\n        startY: centerV + halfHeight,\n        lineWidth: widthPerRay + 1,\n        radialGradient: {\n          x0: i * widthPerRay + 1,\n          y0: centerV + halfHeight,\n          r0: 100,\n          x1: i * widthPerRay + 1,\n          y1: h,\n          r1: 500\n        },\n        gradientStops: [{\n          stop: 0,\n          color: '#010101'\n        }, {\n          stop: 1,\n          color: 'white'\n        }],\n        endX: i * widthPerRay,\n        endY: h,\n        alpha: 1 // alpha: Math.max(0.1, scale)\n\n      }); // const text =\n      //     new XLine({\n      //         fillStyle: 'white',\n      //         x: i * widthPerRay + 1,\n      //         y: h,\n      //         text: ray.distance\n      //     });\n\n      this.projectionRays.push(rect);\n      this.projectionRays.push(floor); // this.projectionRays.push(text);\n\n      this.projectionX.stage.addChild(rect);\n      this.projectionX.stage.addChild(floor); // this.projectionX.stage.addChild(text);\n    }); // console.log(this.projectionRays[0]);\n\n    this.projectionX.gameLoop();\n  }\n\n}\n\nexports.default = RayCasting3Sample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9yYXljYXN0aW5nMy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3JheWNhc3RpbmczLmpzP2U3M2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfeCA9IHJlcXVpcmUoXCIuLi9saWIveC94XCIpO1xuXG52YXIgX3hMaW5lID0gcmVxdWlyZShcIi4uL2xpYi94L3gtbGluZVwiKTtcblxudmFyIF94UmVjdGFuZ2xlID0gcmVxdWlyZShcIi4uL2xpYi94L3gtcmVjdGFuZ2xlXCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvdmVjdG9yXCIpO1xuXG52YXIgX21hdGhmID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9tYXRoZlwiKTtcblxudmFyIF9yYXljYXN0ID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9yYXljYXN0XCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgcXVpY2sgZGVtbyBvZiB1c2luZyByYXljYXN0aW5nIHRvIHByb2plY3QgM2QuXG4gKi9cbmNsYXNzIFJheUNhc3RpbmczU2FtcGxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coJ3JheWNhc3RpbmczIHNhbXBsZScpO1xuICAgIHRoaXMucmF5cyA9IFtdO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5mb3J3YXJkS2V5ID0gZmFsc2U7XG4gICAgdGhpcy5sZWZ0S2V5ID0gZmFsc2U7XG4gICAgdGhpcy5yaWdodEtleSA9IGZhbHNlO1xuICAgIHRoaXMuZG93bktleSA9IGZhbHNlO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQsXG4gICAgICBvbjogJ2tleWRvd24nLFxuICAgICAgY2FsbGJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgLy8gdXAgYXJyb3dcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzgpIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmRLZXkgPSB0cnVlO1xuICAgICAgICB9IC8vIHJpZ2h0IGFycm93XG5cblxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAzOSkge1xuICAgICAgICAgIHRoaXMucmlnaHRLZXkgPSB0cnVlO1xuICAgICAgICB9IC8vIGxlZnQgYXJyb3dcblxuXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09IDM3KSB7XG4gICAgICAgICAgdGhpcy5sZWZ0S2V5ID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBEb3duIGFycm93XG5cblxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSA0MCkge1xuICAgICAgICAgIHRoaXMuYmFja0tleSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LFxuICAgICAgb246ICdrZXl1cCcsXG4gICAgICBjYWxsYmFjazogZXZlbnQgPT4ge1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAzOCkge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZEtleSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzkpIHtcbiAgICAgICAgICB0aGlzLnJpZ2h0S2V5ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAzNykge1xuICAgICAgICAgIHRoaXMubGVmdEtleSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gNDApIHtcbiAgICAgICAgICB0aGlzLmJhY2tLZXkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJvamVjdGlvblJheXMgPSBbXTsgLy8gVGhlIGZpZWxkIG9mIHZpZXcuXG5cbiAgICB0aGlzLmZvdiA9IDQ1O1xuICAgIHRoaXMucmF5UGVyQW5nbGUgPSAwLjE1O1xuICAgIHRoaXMuc3RhcnRBcHAoKTtcbiAgfVxuXG4gIHN0YXJ0QXBwKCkge1xuICAgIGNvbnN0IGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbkNhbnZhcycpO1xuICAgIGNvbnN0IGNhbnZhczJFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2plY3Rpb25DYW52YXMnKTtcbiAgICB0aGlzLlggPSBuZXcgX3guWCh7XG4gICAgICBjYW52YXNFbGVtZW50OiBjYW52YXNFbGVtZW50LFxuICAgICAgZGVidWdNb2RlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5wcm9qZWN0aW9uWCA9IG5ldyBfeC5YKHtcbiAgICAgIGNhbnZhc0VsZW1lbnQ6IGNhbnZhczJFbGVtZW50LFxuICAgICAgZGVidWdNb2RlOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuWC5zZXRTdGFnZUNvbG9yKCdibGFjaycpO1xuICAgIHRoaXMucHJvamVjdGlvblguc2V0U3RhZ2VDb2xvcignYmxhY2snKTsgLy8gQ3JlYXRlIHRoZSBwbGF5ZXJcblxuICAgIHRoaXMucGxheWVyID0gbmV3IF94UmVjdGFuZ2xlLlhSZWN0YW5nbGUoe1xuICAgICAgZmlsbFN0eWxlOiAnd2hpdGUnLFxuICAgICAgeDogd2luZG93LmlubmVyV2lkdGggLyAyIC8gMiAtIDMwMCxcbiAgICAgIHk6IHdpbmRvdy5pbm5lckhlaWdodCAtIDEwMCxcbiAgICAgIHdpZHRoOiAyLFxuICAgICAgaGVpZ3RoOiAyXG4gICAgfSk7XG4gICAgdGhpcy5YLnN0YWdlLmFkZENoaWxkKHRoaXMucGxheWVyKTsgLy8gQ3JlYXRlIGEgYnVuY2ggb2YgbGluZXMgaW4gdGhlIHdvcmxkLlxuXG4gICAgdGhpcy5saW5lcyA9IFtdOyAvLyBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkgKz0gMSkge1xuICAgIC8vICAgICB0aGlzLmxpbmVzLnB1c2gobmV3IFhMaW5lKHtcbiAgICAvLyAgICAgICAgIGxpbmVXaWR0aDogNSxcbiAgICAvLyAgICAgICAgIHN0YXJ0WDogbWF0aGYuZ2V0UmFuZG9tSW50KDAsIDEwMDApLFxuICAgIC8vICAgICAgICAgc3RhcnRZOiBtYXRoZi5nZXRSYW5kb21JbnQoMCwgMTAwMCksXG4gICAgLy8gICAgICAgICBlbmRYOiBtYXRoZi5nZXRSYW5kb21JbnQoMCwgMTAwMCksXG4gICAgLy8gICAgICAgICBlbmRZOiBtYXRoZi5nZXRSYW5kb21JbnQoMCwgMTAwMCksXG4gICAgLy8gICAgIH0pKTtcbiAgICAvLyB9XG5cbiAgICB0aGlzLmxpbmVzLnB1c2gobmV3IF94TGluZS5YTGluZSh7XG4gICAgICBsaW5lV2lkdGg6IDUsXG4gICAgICBzdGFydFg6IDUwLFxuICAgICAgc3RhcnRZOiA1MCxcbiAgICAgIGVuZFg6IDIwMCxcbiAgICAgIGVuZFk6IDUwXG4gICAgfSkpO1xuICAgIHRoaXMubGluZXMucHVzaChuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgIGxpbmVXaWR0aDogNSxcbiAgICAgIHN0YXJ0WDogMjAwLFxuICAgICAgc3RhcnRZOiA1MCxcbiAgICAgIGVuZFg6IDIwMCxcbiAgICAgIGVuZFk6IDIwMFxuICAgIH0pKTtcbiAgICB0aGlzLmxpbmVzLnB1c2gobmV3IF94TGluZS5YTGluZSh7XG4gICAgICBsaW5lV2lkdGg6IDUsXG4gICAgICBzdGFydFg6IDIwMCxcbiAgICAgIHN0YXJ0WTogMjAwLFxuICAgICAgZW5kWDogNTAsXG4gICAgICBlbmRZOiAyMDBcbiAgICB9KSk7XG4gICAgdGhpcy5saW5lcy5wdXNoKG5ldyBfeExpbmUuWExpbmUoe1xuICAgICAgbGluZVdpZHRoOiA1LFxuICAgICAgc3RhcnRYOiA1MCxcbiAgICAgIHN0YXJ0WTogMjAwLFxuICAgICAgZW5kWDogNTAsXG4gICAgICBlbmRZOiA1MFxuICAgIH0pKTtcbiAgICB0aGlzLmxpbmVzLnB1c2gobmV3IF94TGluZS5YTGluZSh7XG4gICAgICBsaW5lV2lkdGg6IDUsXG4gICAgICBzdGFydFg6IDMwMCxcbiAgICAgIHN0YXJ0WTogMzAwLFxuICAgICAgZW5kWDogNTAwLFxuICAgICAgZW5kWTogMzAwXG4gICAgfSkpO1xuICAgIHRoaXMubGluZXMucHVzaChuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgIGxpbmVXaWR0aDogNSxcbiAgICAgIHN0YXJ0WDogNTAwLFxuICAgICAgc3RhcnRZOiAzMDAsXG4gICAgICBlbmRYOiA1MDAsXG4gICAgICBlbmRZOiA1MDBcbiAgICB9KSk7XG4gICAgdGhpcy5saW5lcy5wdXNoKG5ldyBfeExpbmUuWExpbmUoe1xuICAgICAgbGluZVdpZHRoOiA1LFxuICAgICAgc3RhcnRYOiA1MDAsXG4gICAgICBzdGFydFk6IDUwMCxcbiAgICAgIGVuZFg6IDMwMCxcbiAgICAgIGVuZFk6IDUwMFxuICAgIH0pKTtcbiAgICB0aGlzLmxpbmVzLnB1c2gobmV3IF94TGluZS5YTGluZSh7XG4gICAgICBsaW5lV2lkdGg6IDUsXG4gICAgICBzdGFydFg6IDMwMCxcbiAgICAgIHN0YXJ0WTogNTAwLFxuICAgICAgZW5kWDogMzAwLFxuICAgICAgZW5kWTogMzAwXG4gICAgfSkpO1xuICAgIHRoaXMubGluZXMucHVzaChuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgIGxpbmVXaWR0aDogNSxcbiAgICAgIHN0YXJ0WDogNjUwLFxuICAgICAgc3RhcnRZOiA2NTAsXG4gICAgICBlbmRYOiA4MDAsXG4gICAgICBlbmRZOiA2NTBcbiAgICB9KSk7XG4gICAgdGhpcy5saW5lcy5wdXNoKG5ldyBfeExpbmUuWExpbmUoe1xuICAgICAgbGluZVdpZHRoOiA1LFxuICAgICAgc3RhcnRYOiA4MDAsXG4gICAgICBzdGFydFk6IDY1MCxcbiAgICAgIGVuZFg6IDgwMCxcbiAgICAgIGVuZFk6IDgwMFxuICAgIH0pKTtcbiAgICB0aGlzLmxpbmVzLnB1c2gobmV3IF94TGluZS5YTGluZSh7XG4gICAgICBsaW5lV2lkdGg6IDUsXG4gICAgICBzdGFydFg6IDgwMCxcbiAgICAgIHN0YXJ0WTogODAwLFxuICAgICAgZW5kWDogNjUwLFxuICAgICAgZW5kWTogODAwXG4gICAgfSkpO1xuICAgIHRoaXMubGluZXMucHVzaChuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgIGxpbmVXaWR0aDogNSxcbiAgICAgIHN0YXJ0WDogNjUwLFxuICAgICAgc3RhcnRZOiA4MDAsXG4gICAgICBlbmRYOiA2NTAsXG4gICAgICBlbmRZOiA2NTBcbiAgICB9KSk7XG4gICAgY29uc3QgdyA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGNvbnN0IGggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7IC8vIENyZWF0ZSBib3JkZXJzIG9uIHRoZSBlZGdlIG9mIHRoZSB3b3JsZC5cblxuICAgIHRoaXMubGluZXMucHVzaChuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgIGxpbmVXaWR0aDogNSxcbiAgICAgIHN0YXJ0WDogMCxcbiAgICAgIHN0YXJ0WTogMCxcbiAgICAgIGVuZFg6IHcgLyAyLFxuICAgICAgZW5kWTogMFxuICAgIH0pKTtcbiAgICB0aGlzLmxpbmVzLnB1c2gobmV3IF94TGluZS5YTGluZSh7XG4gICAgICBsaW5lV2lkdGg6IDUsXG4gICAgICBzdGFydFg6IHcgLyAyLFxuICAgICAgc3RhcnRZOiAwLFxuICAgICAgZW5kWDogdyAvIDIsXG4gICAgICBlbmRZOiBoXG4gICAgfSkpO1xuICAgIHRoaXMubGluZXMucHVzaChuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgIGxpbmVXaWR0aDogNSxcbiAgICAgIHN0YXJ0WDogdyAvIDIsXG4gICAgICBzdGFydFk6IGgsXG4gICAgICBlbmRYOiAwLFxuICAgICAgZW5kWTogaFxuICAgIH0pKTtcbiAgICB0aGlzLmxpbmVzLnB1c2gobmV3IF94TGluZS5YTGluZSh7XG4gICAgICBsaW5lV2lkdGg6IDUsXG4gICAgICBzdGFydFg6IDAsXG4gICAgICBzdGFydFk6IGgsXG4gICAgICBlbmRYOiAwLFxuICAgICAgZW5kWTogMFxuICAgIH0pKTtcbiAgICB0aGlzLmxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICB0aGlzLlguc3RhZ2UuYWRkQ2hpbGQobGluZSk7XG4gICAgfSk7IC8vIEdldCB0aGUgeC1FbmdpbmUgcG9pbnRlci5cblxuICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLlguZ2V0UG9pbnRlcigpOyAvLyBTdGFydCB0aGUgYW5nbGUgb2YgdGhlIG9yaWdpbiBhdCAwLlxuXG4gICAgdGhpcy5hbmdsZSA9IDA7IC8vIERlZmluZSB0aGUgbnVtYmVyIG9mIHJheXMgYW5kIHRoZSBhbmdsZXMgd2Ugd2FudCB0byBnZW5lcmF0ZS5cblxuICAgIGxldCByYXlBbmdsZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mb3Y7IGkgKz0gdGhpcy5yYXlQZXJBbmdsZSkge1xuICAgICAgcmF5QW5nbGVzLnB1c2goaSk7XG4gICAgfVxuXG4gICAgdGhpcy5YLm9uVGljaygoKSA9PiB7XG4gICAgICB0aGlzLnJheXMuZm9yRWFjaChyYXkgPT4ge1xuICAgICAgICB0aGlzLlguc3RhZ2UucmVtb3ZlQ2hpbGQocmF5KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yYXlzID0gW107XG5cbiAgICAgIGlmICh0aGlzLmxlZnRLZXkpIHtcbiAgICAgICAgdGhpcy5wbGF5ZXIucm90YXRpb24gLT0gMztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucmlnaHRLZXkpIHtcbiAgICAgICAgdGhpcy5wbGF5ZXIucm90YXRpb24gKz0gMztcbiAgICAgIH1cblxuICAgICAgdGhpcy5wbGF5ZXIucm90YXRpb24gPSBfbWF0aGYubWF0aGYud3JhcCh0aGlzLnBsYXllci5yb3RhdGlvbiwgMCwgMzYwKTsgLy8gT3JpZ2luIHNob3VsZCBjZW50ZXIgZnJvbSB3aGVyZSB0aGUgcGxheWVyIHN0YW5kcy5cblxuICAgICAgbGV0IG9yaWdpbiA9IHRoaXMucGxheWVyLnBvc2l0aW9uO1xuICAgICAgbGV0IHJvdGF0aW9uID0gdGhpcy5wbGF5ZXIucm90YXRpb247IC8vIElmIHRoZSBwbGF5ZXIgaXMgcHJlc3Npbmcgc29tZSBrZXkgd2UgYWxsb3cgdGhlIHBsYXllciB0byBtb3ZlIGZvcndhcmQuXG5cbiAgICAgIGlmICh0aGlzLmZvcndhcmRLZXkpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHJvdGF0aW9uIGFuZCBhZGQgYSBmb3J3YXJkVmVjdG9yIGluIHRoYXQgZGlyZWN0aW9uLlxuICAgICAgICBsZXQgZm9yd2FyZFZlY3RvciA9IF92ZWN0b3IuVmVjdG9yLmZyb21BbmdsZShfbWF0aGYubWF0aGYuZGVncmVlVG9SYWRpYW4ocm90YXRpb24sIDEpLCAxMCk7XG5cbiAgICAgICAgb3JpZ2luLmFkZChmb3J3YXJkVmVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmFja0tleSkge1xuICAgICAgICAvLyBHZXQgdGhlIGZvcndhcmQgVmVjdG9yIGFuZCBuZWdhdGUgaXQuXG4gICAgICAgIGxldCBmb3J3YXJkVmVjdG9yID0gX3ZlY3Rvci5WZWN0b3IuZnJvbUFuZ2xlKF9tYXRoZi5tYXRoZi5kZWdyZWVUb1JhZGlhbihyb3RhdGlvbiwgMSksIDEwKTtcblxuICAgICAgICBvcmlnaW4uYWRkKGZvcndhcmRWZWN0b3IubmVnYXRlKCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhpdFJheWNhc3RzID0gW107IC8vIExvb3AgdGhyb3VnaCBlYWNoIGxpbmUgb2JqZWN0IHRvIHNlZSBpZiB0aGVyZSBpcyBhIGNvbGxpc2lvbi5cblxuICAgICAgdGhpcy5saW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICAvLyBGb3IgZWFjaCByYXkgdGVzdCB0byBzZWUgaWYgdGhlcmUgaXMgYSBjb2xsaXNpb24uXG4gICAgICAgIHJheUFuZ2xlcy5mb3JFYWNoKChhbmdsZSwgaSkgPT4ge1xuICAgICAgICAgIC8vIC8vIE9mZnNldCB0aGUgYW5nbGUgc28gdGhlIGZpZWxkIG9mIHZpZXcgaXMgY2VudGVyZWQuXG4gICAgICAgICAgYW5nbGUgLT0gdGhpcy5mb3YgLyAyO1xuXG4gICAgICAgICAgY29uc3QgcmF5Y2FzdCA9IF9yYXljYXN0LlJheWNhc3QuY2FzdEluZmluaXRlMmRSYXkob3JpZ2luLCBfbWF0aGYubWF0aGYuZGVncmVlVG9SYWRpYW4oYW5nbGUgKyByb3RhdGlvbiksIG5ldyBfdmVjdG9yLlZlY3RvcihsaW5lLnN0YXJ0WCwgbGluZS5zdGFydFkpLCBuZXcgX3ZlY3Rvci5WZWN0b3IobGluZS5lbmRYLCBsaW5lLmVuZFkpKTsgLy8gSWYgdGhlIGN1cnJlbnQgcmF5Y2FzdCBpcyBoaXR0aW5nLlxuXG5cbiAgICAgICAgICBpZiAocmF5Y2FzdC5oaXQpIHtcbiAgICAgICAgICAgIHJheWNhc3Qub3JpZ2luYWxBbmdsZSA9IGFuZ2xlO1xuICAgICAgICAgICAgcmF5Y2FzdC5vcmRlciA9IGk7XG4gICAgICAgICAgICB0aGlzLmhpdFJheWNhc3RzLnB1c2gocmF5Y2FzdCk7IC8vIE5vdyBwcmV2aW91c2x5LCB0aGVyZSBtaWdodCBoYXZlIGJlZW4gb3RoZXIgcmF5c1xuICAgICAgICAgICAgLy8gb2YgdGhlIHNhbWUgYW5nbGUuXG4gICAgICAgICAgICAvLyAgSW4gdGhpcyBjYXNlLCB3ZSB3YW50IHRoZSByYXlcbiAgICAgICAgICAgIC8vIHRoYXQgaXMgb2YgdGhlIHNob3J0ZXN0IGRpc3RhbmNlIG92ZXIgdGhlIGxvbmdlciBvbmUuXG4gICAgICAgICAgICAvLyBUaGlzIGNyZWF0ZXMgYSB2aXN1YWwgZWZmZWN0LCB3aGVyZSBhIHJheSBhcHBlYXJzXG4gICAgICAgICAgICAvLyB0byBub3QgYmUgYWJsZSB0byBwZW5ldHJhdGUgd2FsbHMgLSBtZXJlbHkgYmVjYXVzZVxuICAgICAgICAgICAgLy8gd2UgYXJlIGZpbHRlcmVkIG91dCBkdXBsaWNhdGUgYW5nbGUgcmF5cyB0aGF0IHBlbmV0cmF0ZVxuICAgICAgICAgICAgLy8gd2FsbHMuXG5cbiAgICAgICAgICAgIGxldCBzaG9ydGVzdENhc3QgPSByYXljYXN0O1xuICAgICAgICAgICAgdGhpcy5oaXRSYXljYXN0cy5mb3JFYWNoKHJheSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyYXkuYW5nbGUgPT0gc2hvcnRlc3RDYXN0LmFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJheSA9PSBzaG9ydGVzdENhc3QpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJheS5kaXN0YW5jZSA+PSBzaG9ydGVzdENhc3QuZGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaGl0UmF5Y2FzdHMuc3BsaWNlKHRoaXMuaGl0UmF5Y2FzdHMuaW5kZXhPZihyYXkpLCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5oaXRSYXljYXN0cy5zcGxpY2UodGhpcy5oaXRSYXljYXN0cy5pbmRleE9mKHNob3J0ZXN0Q2FzdCksIDEpO1xuICAgICAgICAgICAgICAgICAgc2hvcnRlc3RDYXN0ID0gcmF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBGb3IgZWFjaCByYXljYXN0LCB3ZSBhcmUgZ29pbmcgdG8gcmVuZGVyIGl0IG91dC5cblxuICAgICAgdGhpcy5oaXRSYXljYXN0cy5mb3JFYWNoKHJheWNhc3QgPT4ge1xuICAgICAgICAvLyBjb25zdCBlbmRHcmFkaWVudFZlY3RvciA9IFZlY3Rvci5mcm9tQW5nbGUocmF5Y2FzdC5hbmdsZSwgMTAwKTtcbiAgICAgICAgLy8gbGV0IGVuZCA9IFZlY3Rvci5hZGQob3JpZ2luLCBlbmRHcmFkaWVudFZlY3Rvcik7XG4gICAgICAgIC8vIGNvbnN0IHVzZUVuZCA9IGVuZC5tYWduaXR1ZGUoKSA8IHJheWNhc3QuZGlzdGFuY2U7XG4gICAgICAgIC8vIGVuZCA9IHVzZUVuZCA/IGVuZCA6IHJheWNhc3QuY29sbGlzaW9uO1xuICAgICAgICBjb25zdCByYXkgPSBuZXcgX3hMaW5lLlhMaW5lKHtcbiAgICAgICAgICBzdHJva2VTdHlsZTogJ3doaXRlJyxcbiAgICAgICAgICBsaW5lV2lkdGg6IDMsXG4gICAgICAgICAgc3RhcnRYOiBvcmlnaW4ueCxcbiAgICAgICAgICBzdGFydFk6IG9yaWdpbi55LFxuICAgICAgICAgIGVuZFg6IHJheWNhc3QuY29sbGlzaW9uLngsXG4gICAgICAgICAgZW5kWTogcmF5Y2FzdC5jb2xsaXNpb24ueVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5YLnN0YWdlLmFkZENoaWxkKHJheSk7XG4gICAgICAgIHRoaXMucmF5cy5wdXNoKHJheSk7XG4gICAgICB9KTsgLy8gU29ydCB0aGUgcmF5IGNhc3RzIGNvcnJlY3RseS5cblxuICAgICAgdGhpcy5oaXRSYXljYXN0cyA9IHRoaXMuaGl0UmF5Y2FzdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvamVjdGlvblhVcGRhdGUodywgaCk7XG4gICAgfSk7XG4gICAgdGhpcy5YLnN0YXJ0KCk7XG4gIH1cblxuICBwcm9qZWN0aW9uWFVwZGF0ZSh3LCBoKSB7XG4gICAgdGhpcy5wcm9qZWN0aW9uWC5jbGVhcigpO1xuICAgIHRoaXMucHJvamVjdGlvblJheXMuZm9yRWFjaChyYXkgPT4ge1xuICAgICAgdGhpcy5wcm9qZWN0aW9uWC5zdGFnZS5yZW1vdmVDaGlsZChyYXkpO1xuICAgIH0pO1xuICAgIHRoaXMucHJvamVjdGlvblJheXMgPSBbXTtcbiAgICBsZXQgd2lkdGhQZXJSYXkgPSB3ICogMC41IC8gKHRoaXMuaGl0UmF5Y2FzdHMubGVuZ3RoIC0gMSk7IC8vIENyZWF0ZSBhIHJlY3RhbmdsZSBmb3IgZWFjaCByYXkuICBUaGUgbW9yZSBkaXN0YW5jZSwgdGhlIG1vcmUgZmFkZWQgaXRcbiAgICAvLyBzaG91bGQgbG9vay5cblxuICAgIGxldCBkZXB0aCA9IDk7XG4gICAgbGV0IHZpc2lvbkRpc3RhbmNlID0gMzAwMDtcbiAgICB0aGlzLmhpdFJheWNhc3RzLmZvckVhY2goKHJheSwgaSkgPT4ge1xuICAgICAgbGV0IGRpc3RhbmNlID0gcmF5LmRpc3RhbmNlO1xuICAgICAgbGV0IHNjYWxlID0gZGlzdGFuY2UgLyB2aXNpb25EaXN0YW5jZTtcbiAgICAgIHNjYWxlID0gMSAtIF9tYXRoZi5tYXRoZi5jbGFtcDAxKHNjYWxlKTsgLy8gQXZvaWQgZmlzaGV5ZSBzbyB1c2Ugc3F1YXJlLlxuXG4gICAgICBzY2FsZSA9IE1hdGgucG93KHNjYWxlLCBkZXB0aCk7XG4gICAgICBsZXQgaGVpZ2h0ID0gTWF0aC5tYXgoaCAqIHNjYWxlLCAxKTtcbiAgICAgIGxldCBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICAgIGxldCBjZW50ZXJWID0gaCAvIDI7XG4gICAgICBjb25zdCByZWN0ID0gbmV3IF94TGluZS5YTGluZSh7XG4gICAgICAgIHN0YXJ0WDogaSAqIHdpZHRoUGVyUmF5ICsgMSxcbiAgICAgICAgc3RhcnRZOiBjZW50ZXJWIC0gaGFsZkhlaWdodCxcbiAgICAgICAgbGluZVdpZHRoOiB3aWR0aFBlclJheSArIDEsXG4gICAgICAgIHN0cm9rZVN0eWxlOiAncmVkJyxcbiAgICAgICAgZW5kWDogaSAqIHdpZHRoUGVyUmF5LFxuICAgICAgICBlbmRZOiBjZW50ZXJWICsgaGFsZkhlaWdodCxcbiAgICAgICAgYWxwaGE6IE1hdGgubWF4KDAuMSwgc2NhbGUpXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGZsb29yID0gbmV3IF94TGluZS5YTGluZSh7XG4gICAgICAgIHN0YXJ0WDogaSAqIHdpZHRoUGVyUmF5ICsgMSxcbiAgICAgICAgc3RhcnRZOiBjZW50ZXJWICsgaGFsZkhlaWdodCxcbiAgICAgICAgbGluZVdpZHRoOiB3aWR0aFBlclJheSArIDEsXG4gICAgICAgIHJhZGlhbEdyYWRpZW50OiB7XG4gICAgICAgICAgeDA6IGkgKiB3aWR0aFBlclJheSArIDEsXG4gICAgICAgICAgeTA6IGNlbnRlclYgKyBoYWxmSGVpZ2h0LFxuICAgICAgICAgIHIwOiAxMDAsXG4gICAgICAgICAgeDE6IGkgKiB3aWR0aFBlclJheSArIDEsXG4gICAgICAgICAgeTE6IGgsXG4gICAgICAgICAgcjE6IDUwMFxuICAgICAgICB9LFxuICAgICAgICBncmFkaWVudFN0b3BzOiBbe1xuICAgICAgICAgIHN0b3A6IDAsXG4gICAgICAgICAgY29sb3I6ICcjMDEwMTAxJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgc3RvcDogMSxcbiAgICAgICAgICBjb2xvcjogJ3doaXRlJ1xuICAgICAgICB9XSxcbiAgICAgICAgZW5kWDogaSAqIHdpZHRoUGVyUmF5LFxuICAgICAgICBlbmRZOiBoLFxuICAgICAgICBhbHBoYTogMSAvLyBhbHBoYTogTWF0aC5tYXgoMC4xLCBzY2FsZSlcblxuICAgICAgfSk7IC8vIGNvbnN0IHRleHQgPVxuICAgICAgLy8gICAgIG5ldyBYTGluZSh7XG4gICAgICAvLyAgICAgICAgIGZpbGxTdHlsZTogJ3doaXRlJyxcbiAgICAgIC8vICAgICAgICAgeDogaSAqIHdpZHRoUGVyUmF5ICsgMSxcbiAgICAgIC8vICAgICAgICAgeTogaCxcbiAgICAgIC8vICAgICAgICAgdGV4dDogcmF5LmRpc3RhbmNlXG4gICAgICAvLyAgICAgfSk7XG5cbiAgICAgIHRoaXMucHJvamVjdGlvblJheXMucHVzaChyZWN0KTtcbiAgICAgIHRoaXMucHJvamVjdGlvblJheXMucHVzaChmbG9vcik7IC8vIHRoaXMucHJvamVjdGlvblJheXMucHVzaCh0ZXh0KTtcblxuICAgICAgdGhpcy5wcm9qZWN0aW9uWC5zdGFnZS5hZGRDaGlsZChyZWN0KTtcbiAgICAgIHRoaXMucHJvamVjdGlvblguc3RhZ2UuYWRkQ2hpbGQoZmxvb3IpOyAvLyB0aGlzLnByb2plY3Rpb25YLnN0YWdlLmFkZENoaWxkKHRleHQpO1xuICAgIH0pOyAvLyBjb25zb2xlLmxvZyh0aGlzLnByb2plY3Rpb25SYXlzWzBdKTtcblxuICAgIHRoaXMucHJvamVjdGlvblguZ2FtZUxvb3AoKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJheUNhc3RpbmczU2FtcGxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/raycasting3.js\n");

/***/ }),

/***/ "./examples/scripts/index.js":
/*!***********************************!*\
  !*** ./examples/scripts/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! ../styles/index.sass */ \"./examples/styles/index.sass\");\n\n__webpack_require__(/*! intersection-observer */ \"./node_modules/intersection-observer/intersection-observer.js\");\n\nvar _bezierCurve = __webpack_require__(/*! ../bezier-curve */ \"./examples/bezier-curve.js\");\n\nvar _bezierCurve2 = _interopRequireDefault(_bezierCurve);\n\nvar _canvasImageSequence = __webpack_require__(/*! ../canvas-image-sequence */ \"./examples/canvas-image-sequence.js\");\n\nvar _canvasImageSequence2 = _interopRequireDefault(_canvasImageSequence);\n\nvar _canvasImageSequence3 = __webpack_require__(/*! ../canvas-image-sequence10 */ \"./examples/canvas-image-sequence10.js\");\n\nvar _canvasImageSequence4 = _interopRequireDefault(_canvasImageSequence3);\n\nvar _canvasImageSequence5 = __webpack_require__(/*! ../canvas-image-sequence2 */ \"./examples/canvas-image-sequence2.js\");\n\nvar _canvasImageSequence6 = _interopRequireDefault(_canvasImageSequence5);\n\nvar _canvasImageSequence7 = __webpack_require__(/*! ../canvas-image-sequence3 */ \"./examples/canvas-image-sequence3.js\");\n\nvar _canvasImageSequence8 = _interopRequireDefault(_canvasImageSequence7);\n\nvar _canvasImageSequence9 = __webpack_require__(/*! ../canvas-image-sequence4 */ \"./examples/canvas-image-sequence4.js\");\n\nvar _canvasImageSequence10 = _interopRequireDefault(_canvasImageSequence9);\n\nvar _canvasImageSequence11 = __webpack_require__(/*! ../canvas-image-sequence5 */ \"./examples/canvas-image-sequence5.js\");\n\nvar _canvasImageSequence12 = _interopRequireDefault(_canvasImageSequence11);\n\nvar _canvasImageSequence13 = __webpack_require__(/*! ../canvas-image-sequence7 */ \"./examples/canvas-image-sequence7.js\");\n\nvar _canvasImageSequence14 = _interopRequireDefault(_canvasImageSequence13);\n\nvar _canvasImageSequence15 = __webpack_require__(/*! ../canvas-image-sequence8 */ \"./examples/canvas-image-sequence8.js\");\n\nvar _canvasImageSequence16 = _interopRequireDefault(_canvasImageSequence15);\n\nvar _canvasImageSequence17 = __webpack_require__(/*! ../canvas-image-sequence9 */ \"./examples/canvas-image-sequence9.js\");\n\nvar _canvasImageSequence18 = _interopRequireDefault(_canvasImageSequence17);\n\nvar _carousel = __webpack_require__(/*! ../carousel */ \"./examples/carousel.js\");\n\nvar _carousel2 = _interopRequireDefault(_carousel);\n\nvar _catmullRom = __webpack_require__(/*! ../catmull-rom */ \"./examples/catmull-rom.js\");\n\nvar _catmullRom2 = _interopRequireDefault(_catmullRom);\n\nvar _cssVarInterpolate = __webpack_require__(/*! ../css-var-interpolate */ \"./examples/css-var-interpolate.js\");\n\nvar _cssVarInterpolate2 = _interopRequireDefault(_cssVarInterpolate);\n\nvar _cssVarInterpolate3 = __webpack_require__(/*! ../css-var-interpolate2 */ \"./examples/css-var-interpolate2.js\");\n\nvar _cssVarInterpolate4 = _interopRequireDefault(_cssVarInterpolate3);\n\nvar _cssVarInterpolate5 = __webpack_require__(/*! ../css-var-interpolate3 */ \"./examples/css-var-interpolate3.js\");\n\nvar _cssVarInterpolate6 = _interopRequireDefault(_cssVarInterpolate5);\n\nvar _domCanvas = __webpack_require__(/*! ../dom-canvas */ \"./examples/dom-canvas.js\");\n\nvar _domCanvas2 = _interopRequireDefault(_domCanvas);\n\nvar _domWatcher = __webpack_require__(/*! ../dom-watcher */ \"./examples/dom-watcher.js\");\n\nvar _domWatcher2 = _interopRequireDefault(_domWatcher);\n\nvar _easerDisableRaf = __webpack_require__(/*! ../easer-disable-raf */ \"./examples/easer-disable-raf.js\");\n\nvar _easerDisableRaf2 = _interopRequireDefault(_easerDisableRaf);\n\nvar _easer = __webpack_require__(/*! ../easer */ \"./examples/easer.js\");\n\nvar _easer2 = _interopRequireDefault(_easer);\n\nvar _glslPlayground = __webpack_require__(/*! ../glsl-playground */ \"./examples/glsl-playground.js\");\n\nvar _glslPlayground2 = _interopRequireDefault(_glslPlayground);\n\nvar _glslPlayground3 = __webpack_require__(/*! ../glsl-playground2 */ \"./examples/glsl-playground2.js\");\n\nvar _glslPlayground4 = _interopRequireDefault(_glslPlayground3);\n\nvar _glslPlayground5 = __webpack_require__(/*! ../glsl-playground3 */ \"./examples/glsl-playground3.js\");\n\nvar _glslPlayground6 = _interopRequireDefault(_glslPlayground5);\n\nvar _glslPlayground7 = __webpack_require__(/*! ../glsl-playground4 */ \"./examples/glsl-playground4.js\");\n\nvar _glslPlayground8 = _interopRequireDefault(_glslPlayground7);\n\nvar _glslPlayground9 = __webpack_require__(/*! ../glsl-playground5 */ \"./examples/glsl-playground5.js\");\n\nvar _glslPlayground10 = _interopRequireDefault(_glslPlayground9);\n\nvar _glslPlayground11 = __webpack_require__(/*! ../glsl-playground6 */ \"./examples/glsl-playground6.js\");\n\nvar _glslPlayground12 = _interopRequireDefault(_glslPlayground11);\n\nvar _glslPlayground13 = __webpack_require__(/*! ../glsl-playground7 */ \"./examples/glsl-playground7.js\");\n\nvar _glslPlayground14 = _interopRequireDefault(_glslPlayground13);\n\nvar _glslPlayground15 = __webpack_require__(/*! ../glsl-playground8 */ \"./examples/glsl-playground8.js\");\n\nvar _glslPlayground16 = _interopRequireDefault(_glslPlayground15);\n\nvar _glslPlayground17 = __webpack_require__(/*! ../glsl-playground9 */ \"./examples/glsl-playground9.js\");\n\nvar _glslPlayground18 = _interopRequireDefault(_glslPlayground17);\n\nvar _glslPlayground19 = __webpack_require__(/*! ../glsl-playground10 */ \"./examples/glsl-playground10.js\");\n\nvar _glslPlayground20 = _interopRequireDefault(_glslPlayground19);\n\nvar _glslPlayground21 = __webpack_require__(/*! ../glsl-playground11 */ \"./examples/glsl-playground11.js\");\n\nvar _glslPlayground22 = _interopRequireDefault(_glslPlayground21);\n\nvar _glslPlayground23 = __webpack_require__(/*! ../glsl-playground12 */ \"./examples/glsl-playground12.js\");\n\nvar _glslPlayground24 = _interopRequireDefault(_glslPlayground23);\n\nvar _glslPlayground25 = __webpack_require__(/*! ../glsl-playground13 */ \"./examples/glsl-playground13.js\");\n\nvar _glslPlayground26 = _interopRequireDefault(_glslPlayground25);\n\nvar _glslPlayground27 = __webpack_require__(/*! ../glsl-playground14 */ \"./examples/glsl-playground14.js\");\n\nvar _glslPlayground28 = _interopRequireDefault(_glslPlayground27);\n\nvar _glslPlayground29 = __webpack_require__(/*! ../glsl-playground15 */ \"./examples/glsl-playground15.js\");\n\nvar _glslPlayground30 = _interopRequireDefault(_glslPlayground29);\n\nvar _glslPlayground31 = __webpack_require__(/*! ../glsl-playground16 */ \"./examples/glsl-playground16.js\");\n\nvar _glslPlayground32 = _interopRequireDefault(_glslPlayground31);\n\nvar _glslPlayground33 = __webpack_require__(/*! ../glsl-playground17 */ \"./examples/glsl-playground17.js\");\n\nvar _glslPlayground34 = _interopRequireDefault(_glslPlayground33);\n\nvar _glslPlayground35 = __webpack_require__(/*! ../glsl-playground18 */ \"./examples/glsl-playground18.js\");\n\nvar _glslPlayground36 = _interopRequireDefault(_glslPlayground35);\n\nvar _glslPlayground37 = __webpack_require__(/*! ../glsl-playground19 */ \"./examples/glsl-playground19.js\");\n\nvar _glslPlayground38 = _interopRequireDefault(_glslPlayground37);\n\nvar _glslPlayground39 = __webpack_require__(/*! ../glsl-playground20 */ \"./examples/glsl-playground20.js\");\n\nvar _glslPlayground40 = _interopRequireDefault(_glslPlayground39);\n\nvar _glslPlayground41 = __webpack_require__(/*! ../glsl-playground21 */ \"./examples/glsl-playground21.js\");\n\nvar _glslPlayground42 = _interopRequireDefault(_glslPlayground41);\n\nvar _glslPlayground43 = __webpack_require__(/*! ../glsl-playground22 */ \"./examples/glsl-playground22.js\");\n\nvar _glslPlayground44 = _interopRequireDefault(_glslPlayground43);\n\nvar _glslPlayground45 = __webpack_require__(/*! ../glsl-playground23 */ \"./examples/glsl-playground23.js\");\n\nvar _glslPlayground46 = _interopRequireDefault(_glslPlayground45);\n\nvar _glslPlayground47 = __webpack_require__(/*! ../glsl-playground24 */ \"./examples/glsl-playground24.js\");\n\nvar _glslPlayground48 = _interopRequireDefault(_glslPlayground47);\n\nvar _glslPlayground49 = __webpack_require__(/*! ../glsl-playground25 */ \"./examples/glsl-playground25.js\");\n\nvar _glslPlayground50 = _interopRequireDefault(_glslPlayground49);\n\nvar _glslPlayground51 = __webpack_require__(/*! ../glsl-playground26 */ \"./examples/glsl-playground26.js\");\n\nvar _glslPlayground52 = _interopRequireDefault(_glslPlayground51);\n\nvar _glslPlayground53 = __webpack_require__(/*! ../glsl-playground27 */ \"./examples/glsl-playground27.js\");\n\nvar _glslPlayground54 = _interopRequireDefault(_glslPlayground53);\n\nvar _glslPlayground55 = __webpack_require__(/*! ../glsl-playground28 */ \"./examples/glsl-playground28.js\");\n\nvar _glslPlayground56 = _interopRequireDefault(_glslPlayground55);\n\nvar _glslPlayground57 = __webpack_require__(/*! ../glsl-playground29 */ \"./examples/glsl-playground29.js\");\n\nvar _glslPlayground58 = _interopRequireDefault(_glslPlayground57);\n\nvar _glslPlayground59 = __webpack_require__(/*! ../glsl-playground30 */ \"./examples/glsl-playground30.js\");\n\nvar _glslPlayground60 = _interopRequireDefault(_glslPlayground59);\n\nvar _hermiteCurve = __webpack_require__(/*! ../hermite-curve */ \"./examples/hermite-curve.js\");\n\nvar _hermiteCurve2 = _interopRequireDefault(_hermiteCurve);\n\nvar _interpolate = __webpack_require__(/*! ../interpolate */ \"./examples/interpolate.js\");\n\nvar _interpolate2 = _interopRequireDefault(_interpolate);\n\nvar _mathfEase = __webpack_require__(/*! ../mathf-ease */ \"./examples/mathf-ease.js\");\n\nvar _mathfEase2 = _interopRequireDefault(_mathfEase);\n\nvar _matrixIV = __webpack_require__(/*! ../matrixIV */ \"./examples/matrixIV.js\");\n\nvar _matrixIV2 = _interopRequireDefault(_matrixIV);\n\nvar _matrixIV3 = __webpack_require__(/*! ../matrixIV2 */ \"./examples/matrixIV2.js\");\n\nvar _matrixIV4 = _interopRequireDefault(_matrixIV3);\n\nvar _matrixIV5 = __webpack_require__(/*! ../matrixIV3 */ \"./examples/matrixIV3.js\");\n\nvar _matrixIV6 = _interopRequireDefault(_matrixIV5);\n\nvar _multiInterpolate = __webpack_require__(/*! ../multi-interpolate */ \"./examples/multi-interpolate.js\");\n\nvar _multiInterpolate2 = _interopRequireDefault(_multiInterpolate);\n\nvar _offScreenCanvas = __webpack_require__(/*! ../off-screen-canvas */ \"./examples/off-screen-canvas.js\");\n\nvar _offScreenCanvas2 = _interopRequireDefault(_offScreenCanvas);\n\nvar _perlinNoise = __webpack_require__(/*! ../perlin-noise */ \"./examples/perlin-noise.js\");\n\nvar _perlinNoise2 = _interopRequireDefault(_perlinNoise);\n\nvar _playground = __webpack_require__(/*! ../playground */ \"./examples/playground.js\");\n\nvar _playground2 = _interopRequireDefault(_playground);\n\nvar _pseudo3dCanvas = __webpack_require__(/*! ../pseudo-3d-canvas */ \"./examples/pseudo-3d-canvas.js\");\n\nvar _pseudo3dCanvas2 = _interopRequireDefault(_pseudo3dCanvas);\n\nvar _quaternion = __webpack_require__(/*! ../quaternion */ \"./examples/quaternion.js\");\n\nvar _quaternion2 = _interopRequireDefault(_quaternion);\n\nvar _rafProgress = __webpack_require__(/*! ../raf-progress */ \"./examples/raf-progress.js\");\n\nvar _rafProgress2 = _interopRequireDefault(_rafProgress);\n\nvar _raf = __webpack_require__(/*! ../raf */ \"./examples/raf.js\");\n\nvar _raf2 = _interopRequireDefault(_raf);\n\nvar _raf3 = __webpack_require__(/*! ../raf2 */ \"./examples/raf2.js\");\n\nvar _raf4 = _interopRequireDefault(_raf3);\n\nvar _rafTimer = __webpack_require__(/*! ../raf-timer */ \"./examples/raf-timer.js\");\n\nvar _rafTimer2 = _interopRequireDefault(_rafTimer);\n\nvar _raycasting = __webpack_require__(/*! ../raycasting2 */ \"./examples/raycasting2.js\");\n\nvar _raycasting2 = _interopRequireDefault(_raycasting);\n\nvar _raycasting3 = __webpack_require__(/*! ../raycasting3 */ \"./examples/raycasting3.js\");\n\nvar _raycasting4 = _interopRequireDefault(_raycasting3);\n\nvar _raycasting5 = __webpack_require__(/*! ../raycasting */ \"./examples/raycasting.js\");\n\nvar _raycasting6 = _interopRequireDefault(_raycasting5);\n\nvar _scrollDemo = __webpack_require__(/*! ../scroll-demo */ \"./examples/scroll-demo.js\");\n\nvar _scrollDemo2 = _interopRequireDefault(_scrollDemo);\n\nvar _scrollDemo3 = __webpack_require__(/*! ../scroll-demo2 */ \"./examples/scroll-demo2.js\");\n\nvar _scrollDemo4 = _interopRequireDefault(_scrollDemo3);\n\nvar _scrollDemo5 = __webpack_require__(/*! ../scroll-demo3 */ \"./examples/scroll-demo3.js\");\n\nvar _scrollDemo6 = _interopRequireDefault(_scrollDemo5);\n\nvar _scrollDemo7 = __webpack_require__(/*! ../scroll-demo4 */ \"./examples/scroll-demo4.js\");\n\nvar _scrollDemo8 = _interopRequireDefault(_scrollDemo7);\n\nvar _scrollDemo9 = __webpack_require__(/*! ../scroll-demo5 */ \"./examples/scroll-demo5.js\");\n\nvar _scrollDemo10 = _interopRequireDefault(_scrollDemo9);\n\nvar _textSplit = __webpack_require__(/*! ../text-split */ \"./examples/text-split.js\");\n\nvar _textSplit2 = _interopRequireDefault(_textSplit);\n\nvar _threeSceneRenderer = __webpack_require__(/*! ../three-scene-renderer */ \"./examples/three-scene-renderer.js\");\n\nvar _threeSceneRenderer2 = _interopRequireDefault(_threeSceneRenderer);\n\nvar _threeSceneRenderer3 = __webpack_require__(/*! ../three-scene-renderer2 */ \"./examples/three-scene-renderer2.js\");\n\nvar _threeSceneRenderer4 = _interopRequireDefault(_threeSceneRenderer3);\n\nvar _threeLightTest = __webpack_require__(/*! ../three-light-test */ \"./examples/three-light-test.js\");\n\nvar _threeLightTest2 = _interopRequireDefault(_threeLightTest);\n\nvar _threeLightTest3 = __webpack_require__(/*! ../three-light-test2 */ \"./examples/three-light-test2.js\");\n\nvar _threeLightTest4 = _interopRequireDefault(_threeLightTest3);\n\nvar _threeObjectViewer = __webpack_require__(/*! ../three-object-viewer */ \"./examples/three-object-viewer.js\");\n\nvar _threeObjectViewer2 = _interopRequireDefault(_threeObjectViewer);\n\nvar _threeObjectViewer3 = __webpack_require__(/*! ../three-object-viewer10 */ \"./examples/three-object-viewer10.js\");\n\nvar _threeObjectViewer4 = _interopRequireDefault(_threeObjectViewer3);\n\nvar _threeObjectViewer5 = __webpack_require__(/*! ../three-object-viewer11 */ \"./examples/three-object-viewer11.js\");\n\nvar _threeObjectViewer6 = _interopRequireDefault(_threeObjectViewer5);\n\nvar _threeObjectViewer7 = __webpack_require__(/*! ../three-object-viewer2 */ \"./examples/three-object-viewer2.js\");\n\nvar _threeObjectViewer8 = _interopRequireDefault(_threeObjectViewer7);\n\nvar _threeObjectViewer9 = __webpack_require__(/*! ../three-object-viewer3 */ \"./examples/three-object-viewer3.js\");\n\nvar _threeObjectViewer10 = _interopRequireDefault(_threeObjectViewer9);\n\nvar _threeObjectViewer11 = __webpack_require__(/*! ../three-object-viewer4 */ \"./examples/three-object-viewer4.js\");\n\nvar _threeObjectViewer12 = _interopRequireDefault(_threeObjectViewer11);\n\nvar _threeObjectViewer13 = __webpack_require__(/*! ../three-object-viewer5 */ \"./examples/three-object-viewer5.js\");\n\nvar _threeObjectViewer14 = _interopRequireDefault(_threeObjectViewer13);\n\nvar _threeObjectViewer15 = __webpack_require__(/*! ../three-object-viewer6 */ \"./examples/three-object-viewer6.js\");\n\nvar _threeObjectViewer16 = _interopRequireDefault(_threeObjectViewer15);\n\nvar _threeObjectViewer17 = __webpack_require__(/*! ../three-object-viewer7 */ \"./examples/three-object-viewer7.js\");\n\nvar _threeObjectViewer18 = _interopRequireDefault(_threeObjectViewer17);\n\nvar _threeObjectViewer19 = __webpack_require__(/*! ../three-object-viewer8 */ \"./examples/three-object-viewer8.js\");\n\nvar _threeObjectViewer20 = _interopRequireDefault(_threeObjectViewer19);\n\nvar _threeObjectViewer21 = __webpack_require__(/*! ../three-object-viewer9 */ \"./examples/three-object-viewer9.js\");\n\nvar _threeObjectViewer22 = _interopRequireDefault(_threeObjectViewer21);\n\nvar _vectorDom = __webpack_require__(/*! ../vector-dom */ \"./examples/vector-dom.js\");\n\nvar _vectorDom2 = _interopRequireDefault(_vectorDom);\n\nvar _vectorDom3 = __webpack_require__(/*! ../vector-dom2 */ \"./examples/vector-dom2.js\");\n\nvar _vectorDom4 = _interopRequireDefault(_vectorDom3);\n\nvar _vectorDom5 = __webpack_require__(/*! ../vector-dom3 */ \"./examples/vector-dom3.js\");\n\nvar _vectorDom6 = _interopRequireDefault(_vectorDom5);\n\nvar _videoProgress = __webpack_require__(/*! ../video-progress */ \"./examples/video-progress.js\");\n\nvar _videoProgress2 = _interopRequireDefault(_videoProgress);\n\nvar _videoPlayer = __webpack_require__(/*! ../video-player */ \"./examples/video-player.js\");\n\nvar _videoPlayer2 = _interopRequireDefault(_videoPlayer);\n\nvar _webglImageSequence = __webpack_require__(/*! ../webgl-image-sequence */ \"./examples/webgl-image-sequence.js\");\n\nvar _webglImageSequence2 = _interopRequireDefault(_webglImageSequence);\n\nvar _webglImageSequence3 = __webpack_require__(/*! ../webgl-image-sequence2 */ \"./examples/webgl-image-sequence2.js\");\n\nvar _webglImageSequence4 = _interopRequireDefault(_webglImageSequence3);\n\nvar _webglImageSequence5 = __webpack_require__(/*! ../webgl-image-sequence3 */ \"./examples/webgl-image-sequence3.js\");\n\nvar _webglImageSequence6 = _interopRequireDefault(_webglImageSequence5);\n\nvar _webglImageSequence7 = __webpack_require__(/*! ../webgl-image-sequence4 */ \"./examples/webgl-image-sequence4.js\");\n\nvar _webglImageSequence8 = _interopRequireDefault(_webglImageSequence7);\n\nvar _webglImageSequence9 = __webpack_require__(/*! ../webgl-image-sequence5 */ \"./examples/webgl-image-sequence5.js\");\n\nvar _webglImageSequence10 = _interopRequireDefault(_webglImageSequence9);\n\nvar _webglImageSequence11 = __webpack_require__(/*! ../webgl-image-sequence7 */ \"./examples/webgl-image-sequence7.js\");\n\nvar _webglImageSequence12 = _interopRequireDefault(_webglImageSequence11);\n\nvar _webglImageSequence13 = __webpack_require__(/*! ../webgl-image-sequence9 */ \"./examples/webgl-image-sequence9.js\");\n\nvar _webglImageSequence14 = _interopRequireDefault(_webglImageSequence13);\n\nvar _x = __webpack_require__(/*! ../x2 */ \"./examples/x2.js\");\n\nvar _x2 = _interopRequireDefault(_x);\n\nvar _x3 = __webpack_require__(/*! ../x */ \"./examples/x.js\");\n\nvar _x4 = _interopRequireDefault(_x3);\n\nvar _inview = __webpack_require__(/*! ../inview */ \"./examples/inview.js\");\n\nvar _inview2 = _interopRequireDefault(_inview);\n\nvar _webgl = __webpack_require__(/*! ../webgl */ \"./examples/webgl.js\");\n\nvar _webgl2 = _interopRequireDefault(_webgl);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Examples.\n// import VideoProgressSample from '../playground/video-progress';\nconst samples = {\n  'carouselSample': _carousel2.default,\n  'easerDisableRafSample': _easerDisableRaf2.default,\n  'easerSample': _easer2.default,\n  'interpolateSample': _interpolate2.default,\n  'mathfEaseSample': _mathfEase2.default,\n  'multiInterpolateSample': _multiInterpolate2.default,\n  'cssVarInterpolateSample': _cssVarInterpolate2.default,\n  'cssVarInterpolateSample2': _cssVarInterpolate4.default,\n  'cssVarInterpolateSample3': _cssVarInterpolate6.default,\n  'canvasImageSequenceSample': _canvasImageSequence2.default,\n  'canvasImageSequenceSample2': _canvasImageSequence6.default,\n  'canvasImageSequenceSample3': _canvasImageSequence8.default,\n  'canvasImageSequenceSample4': _canvasImageSequence10.default,\n  'canvasImageSequenceSample5': _canvasImageSequence12.default,\n  'canvasImageSequenceSample7': _canvasImageSequence14.default,\n  'canvasImageSequenceSample8': _canvasImageSequence16.default,\n  'canvasImageSequenceSample9': _canvasImageSequence18.default,\n  'canvasImageSequenceSample10': _canvasImageSequence4.default,\n  'webglImageSequenceSample': _webglImageSequence2.default,\n  'webglImageSequenceSample2': _webglImageSequence4.default,\n  'webglImageSequenceSample3': _webglImageSequence6.default,\n  'webglImageSequenceSample4': _webglImageSequence8.default,\n  'webglImageSequenceSample5': _webglImageSequence10.default,\n  'webglImageSequenceSample7': _webglImageSequence12.default,\n  'webglImageSequenceSample9': _webglImageSequence14.default,\n  'rafSample': _raf2.default,\n  'rafSample2': _raf4.default,\n  'rafTimerSample': _rafTimer2.default,\n  'rafProgressSample': _rafProgress2.default,\n  'playgroundSample': _playground2.default,\n  'offScreenCanvasSample': _offScreenCanvas2.default,\n  'catmullRomSample': _catmullRom2.default,\n  'hermitCurveSample': _hermiteCurve2.default,\n  'bezierCurveSample': _bezierCurve2.default,\n  'videoProgressSample': _videoProgress2.default,\n  'videoPlayerSample': _videoPlayer2.default,\n  'matrixIVSample': _matrixIV2.default,\n  'matrixIVSample2': _matrixIV4.default,\n  'matrixIVSample3': _matrixIV6.default,\n  'pseudo3dCanvasSample': _pseudo3dCanvas2.default,\n  'vectorDomSample': _vectorDom2.default,\n  'vectorDomSample2': _vectorDom4.default,\n  'vectorDomSample3': _vectorDom6.default,\n  'rayCastingSample': _raycasting6.default,\n  'rayCasting2Sample': _raycasting2.default,\n  'rayCasting3Sample': _raycasting4.default,\n  'quaternionSample': _quaternion2.default,\n  'xSample': _x4.default,\n  'x2Sample': _x2.default,\n  'domWatcherSample': _domWatcher2.default,\n  'domCanvasSample': _domCanvas2.default,\n  'perlinNoiseSample': _perlinNoise2.default,\n  'scrollDemoSample': _scrollDemo2.default,\n  'scrollDemoSample2': _scrollDemo4.default,\n  'scrollDemoSample3': _scrollDemo6.default,\n  'scrollDemoSample4': _scrollDemo8.default,\n  'scrollDemoSample5': _scrollDemo10.default,\n  'threeSceneRenderer': _threeSceneRenderer2.default,\n  'threeSceneRenderer2': _threeSceneRenderer4.default,\n  'threeLightTest': _threeLightTest2.default,\n  'threeLightTest2': _threeLightTest4.default,\n  'threeObjectViewer': _threeObjectViewer2.default,\n  'threeObjectViewer2': _threeObjectViewer8.default,\n  'threeObjectViewer3': _threeObjectViewer10.default,\n  'threeObjectViewer4': _threeObjectViewer12.default,\n  'threeObjectViewer5': _threeObjectViewer14.default,\n  'threeObjectViewer6': _threeObjectViewer16.default,\n  'threeObjectViewer7': _threeObjectViewer18.default,\n  'threeObjectViewer8': _threeObjectViewer20.default,\n  'threeObjectViewer9': _threeObjectViewer22.default,\n  'threeObjectViewer10': _threeObjectViewer4.default,\n  'threeObjectViewer11': _threeObjectViewer6.default,\n  'textSplitSample': _textSplit2.default,\n  'webGlSample': _webgl2.default,\n  'glslPlayground': _glslPlayground2.default,\n  'glslPlayground2': _glslPlayground4.default,\n  'glslPlayground3': _glslPlayground6.default,\n  'glslPlayground4': _glslPlayground8.default,\n  'glslPlayground5': _glslPlayground10.default,\n  'glslPlayground6': _glslPlayground12.default,\n  'glslPlayground7': _glslPlayground14.default,\n  'glslPlayground8': _glslPlayground16.default,\n  'glslPlayground9': _glslPlayground18.default,\n  'glslPlayground10': _glslPlayground20.default,\n  'glslPlayground11': _glslPlayground22.default,\n  'glslPlayground12': _glslPlayground24.default,\n  'glslPlayground13': _glslPlayground26.default,\n  'glslPlayground14': _glslPlayground28.default,\n  'glslPlayground15': _glslPlayground30.default,\n  'glslPlayground16': _glslPlayground32.default,\n  'glslPlayground17': _glslPlayground34.default,\n  'glslPlayground18': _glslPlayground36.default,\n  'glslPlayground19': _glslPlayground38.default,\n  'glslPlayground20': _glslPlayground40.default,\n  'glslPlayground21': _glslPlayground42.default,\n  'glslPlayground22': _glslPlayground44.default,\n  'glslPlayground23': _glslPlayground46.default,\n  'glslPlayground24': _glslPlayground48.default,\n  'glslPlayground25': _glslPlayground50.default,\n  'glslPlayground26': _glslPlayground52.default,\n  'glslPlayground27': _glslPlayground54.default,\n  'glslPlayground28': _glslPlayground56.default,\n  'glslPlayground29': _glslPlayground58.default,\n  'glslPlayground30': _glslPlayground60.default,\n  'inviewSample': _inview2.default\n};\n\nclass Main {\n  constructor() {\n    this.createClassInstanceFromAttribute_();\n  }\n\n  createClassInstanceFromAttribute_() {\n    // Do a look up of the 'int-sample' data attribute and then\n    // attempt to run an instance of a class with that data attribute name.\n    let element = document.querySelector('[init-sample]');\n\n    if (!element) {\n      return;\n    }\n\n    let className = element.getAttribute('init-sample');\n\n    if (samples[className]) {\n      console.log('Instantiating', className);\n      new samples[className]();\n    }\n  }\n\n}\n\nwindow.addEventListener('load', () => {\n  new Main();\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9zY3JpcHRzL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvc2NyaXB0cy9pbmRleC5qcz9jYjI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiLi4vc3R5bGVzL2luZGV4LnNhc3NcIik7XG5cbnJlcXVpcmUoXCJpbnRlcnNlY3Rpb24tb2JzZXJ2ZXJcIik7XG5cbnZhciBfYmV6aWVyQ3VydmUgPSByZXF1aXJlKFwiLi4vYmV6aWVyLWN1cnZlXCIpO1xuXG52YXIgX2JlemllckN1cnZlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JlemllckN1cnZlKTtcblxudmFyIF9jYW52YXNJbWFnZVNlcXVlbmNlID0gcmVxdWlyZShcIi4uL2NhbnZhcy1pbWFnZS1zZXF1ZW5jZVwiKTtcblxudmFyIF9jYW52YXNJbWFnZVNlcXVlbmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NhbnZhc0ltYWdlU2VxdWVuY2UpO1xuXG52YXIgX2NhbnZhc0ltYWdlU2VxdWVuY2UzID0gcmVxdWlyZShcIi4uL2NhbnZhcy1pbWFnZS1zZXF1ZW5jZTEwXCIpO1xuXG52YXIgX2NhbnZhc0ltYWdlU2VxdWVuY2U0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2FudmFzSW1hZ2VTZXF1ZW5jZTMpO1xuXG52YXIgX2NhbnZhc0ltYWdlU2VxdWVuY2U1ID0gcmVxdWlyZShcIi4uL2NhbnZhcy1pbWFnZS1zZXF1ZW5jZTJcIik7XG5cbnZhciBfY2FudmFzSW1hZ2VTZXF1ZW5jZTYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jYW52YXNJbWFnZVNlcXVlbmNlNSk7XG5cbnZhciBfY2FudmFzSW1hZ2VTZXF1ZW5jZTcgPSByZXF1aXJlKFwiLi4vY2FudmFzLWltYWdlLXNlcXVlbmNlM1wiKTtcblxudmFyIF9jYW52YXNJbWFnZVNlcXVlbmNlOCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NhbnZhc0ltYWdlU2VxdWVuY2U3KTtcblxudmFyIF9jYW52YXNJbWFnZVNlcXVlbmNlOSA9IHJlcXVpcmUoXCIuLi9jYW52YXMtaW1hZ2Utc2VxdWVuY2U0XCIpO1xuXG52YXIgX2NhbnZhc0ltYWdlU2VxdWVuY2UxMCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NhbnZhc0ltYWdlU2VxdWVuY2U5KTtcblxudmFyIF9jYW52YXNJbWFnZVNlcXVlbmNlMTEgPSByZXF1aXJlKFwiLi4vY2FudmFzLWltYWdlLXNlcXVlbmNlNVwiKTtcblxudmFyIF9jYW52YXNJbWFnZVNlcXVlbmNlMTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jYW52YXNJbWFnZVNlcXVlbmNlMTEpO1xuXG52YXIgX2NhbnZhc0ltYWdlU2VxdWVuY2UxMyA9IHJlcXVpcmUoXCIuLi9jYW52YXMtaW1hZ2Utc2VxdWVuY2U3XCIpO1xuXG52YXIgX2NhbnZhc0ltYWdlU2VxdWVuY2UxNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NhbnZhc0ltYWdlU2VxdWVuY2UxMyk7XG5cbnZhciBfY2FudmFzSW1hZ2VTZXF1ZW5jZTE1ID0gcmVxdWlyZShcIi4uL2NhbnZhcy1pbWFnZS1zZXF1ZW5jZThcIik7XG5cbnZhciBfY2FudmFzSW1hZ2VTZXF1ZW5jZTE2ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2FudmFzSW1hZ2VTZXF1ZW5jZTE1KTtcblxudmFyIF9jYW52YXNJbWFnZVNlcXVlbmNlMTcgPSByZXF1aXJlKFwiLi4vY2FudmFzLWltYWdlLXNlcXVlbmNlOVwiKTtcblxudmFyIF9jYW52YXNJbWFnZVNlcXVlbmNlMTggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jYW52YXNJbWFnZVNlcXVlbmNlMTcpO1xuXG52YXIgX2Nhcm91c2VsID0gcmVxdWlyZShcIi4uL2Nhcm91c2VsXCIpO1xuXG52YXIgX2Nhcm91c2VsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nhcm91c2VsKTtcblxudmFyIF9jYXRtdWxsUm9tID0gcmVxdWlyZShcIi4uL2NhdG11bGwtcm9tXCIpO1xuXG52YXIgX2NhdG11bGxSb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2F0bXVsbFJvbSk7XG5cbnZhciBfY3NzVmFySW50ZXJwb2xhdGUgPSByZXF1aXJlKFwiLi4vY3NzLXZhci1pbnRlcnBvbGF0ZVwiKTtcblxudmFyIF9jc3NWYXJJbnRlcnBvbGF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jc3NWYXJJbnRlcnBvbGF0ZSk7XG5cbnZhciBfY3NzVmFySW50ZXJwb2xhdGUzID0gcmVxdWlyZShcIi4uL2Nzcy12YXItaW50ZXJwb2xhdGUyXCIpO1xuXG52YXIgX2Nzc1ZhckludGVycG9sYXRlNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nzc1ZhckludGVycG9sYXRlMyk7XG5cbnZhciBfY3NzVmFySW50ZXJwb2xhdGU1ID0gcmVxdWlyZShcIi4uL2Nzcy12YXItaW50ZXJwb2xhdGUzXCIpO1xuXG52YXIgX2Nzc1ZhckludGVycG9sYXRlNiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nzc1ZhckludGVycG9sYXRlNSk7XG5cbnZhciBfZG9tQ2FudmFzID0gcmVxdWlyZShcIi4uL2RvbS1jYW52YXNcIik7XG5cbnZhciBfZG9tQ2FudmFzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvbUNhbnZhcyk7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9kb20td2F0Y2hlclwiKTtcblxudmFyIF9kb21XYXRjaGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvbVdhdGNoZXIpO1xuXG52YXIgX2Vhc2VyRGlzYWJsZVJhZiA9IHJlcXVpcmUoXCIuLi9lYXNlci1kaXNhYmxlLXJhZlwiKTtcblxudmFyIF9lYXNlckRpc2FibGVSYWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFzZXJEaXNhYmxlUmFmKTtcblxudmFyIF9lYXNlciA9IHJlcXVpcmUoXCIuLi9lYXNlclwiKTtcblxudmFyIF9lYXNlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYXNlcik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kXCIpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kKTtcblxudmFyIF9nbHNsUGxheWdyb3VuZDMgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMlwiKTtcblxudmFyIF9nbHNsUGxheWdyb3VuZDQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbHNsUGxheWdyb3VuZDMpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kNSA9IHJlcXVpcmUoXCIuLi9nbHNsLXBsYXlncm91bmQzXCIpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kNiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kNSk7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQ3ID0gcmVxdWlyZShcIi4uL2dsc2wtcGxheWdyb3VuZDRcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQ4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xzbFBsYXlncm91bmQ3KTtcblxudmFyIF9nbHNsUGxheWdyb3VuZDkgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kNVwiKTtcblxudmFyIF9nbHNsUGxheWdyb3VuZDEwID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xzbFBsYXlncm91bmQ5KTtcblxudmFyIF9nbHNsUGxheWdyb3VuZDExID0gcmVxdWlyZShcIi4uL2dsc2wtcGxheWdyb3VuZDZcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQxMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kMTEpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kMTMgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kN1wiKTtcblxudmFyIF9nbHNsUGxheWdyb3VuZDE0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2xzbFBsYXlncm91bmQxMyk7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQxNSA9IHJlcXVpcmUoXCIuLi9nbHNsLXBsYXlncm91bmQ4XCIpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kMTYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbHNsUGxheWdyb3VuZDE1KTtcblxudmFyIF9nbHNsUGxheWdyb3VuZDE3ID0gcmVxdWlyZShcIi4uL2dsc2wtcGxheWdyb3VuZDlcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQxOCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kMTcpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kMTkgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMTBcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQyMCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kMTkpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kMjEgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMTFcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kMjEpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kMjMgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMTJcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQyNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kMjMpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kMjUgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMTNcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQyNiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kMjUpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kMjcgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMTRcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQyOCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kMjcpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kMjkgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMTVcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQzMCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kMjkpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kMzEgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMTZcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kMzEpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kMzMgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMTdcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQzNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kMzMpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kMzUgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMThcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQzNiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kMzUpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kMzcgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMTlcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQzOCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kMzcpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kMzkgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMjBcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQ0MCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kMzkpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kNDEgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMjFcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQ0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kNDEpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kNDMgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMjJcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQ0NCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kNDMpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kNDUgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMjNcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQ0NiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kNDUpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kNDcgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMjRcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQ0OCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kNDcpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kNDkgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMjVcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQ1MCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kNDkpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kNTEgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMjZcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQ1MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kNTEpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kNTMgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMjdcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQ1NCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kNTMpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kNTUgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMjhcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQ1NiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kNTUpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kNTcgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMjlcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQ1OCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kNTcpO1xuXG52YXIgX2dsc2xQbGF5Z3JvdW5kNTkgPSByZXF1aXJlKFwiLi4vZ2xzbC1wbGF5Z3JvdW5kMzBcIik7XG5cbnZhciBfZ2xzbFBsYXlncm91bmQ2MCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsc2xQbGF5Z3JvdW5kNTkpO1xuXG52YXIgX2hlcm1pdGVDdXJ2ZSA9IHJlcXVpcmUoXCIuLi9oZXJtaXRlLWN1cnZlXCIpO1xuXG52YXIgX2hlcm1pdGVDdXJ2ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZXJtaXRlQ3VydmUpO1xuXG52YXIgX2ludGVycG9sYXRlID0gcmVxdWlyZShcIi4uL2ludGVycG9sYXRlXCIpO1xuXG52YXIgX2ludGVycG9sYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludGVycG9sYXRlKTtcblxudmFyIF9tYXRoZkVhc2UgPSByZXF1aXJlKFwiLi4vbWF0aGYtZWFzZVwiKTtcblxudmFyIF9tYXRoZkVhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0aGZFYXNlKTtcblxudmFyIF9tYXRyaXhJViA9IHJlcXVpcmUoXCIuLi9tYXRyaXhJVlwiKTtcblxudmFyIF9tYXRyaXhJVjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRyaXhJVik7XG5cbnZhciBfbWF0cml4SVYzID0gcmVxdWlyZShcIi4uL21hdHJpeElWMlwiKTtcblxudmFyIF9tYXRyaXhJVjQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRyaXhJVjMpO1xuXG52YXIgX21hdHJpeElWNSA9IHJlcXVpcmUoXCIuLi9tYXRyaXhJVjNcIik7XG5cbnZhciBfbWF0cml4SVY2ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0cml4SVY1KTtcblxudmFyIF9tdWx0aUludGVycG9sYXRlID0gcmVxdWlyZShcIi4uL211bHRpLWludGVycG9sYXRlXCIpO1xuXG52YXIgX211bHRpSW50ZXJwb2xhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbXVsdGlJbnRlcnBvbGF0ZSk7XG5cbnZhciBfb2ZmU2NyZWVuQ2FudmFzID0gcmVxdWlyZShcIi4uL29mZi1zY3JlZW4tY2FudmFzXCIpO1xuXG52YXIgX29mZlNjcmVlbkNhbnZhczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vZmZTY3JlZW5DYW52YXMpO1xuXG52YXIgX3Blcmxpbk5vaXNlID0gcmVxdWlyZShcIi4uL3Blcmxpbi1ub2lzZVwiKTtcblxudmFyIF9wZXJsaW5Ob2lzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wZXJsaW5Ob2lzZSk7XG5cbnZhciBfcGxheWdyb3VuZCA9IHJlcXVpcmUoXCIuLi9wbGF5Z3JvdW5kXCIpO1xuXG52YXIgX3BsYXlncm91bmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxheWdyb3VuZCk7XG5cbnZhciBfcHNldWRvM2RDYW52YXMgPSByZXF1aXJlKFwiLi4vcHNldWRvLTNkLWNhbnZhc1wiKTtcblxudmFyIF9wc2V1ZG8zZENhbnZhczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wc2V1ZG8zZENhbnZhcyk7XG5cbnZhciBfcXVhdGVybmlvbiA9IHJlcXVpcmUoXCIuLi9xdWF0ZXJuaW9uXCIpO1xuXG52YXIgX3F1YXRlcm5pb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcXVhdGVybmlvbik7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vcmFmLXByb2dyZXNzXCIpO1xuXG52YXIgX3JhZlByb2dyZXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JhZlByb2dyZXNzKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vcmFmXCIpO1xuXG52YXIgX3JhZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yYWYpO1xuXG52YXIgX3JhZjMgPSByZXF1aXJlKFwiLi4vcmFmMlwiKTtcblxudmFyIF9yYWY0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmFmMyk7XG5cbnZhciBfcmFmVGltZXIgPSByZXF1aXJlKFwiLi4vcmFmLXRpbWVyXCIpO1xuXG52YXIgX3JhZlRpbWVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JhZlRpbWVyKTtcblxudmFyIF9yYXljYXN0aW5nID0gcmVxdWlyZShcIi4uL3JheWNhc3RpbmcyXCIpO1xuXG52YXIgX3JheWNhc3RpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmF5Y2FzdGluZyk7XG5cbnZhciBfcmF5Y2FzdGluZzMgPSByZXF1aXJlKFwiLi4vcmF5Y2FzdGluZzNcIik7XG5cbnZhciBfcmF5Y2FzdGluZzQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yYXljYXN0aW5nMyk7XG5cbnZhciBfcmF5Y2FzdGluZzUgPSByZXF1aXJlKFwiLi4vcmF5Y2FzdGluZ1wiKTtcblxudmFyIF9yYXljYXN0aW5nNiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JheWNhc3Rpbmc1KTtcblxudmFyIF9zY3JvbGxEZW1vID0gcmVxdWlyZShcIi4uL3Njcm9sbC1kZW1vXCIpO1xuXG52YXIgX3Njcm9sbERlbW8yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2Nyb2xsRGVtbyk7XG5cbnZhciBfc2Nyb2xsRGVtbzMgPSByZXF1aXJlKFwiLi4vc2Nyb2xsLWRlbW8yXCIpO1xuXG52YXIgX3Njcm9sbERlbW80ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2Nyb2xsRGVtbzMpO1xuXG52YXIgX3Njcm9sbERlbW81ID0gcmVxdWlyZShcIi4uL3Njcm9sbC1kZW1vM1wiKTtcblxudmFyIF9zY3JvbGxEZW1vNiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Njcm9sbERlbW81KTtcblxudmFyIF9zY3JvbGxEZW1vNyA9IHJlcXVpcmUoXCIuLi9zY3JvbGwtZGVtbzRcIik7XG5cbnZhciBfc2Nyb2xsRGVtbzggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zY3JvbGxEZW1vNyk7XG5cbnZhciBfc2Nyb2xsRGVtbzkgPSByZXF1aXJlKFwiLi4vc2Nyb2xsLWRlbW81XCIpO1xuXG52YXIgX3Njcm9sbERlbW8xMCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Njcm9sbERlbW85KTtcblxudmFyIF90ZXh0U3BsaXQgPSByZXF1aXJlKFwiLi4vdGV4dC1zcGxpdFwiKTtcblxudmFyIF90ZXh0U3BsaXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dFNwbGl0KTtcblxudmFyIF90aHJlZVNjZW5lUmVuZGVyZXIgPSByZXF1aXJlKFwiLi4vdGhyZWUtc2NlbmUtcmVuZGVyZXJcIik7XG5cbnZhciBfdGhyZWVTY2VuZVJlbmRlcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RocmVlU2NlbmVSZW5kZXJlcik7XG5cbnZhciBfdGhyZWVTY2VuZVJlbmRlcmVyMyA9IHJlcXVpcmUoXCIuLi90aHJlZS1zY2VuZS1yZW5kZXJlcjJcIik7XG5cbnZhciBfdGhyZWVTY2VuZVJlbmRlcmVyNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RocmVlU2NlbmVSZW5kZXJlcjMpO1xuXG52YXIgX3RocmVlTGlnaHRUZXN0ID0gcmVxdWlyZShcIi4uL3RocmVlLWxpZ2h0LXRlc3RcIik7XG5cbnZhciBfdGhyZWVMaWdodFRlc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGhyZWVMaWdodFRlc3QpO1xuXG52YXIgX3RocmVlTGlnaHRUZXN0MyA9IHJlcXVpcmUoXCIuLi90aHJlZS1saWdodC10ZXN0MlwiKTtcblxudmFyIF90aHJlZUxpZ2h0VGVzdDQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aHJlZUxpZ2h0VGVzdDMpO1xuXG52YXIgX3RocmVlT2JqZWN0Vmlld2VyID0gcmVxdWlyZShcIi4uL3RocmVlLW9iamVjdC12aWV3ZXJcIik7XG5cbnZhciBfdGhyZWVPYmplY3RWaWV3ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGhyZWVPYmplY3RWaWV3ZXIpO1xuXG52YXIgX3RocmVlT2JqZWN0Vmlld2VyMyA9IHJlcXVpcmUoXCIuLi90aHJlZS1vYmplY3Qtdmlld2VyMTBcIik7XG5cbnZhciBfdGhyZWVPYmplY3RWaWV3ZXI0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGhyZWVPYmplY3RWaWV3ZXIzKTtcblxudmFyIF90aHJlZU9iamVjdFZpZXdlcjUgPSByZXF1aXJlKFwiLi4vdGhyZWUtb2JqZWN0LXZpZXdlcjExXCIpO1xuXG52YXIgX3RocmVlT2JqZWN0Vmlld2VyNiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RocmVlT2JqZWN0Vmlld2VyNSk7XG5cbnZhciBfdGhyZWVPYmplY3RWaWV3ZXI3ID0gcmVxdWlyZShcIi4uL3RocmVlLW9iamVjdC12aWV3ZXIyXCIpO1xuXG52YXIgX3RocmVlT2JqZWN0Vmlld2VyOCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RocmVlT2JqZWN0Vmlld2VyNyk7XG5cbnZhciBfdGhyZWVPYmplY3RWaWV3ZXI5ID0gcmVxdWlyZShcIi4uL3RocmVlLW9iamVjdC12aWV3ZXIzXCIpO1xuXG52YXIgX3RocmVlT2JqZWN0Vmlld2VyMTAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aHJlZU9iamVjdFZpZXdlcjkpO1xuXG52YXIgX3RocmVlT2JqZWN0Vmlld2VyMTEgPSByZXF1aXJlKFwiLi4vdGhyZWUtb2JqZWN0LXZpZXdlcjRcIik7XG5cbnZhciBfdGhyZWVPYmplY3RWaWV3ZXIxMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RocmVlT2JqZWN0Vmlld2VyMTEpO1xuXG52YXIgX3RocmVlT2JqZWN0Vmlld2VyMTMgPSByZXF1aXJlKFwiLi4vdGhyZWUtb2JqZWN0LXZpZXdlcjVcIik7XG5cbnZhciBfdGhyZWVPYmplY3RWaWV3ZXIxNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RocmVlT2JqZWN0Vmlld2VyMTMpO1xuXG52YXIgX3RocmVlT2JqZWN0Vmlld2VyMTUgPSByZXF1aXJlKFwiLi4vdGhyZWUtb2JqZWN0LXZpZXdlcjZcIik7XG5cbnZhciBfdGhyZWVPYmplY3RWaWV3ZXIxNiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RocmVlT2JqZWN0Vmlld2VyMTUpO1xuXG52YXIgX3RocmVlT2JqZWN0Vmlld2VyMTcgPSByZXF1aXJlKFwiLi4vdGhyZWUtb2JqZWN0LXZpZXdlcjdcIik7XG5cbnZhciBfdGhyZWVPYmplY3RWaWV3ZXIxOCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RocmVlT2JqZWN0Vmlld2VyMTcpO1xuXG52YXIgX3RocmVlT2JqZWN0Vmlld2VyMTkgPSByZXF1aXJlKFwiLi4vdGhyZWUtb2JqZWN0LXZpZXdlcjhcIik7XG5cbnZhciBfdGhyZWVPYmplY3RWaWV3ZXIyMCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RocmVlT2JqZWN0Vmlld2VyMTkpO1xuXG52YXIgX3RocmVlT2JqZWN0Vmlld2VyMjEgPSByZXF1aXJlKFwiLi4vdGhyZWUtb2JqZWN0LXZpZXdlcjlcIik7XG5cbnZhciBfdGhyZWVPYmplY3RWaWV3ZXIyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RocmVlT2JqZWN0Vmlld2VyMjEpO1xuXG52YXIgX3ZlY3RvckRvbSA9IHJlcXVpcmUoXCIuLi92ZWN0b3ItZG9tXCIpO1xuXG52YXIgX3ZlY3RvckRvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92ZWN0b3JEb20pO1xuXG52YXIgX3ZlY3RvckRvbTMgPSByZXF1aXJlKFwiLi4vdmVjdG9yLWRvbTJcIik7XG5cbnZhciBfdmVjdG9yRG9tNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZlY3RvckRvbTMpO1xuXG52YXIgX3ZlY3RvckRvbTUgPSByZXF1aXJlKFwiLi4vdmVjdG9yLWRvbTNcIik7XG5cbnZhciBfdmVjdG9yRG9tNiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZlY3RvckRvbTUpO1xuXG52YXIgX3ZpZGVvUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vdmlkZW8tcHJvZ3Jlc3NcIik7XG5cbnZhciBfdmlkZW9Qcm9ncmVzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aWRlb1Byb2dyZXNzKTtcblxudmFyIF92aWRlb1BsYXllciA9IHJlcXVpcmUoXCIuLi92aWRlby1wbGF5ZXJcIik7XG5cbnZhciBfdmlkZW9QbGF5ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlkZW9QbGF5ZXIpO1xuXG52YXIgX3dlYmdsSW1hZ2VTZXF1ZW5jZSA9IHJlcXVpcmUoXCIuLi93ZWJnbC1pbWFnZS1zZXF1ZW5jZVwiKTtcblxudmFyIF93ZWJnbEltYWdlU2VxdWVuY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2ViZ2xJbWFnZVNlcXVlbmNlKTtcblxudmFyIF93ZWJnbEltYWdlU2VxdWVuY2UzID0gcmVxdWlyZShcIi4uL3dlYmdsLWltYWdlLXNlcXVlbmNlMlwiKTtcblxudmFyIF93ZWJnbEltYWdlU2VxdWVuY2U0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2ViZ2xJbWFnZVNlcXVlbmNlMyk7XG5cbnZhciBfd2ViZ2xJbWFnZVNlcXVlbmNlNSA9IHJlcXVpcmUoXCIuLi93ZWJnbC1pbWFnZS1zZXF1ZW5jZTNcIik7XG5cbnZhciBfd2ViZ2xJbWFnZVNlcXVlbmNlNiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dlYmdsSW1hZ2VTZXF1ZW5jZTUpO1xuXG52YXIgX3dlYmdsSW1hZ2VTZXF1ZW5jZTcgPSByZXF1aXJlKFwiLi4vd2ViZ2wtaW1hZ2Utc2VxdWVuY2U0XCIpO1xuXG52YXIgX3dlYmdsSW1hZ2VTZXF1ZW5jZTggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93ZWJnbEltYWdlU2VxdWVuY2U3KTtcblxudmFyIF93ZWJnbEltYWdlU2VxdWVuY2U5ID0gcmVxdWlyZShcIi4uL3dlYmdsLWltYWdlLXNlcXVlbmNlNVwiKTtcblxudmFyIF93ZWJnbEltYWdlU2VxdWVuY2UxMCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dlYmdsSW1hZ2VTZXF1ZW5jZTkpO1xuXG52YXIgX3dlYmdsSW1hZ2VTZXF1ZW5jZTExID0gcmVxdWlyZShcIi4uL3dlYmdsLWltYWdlLXNlcXVlbmNlN1wiKTtcblxudmFyIF93ZWJnbEltYWdlU2VxdWVuY2UxMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dlYmdsSW1hZ2VTZXF1ZW5jZTExKTtcblxudmFyIF93ZWJnbEltYWdlU2VxdWVuY2UxMyA9IHJlcXVpcmUoXCIuLi93ZWJnbC1pbWFnZS1zZXF1ZW5jZTlcIik7XG5cbnZhciBfd2ViZ2xJbWFnZVNlcXVlbmNlMTQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93ZWJnbEltYWdlU2VxdWVuY2UxMyk7XG5cbnZhciBfeCA9IHJlcXVpcmUoXCIuLi94MlwiKTtcblxudmFyIF94MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3gpO1xuXG52YXIgX3gzID0gcmVxdWlyZShcIi4uL3hcIik7XG5cbnZhciBfeDQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF94Myk7XG5cbnZhciBfaW52aWV3ID0gcmVxdWlyZShcIi4uL2ludmlld1wiKTtcblxudmFyIF9pbnZpZXcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52aWV3KTtcblxudmFyIF93ZWJnbCA9IHJlcXVpcmUoXCIuLi93ZWJnbFwiKTtcblxudmFyIF93ZWJnbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93ZWJnbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIEV4YW1wbGVzLlxuLy8gaW1wb3J0IFZpZGVvUHJvZ3Jlc3NTYW1wbGUgZnJvbSAnLi4vcGxheWdyb3VuZC92aWRlby1wcm9ncmVzcyc7XG5jb25zdCBzYW1wbGVzID0ge1xuICAnY2Fyb3VzZWxTYW1wbGUnOiBfY2Fyb3VzZWwyLmRlZmF1bHQsXG4gICdlYXNlckRpc2FibGVSYWZTYW1wbGUnOiBfZWFzZXJEaXNhYmxlUmFmMi5kZWZhdWx0LFxuICAnZWFzZXJTYW1wbGUnOiBfZWFzZXIyLmRlZmF1bHQsXG4gICdpbnRlcnBvbGF0ZVNhbXBsZSc6IF9pbnRlcnBvbGF0ZTIuZGVmYXVsdCxcbiAgJ21hdGhmRWFzZVNhbXBsZSc6IF9tYXRoZkVhc2UyLmRlZmF1bHQsXG4gICdtdWx0aUludGVycG9sYXRlU2FtcGxlJzogX211bHRpSW50ZXJwb2xhdGUyLmRlZmF1bHQsXG4gICdjc3NWYXJJbnRlcnBvbGF0ZVNhbXBsZSc6IF9jc3NWYXJJbnRlcnBvbGF0ZTIuZGVmYXVsdCxcbiAgJ2Nzc1ZhckludGVycG9sYXRlU2FtcGxlMic6IF9jc3NWYXJJbnRlcnBvbGF0ZTQuZGVmYXVsdCxcbiAgJ2Nzc1ZhckludGVycG9sYXRlU2FtcGxlMyc6IF9jc3NWYXJJbnRlcnBvbGF0ZTYuZGVmYXVsdCxcbiAgJ2NhbnZhc0ltYWdlU2VxdWVuY2VTYW1wbGUnOiBfY2FudmFzSW1hZ2VTZXF1ZW5jZTIuZGVmYXVsdCxcbiAgJ2NhbnZhc0ltYWdlU2VxdWVuY2VTYW1wbGUyJzogX2NhbnZhc0ltYWdlU2VxdWVuY2U2LmRlZmF1bHQsXG4gICdjYW52YXNJbWFnZVNlcXVlbmNlU2FtcGxlMyc6IF9jYW52YXNJbWFnZVNlcXVlbmNlOC5kZWZhdWx0LFxuICAnY2FudmFzSW1hZ2VTZXF1ZW5jZVNhbXBsZTQnOiBfY2FudmFzSW1hZ2VTZXF1ZW5jZTEwLmRlZmF1bHQsXG4gICdjYW52YXNJbWFnZVNlcXVlbmNlU2FtcGxlNSc6IF9jYW52YXNJbWFnZVNlcXVlbmNlMTIuZGVmYXVsdCxcbiAgJ2NhbnZhc0ltYWdlU2VxdWVuY2VTYW1wbGU3JzogX2NhbnZhc0ltYWdlU2VxdWVuY2UxNC5kZWZhdWx0LFxuICAnY2FudmFzSW1hZ2VTZXF1ZW5jZVNhbXBsZTgnOiBfY2FudmFzSW1hZ2VTZXF1ZW5jZTE2LmRlZmF1bHQsXG4gICdjYW52YXNJbWFnZVNlcXVlbmNlU2FtcGxlOSc6IF9jYW52YXNJbWFnZVNlcXVlbmNlMTguZGVmYXVsdCxcbiAgJ2NhbnZhc0ltYWdlU2VxdWVuY2VTYW1wbGUxMCc6IF9jYW52YXNJbWFnZVNlcXVlbmNlNC5kZWZhdWx0LFxuICAnd2ViZ2xJbWFnZVNlcXVlbmNlU2FtcGxlJzogX3dlYmdsSW1hZ2VTZXF1ZW5jZTIuZGVmYXVsdCxcbiAgJ3dlYmdsSW1hZ2VTZXF1ZW5jZVNhbXBsZTInOiBfd2ViZ2xJbWFnZVNlcXVlbmNlNC5kZWZhdWx0LFxuICAnd2ViZ2xJbWFnZVNlcXVlbmNlU2FtcGxlMyc6IF93ZWJnbEltYWdlU2VxdWVuY2U2LmRlZmF1bHQsXG4gICd3ZWJnbEltYWdlU2VxdWVuY2VTYW1wbGU0JzogX3dlYmdsSW1hZ2VTZXF1ZW5jZTguZGVmYXVsdCxcbiAgJ3dlYmdsSW1hZ2VTZXF1ZW5jZVNhbXBsZTUnOiBfd2ViZ2xJbWFnZVNlcXVlbmNlMTAuZGVmYXVsdCxcbiAgJ3dlYmdsSW1hZ2VTZXF1ZW5jZVNhbXBsZTcnOiBfd2ViZ2xJbWFnZVNlcXVlbmNlMTIuZGVmYXVsdCxcbiAgJ3dlYmdsSW1hZ2VTZXF1ZW5jZVNhbXBsZTknOiBfd2ViZ2xJbWFnZVNlcXVlbmNlMTQuZGVmYXVsdCxcbiAgJ3JhZlNhbXBsZSc6IF9yYWYyLmRlZmF1bHQsXG4gICdyYWZTYW1wbGUyJzogX3JhZjQuZGVmYXVsdCxcbiAgJ3JhZlRpbWVyU2FtcGxlJzogX3JhZlRpbWVyMi5kZWZhdWx0LFxuICAncmFmUHJvZ3Jlc3NTYW1wbGUnOiBfcmFmUHJvZ3Jlc3MyLmRlZmF1bHQsXG4gICdwbGF5Z3JvdW5kU2FtcGxlJzogX3BsYXlncm91bmQyLmRlZmF1bHQsXG4gICdvZmZTY3JlZW5DYW52YXNTYW1wbGUnOiBfb2ZmU2NyZWVuQ2FudmFzMi5kZWZhdWx0LFxuICAnY2F0bXVsbFJvbVNhbXBsZSc6IF9jYXRtdWxsUm9tMi5kZWZhdWx0LFxuICAnaGVybWl0Q3VydmVTYW1wbGUnOiBfaGVybWl0ZUN1cnZlMi5kZWZhdWx0LFxuICAnYmV6aWVyQ3VydmVTYW1wbGUnOiBfYmV6aWVyQ3VydmUyLmRlZmF1bHQsXG4gICd2aWRlb1Byb2dyZXNzU2FtcGxlJzogX3ZpZGVvUHJvZ3Jlc3MyLmRlZmF1bHQsXG4gICd2aWRlb1BsYXllclNhbXBsZSc6IF92aWRlb1BsYXllcjIuZGVmYXVsdCxcbiAgJ21hdHJpeElWU2FtcGxlJzogX21hdHJpeElWMi5kZWZhdWx0LFxuICAnbWF0cml4SVZTYW1wbGUyJzogX21hdHJpeElWNC5kZWZhdWx0LFxuICAnbWF0cml4SVZTYW1wbGUzJzogX21hdHJpeElWNi5kZWZhdWx0LFxuICAncHNldWRvM2RDYW52YXNTYW1wbGUnOiBfcHNldWRvM2RDYW52YXMyLmRlZmF1bHQsXG4gICd2ZWN0b3JEb21TYW1wbGUnOiBfdmVjdG9yRG9tMi5kZWZhdWx0LFxuICAndmVjdG9yRG9tU2FtcGxlMic6IF92ZWN0b3JEb200LmRlZmF1bHQsXG4gICd2ZWN0b3JEb21TYW1wbGUzJzogX3ZlY3RvckRvbTYuZGVmYXVsdCxcbiAgJ3JheUNhc3RpbmdTYW1wbGUnOiBfcmF5Y2FzdGluZzYuZGVmYXVsdCxcbiAgJ3JheUNhc3RpbmcyU2FtcGxlJzogX3JheWNhc3RpbmcyLmRlZmF1bHQsXG4gICdyYXlDYXN0aW5nM1NhbXBsZSc6IF9yYXljYXN0aW5nNC5kZWZhdWx0LFxuICAncXVhdGVybmlvblNhbXBsZSc6IF9xdWF0ZXJuaW9uMi5kZWZhdWx0LFxuICAneFNhbXBsZSc6IF94NC5kZWZhdWx0LFxuICAneDJTYW1wbGUnOiBfeDIuZGVmYXVsdCxcbiAgJ2RvbVdhdGNoZXJTYW1wbGUnOiBfZG9tV2F0Y2hlcjIuZGVmYXVsdCxcbiAgJ2RvbUNhbnZhc1NhbXBsZSc6IF9kb21DYW52YXMyLmRlZmF1bHQsXG4gICdwZXJsaW5Ob2lzZVNhbXBsZSc6IF9wZXJsaW5Ob2lzZTIuZGVmYXVsdCxcbiAgJ3Njcm9sbERlbW9TYW1wbGUnOiBfc2Nyb2xsRGVtbzIuZGVmYXVsdCxcbiAgJ3Njcm9sbERlbW9TYW1wbGUyJzogX3Njcm9sbERlbW80LmRlZmF1bHQsXG4gICdzY3JvbGxEZW1vU2FtcGxlMyc6IF9zY3JvbGxEZW1vNi5kZWZhdWx0LFxuICAnc2Nyb2xsRGVtb1NhbXBsZTQnOiBfc2Nyb2xsRGVtbzguZGVmYXVsdCxcbiAgJ3Njcm9sbERlbW9TYW1wbGU1JzogX3Njcm9sbERlbW8xMC5kZWZhdWx0LFxuICAndGhyZWVTY2VuZVJlbmRlcmVyJzogX3RocmVlU2NlbmVSZW5kZXJlcjIuZGVmYXVsdCxcbiAgJ3RocmVlU2NlbmVSZW5kZXJlcjInOiBfdGhyZWVTY2VuZVJlbmRlcmVyNC5kZWZhdWx0LFxuICAndGhyZWVMaWdodFRlc3QnOiBfdGhyZWVMaWdodFRlc3QyLmRlZmF1bHQsXG4gICd0aHJlZUxpZ2h0VGVzdDInOiBfdGhyZWVMaWdodFRlc3Q0LmRlZmF1bHQsXG4gICd0aHJlZU9iamVjdFZpZXdlcic6IF90aHJlZU9iamVjdFZpZXdlcjIuZGVmYXVsdCxcbiAgJ3RocmVlT2JqZWN0Vmlld2VyMic6IF90aHJlZU9iamVjdFZpZXdlcjguZGVmYXVsdCxcbiAgJ3RocmVlT2JqZWN0Vmlld2VyMyc6IF90aHJlZU9iamVjdFZpZXdlcjEwLmRlZmF1bHQsXG4gICd0aHJlZU9iamVjdFZpZXdlcjQnOiBfdGhyZWVPYmplY3RWaWV3ZXIxMi5kZWZhdWx0LFxuICAndGhyZWVPYmplY3RWaWV3ZXI1JzogX3RocmVlT2JqZWN0Vmlld2VyMTQuZGVmYXVsdCxcbiAgJ3RocmVlT2JqZWN0Vmlld2VyNic6IF90aHJlZU9iamVjdFZpZXdlcjE2LmRlZmF1bHQsXG4gICd0aHJlZU9iamVjdFZpZXdlcjcnOiBfdGhyZWVPYmplY3RWaWV3ZXIxOC5kZWZhdWx0LFxuICAndGhyZWVPYmplY3RWaWV3ZXI4JzogX3RocmVlT2JqZWN0Vmlld2VyMjAuZGVmYXVsdCxcbiAgJ3RocmVlT2JqZWN0Vmlld2VyOSc6IF90aHJlZU9iamVjdFZpZXdlcjIyLmRlZmF1bHQsXG4gICd0aHJlZU9iamVjdFZpZXdlcjEwJzogX3RocmVlT2JqZWN0Vmlld2VyNC5kZWZhdWx0LFxuICAndGhyZWVPYmplY3RWaWV3ZXIxMSc6IF90aHJlZU9iamVjdFZpZXdlcjYuZGVmYXVsdCxcbiAgJ3RleHRTcGxpdFNhbXBsZSc6IF90ZXh0U3BsaXQyLmRlZmF1bHQsXG4gICd3ZWJHbFNhbXBsZSc6IF93ZWJnbDIuZGVmYXVsdCxcbiAgJ2dsc2xQbGF5Z3JvdW5kJzogX2dsc2xQbGF5Z3JvdW5kMi5kZWZhdWx0LFxuICAnZ2xzbFBsYXlncm91bmQyJzogX2dsc2xQbGF5Z3JvdW5kNC5kZWZhdWx0LFxuICAnZ2xzbFBsYXlncm91bmQzJzogX2dsc2xQbGF5Z3JvdW5kNi5kZWZhdWx0LFxuICAnZ2xzbFBsYXlncm91bmQ0JzogX2dsc2xQbGF5Z3JvdW5kOC5kZWZhdWx0LFxuICAnZ2xzbFBsYXlncm91bmQ1JzogX2dsc2xQbGF5Z3JvdW5kMTAuZGVmYXVsdCxcbiAgJ2dsc2xQbGF5Z3JvdW5kNic6IF9nbHNsUGxheWdyb3VuZDEyLmRlZmF1bHQsXG4gICdnbHNsUGxheWdyb3VuZDcnOiBfZ2xzbFBsYXlncm91bmQxNC5kZWZhdWx0LFxuICAnZ2xzbFBsYXlncm91bmQ4JzogX2dsc2xQbGF5Z3JvdW5kMTYuZGVmYXVsdCxcbiAgJ2dsc2xQbGF5Z3JvdW5kOSc6IF9nbHNsUGxheWdyb3VuZDE4LmRlZmF1bHQsXG4gICdnbHNsUGxheWdyb3VuZDEwJzogX2dsc2xQbGF5Z3JvdW5kMjAuZGVmYXVsdCxcbiAgJ2dsc2xQbGF5Z3JvdW5kMTEnOiBfZ2xzbFBsYXlncm91bmQyMi5kZWZhdWx0LFxuICAnZ2xzbFBsYXlncm91bmQxMic6IF9nbHNsUGxheWdyb3VuZDI0LmRlZmF1bHQsXG4gICdnbHNsUGxheWdyb3VuZDEzJzogX2dsc2xQbGF5Z3JvdW5kMjYuZGVmYXVsdCxcbiAgJ2dsc2xQbGF5Z3JvdW5kMTQnOiBfZ2xzbFBsYXlncm91bmQyOC5kZWZhdWx0LFxuICAnZ2xzbFBsYXlncm91bmQxNSc6IF9nbHNsUGxheWdyb3VuZDMwLmRlZmF1bHQsXG4gICdnbHNsUGxheWdyb3VuZDE2JzogX2dsc2xQbGF5Z3JvdW5kMzIuZGVmYXVsdCxcbiAgJ2dsc2xQbGF5Z3JvdW5kMTcnOiBfZ2xzbFBsYXlncm91bmQzNC5kZWZhdWx0LFxuICAnZ2xzbFBsYXlncm91bmQxOCc6IF9nbHNsUGxheWdyb3VuZDM2LmRlZmF1bHQsXG4gICdnbHNsUGxheWdyb3VuZDE5JzogX2dsc2xQbGF5Z3JvdW5kMzguZGVmYXVsdCxcbiAgJ2dsc2xQbGF5Z3JvdW5kMjAnOiBfZ2xzbFBsYXlncm91bmQ0MC5kZWZhdWx0LFxuICAnZ2xzbFBsYXlncm91bmQyMSc6IF9nbHNsUGxheWdyb3VuZDQyLmRlZmF1bHQsXG4gICdnbHNsUGxheWdyb3VuZDIyJzogX2dsc2xQbGF5Z3JvdW5kNDQuZGVmYXVsdCxcbiAgJ2dsc2xQbGF5Z3JvdW5kMjMnOiBfZ2xzbFBsYXlncm91bmQ0Ni5kZWZhdWx0LFxuICAnZ2xzbFBsYXlncm91bmQyNCc6IF9nbHNsUGxheWdyb3VuZDQ4LmRlZmF1bHQsXG4gICdnbHNsUGxheWdyb3VuZDI1JzogX2dsc2xQbGF5Z3JvdW5kNTAuZGVmYXVsdCxcbiAgJ2dsc2xQbGF5Z3JvdW5kMjYnOiBfZ2xzbFBsYXlncm91bmQ1Mi5kZWZhdWx0LFxuICAnZ2xzbFBsYXlncm91bmQyNyc6IF9nbHNsUGxheWdyb3VuZDU0LmRlZmF1bHQsXG4gICdnbHNsUGxheWdyb3VuZDI4JzogX2dsc2xQbGF5Z3JvdW5kNTYuZGVmYXVsdCxcbiAgJ2dsc2xQbGF5Z3JvdW5kMjknOiBfZ2xzbFBsYXlncm91bmQ1OC5kZWZhdWx0LFxuICAnZ2xzbFBsYXlncm91bmQzMCc6IF9nbHNsUGxheWdyb3VuZDYwLmRlZmF1bHQsXG4gICdpbnZpZXdTYW1wbGUnOiBfaW52aWV3Mi5kZWZhdWx0XG59O1xuXG5jbGFzcyBNYWluIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jcmVhdGVDbGFzc0luc3RhbmNlRnJvbUF0dHJpYnV0ZV8oKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzSW5zdGFuY2VGcm9tQXR0cmlidXRlXygpIHtcbiAgICAvLyBEbyBhIGxvb2sgdXAgb2YgdGhlICdpbnQtc2FtcGxlJyBkYXRhIGF0dHJpYnV0ZSBhbmQgdGhlblxuICAgIC8vIGF0dGVtcHQgdG8gcnVuIGFuIGluc3RhbmNlIG9mIGEgY2xhc3Mgd2l0aCB0aGF0IGRhdGEgYXR0cmlidXRlIG5hbWUuXG4gICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbaW5pdC1zYW1wbGVdJyk7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY2xhc3NOYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2luaXQtc2FtcGxlJyk7XG5cbiAgICBpZiAoc2FtcGxlc1tjbGFzc05hbWVdKSB7XG4gICAgICBjb25zb2xlLmxvZygnSW5zdGFudGlhdGluZycsIGNsYXNzTmFtZSk7XG4gICAgICBuZXcgc2FtcGxlc1tjbGFzc05hbWVdKCk7XG4gICAgfVxuICB9XG5cbn1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gIG5ldyBNYWluKCk7XG59KTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/scripts/index.js\n");

/***/ }),

/***/ "./examples/scroll-demo.js":
/*!*********************************!*\
  !*** ./examples/scroll-demo.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _vectorDom = __webpack_require__(/*! ../lib/dom/vector-dom */ \"./lib/dom/vector-dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _elementVisibility = __webpack_require__(/*! ../lib/dom/element-visibility */ \"./lib/dom/element-visibility.js\");\n\nclass ScrollDemoSample {\n  constructor() {\n    console.log('hello');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.parentElement = document.getElementById('parent');\n    this.moduleHeight = this.parentElement.offsetHeight;\n    this.childElement = document.getElementById('child'); // Instance of rafProgress.\n\n    const rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        rafProgress.easeTo(this.progress, 0.25, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.flowerElement = document.getElementById('flower');\n    this.flowerVector = new _vectorDom.VectorDom(this.flowerElement);\n    this.flowerVector.anchorX = 0;\n    this.flowerVector.anchorY = 0;\n    this.flowerVector.init(); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    rafProgress.watch(this.onProgressUpdate.bind(this)); // Element visibility.\n\n    let observer = _elementVisibility.elementVisibility.inview(document.getElementById('footer-title'), {}, (element, changes, dispose) => {\n      if (changes.isIntersecting) {\n        console.log('inview');\n        element.classList.add('active');\n      } else {\n        console.log('not inview');\n        element.classList.remove('active');\n      }\n    }); // Example of using DOMWatcher to do something when the footer title\n    // is inview.\n\n\n    let ev = _elementVisibility.elementVisibility.inview(document.getElementById('footer-title'), {});\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      eventOptions: {\n        passive: true\n      },\n      callback: () => {\n        console.log('this should only run when the footer is inview');\n      },\n      runWhen: () => {\n        return ev.state().inview;\n      }\n    }); // Example of disposing the element visibility after\n    // 10 seconds.\n    // window.setTimeout(() => {\n    //     console.log('dispoed');\n    //     observer.dispose();\n    // }, 10000);\n  } // Runs every time eased progress is updated.\n\n\n  onProgressUpdate(easedProgress, direction) {\n    let sin = Math.sin(easedProgress); // Add some rotation per progress update.\n\n    this.flowerVector.rz += 0.1;\n    this.flowerVector.rotation.slerpEulerVector(this.flowerVector.eularRotation, 0.08); // Add some movement.\n\n    let x = (window.innerWidth - this.flowerVector.width) * easedProgress;\n    let y = (window.innerHeight - this.flowerVector.height) * easedProgress; // Since we need to offset.\n\n    let z = 1 * easedProgress - 0.5;\n    this.flowerVector.x = x;\n    this.flowerVector.y = y;\n    this.flowerVector.z = z;\n    this.flowerVector.render();\n  }\n\n}\n\nexports.default = ScrollDemoSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9zY3JvbGwtZGVtby5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3Njcm9sbC1kZW1vLmpzP2E5ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWYtcHJvZ3Jlc3NcIik7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS13YXRjaGVyXCIpO1xuXG52YXIgX3ZlY3RvckRvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL3ZlY3Rvci1kb21cIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG52YXIgX2RvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbVwiKTtcblxudmFyIF9lbGVtZW50VmlzaWJpbGl0eSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2VsZW1lbnQtdmlzaWJpbGl0eVwiKTtcblxuY2xhc3MgU2Nyb2xsRGVtb1NhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdoZWxsbycpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcmVudCcpO1xuICAgIHRoaXMubW9kdWxlSGVpZ2h0ID0gdGhpcy5wYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICB0aGlzLmNoaWxkRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGlsZCcpOyAvLyBJbnN0YW5jZSBvZiByYWZQcm9ncmVzcy5cblxuICAgIGNvbnN0IHJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcygpOyAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIHZhbHVlIHBlciBzY3JvbGwuXG5cbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnc2Nyb2xsJyxcbiAgICAgIGNhbGxiYWNrOiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgICAgIHJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAwLjI1LCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gICAgICB9LFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmZsb3dlckVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmxvd2VyJyk7XG4gICAgdGhpcy5mbG93ZXJWZWN0b3IgPSBuZXcgX3ZlY3RvckRvbS5WZWN0b3JEb20odGhpcy5mbG93ZXJFbGVtZW50KTtcbiAgICB0aGlzLmZsb3dlclZlY3Rvci5hbmNob3JYID0gMDtcbiAgICB0aGlzLmZsb3dlclZlY3Rvci5hbmNob3JZID0gMDtcbiAgICB0aGlzLmZsb3dlclZlY3Rvci5pbml0KCk7IC8vIFVwZGF0ZSBwcm9ncmVzcyBpbW1lZGlhdGVseSBvbiBsb2FkLlxuXG4gICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICByYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMSwgX2Vhc2UuRUFTRS5MaW5lYXIpO1xuICAgIHJhZlByb2dyZXNzLndhdGNoKHRoaXMub25Qcm9ncmVzc1VwZGF0ZS5iaW5kKHRoaXMpKTsgLy8gRWxlbWVudCB2aXNpYmlsaXR5LlxuXG4gICAgbGV0IG9ic2VydmVyID0gX2VsZW1lbnRWaXNpYmlsaXR5LmVsZW1lbnRWaXNpYmlsaXR5Lmludmlldyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9vdGVyLXRpdGxlJyksIHt9LCAoZWxlbWVudCwgY2hhbmdlcywgZGlzcG9zZSkgPT4ge1xuICAgICAgaWYgKGNoYW5nZXMuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2ludmlldycpO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ25vdCBpbnZpZXcnKTtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gRXhhbXBsZSBvZiB1c2luZyBET01XYXRjaGVyIHRvIGRvIHNvbWV0aGluZyB3aGVuIHRoZSBmb290ZXIgdGl0bGVcbiAgICAvLyBpcyBpbnZpZXcuXG5cblxuICAgIGxldCBldiA9IF9lbGVtZW50VmlzaWJpbGl0eS5lbGVtZW50VmlzaWJpbGl0eS5pbnZpZXcoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Zvb3Rlci10aXRsZScpLCB7fSk7XG5cbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnc2Nyb2xsJyxcbiAgICAgIGV2ZW50T3B0aW9uczoge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9LFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ3RoaXMgc2hvdWxkIG9ubHkgcnVuIHdoZW4gdGhlIGZvb3RlciBpcyBpbnZpZXcnKTtcbiAgICAgIH0sXG4gICAgICBydW5XaGVuOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBldi5zdGF0ZSgpLmludmlldztcbiAgICAgIH1cbiAgICB9KTsgLy8gRXhhbXBsZSBvZiBkaXNwb3NpbmcgdGhlIGVsZW1lbnQgdmlzaWJpbGl0eSBhZnRlclxuICAgIC8vIDEwIHNlY29uZHMuXG4gICAgLy8gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgIC8vICAgICBjb25zb2xlLmxvZygnZGlzcG9lZCcpO1xuICAgIC8vICAgICBvYnNlcnZlci5kaXNwb3NlKCk7XG4gICAgLy8gfSwgMTAwMDApO1xuICB9IC8vIFJ1bnMgZXZlcnkgdGltZSBlYXNlZCBwcm9ncmVzcyBpcyB1cGRhdGVkLlxuXG5cbiAgb25Qcm9ncmVzc1VwZGF0ZShlYXNlZFByb2dyZXNzLCBkaXJlY3Rpb24pIHtcbiAgICBsZXQgc2luID0gTWF0aC5zaW4oZWFzZWRQcm9ncmVzcyk7IC8vIEFkZCBzb21lIHJvdGF0aW9uIHBlciBwcm9ncmVzcyB1cGRhdGUuXG5cbiAgICB0aGlzLmZsb3dlclZlY3Rvci5yeiArPSAwLjE7XG4gICAgdGhpcy5mbG93ZXJWZWN0b3Iucm90YXRpb24uc2xlcnBFdWxlclZlY3Rvcih0aGlzLmZsb3dlclZlY3Rvci5ldWxhclJvdGF0aW9uLCAwLjA4KTsgLy8gQWRkIHNvbWUgbW92ZW1lbnQuXG5cbiAgICBsZXQgeCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIHRoaXMuZmxvd2VyVmVjdG9yLndpZHRoKSAqIGVhc2VkUHJvZ3Jlc3M7XG4gICAgbGV0IHkgPSAod2luZG93LmlubmVySGVpZ2h0IC0gdGhpcy5mbG93ZXJWZWN0b3IuaGVpZ2h0KSAqIGVhc2VkUHJvZ3Jlc3M7IC8vIFNpbmNlIHdlIG5lZWQgdG8gb2Zmc2V0LlxuXG4gICAgbGV0IHogPSAxICogZWFzZWRQcm9ncmVzcyAtIDAuNTtcbiAgICB0aGlzLmZsb3dlclZlY3Rvci54ID0geDtcbiAgICB0aGlzLmZsb3dlclZlY3Rvci55ID0geTtcbiAgICB0aGlzLmZsb3dlclZlY3Rvci56ID0gejtcbiAgICB0aGlzLmZsb3dlclZlY3Rvci5yZW5kZXIoKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNjcm9sbERlbW9TYW1wbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/scroll-demo.js\n");

/***/ }),

/***/ "./examples/scroll-demo2.js":
/*!**********************************!*\
  !*** ./examples/scroll-demo2.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _vectorDom = __webpack_require__(/*! ../lib/dom/vector-dom */ \"./lib/dom/vector-dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _catmullRom = __webpack_require__(/*! ../lib/mathf/catmull-rom */ \"./lib/mathf/catmull-rom.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _wave = __webpack_require__(/*! ../lib/mathf/wave */ \"./lib/mathf/wave.js\");\n\nclass ScrollDemoSample2 {\n  constructor() {\n    console.log('hello');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.parentElement = document.getElementById('parent');\n    this.moduleHeight = this.parentElement.offsetHeight;\n    this.childElement = document.getElementById('child');\n    this.pointer = _vector.Vector.ZERO;\n    this.easedProgress = 0;\n    this.progress = 0;\n    this.wave = new _wave.Wave(0.03); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // Calculate the mouse position.\n\n    this.domWatcher.add({\n      element: this.childElement,\n      on: 'mousemove',\n      callback: event => {\n        let pageX;\n        let pageY;\n\n        if (event.touches) {\n          pageX = event.touches[0].pageX;\n          pageY = event.touches[0].pageY;\n        } else {\n          pageX = event.pageX;\n          pageY = event.pageY;\n        }\n\n        const x = pageX - this.childElement.offsetLeft;\n        const y = pageY - this.childElement.offsetTop - this.parentElement.offsetTop; // A pointer vector.\n\n        this.pointer = new _vector.Vector(x, y, 0);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.flowerElement = document.getElementById('flower');\n    this.flowerVector = new _vectorDom.VectorDom(this.flowerElement);\n    this.flowerVector.anchorX = 0;\n    this.flowerVector.anchorY = 0;\n    this.flowerVector.init();\n    this.flowerElement2 = document.getElementById('flower2');\n    this.flowerVector2 = new _vectorDom.VectorDom(this.flowerElement2);\n    this.flowerVector2.anchorX = 0.5;\n    this.flowerVector2.anchorY = 0.5; // keep this flower small.\n\n    this.flowerVector2.z = -0.5; // Center this flower\n\n    this.flowerVector2.setOffset(new _vector.Vector(this.childElement.offsetWidth / 2, this.childElement.offsetHeight / 2));\n    this.flowerVector2.init(); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this)).start();\n  }\n\n  onRaf() {\n    this.easedProgress = _mathf.mathf.lerp(this.easedProgress, this.progress, 0.25);\n    this.wave.update();\n    this.updateFirstFlower();\n    this.updateSecondFlower();\n  }\n  /**\n     * For this flower we will update it's position with acceleration.\n     * The flower should accelerate to the target position + a 10% mouse shift\n     * factor.\n     */\n\n\n  updateFirstFlower() {\n    // Add some movement.\n    let x = (window.innerWidth - this.flowerVector.width) * this.easedProgress;\n    let y = (window.innerHeight - this.flowerVector.height) * this.easedProgress; // Since we need to offset.\n\n    let z = 1 * this.easedProgress - 0.5; // This is the target position.\n\n    let targetPositionVector = new _vector.Vector(x, y, z); // Calcualte the distance.\n\n    const distanceVector = _vector.Vector.subtract(targetPositionVector, this.flowerVector.position); // Calculate the distance from the pointer.\n\n\n    const pointerDistanceVector = _vector.Vector.subtract(this.pointer, this.flowerVector.position); // Add the distance from the target to poitner but we don't want to\n    // make the pointer too strong, so scale it down.\n\n\n    distanceVector.add(pointerDistanceVector.scale(0.1)); // Add that distance to the acceleration of the flowerVector.\n\n    this.flowerVector.acceleration = _vector.Vector.ease(this.flowerVector.acceleration, distanceVector, 0.8); // Let's dampen the acceleration.\n\n    this.flowerVector.acceleration.lerp(_vector.Vector.ZERO, 0.8); // Finally add a little movement to the position itself to create a\n    // floaty feeling.\n\n    let floatyVector = new _vector.Vector(0 * this.wave.sinWave, 4 * this.wave.sinWave, 0);\n    this.flowerVector.position.add(floatyVector); // Finally also update alpha.\n\n    this.flowerVector.alpha = 1 * this.easedProgress + 0.5;\n    this.flowerVector.render();\n  }\n\n  updateSecondFlower() {\n    const pointer = this.pointer.clone(); // We don't want the pointer to affect the scale.\n\n    pointer.z = this.flowerVector2.z;\n\n    const distanceVector = _vector.Vector.subtract(pointer.subtract(this.flowerVector2.offset), this.flowerVector2.position);\n\n    this.flowerVector2.acceleration = _vector.Vector.ease(this.flowerVector2.acceleration, distanceVector, 0.8);\n    this.flowerVector2.acceleration.lerp(_vector.Vector.ZERO, 0.8); // Finally add a little movement to the position itself to create a\n    // floaty feeling.\n\n    let floatyVector = new _vector.Vector(0 * this.wave.sinWave, 10 * this.wave.sinWave, 0);\n    this.flowerVector2.position.add(floatyVector);\n    this.flowerVector2.render();\n  }\n\n}\n\nexports.default = ScrollDemoSample2;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9zY3JvbGwtZGVtbzIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9zY3JvbGwtZGVtbzIuanM/YzRhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWYtcHJvZ3Jlc3NcIik7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS13YXRjaGVyXCIpO1xuXG52YXIgX3ZlY3RvckRvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL3ZlY3Rvci1kb21cIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG52YXIgX2RvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbVwiKTtcblxudmFyIF9tYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvbWF0aGZcIik7XG5cbnZhciBfY2F0bXVsbFJvbSA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvY2F0bXVsbC1yb21cIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi92ZWN0b3JcIik7XG5cbnZhciBfd2F2ZSA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvd2F2ZVwiKTtcblxuY2xhc3MgU2Nyb2xsRGVtb1NhbXBsZTIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygnaGVsbG8nKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIgPSBuZXcgX2RvbVdhdGNoZXIuRG9tV2F0Y2hlcigpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJlbnQnKTtcbiAgICB0aGlzLm1vZHVsZUhlaWdodCA9IHRoaXMucGFyZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5jaGlsZEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hpbGQnKTtcbiAgICB0aGlzLnBvaW50ZXIgPSBfdmVjdG9yLlZlY3Rvci5aRVJPO1xuICAgIHRoaXMuZWFzZWRQcm9ncmVzcyA9IDA7XG4gICAgdGhpcy5wcm9ncmVzcyA9IDA7XG4gICAgdGhpcy53YXZlID0gbmV3IF93YXZlLldhdmUoMC4wMyk7IC8vIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MgdmFsdWUgcGVyIHNjcm9sbC5cblxuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdzY3JvbGwnLFxuICAgICAgY2FsbGJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pOyAvLyBDYWxjdWxhdGUgdGhlIG1vdXNlIHBvc2l0aW9uLlxuXG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB0aGlzLmNoaWxkRWxlbWVudCxcbiAgICAgIG9uOiAnbW91c2Vtb3ZlJyxcbiAgICAgIGNhbGxiYWNrOiBldmVudCA9PiB7XG4gICAgICAgIGxldCBwYWdlWDtcbiAgICAgICAgbGV0IHBhZ2VZO1xuXG4gICAgICAgIGlmIChldmVudC50b3VjaGVzKSB7XG4gICAgICAgICAgcGFnZVggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgIHBhZ2VZID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWdlWCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgICAgIHBhZ2VZID0gZXZlbnQucGFnZVk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB4ID0gcGFnZVggLSB0aGlzLmNoaWxkRWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgICAgICBjb25zdCB5ID0gcGFnZVkgLSB0aGlzLmNoaWxkRWxlbWVudC5vZmZzZXRUb3AgLSB0aGlzLnBhcmVudEVsZW1lbnQub2Zmc2V0VG9wOyAvLyBBIHBvaW50ZXIgdmVjdG9yLlxuXG4gICAgICAgIHRoaXMucG9pbnRlciA9IG5ldyBfdmVjdG9yLlZlY3Rvcih4LCB5LCAwKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZmxvd2VyRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmbG93ZXInKTtcbiAgICB0aGlzLmZsb3dlclZlY3RvciA9IG5ldyBfdmVjdG9yRG9tLlZlY3RvckRvbSh0aGlzLmZsb3dlckVsZW1lbnQpO1xuICAgIHRoaXMuZmxvd2VyVmVjdG9yLmFuY2hvclggPSAwO1xuICAgIHRoaXMuZmxvd2VyVmVjdG9yLmFuY2hvclkgPSAwO1xuICAgIHRoaXMuZmxvd2VyVmVjdG9yLmluaXQoKTtcbiAgICB0aGlzLmZsb3dlckVsZW1lbnQyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Zsb3dlcjInKTtcbiAgICB0aGlzLmZsb3dlclZlY3RvcjIgPSBuZXcgX3ZlY3RvckRvbS5WZWN0b3JEb20odGhpcy5mbG93ZXJFbGVtZW50Mik7XG4gICAgdGhpcy5mbG93ZXJWZWN0b3IyLmFuY2hvclggPSAwLjU7XG4gICAgdGhpcy5mbG93ZXJWZWN0b3IyLmFuY2hvclkgPSAwLjU7IC8vIGtlZXAgdGhpcyBmbG93ZXIgc21hbGwuXG5cbiAgICB0aGlzLmZsb3dlclZlY3RvcjIueiA9IC0wLjU7IC8vIENlbnRlciB0aGlzIGZsb3dlclxuXG4gICAgdGhpcy5mbG93ZXJWZWN0b3IyLnNldE9mZnNldChuZXcgX3ZlY3Rvci5WZWN0b3IodGhpcy5jaGlsZEVsZW1lbnQub2Zmc2V0V2lkdGggLyAyLCB0aGlzLmNoaWxkRWxlbWVudC5vZmZzZXRIZWlnaHQgLyAyKSk7XG4gICAgdGhpcy5mbG93ZXJWZWN0b3IyLmluaXQoKTsgLy8gVXBkYXRlIHByb2dyZXNzIGltbWVkaWF0ZWx5IG9uIGxvYWQuXG5cbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgIHRoaXMucmFmID0gbmV3IF9yYWYuUmFmKHRoaXMub25SYWYuYmluZCh0aGlzKSkuc3RhcnQoKTtcbiAgfVxuXG4gIG9uUmFmKCkge1xuICAgIHRoaXMuZWFzZWRQcm9ncmVzcyA9IF9tYXRoZi5tYXRoZi5sZXJwKHRoaXMuZWFzZWRQcm9ncmVzcywgdGhpcy5wcm9ncmVzcywgMC4yNSk7XG4gICAgdGhpcy53YXZlLnVwZGF0ZSgpO1xuICAgIHRoaXMudXBkYXRlRmlyc3RGbG93ZXIoKTtcbiAgICB0aGlzLnVwZGF0ZVNlY29uZEZsb3dlcigpO1xuICB9XG4gIC8qKlxuICAgICAqIEZvciB0aGlzIGZsb3dlciB3ZSB3aWxsIHVwZGF0ZSBpdCdzIHBvc2l0aW9uIHdpdGggYWNjZWxlcmF0aW9uLlxuICAgICAqIFRoZSBmbG93ZXIgc2hvdWxkIGFjY2VsZXJhdGUgdG8gdGhlIHRhcmdldCBwb3NpdGlvbiArIGEgMTAlIG1vdXNlIHNoaWZ0XG4gICAgICogZmFjdG9yLlxuICAgICAqL1xuXG5cbiAgdXBkYXRlRmlyc3RGbG93ZXIoKSB7XG4gICAgLy8gQWRkIHNvbWUgbW92ZW1lbnQuXG4gICAgbGV0IHggPSAod2luZG93LmlubmVyV2lkdGggLSB0aGlzLmZsb3dlclZlY3Rvci53aWR0aCkgKiB0aGlzLmVhc2VkUHJvZ3Jlc3M7XG4gICAgbGV0IHkgPSAod2luZG93LmlubmVySGVpZ2h0IC0gdGhpcy5mbG93ZXJWZWN0b3IuaGVpZ2h0KSAqIHRoaXMuZWFzZWRQcm9ncmVzczsgLy8gU2luY2Ugd2UgbmVlZCB0byBvZmZzZXQuXG5cbiAgICBsZXQgeiA9IDEgKiB0aGlzLmVhc2VkUHJvZ3Jlc3MgLSAwLjU7IC8vIFRoaXMgaXMgdGhlIHRhcmdldCBwb3NpdGlvbi5cblxuICAgIGxldCB0YXJnZXRQb3NpdGlvblZlY3RvciA9IG5ldyBfdmVjdG9yLlZlY3Rvcih4LCB5LCB6KTsgLy8gQ2FsY3VhbHRlIHRoZSBkaXN0YW5jZS5cblxuICAgIGNvbnN0IGRpc3RhbmNlVmVjdG9yID0gX3ZlY3Rvci5WZWN0b3Iuc3VidHJhY3QodGFyZ2V0UG9zaXRpb25WZWN0b3IsIHRoaXMuZmxvd2VyVmVjdG9yLnBvc2l0aW9uKTsgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludGVyLlxuXG5cbiAgICBjb25zdCBwb2ludGVyRGlzdGFuY2VWZWN0b3IgPSBfdmVjdG9yLlZlY3Rvci5zdWJ0cmFjdCh0aGlzLnBvaW50ZXIsIHRoaXMuZmxvd2VyVmVjdG9yLnBvc2l0aW9uKTsgLy8gQWRkIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSB0YXJnZXQgdG8gcG9pdG5lciBidXQgd2UgZG9uJ3Qgd2FudCB0b1xuICAgIC8vIG1ha2UgdGhlIHBvaW50ZXIgdG9vIHN0cm9uZywgc28gc2NhbGUgaXQgZG93bi5cblxuXG4gICAgZGlzdGFuY2VWZWN0b3IuYWRkKHBvaW50ZXJEaXN0YW5jZVZlY3Rvci5zY2FsZSgwLjEpKTsgLy8gQWRkIHRoYXQgZGlzdGFuY2UgdG8gdGhlIGFjY2VsZXJhdGlvbiBvZiB0aGUgZmxvd2VyVmVjdG9yLlxuXG4gICAgdGhpcy5mbG93ZXJWZWN0b3IuYWNjZWxlcmF0aW9uID0gX3ZlY3Rvci5WZWN0b3IuZWFzZSh0aGlzLmZsb3dlclZlY3Rvci5hY2NlbGVyYXRpb24sIGRpc3RhbmNlVmVjdG9yLCAwLjgpOyAvLyBMZXQncyBkYW1wZW4gdGhlIGFjY2VsZXJhdGlvbi5cblxuICAgIHRoaXMuZmxvd2VyVmVjdG9yLmFjY2VsZXJhdGlvbi5sZXJwKF92ZWN0b3IuVmVjdG9yLlpFUk8sIDAuOCk7IC8vIEZpbmFsbHkgYWRkIGEgbGl0dGxlIG1vdmVtZW50IHRvIHRoZSBwb3NpdGlvbiBpdHNlbGYgdG8gY3JlYXRlIGFcbiAgICAvLyBmbG9hdHkgZmVlbGluZy5cblxuICAgIGxldCBmbG9hdHlWZWN0b3IgPSBuZXcgX3ZlY3Rvci5WZWN0b3IoMCAqIHRoaXMud2F2ZS5zaW5XYXZlLCA0ICogdGhpcy53YXZlLnNpbldhdmUsIDApO1xuICAgIHRoaXMuZmxvd2VyVmVjdG9yLnBvc2l0aW9uLmFkZChmbG9hdHlWZWN0b3IpOyAvLyBGaW5hbGx5IGFsc28gdXBkYXRlIGFscGhhLlxuXG4gICAgdGhpcy5mbG93ZXJWZWN0b3IuYWxwaGEgPSAxICogdGhpcy5lYXNlZFByb2dyZXNzICsgMC41O1xuICAgIHRoaXMuZmxvd2VyVmVjdG9yLnJlbmRlcigpO1xuICB9XG5cbiAgdXBkYXRlU2Vjb25kRmxvd2VyKCkge1xuICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLnBvaW50ZXIuY2xvbmUoKTsgLy8gV2UgZG9uJ3Qgd2FudCB0aGUgcG9pbnRlciB0byBhZmZlY3QgdGhlIHNjYWxlLlxuXG4gICAgcG9pbnRlci56ID0gdGhpcy5mbG93ZXJWZWN0b3IyLno7XG5cbiAgICBjb25zdCBkaXN0YW5jZVZlY3RvciA9IF92ZWN0b3IuVmVjdG9yLnN1YnRyYWN0KHBvaW50ZXIuc3VidHJhY3QodGhpcy5mbG93ZXJWZWN0b3IyLm9mZnNldCksIHRoaXMuZmxvd2VyVmVjdG9yMi5wb3NpdGlvbik7XG5cbiAgICB0aGlzLmZsb3dlclZlY3RvcjIuYWNjZWxlcmF0aW9uID0gX3ZlY3Rvci5WZWN0b3IuZWFzZSh0aGlzLmZsb3dlclZlY3RvcjIuYWNjZWxlcmF0aW9uLCBkaXN0YW5jZVZlY3RvciwgMC44KTtcbiAgICB0aGlzLmZsb3dlclZlY3RvcjIuYWNjZWxlcmF0aW9uLmxlcnAoX3ZlY3Rvci5WZWN0b3IuWkVSTywgMC44KTsgLy8gRmluYWxseSBhZGQgYSBsaXR0bGUgbW92ZW1lbnQgdG8gdGhlIHBvc2l0aW9uIGl0c2VsZiB0byBjcmVhdGUgYVxuICAgIC8vIGZsb2F0eSBmZWVsaW5nLlxuXG4gICAgbGV0IGZsb2F0eVZlY3RvciA9IG5ldyBfdmVjdG9yLlZlY3RvcigwICogdGhpcy53YXZlLnNpbldhdmUsIDEwICogdGhpcy53YXZlLnNpbldhdmUsIDApO1xuICAgIHRoaXMuZmxvd2VyVmVjdG9yMi5wb3NpdGlvbi5hZGQoZmxvYXR5VmVjdG9yKTtcbiAgICB0aGlzLmZsb3dlclZlY3RvcjIucmVuZGVyKCk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBTY3JvbGxEZW1vU2FtcGxlMjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/scroll-demo2.js\n");

/***/ }),

/***/ "./examples/scroll-demo3.js":
/*!**********************************!*\
  !*** ./examples/scroll-demo3.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _vectorDom = __webpack_require__(/*! ../lib/dom/vector-dom */ \"./lib/dom/vector-dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _catmullRom = __webpack_require__(/*! ../lib/mathf/catmull-rom */ \"./lib/mathf/catmull-rom.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nclass ScrollDemoSample3 {\n  constructor() {\n    console.log('Scroll Demo 3');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.parentElement = document.getElementById('parent');\n    this.moduleHeight = this.parentElement.offsetHeight;\n    this.childElement = document.getElementById('child'); // Instance of rafProgress.\n\n    const rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight);\n        rafProgress.easeTo(this.progress, 0.08, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.flowerElement = document.getElementById('flower');\n    this.flowerVector = new _vectorDom.VectorDom(this.flowerElement);\n    this.flowerVector.anchorX = 0.5;\n    this.flowerVector.anchorY = 0.5;\n    let timeline = [{\n      progress: 0,\n      x: 1200,\n      y: 600,\n      z: 2 - 1,\n      rx: 180,\n      ry: 0,\n      rz: 0,\n      alpha: 0\n    }, {\n      progress: 0.3,\n      x: 100,\n      y: 400,\n      z: 2 - 1,\n      rz: 180,\n      alpha: 1\n    }, {\n      progress: 0.6,\n      x: 0,\n      y: 200,\n      z: 1 - 1,\n      ry: 180,\n      rz: 0\n    }, {\n      progress: 0.8,\n      x: 300,\n      y: 800,\n      z: 0.3 - 1,\n      rx: 20,\n      ry: 20,\n      rz: 90,\n      easingFunction: _ease.EASE.easeInOutCubic\n    }, {\n      progress: 1,\n      x: 400,\n      y: 500,\n      z: 5 - 1,\n      rx: 0,\n      ry: 0,\n      rz: 0\n    }];\n\n    this.flowerVector._.timeline.setTimeline(timeline); // Enable smoothing.\n\n\n    this.flowerVector._.timeline.catmullRomMode = true; // Enable this to force the flowerVectorDom to use the\n    // internal eularRotation as the rotation matrix.  You will\n    // see gimble lock.\n    // this.flowerVector.eularRotationAsRotationMatrix = true;\n\n    this.flowerVector.init();\n    this.cityElement = document.getElementById('city');\n    this.cityVector = new _vectorDom.VectorDom(this.cityElement);\n    this.cityVector.anchorX = 0;\n    this.cityVector.anchorY = 0;\n    timeline = [{\n      progress: 0,\n      x: 0,\n      y: 0,\n      rx: 0,\n      rz: 0,\n      z: 0.5 - 1,\n      alpha: 1,\n      easingFunction: _ease.EASE.easeInOutQuint\n    }, {\n      progress: 0.2,\n      x: 1000,\n      y: 400,\n      rx: 0,\n      rz: 360,\n      z: 0 - 1,\n      alpha: 0,\n      easingFunction: _ease.EASE.easeInOutQuint\n    }];\n\n    this.cityVector._.timeline.setTimeline(timeline);\n\n    this.cityVector.init(); // Create a second VectorDom on the parent element.\n\n    this.parentElement = document.getElementById('parent');\n    this.parentVector = new _vectorDom.VectorDom(this.parentElement, {\n      timeline: {\n        cssOnly: true\n      }\n    });\n\n    this.parentVector._.timeline.setTimeline([{\n      'progress': 0,\n      '--background': 'rgba(255, 129, 0, 1)',\n      '--text-color': '#000000'\n    }, {\n      'progress': 0.5,\n      '--background': 'rgba(255, 153, 204, 1)',\n      '--text-color': '#A56023'\n    }, {\n      'progress': 1,\n      // You can interchange between hex and rgba\n      // since it all converts to rgba.\n      '--background': '#000000',\n      '--text-color': '#FFFFFF'\n    }]);\n\n    this.parentVector.init();\n    this.textElement = document.getElementById('text');\n    this.textVector = new _vectorDom.VectorDom(this.textElement);\n    this.textVector.disableStyleRenders = true; // // // Just doing this via straight css var to demo.\n    // // // You can normally just use the y value.\n\n    this.textVector._.timeline.setTimeline([{\n      'progress': 0.25,\n      '--opacity': 0,\n      '--y': '100px'\n    }, {\n      'progress': 0.3,\n      '--opacity': 1,\n      '--y': '0px'\n    }, {\n      'progress': 0.95,\n      '--opacity': 1,\n      '--y': '0px'\n    }, {\n      'progress': 0.98,\n      '--opacity': 0,\n      '--y': '-100px'\n    }]);\n\n    this.textVector.init(); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight);\n    this.render(this.progress);\n    rafProgress.setCurrentProgress(this.progress);\n    rafProgress.watch(this.onProgressUpdate.bind(this));\n  }\n\n  render(easedProgress) {\n    this.parentVector._.timeline.updateProgress(easedProgress);\n\n    this.parentVector.render(true);\n\n    this.textVector._.timeline.updateProgress(easedProgress);\n\n    this.textVector.render(true);\n\n    this.flowerVector._.timeline.updateProgress(easedProgress);\n\n    this.flowerVector.render(true);\n\n    this.cityVector._.timeline.updateProgress(easedProgress);\n\n    this.cityVector.render(true);\n  } // Runs every time eased progress is updated.\n\n\n  onProgressUpdate(easedProgress, direction) {\n    this.render(easedProgress);\n  }\n\n}\n\nexports.default = ScrollDemoSample3;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9zY3JvbGwtZGVtbzMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9zY3JvbGwtZGVtbzMuanM/NTc5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yYWZQcm9ncmVzcyA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZi1wcm9ncmVzc1wiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbnZhciBfdmVjdG9yRG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vdmVjdG9yLWRvbVwiKTtcblxudmFyIF9lYXNlID0gcmVxdWlyZShcIi4uL2xpYi9lYXNlL2Vhc2VcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tXCIpO1xuXG52YXIgX21hdGhmID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9tYXRoZlwiKTtcblxudmFyIF9jYXRtdWxsUm9tID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9jYXRtdWxsLXJvbVwiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL3ZlY3RvclwiKTtcblxuY2xhc3MgU2Nyb2xsRGVtb1NhbXBsZTMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygnU2Nyb2xsIERlbW8gMycpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcmVudCcpO1xuICAgIHRoaXMubW9kdWxlSGVpZ2h0ID0gdGhpcy5wYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICB0aGlzLmNoaWxkRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGlsZCcpOyAvLyBJbnN0YW5jZSBvZiByYWZQcm9ncmVzcy5cblxuICAgIGNvbnN0IHJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcygpOyAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIHZhbHVlIHBlciBzY3JvbGwuXG5cbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnc2Nyb2xsJyxcbiAgICAgIGNhbGxiYWNrOiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgcmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDAuMDgsIF9lYXNlLkVBU0UuTGluZWFyKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZmxvd2VyRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmbG93ZXInKTtcbiAgICB0aGlzLmZsb3dlclZlY3RvciA9IG5ldyBfdmVjdG9yRG9tLlZlY3RvckRvbSh0aGlzLmZsb3dlckVsZW1lbnQpO1xuICAgIHRoaXMuZmxvd2VyVmVjdG9yLmFuY2hvclggPSAwLjU7XG4gICAgdGhpcy5mbG93ZXJWZWN0b3IuYW5jaG9yWSA9IDAuNTtcbiAgICBsZXQgdGltZWxpbmUgPSBbe1xuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICB4OiAxMjAwLFxuICAgICAgeTogNjAwLFxuICAgICAgejogMiAtIDEsXG4gICAgICByeDogMTgwLFxuICAgICAgcnk6IDAsXG4gICAgICByejogMCxcbiAgICAgIGFscGhhOiAwXG4gICAgfSwge1xuICAgICAgcHJvZ3Jlc3M6IDAuMyxcbiAgICAgIHg6IDEwMCxcbiAgICAgIHk6IDQwMCxcbiAgICAgIHo6IDIgLSAxLFxuICAgICAgcno6IDE4MCxcbiAgICAgIGFscGhhOiAxXG4gICAgfSwge1xuICAgICAgcHJvZ3Jlc3M6IDAuNixcbiAgICAgIHg6IDAsXG4gICAgICB5OiAyMDAsXG4gICAgICB6OiAxIC0gMSxcbiAgICAgIHJ5OiAxODAsXG4gICAgICByejogMFxuICAgIH0sIHtcbiAgICAgIHByb2dyZXNzOiAwLjgsXG4gICAgICB4OiAzMDAsXG4gICAgICB5OiA4MDAsXG4gICAgICB6OiAwLjMgLSAxLFxuICAgICAgcng6IDIwLFxuICAgICAgcnk6IDIwLFxuICAgICAgcno6IDkwLFxuICAgICAgZWFzaW5nRnVuY3Rpb246IF9lYXNlLkVBU0UuZWFzZUluT3V0Q3ViaWNcbiAgICB9LCB7XG4gICAgICBwcm9ncmVzczogMSxcbiAgICAgIHg6IDQwMCxcbiAgICAgIHk6IDUwMCxcbiAgICAgIHo6IDUgLSAxLFxuICAgICAgcng6IDAsXG4gICAgICByeTogMCxcbiAgICAgIHJ6OiAwXG4gICAgfV07XG5cbiAgICB0aGlzLmZsb3dlclZlY3Rvci5fLnRpbWVsaW5lLnNldFRpbWVsaW5lKHRpbWVsaW5lKTsgLy8gRW5hYmxlIHNtb290aGluZy5cblxuXG4gICAgdGhpcy5mbG93ZXJWZWN0b3IuXy50aW1lbGluZS5jYXRtdWxsUm9tTW9kZSA9IHRydWU7IC8vIEVuYWJsZSB0aGlzIHRvIGZvcmNlIHRoZSBmbG93ZXJWZWN0b3JEb20gdG8gdXNlIHRoZVxuICAgIC8vIGludGVybmFsIGV1bGFyUm90YXRpb24gYXMgdGhlIHJvdGF0aW9uIG1hdHJpeC4gIFlvdSB3aWxsXG4gICAgLy8gc2VlIGdpbWJsZSBsb2NrLlxuICAgIC8vIHRoaXMuZmxvd2VyVmVjdG9yLmV1bGFyUm90YXRpb25Bc1JvdGF0aW9uTWF0cml4ID0gdHJ1ZTtcblxuICAgIHRoaXMuZmxvd2VyVmVjdG9yLmluaXQoKTtcbiAgICB0aGlzLmNpdHlFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NpdHknKTtcbiAgICB0aGlzLmNpdHlWZWN0b3IgPSBuZXcgX3ZlY3RvckRvbS5WZWN0b3JEb20odGhpcy5jaXR5RWxlbWVudCk7XG4gICAgdGhpcy5jaXR5VmVjdG9yLmFuY2hvclggPSAwO1xuICAgIHRoaXMuY2l0eVZlY3Rvci5hbmNob3JZID0gMDtcbiAgICB0aW1lbGluZSA9IFt7XG4gICAgICBwcm9ncmVzczogMCxcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgcng6IDAsXG4gICAgICByejogMCxcbiAgICAgIHo6IDAuNSAtIDEsXG4gICAgICBhbHBoYTogMSxcbiAgICAgIGVhc2luZ0Z1bmN0aW9uOiBfZWFzZS5FQVNFLmVhc2VJbk91dFF1aW50XG4gICAgfSwge1xuICAgICAgcHJvZ3Jlc3M6IDAuMixcbiAgICAgIHg6IDEwMDAsXG4gICAgICB5OiA0MDAsXG4gICAgICByeDogMCxcbiAgICAgIHJ6OiAzNjAsXG4gICAgICB6OiAwIC0gMSxcbiAgICAgIGFscGhhOiAwLFxuICAgICAgZWFzaW5nRnVuY3Rpb246IF9lYXNlLkVBU0UuZWFzZUluT3V0UXVpbnRcbiAgICB9XTtcblxuICAgIHRoaXMuY2l0eVZlY3Rvci5fLnRpbWVsaW5lLnNldFRpbWVsaW5lKHRpbWVsaW5lKTtcblxuICAgIHRoaXMuY2l0eVZlY3Rvci5pbml0KCk7IC8vIENyZWF0ZSBhIHNlY29uZCBWZWN0b3JEb20gb24gdGhlIHBhcmVudCBlbGVtZW50LlxuXG4gICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcmVudCcpO1xuICAgIHRoaXMucGFyZW50VmVjdG9yID0gbmV3IF92ZWN0b3JEb20uVmVjdG9yRG9tKHRoaXMucGFyZW50RWxlbWVudCwge1xuICAgICAgdGltZWxpbmU6IHtcbiAgICAgICAgY3NzT25seTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5wYXJlbnRWZWN0b3IuXy50aW1lbGluZS5zZXRUaW1lbGluZShbe1xuICAgICAgJ3Byb2dyZXNzJzogMCxcbiAgICAgICctLWJhY2tncm91bmQnOiAncmdiYSgyNTUsIDEyOSwgMCwgMSknLFxuICAgICAgJy0tdGV4dC1jb2xvcic6ICcjMDAwMDAwJ1xuICAgIH0sIHtcbiAgICAgICdwcm9ncmVzcyc6IDAuNSxcbiAgICAgICctLWJhY2tncm91bmQnOiAncmdiYSgyNTUsIDE1MywgMjA0LCAxKScsXG4gICAgICAnLS10ZXh0LWNvbG9yJzogJyNBNTYwMjMnXG4gICAgfSwge1xuICAgICAgJ3Byb2dyZXNzJzogMSxcbiAgICAgIC8vIFlvdSBjYW4gaW50ZXJjaGFuZ2UgYmV0d2VlbiBoZXggYW5kIHJnYmFcbiAgICAgIC8vIHNpbmNlIGl0IGFsbCBjb252ZXJ0cyB0byByZ2JhLlxuICAgICAgJy0tYmFja2dyb3VuZCc6ICcjMDAwMDAwJyxcbiAgICAgICctLXRleHQtY29sb3InOiAnI0ZGRkZGRidcbiAgICB9XSk7XG5cbiAgICB0aGlzLnBhcmVudFZlY3Rvci5pbml0KCk7XG4gICAgdGhpcy50ZXh0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXh0Jyk7XG4gICAgdGhpcy50ZXh0VmVjdG9yID0gbmV3IF92ZWN0b3JEb20uVmVjdG9yRG9tKHRoaXMudGV4dEVsZW1lbnQpO1xuICAgIHRoaXMudGV4dFZlY3Rvci5kaXNhYmxlU3R5bGVSZW5kZXJzID0gdHJ1ZTsgLy8gLy8gLy8gSnVzdCBkb2luZyB0aGlzIHZpYSBzdHJhaWdodCBjc3MgdmFyIHRvIGRlbW8uXG4gICAgLy8gLy8gLy8gWW91IGNhbiBub3JtYWxseSBqdXN0IHVzZSB0aGUgeSB2YWx1ZS5cblxuICAgIHRoaXMudGV4dFZlY3Rvci5fLnRpbWVsaW5lLnNldFRpbWVsaW5lKFt7XG4gICAgICAncHJvZ3Jlc3MnOiAwLjI1LFxuICAgICAgJy0tb3BhY2l0eSc6IDAsXG4gICAgICAnLS15JzogJzEwMHB4J1xuICAgIH0sIHtcbiAgICAgICdwcm9ncmVzcyc6IDAuMyxcbiAgICAgICctLW9wYWNpdHknOiAxLFxuICAgICAgJy0teSc6ICcwcHgnXG4gICAgfSwge1xuICAgICAgJ3Byb2dyZXNzJzogMC45NSxcbiAgICAgICctLW9wYWNpdHknOiAxLFxuICAgICAgJy0teSc6ICcwcHgnXG4gICAgfSwge1xuICAgICAgJ3Byb2dyZXNzJzogMC45OCxcbiAgICAgICctLW9wYWNpdHknOiAwLFxuICAgICAgJy0teSc6ICctMTAwcHgnXG4gICAgfV0pO1xuXG4gICAgdGhpcy50ZXh0VmVjdG9yLmluaXQoKTsgLy8gVXBkYXRlIHByb2dyZXNzIGltbWVkaWF0ZWx5IG9uIGxvYWQuXG5cbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXIodGhpcy5wcm9ncmVzcyk7XG4gICAgcmFmUHJvZ3Jlc3Muc2V0Q3VycmVudFByb2dyZXNzKHRoaXMucHJvZ3Jlc3MpO1xuICAgIHJhZlByb2dyZXNzLndhdGNoKHRoaXMub25Qcm9ncmVzc1VwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHJlbmRlcihlYXNlZFByb2dyZXNzKSB7XG4gICAgdGhpcy5wYXJlbnRWZWN0b3IuXy50aW1lbGluZS51cGRhdGVQcm9ncmVzcyhlYXNlZFByb2dyZXNzKTtcblxuICAgIHRoaXMucGFyZW50VmVjdG9yLnJlbmRlcih0cnVlKTtcblxuICAgIHRoaXMudGV4dFZlY3Rvci5fLnRpbWVsaW5lLnVwZGF0ZVByb2dyZXNzKGVhc2VkUHJvZ3Jlc3MpO1xuXG4gICAgdGhpcy50ZXh0VmVjdG9yLnJlbmRlcih0cnVlKTtcblxuICAgIHRoaXMuZmxvd2VyVmVjdG9yLl8udGltZWxpbmUudXBkYXRlUHJvZ3Jlc3MoZWFzZWRQcm9ncmVzcyk7XG5cbiAgICB0aGlzLmZsb3dlclZlY3Rvci5yZW5kZXIodHJ1ZSk7XG5cbiAgICB0aGlzLmNpdHlWZWN0b3IuXy50aW1lbGluZS51cGRhdGVQcm9ncmVzcyhlYXNlZFByb2dyZXNzKTtcblxuICAgIHRoaXMuY2l0eVZlY3Rvci5yZW5kZXIodHJ1ZSk7XG4gIH0gLy8gUnVucyBldmVyeSB0aW1lIGVhc2VkIHByb2dyZXNzIGlzIHVwZGF0ZWQuXG5cblxuICBvblByb2dyZXNzVXBkYXRlKGVhc2VkUHJvZ3Jlc3MsIGRpcmVjdGlvbikge1xuICAgIHRoaXMucmVuZGVyKGVhc2VkUHJvZ3Jlc3MpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gU2Nyb2xsRGVtb1NhbXBsZTM7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/scroll-demo3.js\n");

/***/ }),

/***/ "./examples/scroll-demo4.js":
/*!**********************************!*\
  !*** ./examples/scroll-demo4.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _vectorDom = __webpack_require__(/*! ../lib/dom/vector-dom */ \"./lib/dom/vector-dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _catmullRom = __webpack_require__(/*! ../lib/mathf/catmull-rom */ \"./lib/mathf/catmull-rom.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _wave = __webpack_require__(/*! ../lib/mathf/wave */ \"./lib/mathf/wave.js\");\n\nclass ScrollDemoSample4 {\n  constructor() {\n    console.log('Scroll Demo 4');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.parentElement = document.getElementById('parent');\n    this.moduleHeight = this.parentElement.offsetHeight;\n    this.childElement = document.getElementById('child');\n    this.easedProgress = 0;\n    this.progress = 0;\n    this.wave = new _wave.Wave(0.03); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.flowerElements = Array.from(document.querySelectorAll('.flower'));\n    this.flowerVectors = [];\n    let ww = window.innerWidth;\n    let wh = window.innerHeight;\n    let columns = 6;\n    let xIncrement = ww / columns;\n    let yIncrement = wh * 0.2;\n    let row = 0;\n    let column = 0;\n    this.flowerElements.forEach((flower, i) => {\n      const flowerVector = new _vectorDom.VectorDom(flower);\n      flowerVector.anchorX = 0;\n      flowerVector.anchorY = 0;\n      let x = xIncrement * column;\n      let y = yIncrement * row; // Use the offset feature to generalliy position the element.\n      // We could also use top, left in css to do this as well.\n\n      flowerVector.setOffset(new _vector.Vector(x, y));\n\n      if (i % 2 == 1) {\n        const timeline = [{\n          progress: 0,\n          x: -100,\n          y: -100,\n          rx: -40,\n          ry: 0,\n          rz: -360,\n          z: 0 - 1\n        }, {\n          progress: 0.2,\n          z: 0 - 1\n        }, {\n          progress: 0.5,\n          ry: 90\n        }, {\n          progress: 0.9,\n          x: -200,\n          y: 0,\n          rx: 10,\n          ry: 0,\n          rz: -10,\n          z: 1 - 1\n        }];\n\n        flowerVector._.timeline.setTimeline(timeline);\n      } else {\n        const timeline = [{\n          'progress': 0,\n          'x': -100,\n          'y': -100,\n          'z': 1 - 1,\n          'rz': 0,\n          'alpha': 1,\n          '--blur': 1\n        }, {\n          progress: 0.8,\n          alpha: 1,\n          easingFunction: _ease.EASE.easeInOutQuint\n        }, {\n          'progress': 0.9,\n          'x': -200,\n          'y': 0,\n          'z': 0.2 - 1,\n          'rz': -360,\n          'alpha': 0,\n          '--blur': 0\n        }];\n\n        flowerVector._.timeline.setTimeline(timeline);\n      }\n\n      flowerVector.id = i;\n      flowerVector.useBoundsForGlobalCalculation = true;\n      flowerVector.waveMovementFactor = _mathf.mathf.getRandomInt(-20, 20);\n      flowerVector.init();\n      this.flowerVectors.push(flowerVector);\n\n      if (column >= columns) {\n        column = 0;\n        row++;\n      } else {\n        column++;\n      }\n    }); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.raf = new _raf.Raf(this.onRaf.bind(this)).start();\n  }\n\n  onRaf() {\n    this.easedProgress = _mathf.mathf.lerp(this.easedProgress, this.progress, 0.25);\n    this.wave.update();\n    let invertProgress = 1 - this.easedProgress;\n    this.flowerVectors.forEach(vector => {\n      vector._.timeline.updateProgress(this.easedProgress); // Add a littie up and down motion.\n\n\n      let floatyVector = new _vector.Vector(vector.waveMovementFactor * this.wave.sinWave * this.easedProgress, // We want the wave effect to be strong bottom and none at the top.\n      vector.waveMovementFactor * this.wave.sinWave * this.easedProgress, 0);\n      vector.position.add(floatyVector); // if (vector.id % 2 == 1) {\n      //     vector._.force.mouseRotationForce(\n      //         -0.15, -0.15, 0, 0.02\n      //     );\n      // } else {\n      //     vector._.force.scrollYRotationForce(\n      //         0, 0.05, 0, 0.02\n      //     );\n      // }\n\n      vector.render(true);\n    });\n  }\n\n}\n\nexports.default = ScrollDemoSample4;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9zY3JvbGwtZGVtbzQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9zY3JvbGwtZGVtbzQuanM/MzljZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWYtcHJvZ3Jlc3NcIik7XG5cbnZhciBfZG9tV2F0Y2hlciA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbS13YXRjaGVyXCIpO1xuXG52YXIgX3ZlY3RvckRvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL3ZlY3Rvci1kb21cIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG52YXIgX2RvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbVwiKTtcblxudmFyIF9tYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvbWF0aGZcIik7XG5cbnZhciBfY2F0bXVsbFJvbSA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvY2F0bXVsbC1yb21cIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi92ZWN0b3JcIik7XG5cbnZhciBfd2F2ZSA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvd2F2ZVwiKTtcblxuY2xhc3MgU2Nyb2xsRGVtb1NhbXBsZTQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygnU2Nyb2xsIERlbW8gNCcpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcmVudCcpO1xuICAgIHRoaXMubW9kdWxlSGVpZ2h0ID0gdGhpcy5wYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICB0aGlzLmNoaWxkRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGlsZCcpO1xuICAgIHRoaXMuZWFzZWRQcm9ncmVzcyA9IDA7XG4gICAgdGhpcy5wcm9ncmVzcyA9IDA7XG4gICAgdGhpcy53YXZlID0gbmV3IF93YXZlLldhdmUoMC4wMyk7IC8vIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MgdmFsdWUgcGVyIHNjcm9sbC5cblxuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdzY3JvbGwnLFxuICAgICAgY2FsbGJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZmxvd2VyRWxlbWVudHMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5mbG93ZXInKSk7XG4gICAgdGhpcy5mbG93ZXJWZWN0b3JzID0gW107XG4gICAgbGV0IHd3ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgbGV0IHdoID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGxldCBjb2x1bW5zID0gNjtcbiAgICBsZXQgeEluY3JlbWVudCA9IHd3IC8gY29sdW1ucztcbiAgICBsZXQgeUluY3JlbWVudCA9IHdoICogMC4yO1xuICAgIGxldCByb3cgPSAwO1xuICAgIGxldCBjb2x1bW4gPSAwO1xuICAgIHRoaXMuZmxvd2VyRWxlbWVudHMuZm9yRWFjaCgoZmxvd2VyLCBpKSA9PiB7XG4gICAgICBjb25zdCBmbG93ZXJWZWN0b3IgPSBuZXcgX3ZlY3RvckRvbS5WZWN0b3JEb20oZmxvd2VyKTtcbiAgICAgIGZsb3dlclZlY3Rvci5hbmNob3JYID0gMDtcbiAgICAgIGZsb3dlclZlY3Rvci5hbmNob3JZID0gMDtcbiAgICAgIGxldCB4ID0geEluY3JlbWVudCAqIGNvbHVtbjtcbiAgICAgIGxldCB5ID0geUluY3JlbWVudCAqIHJvdzsgLy8gVXNlIHRoZSBvZmZzZXQgZmVhdHVyZSB0byBnZW5lcmFsbGl5IHBvc2l0aW9uIHRoZSBlbGVtZW50LlxuICAgICAgLy8gV2UgY291bGQgYWxzbyB1c2UgdG9wLCBsZWZ0IGluIGNzcyB0byBkbyB0aGlzIGFzIHdlbGwuXG5cbiAgICAgIGZsb3dlclZlY3Rvci5zZXRPZmZzZXQobmV3IF92ZWN0b3IuVmVjdG9yKHgsIHkpKTtcblxuICAgICAgaWYgKGkgJSAyID09IDEpIHtcbiAgICAgICAgY29uc3QgdGltZWxpbmUgPSBbe1xuICAgICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICAgIHg6IC0xMDAsXG4gICAgICAgICAgeTogLTEwMCxcbiAgICAgICAgICByeDogLTQwLFxuICAgICAgICAgIHJ5OiAwLFxuICAgICAgICAgIHJ6OiAtMzYwLFxuICAgICAgICAgIHo6IDAgLSAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwcm9ncmVzczogMC4yLFxuICAgICAgICAgIHo6IDAgLSAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwcm9ncmVzczogMC41LFxuICAgICAgICAgIHJ5OiA5MFxuICAgICAgICB9LCB7XG4gICAgICAgICAgcHJvZ3Jlc3M6IDAuOSxcbiAgICAgICAgICB4OiAtMjAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgcng6IDEwLFxuICAgICAgICAgIHJ5OiAwLFxuICAgICAgICAgIHJ6OiAtMTAsXG4gICAgICAgICAgejogMSAtIDFcbiAgICAgICAgfV07XG5cbiAgICAgICAgZmxvd2VyVmVjdG9yLl8udGltZWxpbmUuc2V0VGltZWxpbmUodGltZWxpbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGltZWxpbmUgPSBbe1xuICAgICAgICAgICdwcm9ncmVzcyc6IDAsXG4gICAgICAgICAgJ3gnOiAtMTAwLFxuICAgICAgICAgICd5JzogLTEwMCxcbiAgICAgICAgICAneic6IDEgLSAxLFxuICAgICAgICAgICdyeic6IDAsXG4gICAgICAgICAgJ2FscGhhJzogMSxcbiAgICAgICAgICAnLS1ibHVyJzogMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcHJvZ3Jlc3M6IDAuOCxcbiAgICAgICAgICBhbHBoYTogMSxcbiAgICAgICAgICBlYXNpbmdGdW5jdGlvbjogX2Vhc2UuRUFTRS5lYXNlSW5PdXRRdWludFxuICAgICAgICB9LCB7XG4gICAgICAgICAgJ3Byb2dyZXNzJzogMC45LFxuICAgICAgICAgICd4JzogLTIwMCxcbiAgICAgICAgICAneSc6IDAsXG4gICAgICAgICAgJ3onOiAwLjIgLSAxLFxuICAgICAgICAgICdyeic6IC0zNjAsXG4gICAgICAgICAgJ2FscGhhJzogMCxcbiAgICAgICAgICAnLS1ibHVyJzogMFxuICAgICAgICB9XTtcblxuICAgICAgICBmbG93ZXJWZWN0b3IuXy50aW1lbGluZS5zZXRUaW1lbGluZSh0aW1lbGluZSk7XG4gICAgICB9XG5cbiAgICAgIGZsb3dlclZlY3Rvci5pZCA9IGk7XG4gICAgICBmbG93ZXJWZWN0b3IudXNlQm91bmRzRm9yR2xvYmFsQ2FsY3VsYXRpb24gPSB0cnVlO1xuICAgICAgZmxvd2VyVmVjdG9yLndhdmVNb3ZlbWVudEZhY3RvciA9IF9tYXRoZi5tYXRoZi5nZXRSYW5kb21JbnQoLTIwLCAyMCk7XG4gICAgICBmbG93ZXJWZWN0b3IuaW5pdCgpO1xuICAgICAgdGhpcy5mbG93ZXJWZWN0b3JzLnB1c2goZmxvd2VyVmVjdG9yKTtcblxuICAgICAgaWYgKGNvbHVtbiA+PSBjb2x1bW5zKSB7XG4gICAgICAgIGNvbHVtbiA9IDA7XG4gICAgICAgIHJvdysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uKys7XG4gICAgICB9XG4gICAgfSk7IC8vIFVwZGF0ZSBwcm9ncmVzcyBpbW1lZGlhdGVseSBvbiBsb2FkLlxuXG4gICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpLnN0YXJ0KCk7XG4gIH1cblxuICBvblJhZigpIHtcbiAgICB0aGlzLmVhc2VkUHJvZ3Jlc3MgPSBfbWF0aGYubWF0aGYubGVycCh0aGlzLmVhc2VkUHJvZ3Jlc3MsIHRoaXMucHJvZ3Jlc3MsIDAuMjUpO1xuICAgIHRoaXMud2F2ZS51cGRhdGUoKTtcbiAgICBsZXQgaW52ZXJ0UHJvZ3Jlc3MgPSAxIC0gdGhpcy5lYXNlZFByb2dyZXNzO1xuICAgIHRoaXMuZmxvd2VyVmVjdG9ycy5mb3JFYWNoKHZlY3RvciA9PiB7XG4gICAgICB2ZWN0b3IuXy50aW1lbGluZS51cGRhdGVQcm9ncmVzcyh0aGlzLmVhc2VkUHJvZ3Jlc3MpOyAvLyBBZGQgYSBsaXR0aWUgdXAgYW5kIGRvd24gbW90aW9uLlxuXG5cbiAgICAgIGxldCBmbG9hdHlWZWN0b3IgPSBuZXcgX3ZlY3Rvci5WZWN0b3IodmVjdG9yLndhdmVNb3ZlbWVudEZhY3RvciAqIHRoaXMud2F2ZS5zaW5XYXZlICogdGhpcy5lYXNlZFByb2dyZXNzLCAvLyBXZSB3YW50IHRoZSB3YXZlIGVmZmVjdCB0byBiZSBzdHJvbmcgYm90dG9tIGFuZCBub25lIGF0IHRoZSB0b3AuXG4gICAgICB2ZWN0b3Iud2F2ZU1vdmVtZW50RmFjdG9yICogdGhpcy53YXZlLnNpbldhdmUgKiB0aGlzLmVhc2VkUHJvZ3Jlc3MsIDApO1xuICAgICAgdmVjdG9yLnBvc2l0aW9uLmFkZChmbG9hdHlWZWN0b3IpOyAvLyBpZiAodmVjdG9yLmlkICUgMiA9PSAxKSB7XG4gICAgICAvLyAgICAgdmVjdG9yLl8uZm9yY2UubW91c2VSb3RhdGlvbkZvcmNlKFxuICAgICAgLy8gICAgICAgICAtMC4xNSwgLTAuMTUsIDAsIDAuMDJcbiAgICAgIC8vICAgICApO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgICB2ZWN0b3IuXy5mb3JjZS5zY3JvbGxZUm90YXRpb25Gb3JjZShcbiAgICAgIC8vICAgICAgICAgMCwgMC4wNSwgMCwgMC4wMlxuICAgICAgLy8gICAgICk7XG4gICAgICAvLyB9XG5cbiAgICAgIHZlY3Rvci5yZW5kZXIodHJ1ZSk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBTY3JvbGxEZW1vU2FtcGxlNDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/scroll-demo4.js\n");

/***/ }),

/***/ "./examples/scroll-demo5.js":
/*!**********************************!*\
  !*** ./examples/scroll-demo5.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _dat = __webpack_require__(/*! dat.gui */ \"./node_modules/dat.gui/build/dat.gui.module.js\");\n\nvar dat = _interopRequireWildcard(_dat);\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _vectorDom = __webpack_require__(/*! ../lib/dom/vector-dom */ \"./lib/dom/vector-dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _cssVarInterpolate = __webpack_require__(/*! ../lib/interpolate/css-var-interpolate */ \"./lib/interpolate/css-var-interpolate.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nclass ScrollDemoSample5 {\n  constructor() {\n    console.log('Sample 5');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.parentElement = document.getElementById('parent');\n    this.moduleHeight = this.parentElement.offsetHeight;\n    this.childElement = document.getElementById('child'); // Instance of rafProgress.\n\n    const rafProgress = new _rafProgress.RafProgress();\n    const raf = new _raf.Raf(this.raf.bind(this)); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        rafProgress.easeTo(this.progress, 0.08, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.flowerElement = document.getElementById('flower');\n    this.flowerVector = new _vectorDom.VectorDom(this.flowerElement);\n    this.flowerVector.anchorX = 0;\n    this.flowerVector.anchorY = 0;\n    const timeline = [{\n      progress: 0,\n      ry: 0,\n      rz: 0,\n      x: 0,\n      y: 0,\n      z: 0.5 - 1\n    }, {\n      progress: 0.2,\n      ry: -90,\n      rz: 180,\n      x: 200,\n      y: 500,\n      z: 0.2 - 1\n    }, {\n      progress: 0.4,\n      ry: 0,\n      rz: -180,\n      x: 400,\n      y: 100,\n      z: 0.5 - 1\n    }, {\n      progress: 0.6,\n      rz: 0,\n      x: 600,\n      y: 400,\n      z: 1 - 1\n    }, {\n      progress: 0.8,\n      rz: 90,\n      x: 800,\n      y: 500,\n      z: 0.3 - 1\n    }, {\n      progress: 1,\n      rz: 0,\n      x: 1000,\n      y: 200,\n      z: 1 - 1\n    }];\n\n    this.flowerVector._.timeline.setTimeline(timeline);\n\n    this.flowerVector.init(); // Use catmull rom mode to make this super smooth between points.\n\n    this.flowerVector._.timeline.catmullRomMode = true;\n    this.flowerVector._.timeline.catmullRomTension = 1; // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    rafProgress.watch(this.onProgressUpdate.bind(this)); // Animate the background color of the body with css var interpolate.\n\n    this.cssVarInterpolate = new _cssVarInterpolate.CssVarInterpolate(document.body, {\n      interpolations: [{\n        progress: [{\n          from: 0,\n          to: 0.5,\n          start: 'rgba(255, 128, 0, 0.3)',\n          // orange\n          end: 'rgba(255, 153, 204, 1)' // pink\n\n        }, {\n          from: 0.5,\n          to: 1,\n          start: 'rgba(255, 153, 204, 1)',\n          // pink\n          end: 'rgba(0, 0, 255, 1)' // blue\n\n        }],\n        id: '--background'\n      }]\n    });\n    this.gui = new dat.GUI();\n    let datFolder = this.gui.addFolder('Catmull Rom');\n    datFolder.add(this.flowerVector._.timeline, 'catmullRomMode');\n    datFolder.add(this.flowerVector._.timeline, 'catmullRomTension', -3, 3);\n    raf.start();\n  } // Runs every time eased progress is updated.\n\n\n  onProgressUpdate(easedProgress, direction) {\n    let sin = Math.sin(easedProgress);\n    this.cssVarInterpolate.update(easedProgress);\n\n    this.flowerVector._.timeline.updateProgress(easedProgress);\n  }\n\n  raf() {\n    this.flowerVector.slerpEularRotation(0.1);\n    this.flowerVector.render();\n  }\n\n}\n\nexports.default = ScrollDemoSample5;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9zY3JvbGwtZGVtbzUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9zY3JvbGwtZGVtbzUuanM/YzZiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9kYXQgPSByZXF1aXJlKFwiZGF0Lmd1aVwiKTtcblxudmFyIGRhdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9kYXQpO1xuXG52YXIgX3JhZiA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZlwiKTtcblxudmFyIF9yYWZQcm9ncmVzcyA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZi1wcm9ncmVzc1wiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbnZhciBfdmVjdG9yRG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vdmVjdG9yLWRvbVwiKTtcblxudmFyIF9lYXNlID0gcmVxdWlyZShcIi4uL2xpYi9lYXNlL2Vhc2VcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tXCIpO1xuXG52YXIgX2Nzc1ZhckludGVycG9sYXRlID0gcmVxdWlyZShcIi4uL2xpYi9pbnRlcnBvbGF0ZS9jc3MtdmFyLWludGVycG9sYXRlXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmNsYXNzIFNjcm9sbERlbW9TYW1wbGU1IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coJ1NhbXBsZSA1Jyk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyZW50Jyk7XG4gICAgdGhpcy5tb2R1bGVIZWlnaHQgPSB0aGlzLnBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIHRoaXMuY2hpbGRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoaWxkJyk7IC8vIEluc3RhbmNlIG9mIHJhZlByb2dyZXNzLlxuXG4gICAgY29uc3QgcmFmUHJvZ3Jlc3MgPSBuZXcgX3JhZlByb2dyZXNzLlJhZlByb2dyZXNzKCk7XG4gICAgY29uc3QgcmFmID0gbmV3IF9yYWYuUmFmKHRoaXMucmFmLmJpbmQodGhpcykpOyAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIHZhbHVlIHBlciBzY3JvbGwuXG5cbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnc2Nyb2xsJyxcbiAgICAgIGNhbGxiYWNrOiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgICAgIHJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAwLjA4LCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gICAgICB9LFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmZsb3dlckVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmxvd2VyJyk7XG4gICAgdGhpcy5mbG93ZXJWZWN0b3IgPSBuZXcgX3ZlY3RvckRvbS5WZWN0b3JEb20odGhpcy5mbG93ZXJFbGVtZW50KTtcbiAgICB0aGlzLmZsb3dlclZlY3Rvci5hbmNob3JYID0gMDtcbiAgICB0aGlzLmZsb3dlclZlY3Rvci5hbmNob3JZID0gMDtcbiAgICBjb25zdCB0aW1lbGluZSA9IFt7XG4gICAgICBwcm9ncmVzczogMCxcbiAgICAgIHJ5OiAwLFxuICAgICAgcno6IDAsXG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHo6IDAuNSAtIDFcbiAgICB9LCB7XG4gICAgICBwcm9ncmVzczogMC4yLFxuICAgICAgcnk6IC05MCxcbiAgICAgIHJ6OiAxODAsXG4gICAgICB4OiAyMDAsXG4gICAgICB5OiA1MDAsXG4gICAgICB6OiAwLjIgLSAxXG4gICAgfSwge1xuICAgICAgcHJvZ3Jlc3M6IDAuNCxcbiAgICAgIHJ5OiAwLFxuICAgICAgcno6IC0xODAsXG4gICAgICB4OiA0MDAsXG4gICAgICB5OiAxMDAsXG4gICAgICB6OiAwLjUgLSAxXG4gICAgfSwge1xuICAgICAgcHJvZ3Jlc3M6IDAuNixcbiAgICAgIHJ6OiAwLFxuICAgICAgeDogNjAwLFxuICAgICAgeTogNDAwLFxuICAgICAgejogMSAtIDFcbiAgICB9LCB7XG4gICAgICBwcm9ncmVzczogMC44LFxuICAgICAgcno6IDkwLFxuICAgICAgeDogODAwLFxuICAgICAgeTogNTAwLFxuICAgICAgejogMC4zIC0gMVxuICAgIH0sIHtcbiAgICAgIHByb2dyZXNzOiAxLFxuICAgICAgcno6IDAsXG4gICAgICB4OiAxMDAwLFxuICAgICAgeTogMjAwLFxuICAgICAgejogMSAtIDFcbiAgICB9XTtcblxuICAgIHRoaXMuZmxvd2VyVmVjdG9yLl8udGltZWxpbmUuc2V0VGltZWxpbmUodGltZWxpbmUpO1xuXG4gICAgdGhpcy5mbG93ZXJWZWN0b3IuaW5pdCgpOyAvLyBVc2UgY2F0bXVsbCByb20gbW9kZSB0byBtYWtlIHRoaXMgc3VwZXIgc21vb3RoIGJldHdlZW4gcG9pbnRzLlxuXG4gICAgdGhpcy5mbG93ZXJWZWN0b3IuXy50aW1lbGluZS5jYXRtdWxsUm9tTW9kZSA9IHRydWU7XG4gICAgdGhpcy5mbG93ZXJWZWN0b3IuXy50aW1lbGluZS5jYXRtdWxsUm9tVGVuc2lvbiA9IDE7IC8vIFVwZGF0ZSBwcm9ncmVzcyBpbW1lZGlhdGVseSBvbiBsb2FkLlxuXG4gICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICByYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMSwgX2Vhc2UuRUFTRS5MaW5lYXIpO1xuICAgIHJhZlByb2dyZXNzLndhdGNoKHRoaXMub25Qcm9ncmVzc1VwZGF0ZS5iaW5kKHRoaXMpKTsgLy8gQW5pbWF0ZSB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgYm9keSB3aXRoIGNzcyB2YXIgaW50ZXJwb2xhdGUuXG5cbiAgICB0aGlzLmNzc1ZhckludGVycG9sYXRlID0gbmV3IF9jc3NWYXJJbnRlcnBvbGF0ZS5Dc3NWYXJJbnRlcnBvbGF0ZShkb2N1bWVudC5ib2R5LCB7XG4gICAgICBpbnRlcnBvbGF0aW9uczogW3tcbiAgICAgICAgcHJvZ3Jlc3M6IFt7XG4gICAgICAgICAgZnJvbTogMCxcbiAgICAgICAgICB0bzogMC41LFxuICAgICAgICAgIHN0YXJ0OiAncmdiYSgyNTUsIDEyOCwgMCwgMC4zKScsXG4gICAgICAgICAgLy8gb3JhbmdlXG4gICAgICAgICAgZW5kOiAncmdiYSgyNTUsIDE1MywgMjA0LCAxKScgLy8gcGlua1xuXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBmcm9tOiAwLjUsXG4gICAgICAgICAgdG86IDEsXG4gICAgICAgICAgc3RhcnQ6ICdyZ2JhKDI1NSwgMTUzLCAyMDQsIDEpJyxcbiAgICAgICAgICAvLyBwaW5rXG4gICAgICAgICAgZW5kOiAncmdiYSgwLCAwLCAyNTUsIDEpJyAvLyBibHVlXG5cbiAgICAgICAgfV0sXG4gICAgICAgIGlkOiAnLS1iYWNrZ3JvdW5kJ1xuICAgICAgfV1cbiAgICB9KTtcbiAgICB0aGlzLmd1aSA9IG5ldyBkYXQuR1VJKCk7XG4gICAgbGV0IGRhdEZvbGRlciA9IHRoaXMuZ3VpLmFkZEZvbGRlcignQ2F0bXVsbCBSb20nKTtcbiAgICBkYXRGb2xkZXIuYWRkKHRoaXMuZmxvd2VyVmVjdG9yLl8udGltZWxpbmUsICdjYXRtdWxsUm9tTW9kZScpO1xuICAgIGRhdEZvbGRlci5hZGQodGhpcy5mbG93ZXJWZWN0b3IuXy50aW1lbGluZSwgJ2NhdG11bGxSb21UZW5zaW9uJywgLTMsIDMpO1xuICAgIHJhZi5zdGFydCgpO1xuICB9IC8vIFJ1bnMgZXZlcnkgdGltZSBlYXNlZCBwcm9ncmVzcyBpcyB1cGRhdGVkLlxuXG5cbiAgb25Qcm9ncmVzc1VwZGF0ZShlYXNlZFByb2dyZXNzLCBkaXJlY3Rpb24pIHtcbiAgICBsZXQgc2luID0gTWF0aC5zaW4oZWFzZWRQcm9ncmVzcyk7XG4gICAgdGhpcy5jc3NWYXJJbnRlcnBvbGF0ZS51cGRhdGUoZWFzZWRQcm9ncmVzcyk7XG5cbiAgICB0aGlzLmZsb3dlclZlY3Rvci5fLnRpbWVsaW5lLnVwZGF0ZVByb2dyZXNzKGVhc2VkUHJvZ3Jlc3MpO1xuICB9XG5cbiAgcmFmKCkge1xuICAgIHRoaXMuZmxvd2VyVmVjdG9yLnNsZXJwRXVsYXJSb3RhdGlvbigwLjEpO1xuICAgIHRoaXMuZmxvd2VyVmVjdG9yLnJlbmRlcigpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gU2Nyb2xsRGVtb1NhbXBsZTU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/scroll-demo5.js\n");

/***/ }),

/***/ "./examples/styles/index.sass":
/*!************************************!*\
  !*** ./examples/styles/index.sass ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js?sourceMap=true!../../node_modules/sass-loader/lib/loader.js!./index.sass */ \"./node_modules/css-loader/dist/cjs.js?sourceMap=true!./node_modules/sass-loader/lib/loader.js!./examples/styles/index.sass\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy9zdHlsZXMvaW5kZXguc2Fzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3N0eWxlcy9pbmRleC5zYXNzP2VlOWIiXSwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzP3NvdXJjZU1hcD10cnVlIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vaW5kZXguc2Fzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/c291cmNlTWFwPXRydWUhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9pbmRleC5zYXNzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/c291cmNlTWFwPXRydWUhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9pbmRleC5zYXNzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/styles/index.sass\n");

/***/ }),

/***/ "./examples/text-split.js":
/*!********************************!*\
  !*** ./examples/text-split.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _textSplit = __webpack_require__(/*! ../lib/dom/text-split */ \"./lib/dom/text-split.js\");\n\nclass TextSplitSample {\n  constructor() {\n    console.log('text split sample'); // Split by word\n\n    let splitter = new _textSplit.TextSplit({\n      element: document.getElementById('split1'),\n      split: ' '\n    }); // Split by character\n\n    let splitter2 = new _textSplit.TextSplit({\n      element: document.getElementById('split2'),\n      split: ''\n    });\n    let splitter3 = new _textSplit.TextSplit({\n      element: document.getElementById('split3'),\n      split: ' '\n    }); // Run splitting every 2 seconds.\n    // This layout thrashes so in practice, you wouldn't want to do this,\n    // and instead reset a css class.\n\n    window.setInterval(() => {\n      splitter.split();\n      splitter2.split();\n      splitter3.split();\n    }, 2000);\n  }\n\n}\n\nexports.default = TextSplitSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90ZXh0LXNwbGl0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvdGV4dC1zcGxpdC5qcz9mMTRiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RleHRTcGxpdCA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL3RleHQtc3BsaXRcIik7XG5cbmNsYXNzIFRleHRTcGxpdFNhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCd0ZXh0IHNwbGl0IHNhbXBsZScpOyAvLyBTcGxpdCBieSB3b3JkXG5cbiAgICBsZXQgc3BsaXR0ZXIgPSBuZXcgX3RleHRTcGxpdC5UZXh0U3BsaXQoe1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NwbGl0MScpLFxuICAgICAgc3BsaXQ6ICcgJ1xuICAgIH0pOyAvLyBTcGxpdCBieSBjaGFyYWN0ZXJcblxuICAgIGxldCBzcGxpdHRlcjIgPSBuZXcgX3RleHRTcGxpdC5UZXh0U3BsaXQoe1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NwbGl0MicpLFxuICAgICAgc3BsaXQ6ICcnXG4gICAgfSk7XG4gICAgbGV0IHNwbGl0dGVyMyA9IG5ldyBfdGV4dFNwbGl0LlRleHRTcGxpdCh7XG4gICAgICBlbGVtZW50OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3BsaXQzJyksXG4gICAgICBzcGxpdDogJyAnXG4gICAgfSk7IC8vIFJ1biBzcGxpdHRpbmcgZXZlcnkgMiBzZWNvbmRzLlxuICAgIC8vIFRoaXMgbGF5b3V0IHRocmFzaGVzIHNvIGluIHByYWN0aWNlLCB5b3Ugd291bGRuJ3Qgd2FudCB0byBkbyB0aGlzLFxuICAgIC8vIGFuZCBpbnN0ZWFkIHJlc2V0IGEgY3NzIGNsYXNzLlxuXG4gICAgd2luZG93LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHNwbGl0dGVyLnNwbGl0KCk7XG4gICAgICBzcGxpdHRlcjIuc3BsaXQoKTtcbiAgICAgIHNwbGl0dGVyMy5zcGxpdCgpO1xuICAgIH0sIDIwMDApO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gVGV4dFNwbGl0U2FtcGxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/text-split.js\n");

/***/ }),

/***/ "./examples/three-light-test.js":
/*!**************************************!*\
  !*** ./examples/three-light-test.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _GLTFLoader = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _OrbitControls = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n\nvar _sceneRenderer = __webpack_require__(/*! ../lib/threef/scene-renderer */ \"./lib/threef/scene-renderer.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _threef = __webpack_require__(/*! ../lib/threef/threef */ \"./lib/threef/threef.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n// https://threejs.org/examples/webgl_shadowmap_pcss.html\nconst PCSS2 = `\n#define LIGHT_WORLD_SIZE 0.005\n\t\t\t\t#define LIGHT_FRUSTUM_WIDTH 3.75\n\t\t\t\t#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n\t\t\t\t#define NEAR_PLANE 9.5\n\t\t\t\t#define NUM_SAMPLES 30\n\t\t\t\t#define NUM_RINGS 10\n\t\t\t\t#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n\t\t\t\t#define PCF_NUM_SAMPLES NUM_SAMPLES\n\n\t\t\t\tvec2 poissonDisk[NUM_SAMPLES];\n\n\t\t\t\tvoid initPoissonSamples( const in vec2 randomSeed ) {\n\t\t\t\t\tfloat ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n\t\t\t\t\tfloat INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n\t\t\t\t\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n\t\t\t\t\tfloat angle = rand( randomSeed ) * PI2;\n\t\t\t\t\tfloat radius = INV_NUM_SAMPLES;\n\t\t\t\t\tfloat radiusStep = radius;\n\n\t\t\t\t\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n\t\t\t\t\t\tpoissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );\n\t\t\t\t\t\tradius += radiusStep;\n\t\t\t\t\t\tangle += ANGLE_STEP;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n\t\t\t\t\treturn (zReceiver - zBlocker) / zBlocker;\n\t\t\t\t}\n\n\t\t\t\tfloat findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\n\t\t\t\t\t// This uses similar triangles to compute what\n\t\t\t\t\t// area of the shadow map we should search\n\t\t\t\t\tfloat searchRadius = LIGHT_SIZE_UV * ( zReceiver - NEAR_PLANE ) / zReceiver;\n\t\t\t\t\tfloat blockerDepthSum = 0.0;\n\t\t\t\t\tint numBlockers = 0;\n\n\t\t\t\t\tfor( int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++ ) {\n\t\t\t\t\t\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n\t\t\t\t\t\tif ( shadowMapDepth < zReceiver ) {\n\t\t\t\t\t\t\tblockerDepthSum += shadowMapDepth;\n\t\t\t\t\t\t\tnumBlockers ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif( numBlockers == 0 ) return -1.0;\n\n\t\t\t\t\treturn blockerDepthSum / float( numBlockers );\n\t\t\t\t}\n\n\t\t\t\tfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {\n\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t\tfor( int i = 0; i < PCF_NUM_SAMPLES; i ++ ) {\n\t\t\t\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );\n\t\t\t\t\t\tif( zReceiver <= depth ) sum += 1.0;\n\t\t\t\t\t}\n\t\t\t\t\tfor( int i = 0; i < PCF_NUM_SAMPLES; i ++ ) {\n\t\t\t\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );\n\t\t\t\t\t\tif( zReceiver <= depth ) sum += 1.0;\n\t\t\t\t\t}\n\t\t\t\t\treturn sum / ( 2.0 * float( PCF_NUM_SAMPLES ) );\n\t\t\t\t}\n\n\t\t\t\tfloat PCSS ( sampler2D shadowMap, vec4 coords ) {\n\t\t\t\t\tvec2 uv = coords.xy;\n\t\t\t\t\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\n\n\t\t\t\t\tinitPoissonSamples( uv );\n\t\t\t\t\t// STEP 1: blocker search\n\t\t\t\t\tfloat avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver );\n\n\t\t\t\t\t//There are no occluders so early out (this saves filtering)\n\t\t\t\t\tif( avgBlockerDepth == -1.0 ) return 1.0;\n\n\t\t\t\t\t// STEP 2: penumbra size\n\t\t\t\t\tfloat penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );\n\t\t\t\t\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\n\t\t\t\t\t// STEP 3: filtering\n\t\t\t\t\t//return avgBlockerDepth;\n\t\t\t\t\treturn PCF_Filter( shadowMap, uv, zReceiver, filterRadius);\n\t\t\t\t}\n`;\nconst PCSS = `\n#define LIGHT_WORLD_SIZE 0.005\n\t\t\t\t#define LIGHT_FRUSTUM_WIDTH 3.75\n\t\t\t\t#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n\t\t\t\t#define NEAR_PLANE 9.5\n\n\t\t\t\t#define NUM_SAMPLES 17\n\t\t\t\t#define NUM_RINGS 11\n\t\t\t\t#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n\t\t\t\t#define PCF_NUM_SAMPLES NUM_SAMPLES\n\n\t\t\t\tvec2 poissonDisk[NUM_SAMPLES];\n\n\t\t\t\tvoid initPoissonSamples( const in vec2 randomSeed ) {\n\t\t\t\t\tfloat ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n\t\t\t\t\tfloat INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n\t\t\t\t\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n\t\t\t\t\tfloat angle = rand( randomSeed ) * PI2;\n\t\t\t\t\tfloat radius = INV_NUM_SAMPLES;\n\t\t\t\t\tfloat radiusStep = radius;\n\n\t\t\t\t\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\n\t\t\t\t\t\tpoissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );\n\t\t\t\t\t\tradius += radiusStep;\n\t\t\t\t\t\tangle += ANGLE_STEP;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n\t\t\t\t\treturn (zReceiver - zBlocker) / zBlocker;\n\t\t\t\t}\n\n\t\t\t\tfloat findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\n\t\t\t\t\t// This uses similar triangles to compute what\n\t\t\t\t\t// area of the shadow map we should search\n\t\t\t\t\tfloat searchRadius = LIGHT_SIZE_UV * ( zReceiver - NEAR_PLANE ) / zReceiver;\n\t\t\t\t\tfloat blockerDepthSum = 0.0;\n\t\t\t\t\tint numBlockers = 0;\n\n\t\t\t\t\tfor( int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++ ) {\n\t\t\t\t\t\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n\t\t\t\t\t\tif ( shadowMapDepth < zReceiver ) {\n\t\t\t\t\t\t\tblockerDepthSum += shadowMapDepth;\n\t\t\t\t\t\t\tnumBlockers ++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif( numBlockers == 0 ) return -1.0;\n\n\t\t\t\t\treturn blockerDepthSum / float( numBlockers );\n\t\t\t\t}\n\n\t\t\t\tfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {\n\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t\tfor( int i = 0; i < PCF_NUM_SAMPLES; i ++ ) {\n\t\t\t\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );\n\t\t\t\t\t\tif( zReceiver <= depth ) sum += 1.0;\n\t\t\t\t\t}\n\t\t\t\t\tfor( int i = 0; i < PCF_NUM_SAMPLES; i ++ ) {\n\t\t\t\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );\n\t\t\t\t\t\tif( zReceiver <= depth ) sum += 1.0;\n\t\t\t\t\t}\n\t\t\t\t\treturn sum / ( 2.0 * float( PCF_NUM_SAMPLES ) );\n\t\t\t\t}\n\n\t\t\t\tfloat PCSS ( sampler2D shadowMap, vec4 coords ) {\n\t\t\t\t\tvec2 uv = coords.xy;\n\t\t\t\t\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\n\n\t\t\t\t\tinitPoissonSamples( uv );\n\t\t\t\t\t// STEP 1: blocker search\n\t\t\t\t\tfloat avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver );\n\n\t\t\t\t\t//There are no occluders so early out (this saves filtering)\n\t\t\t\t\tif( avgBlockerDepth == -1.0 ) return 1.0;\n\n\t\t\t\t\t// STEP 2: penumbra size\n\t\t\t\t\tfloat penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );\n\t\t\t\t\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\n\t\t\t\t\t// STEP 3: filtering\n\t\t\t\t\t//return avgBlockerDepth;\n\t\t\t\t\treturn PCF_Filter( shadowMap, uv, zReceiver, filterRadius );\n\t\t\t\t}\n`;\nconst PCSSGetShadow = `\n return PCSS( shadowMap, shadowCoord );\n`;\n\nclass ThreeLightTest {\n  constructor() {\n    console.log(\"Three Lighting Test\");\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.sceneRenderer = new _sceneRenderer.SceneRenderer({});\n    this.boxElements = {\n      box1: document.getElementById('box-1')\n    };\n    this.overwriteShadowMap();\n    this.createGltfScene1();\n    this.sceneRenderer.resize();\n    this.raf.start();\n  }\n\n  overwriteShadowMap() {\n    var shader = THREE.ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP' + PCSS2);\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', PCSSGetShadow + '#if defined( SHADOWMAP_TYPE_PCF )');\n    THREE.ShaderChunk.shadowmap_pars_fragment = shader;\n  }\n\n  createGltfScene1() {\n    const domElement = this.boxElements.box1;\n    const scene = new THREE.Scene();\n    const camera = new THREE.PerspectiveCamera(30, domElement.offsetWidth / domElement.offsetWidth, 1, 10000);\n    camera.position.x = 7;\n    camera.position.y = 13;\n    camera.position.z = 7;\n    this.sceneRenderer.addScene({\n      resizingAlgo: 'contain',\n      resizingOptions: {\n        scalarX: 1,\n        scalarY: 1,\n        useFov: false\n      },\n      domElement: domElement,\n      scene: scene,\n      camera: camera,\n      onInit: (renderer, scene, camera) => {\n        scene.userData.sphereGroup = this.addRandomSpheres(scene);\n        scene.userData.group = this.addGround(scene);\n        const ambientLight = new THREE.AmbientLight('#FFFFFF');\n        ambientLight.intensity = 0.5;\n        scene.add(ambientLight); // Light 1\n\n        var light = new THREE.DirectionalLight(0xdfebff, 1);\n        light.position.set(2, 8, 4);\n        light.castShadow = true;\n        light.shadow.mapSize.width = 1024;\n        light.shadow.mapSize.height = 1024; // This blurs but doesn't look great.\n        // light.shadow.radius = 20;\n        // light.shadow.camera.far = 200;\n        // Adjust for blurryness\n\n        light.shadow.camera.far = 50;\n        light.shadow.camera.near = 1;\n        scene.add(light);\n        scene.add(new THREE.CameraHelper(light.shadow.camera)); // var light2 = new THREE.DirectionalLight(0xdfebff, 1);\n        // light2.position.set(0, 8, -5);\n        // light2.castShadow = true;\n        // light2.shadow.mapSize.width = 1024;\n        // light2.shadow.mapSize.height = 1024;\n        // // This blurs but doesn't look great.\n        // // light.shadow.radius = 20;\n        // // light.shadow.camera.far = 200;\n        // // Adjust for blurryness\n        // light2.shadow.camera.far = 100;\n        // scene.add(light2);\n        // scene.add(new THREE.CameraHelper(light2.shadow.camera));\n        // Add orbit controls.\n\n        var controls = new _OrbitControls.OrbitControls(camera, domElement);\n        controls.maxPolarAngle = Math.PI * 0.5;\n        controls.minDistance = 10;\n        controls.maxDistance = 75;\n        controls.target.set(0, 2.5, 0);\n        controls.update();\n        scene.userData.controls = controls;\n      },\n      onBeforeRender: (renderer, scene) => {\n        renderer.gammaInput = true;\n        renderer.gammaOutput = true;\n        renderer.shadowMap.enabled = true; // renderer.shadowMapSoft = true;\n        // renderer.shadowMapType = THREE.PCFSoftShadowMap;\n\n        scene.userData.sphereGroup.traverse(child => {\n          if ('phase' in child.userData) {\n            child.position.y = Math.abs(Math.sin(this.raf.getElapsedTime() + child.userData.phase)) * 5 + 0.3;\n          }\n        });\n      }\n    }, true);\n  }\n  /**\n   * Add shadow casting spheres.\n   */\n\n\n  addRandomSpheres(scene) {\n    const group = new THREE.Group();\n\n    for (var i = 0; i < 12; i++) {\n      var geometry = new THREE.SphereBufferGeometry(0.3, _mathf.mathf.getRandomInt(10, 50), _mathf.mathf.getRandomInt(10, 50));\n      var material;\n\n      if (i % 2 == 0) {\n        material = new THREE.MeshStandardMaterial({\n          color: Math.random() * 0xffffff\n        });\n      } else {\n        material = new THREE.MeshPhongMaterial({\n          color: Math.random() * 0xffffff\n        });\n      }\n\n      var sphere = new THREE.Mesh(geometry, material);\n      sphere.position.x = Math.random() - 0.5;\n      sphere.position.z = Math.random() - 0.5;\n      sphere.position.normalize();\n      sphere.position.multiplyScalar(Math.random() * 2 + 1);\n      sphere.castShadow = true;\n      sphere.receiveShadow = true;\n      sphere.userData.phase = Math.random() * Math.PI;\n      group.add(sphere);\n    }\n\n    scene.add(group);\n    return group;\n  }\n\n  addGround(scene) {\n    var groundMaterial = new THREE.MeshPhongMaterial({\n      color: 0xFFFFFF,\n      specular: 0xFFFFFFF\n    });\n    var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(20000, 20000, 8, 8), groundMaterial);\n    mesh.rotation.x = -Math.PI / 2;\n    mesh.receiveShadow = true;\n    scene.add(mesh);\n    mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 4, 1), groundMaterial);\n    mesh.position.y = 2;\n    mesh.castShadow = true;\n    mesh.receiveShadow = true;\n    scene.add(mesh);\n  }\n\n  onRaf() {\n    this.sceneRenderer.render();\n  }\n\n}\n\nexports.default = ThreeLightTest;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1saWdodC10ZXN0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvdGhyZWUtbGlnaHQtdGVzdC5qcz85ZDNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX0dMVEZMb2FkZXIgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvR0xURkxvYWRlclwiKTtcblxudmFyIF90aHJlZSA9IHJlcXVpcmUoXCJ0aHJlZVwiKTtcblxudmFyIFRIUkVFID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3RocmVlKTtcblxudmFyIF9PcmJpdENvbnRyb2xzID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9jb250cm9scy9PcmJpdENvbnRyb2xzXCIpO1xuXG52YXIgX3NjZW5lUmVuZGVyZXIgPSByZXF1aXJlKFwiLi4vbGliL3RocmVlZi9zY2VuZS1yZW5kZXJlclwiKTtcblxudmFyIF9tYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvbWF0aGZcIik7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX3RocmVlZiA9IHJlcXVpcmUoXCIuLi9saWIvdGhyZWVmL3RocmVlZlwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vLyBodHRwczovL3RocmVlanMub3JnL2V4YW1wbGVzL3dlYmdsX3NoYWRvd21hcF9wY3NzLmh0bWxcbmNvbnN0IFBDU1MyID0gYFxuI2RlZmluZSBMSUdIVF9XT1JMRF9TSVpFIDAuMDA1XG5cdFx0XHRcdCNkZWZpbmUgTElHSFRfRlJVU1RVTV9XSURUSCAzLjc1XG5cdFx0XHRcdCNkZWZpbmUgTElHSFRfU0laRV9VViAoTElHSFRfV09STERfU0laRSAvIExJR0hUX0ZSVVNUVU1fV0lEVEgpXG5cdFx0XHRcdCNkZWZpbmUgTkVBUl9QTEFORSA5LjVcblx0XHRcdFx0I2RlZmluZSBOVU1fU0FNUExFUyAzMFxuXHRcdFx0XHQjZGVmaW5lIE5VTV9SSU5HUyAxMFxuXHRcdFx0XHQjZGVmaW5lIEJMT0NLRVJfU0VBUkNIX05VTV9TQU1QTEVTIE5VTV9TQU1QTEVTXG5cdFx0XHRcdCNkZWZpbmUgUENGX05VTV9TQU1QTEVTIE5VTV9TQU1QTEVTXG5cblx0XHRcdFx0dmVjMiBwb2lzc29uRGlza1tOVU1fU0FNUExFU107XG5cblx0XHRcdFx0dm9pZCBpbml0UG9pc3NvblNhbXBsZXMoIGNvbnN0IGluIHZlYzIgcmFuZG9tU2VlZCApIHtcblx0XHRcdFx0XHRmbG9hdCBBTkdMRV9TVEVQID0gUEkyICogZmxvYXQoIE5VTV9SSU5HUyApIC8gZmxvYXQoIE5VTV9TQU1QTEVTICk7XG5cdFx0XHRcdFx0ZmxvYXQgSU5WX05VTV9TQU1QTEVTID0gMS4wIC8gZmxvYXQoIE5VTV9TQU1QTEVTICk7XG5cblx0XHRcdFx0XHQvLyBqc2ZpZGRsZSB0aGF0IHNob3dzIHNhbXBsZSBwYXR0ZXJuOiBodHRwczovL2pzZmlkZGxlLm5ldC9hMTZmZjFwNy9cblx0XHRcdFx0XHRmbG9hdCBhbmdsZSA9IHJhbmQoIHJhbmRvbVNlZWQgKSAqIFBJMjtcblx0XHRcdFx0XHRmbG9hdCByYWRpdXMgPSBJTlZfTlVNX1NBTVBMRVM7XG5cdFx0XHRcdFx0ZmxvYXQgcmFkaXVzU3RlcCA9IHJhZGl1cztcblxuXHRcdFx0XHRcdGZvciggaW50IGkgPSAwOyBpIDwgTlVNX1NBTVBMRVM7IGkgKysgKSB7XG5cdFx0XHRcdFx0XHRwb2lzc29uRGlza1tpXSA9IHZlYzIoIGNvcyggYW5nbGUgKSwgc2luKCBhbmdsZSApICkgKiBwb3coIHJhZGl1cywgMC43NSApO1xuXHRcdFx0XHRcdFx0cmFkaXVzICs9IHJhZGl1c1N0ZXA7XG5cdFx0XHRcdFx0XHRhbmdsZSArPSBBTkdMRV9TVEVQO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZsb2F0IHBlbnVtYnJhU2l6ZSggY29uc3QgaW4gZmxvYXQgelJlY2VpdmVyLCBjb25zdCBpbiBmbG9hdCB6QmxvY2tlciApIHsgLy8gUGFyYWxsZWwgcGxhbmUgZXN0aW1hdGlvblxuXHRcdFx0XHRcdHJldHVybiAoelJlY2VpdmVyIC0gekJsb2NrZXIpIC8gekJsb2NrZXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmbG9hdCBmaW5kQmxvY2tlciggc2FtcGxlcjJEIHNoYWRvd01hcCwgY29uc3QgaW4gdmVjMiB1diwgY29uc3QgaW4gZmxvYXQgelJlY2VpdmVyICkge1xuXHRcdFx0XHRcdC8vIFRoaXMgdXNlcyBzaW1pbGFyIHRyaWFuZ2xlcyB0byBjb21wdXRlIHdoYXRcblx0XHRcdFx0XHQvLyBhcmVhIG9mIHRoZSBzaGFkb3cgbWFwIHdlIHNob3VsZCBzZWFyY2hcblx0XHRcdFx0XHRmbG9hdCBzZWFyY2hSYWRpdXMgPSBMSUdIVF9TSVpFX1VWICogKCB6UmVjZWl2ZXIgLSBORUFSX1BMQU5FICkgLyB6UmVjZWl2ZXI7XG5cdFx0XHRcdFx0ZmxvYXQgYmxvY2tlckRlcHRoU3VtID0gMC4wO1xuXHRcdFx0XHRcdGludCBudW1CbG9ja2VycyA9IDA7XG5cblx0XHRcdFx0XHRmb3IoIGludCBpID0gMDsgaSA8IEJMT0NLRVJfU0VBUkNIX05VTV9TQU1QTEVTOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRmbG9hdCBzaGFkb3dNYXBEZXB0aCA9IHVucGFja1JHQkFUb0RlcHRoKHRleHR1cmUyRChzaGFkb3dNYXAsIHV2ICsgcG9pc3NvbkRpc2tbaV0gKiBzZWFyY2hSYWRpdXMpKTtcblx0XHRcdFx0XHRcdGlmICggc2hhZG93TWFwRGVwdGggPCB6UmVjZWl2ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdGJsb2NrZXJEZXB0aFN1bSArPSBzaGFkb3dNYXBEZXB0aDtcblx0XHRcdFx0XHRcdFx0bnVtQmxvY2tlcnMgKys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoIG51bUJsb2NrZXJzID09IDAgKSByZXR1cm4gLTEuMDtcblxuXHRcdFx0XHRcdHJldHVybiBibG9ja2VyRGVwdGhTdW0gLyBmbG9hdCggbnVtQmxvY2tlcnMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZsb2F0IFBDRl9GaWx0ZXIoc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiB1diwgZmxvYXQgelJlY2VpdmVyLCBmbG9hdCBmaWx0ZXJSYWRpdXMgKSB7XG5cdFx0XHRcdFx0ZmxvYXQgc3VtID0gMC4wO1xuXHRcdFx0XHRcdGZvciggaW50IGkgPSAwOyBpIDwgUENGX05VTV9TQU1QTEVTOyBpICsrICkge1xuXHRcdFx0XHRcdFx0ZmxvYXQgZGVwdGggPSB1bnBhY2tSR0JBVG9EZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXAsIHV2ICsgcG9pc3NvbkRpc2tbIGkgXSAqIGZpbHRlclJhZGl1cyApICk7XG5cdFx0XHRcdFx0XHRpZiggelJlY2VpdmVyIDw9IGRlcHRoICkgc3VtICs9IDEuMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBQQ0ZfTlVNX1NBTVBMRVM7IGkgKysgKSB7XG5cdFx0XHRcdFx0XHRmbG9hdCBkZXB0aCA9IHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcCwgdXYgKyAtcG9pc3NvbkRpc2tbIGkgXS55eCAqIGZpbHRlclJhZGl1cyApICk7XG5cdFx0XHRcdFx0XHRpZiggelJlY2VpdmVyIDw9IGRlcHRoICkgc3VtICs9IDEuMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHN1bSAvICggMi4wICogZmxvYXQoIFBDRl9OVU1fU0FNUExFUyApICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmbG9hdCBQQ1NTICggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjNCBjb29yZHMgKSB7XG5cdFx0XHRcdFx0dmVjMiB1diA9IGNvb3Jkcy54eTtcblx0XHRcdFx0XHRmbG9hdCB6UmVjZWl2ZXIgPSBjb29yZHMuejsgLy8gQXNzdW1lZCB0byBiZSBleWUtc3BhY2UgeiBpbiB0aGlzIGNvZGVcblxuXHRcdFx0XHRcdGluaXRQb2lzc29uU2FtcGxlcyggdXYgKTtcblx0XHRcdFx0XHQvLyBTVEVQIDE6IGJsb2NrZXIgc2VhcmNoXG5cdFx0XHRcdFx0ZmxvYXQgYXZnQmxvY2tlckRlcHRoID0gZmluZEJsb2NrZXIoIHNoYWRvd01hcCwgdXYsIHpSZWNlaXZlciApO1xuXG5cdFx0XHRcdFx0Ly9UaGVyZSBhcmUgbm8gb2NjbHVkZXJzIHNvIGVhcmx5IG91dCAodGhpcyBzYXZlcyBmaWx0ZXJpbmcpXG5cdFx0XHRcdFx0aWYoIGF2Z0Jsb2NrZXJEZXB0aCA9PSAtMS4wICkgcmV0dXJuIDEuMDtcblxuXHRcdFx0XHRcdC8vIFNURVAgMjogcGVudW1icmEgc2l6ZVxuXHRcdFx0XHRcdGZsb2F0IHBlbnVtYnJhUmF0aW8gPSBwZW51bWJyYVNpemUoIHpSZWNlaXZlciwgYXZnQmxvY2tlckRlcHRoICk7XG5cdFx0XHRcdFx0ZmxvYXQgZmlsdGVyUmFkaXVzID0gcGVudW1icmFSYXRpbyAqIExJR0hUX1NJWkVfVVYgKiBORUFSX1BMQU5FIC8gelJlY2VpdmVyO1xuXG5cdFx0XHRcdFx0Ly8gU1RFUCAzOiBmaWx0ZXJpbmdcblx0XHRcdFx0XHQvL3JldHVybiBhdmdCbG9ja2VyRGVwdGg7XG5cdFx0XHRcdFx0cmV0dXJuIFBDRl9GaWx0ZXIoIHNoYWRvd01hcCwgdXYsIHpSZWNlaXZlciwgZmlsdGVyUmFkaXVzKTtcblx0XHRcdFx0fVxuYDtcbmNvbnN0IFBDU1MgPSBgXG4jZGVmaW5lIExJR0hUX1dPUkxEX1NJWkUgMC4wMDVcblx0XHRcdFx0I2RlZmluZSBMSUdIVF9GUlVTVFVNX1dJRFRIIDMuNzVcblx0XHRcdFx0I2RlZmluZSBMSUdIVF9TSVpFX1VWIChMSUdIVF9XT1JMRF9TSVpFIC8gTElHSFRfRlJVU1RVTV9XSURUSClcblx0XHRcdFx0I2RlZmluZSBORUFSX1BMQU5FIDkuNVxuXG5cdFx0XHRcdCNkZWZpbmUgTlVNX1NBTVBMRVMgMTdcblx0XHRcdFx0I2RlZmluZSBOVU1fUklOR1MgMTFcblx0XHRcdFx0I2RlZmluZSBCTE9DS0VSX1NFQVJDSF9OVU1fU0FNUExFUyBOVU1fU0FNUExFU1xuXHRcdFx0XHQjZGVmaW5lIFBDRl9OVU1fU0FNUExFUyBOVU1fU0FNUExFU1xuXG5cdFx0XHRcdHZlYzIgcG9pc3NvbkRpc2tbTlVNX1NBTVBMRVNdO1xuXG5cdFx0XHRcdHZvaWQgaW5pdFBvaXNzb25TYW1wbGVzKCBjb25zdCBpbiB2ZWMyIHJhbmRvbVNlZWQgKSB7XG5cdFx0XHRcdFx0ZmxvYXQgQU5HTEVfU1RFUCA9IFBJMiAqIGZsb2F0KCBOVU1fUklOR1MgKSAvIGZsb2F0KCBOVU1fU0FNUExFUyApO1xuXHRcdFx0XHRcdGZsb2F0IElOVl9OVU1fU0FNUExFUyA9IDEuMCAvIGZsb2F0KCBOVU1fU0FNUExFUyApO1xuXG5cdFx0XHRcdFx0Ly8ganNmaWRkbGUgdGhhdCBzaG93cyBzYW1wbGUgcGF0dGVybjogaHR0cHM6Ly9qc2ZpZGRsZS5uZXQvYTE2ZmYxcDcvXG5cdFx0XHRcdFx0ZmxvYXQgYW5nbGUgPSByYW5kKCByYW5kb21TZWVkICkgKiBQSTI7XG5cdFx0XHRcdFx0ZmxvYXQgcmFkaXVzID0gSU5WX05VTV9TQU1QTEVTO1xuXHRcdFx0XHRcdGZsb2F0IHJhZGl1c1N0ZXAgPSByYWRpdXM7XG5cblx0XHRcdFx0XHRmb3IoIGludCBpID0gMDsgaSA8IE5VTV9TQU1QTEVTOyBpICsrICkge1xuXHRcdFx0XHRcdFx0cG9pc3NvbkRpc2tbaV0gPSB2ZWMyKCBjb3MoIGFuZ2xlICksIHNpbiggYW5nbGUgKSApICogcG93KCByYWRpdXMsIDAuNzUgKTtcblx0XHRcdFx0XHRcdHJhZGl1cyArPSByYWRpdXNTdGVwO1xuXHRcdFx0XHRcdFx0YW5nbGUgKz0gQU5HTEVfU1RFUDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmbG9hdCBwZW51bWJyYVNpemUoIGNvbnN0IGluIGZsb2F0IHpSZWNlaXZlciwgY29uc3QgaW4gZmxvYXQgekJsb2NrZXIgKSB7IC8vIFBhcmFsbGVsIHBsYW5lIGVzdGltYXRpb25cblx0XHRcdFx0XHRyZXR1cm4gKHpSZWNlaXZlciAtIHpCbG9ja2VyKSAvIHpCbG9ja2VyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmxvYXQgZmluZEJsb2NrZXIoIHNhbXBsZXIyRCBzaGFkb3dNYXAsIGNvbnN0IGluIHZlYzIgdXYsIGNvbnN0IGluIGZsb2F0IHpSZWNlaXZlciApIHtcblx0XHRcdFx0XHQvLyBUaGlzIHVzZXMgc2ltaWxhciB0cmlhbmdsZXMgdG8gY29tcHV0ZSB3aGF0XG5cdFx0XHRcdFx0Ly8gYXJlYSBvZiB0aGUgc2hhZG93IG1hcCB3ZSBzaG91bGQgc2VhcmNoXG5cdFx0XHRcdFx0ZmxvYXQgc2VhcmNoUmFkaXVzID0gTElHSFRfU0laRV9VViAqICggelJlY2VpdmVyIC0gTkVBUl9QTEFORSApIC8gelJlY2VpdmVyO1xuXHRcdFx0XHRcdGZsb2F0IGJsb2NrZXJEZXB0aFN1bSA9IDAuMDtcblx0XHRcdFx0XHRpbnQgbnVtQmxvY2tlcnMgPSAwO1xuXG5cdFx0XHRcdFx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBCTE9DS0VSX1NFQVJDSF9OVU1fU0FNUExFUzsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZmxvYXQgc2hhZG93TWFwRGVwdGggPSB1bnBhY2tSR0JBVG9EZXB0aCh0ZXh0dXJlMkQoc2hhZG93TWFwLCB1diArIHBvaXNzb25EaXNrW2ldICogc2VhcmNoUmFkaXVzKSk7XG5cdFx0XHRcdFx0XHRpZiAoIHNoYWRvd01hcERlcHRoIDwgelJlY2VpdmVyICkge1xuXHRcdFx0XHRcdFx0XHRibG9ja2VyRGVwdGhTdW0gKz0gc2hhZG93TWFwRGVwdGg7XG5cdFx0XHRcdFx0XHRcdG51bUJsb2NrZXJzICsrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmKCBudW1CbG9ja2VycyA9PSAwICkgcmV0dXJuIC0xLjA7XG5cblx0XHRcdFx0XHRyZXR1cm4gYmxvY2tlckRlcHRoU3VtIC8gZmxvYXQoIG51bUJsb2NrZXJzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmbG9hdCBQQ0ZfRmlsdGVyKHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgdXYsIGZsb2F0IHpSZWNlaXZlciwgZmxvYXQgZmlsdGVyUmFkaXVzICkge1xuXHRcdFx0XHRcdGZsb2F0IHN1bSA9IDAuMDtcblx0XHRcdFx0XHRmb3IoIGludCBpID0gMDsgaSA8IFBDRl9OVU1fU0FNUExFUzsgaSArKyApIHtcblx0XHRcdFx0XHRcdGZsb2F0IGRlcHRoID0gdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwLCB1diArIHBvaXNzb25EaXNrWyBpIF0gKiBmaWx0ZXJSYWRpdXMgKSApO1xuXHRcdFx0XHRcdFx0aWYoIHpSZWNlaXZlciA8PSBkZXB0aCApIHN1bSArPSAxLjA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvciggaW50IGkgPSAwOyBpIDwgUENGX05VTV9TQU1QTEVTOyBpICsrICkge1xuXHRcdFx0XHRcdFx0ZmxvYXQgZGVwdGggPSB1bnBhY2tSR0JBVG9EZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXAsIHV2ICsgLXBvaXNzb25EaXNrWyBpIF0ueXggKiBmaWx0ZXJSYWRpdXMgKSApO1xuXHRcdFx0XHRcdFx0aWYoIHpSZWNlaXZlciA8PSBkZXB0aCApIHN1bSArPSAxLjA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBzdW0gLyAoIDIuMCAqIGZsb2F0KCBQQ0ZfTlVNX1NBTVBMRVMgKSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmxvYXQgUENTUyAoIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzQgY29vcmRzICkge1xuXHRcdFx0XHRcdHZlYzIgdXYgPSBjb29yZHMueHk7XG5cdFx0XHRcdFx0ZmxvYXQgelJlY2VpdmVyID0gY29vcmRzLno7IC8vIEFzc3VtZWQgdG8gYmUgZXllLXNwYWNlIHogaW4gdGhpcyBjb2RlXG5cblx0XHRcdFx0XHRpbml0UG9pc3NvblNhbXBsZXMoIHV2ICk7XG5cdFx0XHRcdFx0Ly8gU1RFUCAxOiBibG9ja2VyIHNlYXJjaFxuXHRcdFx0XHRcdGZsb2F0IGF2Z0Jsb2NrZXJEZXB0aCA9IGZpbmRCbG9ja2VyKCBzaGFkb3dNYXAsIHV2LCB6UmVjZWl2ZXIgKTtcblxuXHRcdFx0XHRcdC8vVGhlcmUgYXJlIG5vIG9jY2x1ZGVycyBzbyBlYXJseSBvdXQgKHRoaXMgc2F2ZXMgZmlsdGVyaW5nKVxuXHRcdFx0XHRcdGlmKCBhdmdCbG9ja2VyRGVwdGggPT0gLTEuMCApIHJldHVybiAxLjA7XG5cblx0XHRcdFx0XHQvLyBTVEVQIDI6IHBlbnVtYnJhIHNpemVcblx0XHRcdFx0XHRmbG9hdCBwZW51bWJyYVJhdGlvID0gcGVudW1icmFTaXplKCB6UmVjZWl2ZXIsIGF2Z0Jsb2NrZXJEZXB0aCApO1xuXHRcdFx0XHRcdGZsb2F0IGZpbHRlclJhZGl1cyA9IHBlbnVtYnJhUmF0aW8gKiBMSUdIVF9TSVpFX1VWICogTkVBUl9QTEFORSAvIHpSZWNlaXZlcjtcblxuXHRcdFx0XHRcdC8vIFNURVAgMzogZmlsdGVyaW5nXG5cdFx0XHRcdFx0Ly9yZXR1cm4gYXZnQmxvY2tlckRlcHRoO1xuXHRcdFx0XHRcdHJldHVybiBQQ0ZfRmlsdGVyKCBzaGFkb3dNYXAsIHV2LCB6UmVjZWl2ZXIsIGZpbHRlclJhZGl1cyApO1xuXHRcdFx0XHR9XG5gO1xuY29uc3QgUENTU0dldFNoYWRvdyA9IGBcbiByZXR1cm4gUENTUyggc2hhZG93TWFwLCBzaGFkb3dDb29yZCApO1xuYDtcblxuY2xhc3MgVGhyZWVMaWdodFRlc3Qge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZyhcIlRocmVlIExpZ2h0aW5nIFRlc3RcIik7XG4gICAgdGhpcy5yYWYgPSBuZXcgX3JhZi5SYWYodGhpcy5vblJhZi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNjZW5lUmVuZGVyZXIgPSBuZXcgX3NjZW5lUmVuZGVyZXIuU2NlbmVSZW5kZXJlcih7fSk7XG4gICAgdGhpcy5ib3hFbGVtZW50cyA9IHtcbiAgICAgIGJveDE6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib3gtMScpXG4gICAgfTtcbiAgICB0aGlzLm92ZXJ3cml0ZVNoYWRvd01hcCgpO1xuICAgIHRoaXMuY3JlYXRlR2x0ZlNjZW5lMSgpO1xuICAgIHRoaXMuc2NlbmVSZW5kZXJlci5yZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICB9XG5cbiAgb3ZlcndyaXRlU2hhZG93TWFwKCkge1xuICAgIHZhciBzaGFkZXIgPSBUSFJFRS5TaGFkZXJDaHVuay5zaGFkb3dtYXBfcGFyc19mcmFnbWVudDtcbiAgICBzaGFkZXIgPSBzaGFkZXIucmVwbGFjZSgnI2lmZGVmIFVTRV9TSEFET1dNQVAnLCAnI2lmZGVmIFVTRV9TSEFET1dNQVAnICsgUENTUzIpO1xuICAgIHNoYWRlciA9IHNoYWRlci5yZXBsYWNlKCcjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICknLCBQQ1NTR2V0U2hhZG93ICsgJyNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKScpO1xuICAgIFRIUkVFLlNoYWRlckNodW5rLnNoYWRvd21hcF9wYXJzX2ZyYWdtZW50ID0gc2hhZGVyO1xuICB9XG5cbiAgY3JlYXRlR2x0ZlNjZW5lMSgpIHtcbiAgICBjb25zdCBkb21FbGVtZW50ID0gdGhpcy5ib3hFbGVtZW50cy5ib3gxO1xuICAgIGNvbnN0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgY29uc3QgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDMwLCBkb21FbGVtZW50Lm9mZnNldFdpZHRoIC8gZG9tRWxlbWVudC5vZmZzZXRXaWR0aCwgMSwgMTAwMDApO1xuICAgIGNhbWVyYS5wb3NpdGlvbi54ID0gNztcbiAgICBjYW1lcmEucG9zaXRpb24ueSA9IDEzO1xuICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gNztcbiAgICB0aGlzLnNjZW5lUmVuZGVyZXIuYWRkU2NlbmUoe1xuICAgICAgcmVzaXppbmdBbGdvOiAnY29udGFpbicsXG4gICAgICByZXNpemluZ09wdGlvbnM6IHtcbiAgICAgICAgc2NhbGFyWDogMSxcbiAgICAgICAgc2NhbGFyWTogMSxcbiAgICAgICAgdXNlRm92OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGRvbUVsZW1lbnQ6IGRvbUVsZW1lbnQsXG4gICAgICBzY2VuZTogc2NlbmUsXG4gICAgICBjYW1lcmE6IGNhbWVyYSxcbiAgICAgIG9uSW5pdDogKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhKSA9PiB7XG4gICAgICAgIHNjZW5lLnVzZXJEYXRhLnNwaGVyZUdyb3VwID0gdGhpcy5hZGRSYW5kb21TcGhlcmVzKHNjZW5lKTtcbiAgICAgICAgc2NlbmUudXNlckRhdGEuZ3JvdXAgPSB0aGlzLmFkZEdyb3VuZChzY2VuZSk7XG4gICAgICAgIGNvbnN0IGFtYmllbnRMaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoJyNGRkZGRkYnKTtcbiAgICAgICAgYW1iaWVudExpZ2h0LmludGVuc2l0eSA9IDAuNTtcbiAgICAgICAgc2NlbmUuYWRkKGFtYmllbnRMaWdodCk7IC8vIExpZ2h0IDFcblxuICAgICAgICB2YXIgbGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweGRmZWJmZiwgMSk7XG4gICAgICAgIGxpZ2h0LnBvc2l0aW9uLnNldCgyLCA4LCA0KTtcbiAgICAgICAgbGlnaHQuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgIGxpZ2h0LnNoYWRvdy5tYXBTaXplLndpZHRoID0gMTAyNDtcbiAgICAgICAgbGlnaHQuc2hhZG93Lm1hcFNpemUuaGVpZ2h0ID0gMTAyNDsgLy8gVGhpcyBibHVycyBidXQgZG9lc24ndCBsb29rIGdyZWF0LlxuICAgICAgICAvLyBsaWdodC5zaGFkb3cucmFkaXVzID0gMjA7XG4gICAgICAgIC8vIGxpZ2h0LnNoYWRvdy5jYW1lcmEuZmFyID0gMjAwO1xuICAgICAgICAvLyBBZGp1c3QgZm9yIGJsdXJyeW5lc3NcblxuICAgICAgICBsaWdodC5zaGFkb3cuY2FtZXJhLmZhciA9IDUwO1xuICAgICAgICBsaWdodC5zaGFkb3cuY2FtZXJhLm5lYXIgPSAxO1xuICAgICAgICBzY2VuZS5hZGQobGlnaHQpO1xuICAgICAgICBzY2VuZS5hZGQobmV3IFRIUkVFLkNhbWVyYUhlbHBlcihsaWdodC5zaGFkb3cuY2FtZXJhKSk7IC8vIHZhciBsaWdodDIgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweGRmZWJmZiwgMSk7XG4gICAgICAgIC8vIGxpZ2h0Mi5wb3NpdGlvbi5zZXQoMCwgOCwgLTUpO1xuICAgICAgICAvLyBsaWdodDIuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgIC8vIGxpZ2h0Mi5zaGFkb3cubWFwU2l6ZS53aWR0aCA9IDEwMjQ7XG4gICAgICAgIC8vIGxpZ2h0Mi5zaGFkb3cubWFwU2l6ZS5oZWlnaHQgPSAxMDI0O1xuICAgICAgICAvLyAvLyBUaGlzIGJsdXJzIGJ1dCBkb2Vzbid0IGxvb2sgZ3JlYXQuXG4gICAgICAgIC8vIC8vIGxpZ2h0LnNoYWRvdy5yYWRpdXMgPSAyMDtcbiAgICAgICAgLy8gLy8gbGlnaHQuc2hhZG93LmNhbWVyYS5mYXIgPSAyMDA7XG4gICAgICAgIC8vIC8vIEFkanVzdCBmb3IgYmx1cnJ5bmVzc1xuICAgICAgICAvLyBsaWdodDIuc2hhZG93LmNhbWVyYS5mYXIgPSAxMDA7XG4gICAgICAgIC8vIHNjZW5lLmFkZChsaWdodDIpO1xuICAgICAgICAvLyBzY2VuZS5hZGQobmV3IFRIUkVFLkNhbWVyYUhlbHBlcihsaWdodDIuc2hhZG93LmNhbWVyYSkpO1xuICAgICAgICAvLyBBZGQgb3JiaXQgY29udHJvbHMuXG5cbiAgICAgICAgdmFyIGNvbnRyb2xzID0gbmV3IF9PcmJpdENvbnRyb2xzLk9yYml0Q29udHJvbHMoY2FtZXJhLCBkb21FbGVtZW50KTtcbiAgICAgICAgY29udHJvbHMubWF4UG9sYXJBbmdsZSA9IE1hdGguUEkgKiAwLjU7XG4gICAgICAgIGNvbnRyb2xzLm1pbkRpc3RhbmNlID0gMTA7XG4gICAgICAgIGNvbnRyb2xzLm1heERpc3RhbmNlID0gNzU7XG4gICAgICAgIGNvbnRyb2xzLnRhcmdldC5zZXQoMCwgMi41LCAwKTtcbiAgICAgICAgY29udHJvbHMudXBkYXRlKCk7XG4gICAgICAgIHNjZW5lLnVzZXJEYXRhLmNvbnRyb2xzID0gY29udHJvbHM7XG4gICAgICB9LFxuICAgICAgb25CZWZvcmVSZW5kZXI6IChyZW5kZXJlciwgc2NlbmUpID0+IHtcbiAgICAgICAgcmVuZGVyZXIuZ2FtbWFJbnB1dCA9IHRydWU7XG4gICAgICAgIHJlbmRlcmVyLmdhbW1hT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSB0cnVlOyAvLyByZW5kZXJlci5zaGFkb3dNYXBTb2Z0ID0gdHJ1ZTtcbiAgICAgICAgLy8gcmVuZGVyZXIuc2hhZG93TWFwVHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG5cbiAgICAgICAgc2NlbmUudXNlckRhdGEuc3BoZXJlR3JvdXAudHJhdmVyc2UoY2hpbGQgPT4ge1xuICAgICAgICAgIGlmICgncGhhc2UnIGluIGNoaWxkLnVzZXJEYXRhKSB7XG4gICAgICAgICAgICBjaGlsZC5wb3NpdGlvbi55ID0gTWF0aC5hYnMoTWF0aC5zaW4odGhpcy5yYWYuZ2V0RWxhcHNlZFRpbWUoKSArIGNoaWxkLnVzZXJEYXRhLnBoYXNlKSkgKiA1ICsgMC4zO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBzaGFkb3cgY2FzdGluZyBzcGhlcmVzLlxuICAgKi9cblxuXG4gIGFkZFJhbmRvbVNwaGVyZXMoc2NlbmUpIHtcbiAgICBjb25zdCBncm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkoMC4zLCBfbWF0aGYubWF0aGYuZ2V0UmFuZG9tSW50KDEwLCA1MCksIF9tYXRoZi5tYXRoZi5nZXRSYW5kb21JbnQoMTAsIDUwKSk7XG4gICAgICB2YXIgbWF0ZXJpYWw7XG5cbiAgICAgIGlmIChpICUgMiA9PSAwKSB7XG4gICAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgICAgICBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoe1xuICAgICAgICAgIGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgc3BoZXJlLnBvc2l0aW9uLnggPSBNYXRoLnJhbmRvbSgpIC0gMC41O1xuICAgICAgc3BoZXJlLnBvc2l0aW9uLnogPSBNYXRoLnJhbmRvbSgpIC0gMC41O1xuICAgICAgc3BoZXJlLnBvc2l0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgc3BoZXJlLnBvc2l0aW9uLm11bHRpcGx5U2NhbGFyKE1hdGgucmFuZG9tKCkgKiAyICsgMSk7XG4gICAgICBzcGhlcmUuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICBzcGhlcmUucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gICAgICBzcGhlcmUudXNlckRhdGEucGhhc2UgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSTtcbiAgICAgIGdyb3VwLmFkZChzcGhlcmUpO1xuICAgIH1cblxuICAgIHNjZW5lLmFkZChncm91cCk7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9XG5cbiAgYWRkR3JvdW5kKHNjZW5lKSB7XG4gICAgdmFyIGdyb3VuZE1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAweEZGRkZGRixcbiAgICAgIHNwZWN1bGFyOiAweEZGRkZGRkZcbiAgICB9KTtcbiAgICB2YXIgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KDIwMDAwLCAyMDAwMCwgOCwgOCksIGdyb3VuZE1hdGVyaWFsKTtcbiAgICBtZXNoLnJvdGF0aW9uLnggPSAtTWF0aC5QSSAvIDI7XG4gICAgbWVzaC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcbiAgICBzY2VuZS5hZGQobWVzaCk7XG4gICAgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKG5ldyBUSFJFRS5Cb3hCdWZmZXJHZW9tZXRyeSgxLCA0LCAxKSwgZ3JvdW5kTWF0ZXJpYWwpO1xuICAgIG1lc2gucG9zaXRpb24ueSA9IDI7XG4gICAgbWVzaC5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICBtZXNoLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgIHNjZW5lLmFkZChtZXNoKTtcbiAgfVxuXG4gIG9uUmFmKCkge1xuICAgIHRoaXMuc2NlbmVSZW5kZXJlci5yZW5kZXIoKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRocmVlTGlnaHRUZXN0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/three-light-test.js\n");

/***/ }),

/***/ "./examples/three-light-test2.js":
/*!***************************************!*\
  !*** ./examples/three-light-test2.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _GLTFLoader = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _OrbitControls = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n\nvar _sceneRenderer = __webpack_require__(/*! ../lib/threef/scene-renderer */ \"./lib/threef/scene-renderer.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _threef = __webpack_require__(/*! ../lib/threef/threef */ \"./lib/threef/threef.js\");\n\nvar _deguMathf = __webpack_require__(/*! ../lib/shaders/three-shader-chunks/degu-mathf */ \"./lib/shaders/three-shader-chunks/degu-mathf.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n// Import shader chunks\n(0, _deguMathf.deguMathf)(THREE);\nconst vshader = `\n#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvarying vec3 vPosition;\nvarying vec2 v_uv;\nvarying vec3 vWorldNormal;\nvarying mat4 vModelMatrix;\n\nvoid main() {\n  vPosition = position;\n  v_uv = uv;\n\n//   vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);\n  vModelMatrix = modelMatrix;\n\n  #include <begin_vertex>\n  #include <project_vertex>\n  #include <worldpos_vertex>\n  #include <shadowmap_vertex>\n  #include <fog_vertex>\n}\n`;\nconst fshader = `\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <dithering_pars_fragment>\n\n\n// https://github.com/mrdoob/three.js/blob/master/src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl.js\n// Get the shadow value at specific coordinates.\nfloat getCustomShadowMask(vec2 offset) {\n    float shadow = 1.0;\n\n    #ifdef USE_SHADOWMAP\n    #if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n        directionalLight = directionalLights[ i ];\n\n        // Get the shadow value.\n        float s = 1.0;\n        vec4 coords = vDirectionalShadowCoord[ i ];\n        coords.x += offset.x;\n        coords.z += -offset.y;\n        s =\n           getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize,\n           directionalLight.shadowBias,\n           directionalLight.shadowRadius,\n           coords\n          );\n\n        shadow *= s;\n\t}\n\t#endif\n\n    #endif\n\n\treturn shadow;\n}\n\n\n\nuniform vec2 u_resolution;\nvarying vec2 v_uv;\nvarying vec3 vPosition;\nvarying vec3 vWorldNormal;\nvarying mat4 vModelMatrix;\n\nvoid main() {\n  float zReceiver = vPosition.z;\n  vec3 worldPosition = ( vModelMatrix * vec4( vPosition, 1.0 )).xyz;\n  vec2 uv = vec2(gl_FragCoord.xy / u_resolution.xy);\n\n  vec3 finalColor = vec3(1.0, 1.0, 1.0);\n  vec3 shadowColor = vec3(0, 0, 0);\n  float shadowPower = 0.1;\n  float shadowStrength = 1.0;\n\n  for ( int i = 0; i < 20; i ++ ) {\n    vec2 offset = vec2(\n            float(i) * 0.01,\n            float(i) * 0.01);\n\n    float s = mix(\n        getCustomShadowMask(vec2(0.0, 0.0)),\n        getCustomShadowMask(offset),\n        0.5);\n\n    shadowStrength *= s;\n  }\n\n//   shadowStrength *= shadowPower;\n\n\n  vec3 color = mix(finalColor, shadowColor, shadowStrength);\n\n  vec2 direction = vec2(1.0, 1.0);\n\n  gl_FragColor = vec4(color, 1.0);\n  #include <fog_fragment>\n  #include <dithering_fragment>\n}\n`;\n\nclass ThreeLightTest2 {\n  constructor() {\n    console.log(\"Three Lighting Test2\");\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.sceneRenderer = new _sceneRenderer.SceneRenderer({});\n    this.boxElements = {\n      box1: document.getElementById('box-1')\n    };\n    this.createGltfScene1();\n    this.sceneRenderer.resize();\n    this.raf.start();\n  }\n\n  createGltfScene1() {\n    const domElement = this.boxElements.box1;\n    const scene = new THREE.Scene();\n    const camera = new THREE.PerspectiveCamera(30, domElement.offsetWidth / domElement.offsetWidth, 1, 10000);\n    camera.position.x = 7;\n    camera.position.y = 13;\n    camera.position.z = 7; // Setup uniforms.\n\n    this.uniforms = {};\n    this.uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib[\"common\"], THREE.UniformsLib[\"lights\"], THREE.UniformsLib[\"fog\"]]); // this.uniforms.u_light = { value: new THREE.Vector3(0.5, 0.8, 0.1) };\n    // this.uniforms.u_resolution = { value: new THREE.Vector2(1.0, 1.0) };\n    // this.uniforms.u_color = { value: new THREE.Color(0xaa6611) };\n    // this.uniforms.u_diffuse_map = { value: new THREE.TextureLoader().load('./public/bricks-diffuse3.png') };\n    // this.uniforms.u_normal_map = { value: new THREE.TextureLoader().load('./public/bricks-normal3.png') };\n    // this.uniforms.u_time = { value: 0.0 };\n\n    this.uniforms.u_resolution = {\n      value: {\n        x: 0.0,\n        y: 0.0\n      }\n    }; // Primary shader maaterial\n\n    this.material = new THREE.ShaderMaterial({\n      uniforms: this.uniforms,\n      vertexShader: vshader,\n      fragmentShader: fshader,\n      lights: true,\n      wireframe: false,\n      dithering: true,\n      transparent: true\n    });\n    this.sceneRenderer.addScene({\n      resizingAlgo: 'contain',\n      resizingOptions: {\n        scalarX: 1,\n        scalarY: 1,\n        useFov: false\n      },\n      domElement: domElement,\n      scene: scene,\n      camera: camera,\n      onInit: (renderer, scene, camera) => {\n        scene.userData.sphereGroup = this.addRandomSpheres(scene);\n        scene.userData.group = this.addGround(scene);\n        const ambientLight = new THREE.AmbientLight('#FFFFFF');\n        ambientLight.intensity = 0.5;\n        scene.add(ambientLight); // Light 1\n\n        var light = new THREE.DirectionalLight(0xdfebff, 1);\n        light.position.set(2, 8, 4);\n        light.castShadow = true;\n        light.shadow.mapSize.set(2048, 2048); // This blurs but doesn't look great.\n        // light.shadow.radius = 1;\n        // light.shadow.camera.far = 200;\n\n        light.shadowDarkness = 0.5; // Adjust for blurryness\n\n        light.shadow.camera.far = 50;\n        light.shadow.camera.near = 1;\n        scene.add(light);\n        scene.add(new THREE.CameraHelper(light.shadow.camera));\n        renderer.gammaInput = true;\n        renderer.gammaOutput = true;\n        renderer.shadowMap.enabled = true;\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        renderer.shadowMap.soft = true;\n        renderer.shadowMap.needsUpdate = true;\n        renderer.shadowMap.bias = 0.000001; // Add orbit controls.\n\n        var controls = new _OrbitControls.OrbitControls(camera, domElement);\n        controls.maxPolarAngle = Math.PI * 0.5;\n        controls.minDistance = 10;\n        controls.maxDistance = 75;\n        controls.target.set(0, 2.5, 0);\n        controls.update();\n        scene.userData.controls = controls;\n      },\n      onResize: (renderer, scene) => {\n        this.uniforms.u_resolution.value.x = domElement.offsetWidth;\n        this.uniforms.u_resolution.value.y = domElement.offsetHeight;\n      },\n      onBeforeRender: (renderer, scene) => {\n        // if (this.uniforms) {\n        //     this.uniforms.u_time.value += this.raf.getDelta(true);\n        // }\n        scene.userData.sphereGroup.traverse(child => {\n          if ('phase' in child.userData) {\n            child.position.y = Math.abs(Math.sin(this.raf.getElapsedTime() + child.userData.phase)) * 5 + 0.3;\n          }\n        });\n      }\n    }, true);\n  }\n  /**\n   * Add shadow casting spheres.\n   */\n\n\n  addRandomSpheres(scene) {\n    const group = new THREE.Group();\n\n    for (var i = 0; i < 2; i++) {\n      var geometry = new THREE.SphereBufferGeometry(0.3, _mathf.mathf.getRandomInt(10, 50), _mathf.mathf.getRandomInt(10, 50));\n      var material;\n\n      if (i % 2 == 0) {\n        material = new THREE.MeshStandardMaterial({\n          color: Math.random() * 0xffffff\n        });\n      } else {\n        material = new THREE.MeshPhongMaterial({\n          color: Math.random() * 0xffffff\n        });\n      }\n\n      var sphere = new THREE.Mesh(geometry, material);\n      sphere.position.x = Math.random() - 0.5;\n      sphere.position.z = Math.random() - 0.5;\n      sphere.position.normalize();\n      sphere.position.multiplyScalar(Math.random() * 2 + 1);\n      sphere.castShadow = true;\n      sphere.receiveShadow = true;\n      sphere.userData.phase = Math.random() * Math.PI;\n      group.add(sphere);\n    }\n\n    scene.add(group);\n    return group;\n  }\n\n  addGround(scene) {\n    var groundMaterial = new THREE.MeshPhongMaterial({\n      color: 0xFFFFFF,\n      specular: 0xFFFFFFF\n    });\n    var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(20000, 20000, 8, 8), this.material);\n    mesh.rotation.x = -Math.PI / 2;\n    mesh.receiveShadow = true;\n    scene.add(mesh);\n    mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 4, 1), groundMaterial);\n    mesh.position.y = 2;\n    mesh.castShadow = true;\n    mesh.receiveShadow = true;\n    scene.add(mesh);\n  }\n\n  onRaf() {\n    this.sceneRenderer.render();\n  }\n\n}\n\nexports.default = ThreeLightTest2;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1saWdodC10ZXN0Mi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3RocmVlLWxpZ2h0LXRlc3QyLmpzPzk2MzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfR0xURkxvYWRlciA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9HTFRGTG9hZGVyXCIpO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX09yYml0Q29udHJvbHMgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL2NvbnRyb2xzL09yYml0Q29udHJvbHNcIik7XG5cbnZhciBfc2NlbmVSZW5kZXJlciA9IHJlcXVpcmUoXCIuLi9saWIvdGhyZWVmL3NjZW5lLXJlbmRlcmVyXCIpO1xuXG52YXIgX21hdGhmID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9tYXRoZlwiKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfdGhyZWVmID0gcmVxdWlyZShcIi4uL2xpYi90aHJlZWYvdGhyZWVmXCIpO1xuXG52YXIgX2RlZ3VNYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvc2hhZGVycy90aHJlZS1zaGFkZXItY2h1bmtzL2RlZ3UtbWF0aGZcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLy8gSW1wb3J0IHNoYWRlciBjaHVua3NcbigwLCBfZGVndU1hdGhmLmRlZ3VNYXRoZikoVEhSRUUpO1xuY29uc3QgdnNoYWRlciA9IGBcbiNpbmNsdWRlIDxjb21tb24+XG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cblxudmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcbnZhcnlpbmcgdmVjMiB2X3V2O1xudmFyeWluZyB2ZWMzIHZXb3JsZE5vcm1hbDtcbnZhcnlpbmcgbWF0NCB2TW9kZWxNYXRyaXg7XG5cbnZvaWQgbWFpbigpIHtcbiAgdlBvc2l0aW9uID0gcG9zaXRpb247XG4gIHZfdXYgPSB1djtcblxuLy8gICB2V29ybGROb3JtYWwgPSBub3JtYWxpemUoKG1vZGVsTWF0cml4ICogdmVjNChub3JtYWwsIDAuMCkpLnh5eik7XG4gIHZNb2RlbE1hdHJpeCA9IG1vZGVsTWF0cml4O1xuXG4gICNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XG4gICNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cbiAgI2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cbiAgI2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XG4gICNpbmNsdWRlIDxmb2dfdmVydGV4PlxufVxuYDtcbmNvbnN0IGZzaGFkZXIgPSBgXG4jaW5jbHVkZSA8Y29tbW9uPlxuI2luY2x1ZGUgPHBhY2tpbmc+XG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8YnNkZnM+XG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XG4jaW5jbHVkZSA8c2hhZG93bWFza19wYXJzX2ZyYWdtZW50PlxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxuXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi9tYXN0ZXIvc3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hc2tfcGFyc19mcmFnbWVudC5nbHNsLmpzXG4vLyBHZXQgdGhlIHNoYWRvdyB2YWx1ZSBhdCBzcGVjaWZpYyBjb29yZGluYXRlcy5cbmZsb2F0IGdldEN1c3RvbVNoYWRvd01hc2sodmVjMiBvZmZzZXQpIHtcbiAgICBmbG9hdCBzaGFkb3cgPSAxLjA7XG5cbiAgICAjaWZkZWYgVVNFX1NIQURPV01BUFxuICAgICNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXG5cdERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodDtcblx0I3ByYWdtYSB1bnJvbGxfbG9vcFxuXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XG4gICAgICAgIGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdO1xuXG4gICAgICAgIC8vIEdldCB0aGUgc2hhZG93IHZhbHVlLlxuICAgICAgICBmbG9hdCBzID0gMS4wO1xuICAgICAgICB2ZWM0IGNvb3JkcyA9IHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF07XG4gICAgICAgIGNvb3Jkcy54ICs9IG9mZnNldC54O1xuICAgICAgICBjb29yZHMueiArPSAtb2Zmc2V0Lnk7XG4gICAgICAgIHMgPVxuICAgICAgICAgICBnZXRTaGFkb3coIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBpIF0sIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93TWFwU2l6ZSxcbiAgICAgICAgICAgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dCaWFzLFxuICAgICAgICAgICBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd1JhZGl1cyxcbiAgICAgICAgICAgY29vcmRzXG4gICAgICAgICAgKTtcblxuICAgICAgICBzaGFkb3cgKj0gcztcblx0fVxuXHQjZW5kaWZcblxuICAgICNlbmRpZlxuXG5cdHJldHVybiBzaGFkb3c7XG59XG5cblxuXG51bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xudmFyeWluZyB2ZWMyIHZfdXY7XG52YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xudmFyeWluZyB2ZWMzIHZXb3JsZE5vcm1hbDtcbnZhcnlpbmcgbWF0NCB2TW9kZWxNYXRyaXg7XG5cbnZvaWQgbWFpbigpIHtcbiAgZmxvYXQgelJlY2VpdmVyID0gdlBvc2l0aW9uLno7XG4gIHZlYzMgd29ybGRQb3NpdGlvbiA9ICggdk1vZGVsTWF0cml4ICogdmVjNCggdlBvc2l0aW9uLCAxLjAgKSkueHl6O1xuICB2ZWMyIHV2ID0gdmVjMihnbF9GcmFnQ29vcmQueHkgLyB1X3Jlc29sdXRpb24ueHkpO1xuXG4gIHZlYzMgZmluYWxDb2xvciA9IHZlYzMoMS4wLCAxLjAsIDEuMCk7XG4gIHZlYzMgc2hhZG93Q29sb3IgPSB2ZWMzKDAsIDAsIDApO1xuICBmbG9hdCBzaGFkb3dQb3dlciA9IDAuMTtcbiAgZmxvYXQgc2hhZG93U3RyZW5ndGggPSAxLjA7XG5cbiAgZm9yICggaW50IGkgPSAwOyBpIDwgMjA7IGkgKysgKSB7XG4gICAgdmVjMiBvZmZzZXQgPSB2ZWMyKFxuICAgICAgICAgICAgZmxvYXQoaSkgKiAwLjAxLFxuICAgICAgICAgICAgZmxvYXQoaSkgKiAwLjAxKTtcblxuICAgIGZsb2F0IHMgPSBtaXgoXG4gICAgICAgIGdldEN1c3RvbVNoYWRvd01hc2sodmVjMigwLjAsIDAuMCkpLFxuICAgICAgICBnZXRDdXN0b21TaGFkb3dNYXNrKG9mZnNldCksXG4gICAgICAgIDAuNSk7XG5cbiAgICBzaGFkb3dTdHJlbmd0aCAqPSBzO1xuICB9XG5cbi8vICAgc2hhZG93U3RyZW5ndGggKj0gc2hhZG93UG93ZXI7XG5cblxuICB2ZWMzIGNvbG9yID0gbWl4KGZpbmFsQ29sb3IsIHNoYWRvd0NvbG9yLCBzaGFkb3dTdHJlbmd0aCk7XG5cbiAgdmVjMiBkaXJlY3Rpb24gPSB2ZWMyKDEuMCwgMS4wKTtcblxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1xuICAjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxuICAjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50PlxufVxuYDtcblxuY2xhc3MgVGhyZWVMaWdodFRlc3QyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coXCJUaHJlZSBMaWdodGluZyBUZXN0MlwiKTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc2NlbmVSZW5kZXJlciA9IG5ldyBfc2NlbmVSZW5kZXJlci5TY2VuZVJlbmRlcmVyKHt9KTtcbiAgICB0aGlzLmJveEVsZW1lbnRzID0ge1xuICAgICAgYm94MTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JveC0xJylcbiAgICB9O1xuICAgIHRoaXMuY3JlYXRlR2x0ZlNjZW5lMSgpO1xuICAgIHRoaXMuc2NlbmVSZW5kZXJlci5yZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICB9XG5cbiAgY3JlYXRlR2x0ZlNjZW5lMSgpIHtcbiAgICBjb25zdCBkb21FbGVtZW50ID0gdGhpcy5ib3hFbGVtZW50cy5ib3gxO1xuICAgIGNvbnN0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgY29uc3QgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDMwLCBkb21FbGVtZW50Lm9mZnNldFdpZHRoIC8gZG9tRWxlbWVudC5vZmZzZXRXaWR0aCwgMSwgMTAwMDApO1xuICAgIGNhbWVyYS5wb3NpdGlvbi54ID0gNztcbiAgICBjYW1lcmEucG9zaXRpb24ueSA9IDEzO1xuICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gNzsgLy8gU2V0dXAgdW5pZm9ybXMuXG5cbiAgICB0aGlzLnVuaWZvcm1zID0ge307XG4gICAgdGhpcy51bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoW1RIUkVFLlVuaWZvcm1zTGliW1wiY29tbW9uXCJdLCBUSFJFRS5Vbmlmb3Jtc0xpYltcImxpZ2h0c1wiXSwgVEhSRUUuVW5pZm9ybXNMaWJbXCJmb2dcIl1dKTsgLy8gdGhpcy51bmlmb3Jtcy51X2xpZ2h0ID0geyB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjMoMC41LCAwLjgsIDAuMSkgfTtcbiAgICAvLyB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbiA9IHsgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKDEuMCwgMS4wKSB9O1xuICAgIC8vIHRoaXMudW5pZm9ybXMudV9jb2xvciA9IHsgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcigweGFhNjYxMSkgfTtcbiAgICAvLyB0aGlzLnVuaWZvcm1zLnVfZGlmZnVzZV9tYXAgPSB7IHZhbHVlOiBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoJy4vcHVibGljL2JyaWNrcy1kaWZmdXNlMy5wbmcnKSB9O1xuICAgIC8vIHRoaXMudW5pZm9ybXMudV9ub3JtYWxfbWFwID0geyB2YWx1ZTogbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKCcuL3B1YmxpYy9icmlja3Mtbm9ybWFsMy5wbmcnKSB9O1xuICAgIC8vIHRoaXMudW5pZm9ybXMudV90aW1lID0geyB2YWx1ZTogMC4wIH07XG5cbiAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbiA9IHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHg6IDAuMCxcbiAgICAgICAgeTogMC4wXG4gICAgICB9XG4gICAgfTsgLy8gUHJpbWFyeSBzaGFkZXIgbWFhdGVyaWFsXG5cbiAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zOiB0aGlzLnVuaWZvcm1zLFxuICAgICAgdmVydGV4U2hhZGVyOiB2c2hhZGVyLFxuICAgICAgZnJhZ21lbnRTaGFkZXI6IGZzaGFkZXIsXG4gICAgICBsaWdodHM6IHRydWUsXG4gICAgICB3aXJlZnJhbWU6IGZhbHNlLFxuICAgICAgZGl0aGVyaW5nOiB0cnVlLFxuICAgICAgdHJhbnNwYXJlbnQ6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnNjZW5lUmVuZGVyZXIuYWRkU2NlbmUoe1xuICAgICAgcmVzaXppbmdBbGdvOiAnY29udGFpbicsXG4gICAgICByZXNpemluZ09wdGlvbnM6IHtcbiAgICAgICAgc2NhbGFyWDogMSxcbiAgICAgICAgc2NhbGFyWTogMSxcbiAgICAgICAgdXNlRm92OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGRvbUVsZW1lbnQ6IGRvbUVsZW1lbnQsXG4gICAgICBzY2VuZTogc2NlbmUsXG4gICAgICBjYW1lcmE6IGNhbWVyYSxcbiAgICAgIG9uSW5pdDogKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhKSA9PiB7XG4gICAgICAgIHNjZW5lLnVzZXJEYXRhLnNwaGVyZUdyb3VwID0gdGhpcy5hZGRSYW5kb21TcGhlcmVzKHNjZW5lKTtcbiAgICAgICAgc2NlbmUudXNlckRhdGEuZ3JvdXAgPSB0aGlzLmFkZEdyb3VuZChzY2VuZSk7XG4gICAgICAgIGNvbnN0IGFtYmllbnRMaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoJyNGRkZGRkYnKTtcbiAgICAgICAgYW1iaWVudExpZ2h0LmludGVuc2l0eSA9IDAuNTtcbiAgICAgICAgc2NlbmUuYWRkKGFtYmllbnRMaWdodCk7IC8vIExpZ2h0IDFcblxuICAgICAgICB2YXIgbGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgweGRmZWJmZiwgMSk7XG4gICAgICAgIGxpZ2h0LnBvc2l0aW9uLnNldCgyLCA4LCA0KTtcbiAgICAgICAgbGlnaHQuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgIGxpZ2h0LnNoYWRvdy5tYXBTaXplLnNldCgyMDQ4LCAyMDQ4KTsgLy8gVGhpcyBibHVycyBidXQgZG9lc24ndCBsb29rIGdyZWF0LlxuICAgICAgICAvLyBsaWdodC5zaGFkb3cucmFkaXVzID0gMTtcbiAgICAgICAgLy8gbGlnaHQuc2hhZG93LmNhbWVyYS5mYXIgPSAyMDA7XG5cbiAgICAgICAgbGlnaHQuc2hhZG93RGFya25lc3MgPSAwLjU7IC8vIEFkanVzdCBmb3IgYmx1cnJ5bmVzc1xuXG4gICAgICAgIGxpZ2h0LnNoYWRvdy5jYW1lcmEuZmFyID0gNTA7XG4gICAgICAgIGxpZ2h0LnNoYWRvdy5jYW1lcmEubmVhciA9IDE7XG4gICAgICAgIHNjZW5lLmFkZChsaWdodCk7XG4gICAgICAgIHNjZW5lLmFkZChuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKGxpZ2h0LnNoYWRvdy5jYW1lcmEpKTtcbiAgICAgICAgcmVuZGVyZXIuZ2FtbWFJbnB1dCA9IHRydWU7XG4gICAgICAgIHJlbmRlcmVyLmdhbW1hT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICByZW5kZXJlci5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICAgIHJlbmRlcmVyLnNoYWRvd01hcC5zb2Z0ID0gdHJ1ZTtcbiAgICAgICAgcmVuZGVyZXIuc2hhZG93TWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcmVuZGVyZXIuc2hhZG93TWFwLmJpYXMgPSAwLjAwMDAwMTsgLy8gQWRkIG9yYml0IGNvbnRyb2xzLlxuXG4gICAgICAgIHZhciBjb250cm9scyA9IG5ldyBfT3JiaXRDb250cm9scy5PcmJpdENvbnRyb2xzKGNhbWVyYSwgZG9tRWxlbWVudCk7XG4gICAgICAgIGNvbnRyb2xzLm1heFBvbGFyQW5nbGUgPSBNYXRoLlBJICogMC41O1xuICAgICAgICBjb250cm9scy5taW5EaXN0YW5jZSA9IDEwO1xuICAgICAgICBjb250cm9scy5tYXhEaXN0YW5jZSA9IDc1O1xuICAgICAgICBjb250cm9scy50YXJnZXQuc2V0KDAsIDIuNSwgMCk7XG4gICAgICAgIGNvbnRyb2xzLnVwZGF0ZSgpO1xuICAgICAgICBzY2VuZS51c2VyRGF0YS5jb250cm9scyA9IGNvbnRyb2xzO1xuICAgICAgfSxcbiAgICAgIG9uUmVzaXplOiAocmVuZGVyZXIsIHNjZW5lKSA9PiB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMudV9yZXNvbHV0aW9uLnZhbHVlLnggPSBkb21FbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnVfcmVzb2x1dGlvbi52YWx1ZS55ID0gZG9tRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICB9LFxuICAgICAgb25CZWZvcmVSZW5kZXI6IChyZW5kZXJlciwgc2NlbmUpID0+IHtcbiAgICAgICAgLy8gaWYgKHRoaXMudW5pZm9ybXMpIHtcbiAgICAgICAgLy8gICAgIHRoaXMudW5pZm9ybXMudV90aW1lLnZhbHVlICs9IHRoaXMucmFmLmdldERlbHRhKHRydWUpO1xuICAgICAgICAvLyB9XG4gICAgICAgIHNjZW5lLnVzZXJEYXRhLnNwaGVyZUdyb3VwLnRyYXZlcnNlKGNoaWxkID0+IHtcbiAgICAgICAgICBpZiAoJ3BoYXNlJyBpbiBjaGlsZC51c2VyRGF0YSkge1xuICAgICAgICAgICAgY2hpbGQucG9zaXRpb24ueSA9IE1hdGguYWJzKE1hdGguc2luKHRoaXMucmFmLmdldEVsYXBzZWRUaW1lKCkgKyBjaGlsZC51c2VyRGF0YS5waGFzZSkpICogNSArIDAuMztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgc2hhZG93IGNhc3Rpbmcgc3BoZXJlcy5cbiAgICovXG5cblxuICBhZGRSYW5kb21TcGhlcmVzKHNjZW5lKSB7XG4gICAgY29uc3QgZ3JvdXAgPSBuZXcgVEhSRUUuR3JvdXAoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkoMC4zLCBfbWF0aGYubWF0aGYuZ2V0UmFuZG9tSW50KDEwLCA1MCksIF9tYXRoZi5tYXRoZi5nZXRSYW5kb21JbnQoMTAsIDUwKSk7XG4gICAgICB2YXIgbWF0ZXJpYWw7XG5cbiAgICAgIGlmIChpICUgMiA9PSAwKSB7XG4gICAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgICAgICBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoe1xuICAgICAgICAgIGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgc3BoZXJlLnBvc2l0aW9uLnggPSBNYXRoLnJhbmRvbSgpIC0gMC41O1xuICAgICAgc3BoZXJlLnBvc2l0aW9uLnogPSBNYXRoLnJhbmRvbSgpIC0gMC41O1xuICAgICAgc3BoZXJlLnBvc2l0aW9uLm5vcm1hbGl6ZSgpO1xuICAgICAgc3BoZXJlLnBvc2l0aW9uLm11bHRpcGx5U2NhbGFyKE1hdGgucmFuZG9tKCkgKiAyICsgMSk7XG4gICAgICBzcGhlcmUuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICBzcGhlcmUucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gICAgICBzcGhlcmUudXNlckRhdGEucGhhc2UgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSTtcbiAgICAgIGdyb3VwLmFkZChzcGhlcmUpO1xuICAgIH1cblxuICAgIHNjZW5lLmFkZChncm91cCk7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9XG5cbiAgYWRkR3JvdW5kKHNjZW5lKSB7XG4gICAgdmFyIGdyb3VuZE1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAweEZGRkZGRixcbiAgICAgIHNwZWN1bGFyOiAweEZGRkZGRkZcbiAgICB9KTtcbiAgICB2YXIgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KDIwMDAwLCAyMDAwMCwgOCwgOCksIHRoaXMubWF0ZXJpYWwpO1xuICAgIG1lc2gucm90YXRpb24ueCA9IC1NYXRoLlBJIC8gMjtcbiAgICBtZXNoLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgIHNjZW5lLmFkZChtZXNoKTtcbiAgICBtZXNoID0gbmV3IFRIUkVFLk1lc2gobmV3IFRIUkVFLkJveEJ1ZmZlckdlb21ldHJ5KDEsIDQsIDEpLCBncm91bmRNYXRlcmlhbCk7XG4gICAgbWVzaC5wb3NpdGlvbi55ID0gMjtcbiAgICBtZXNoLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgIG1lc2gucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gICAgc2NlbmUuYWRkKG1lc2gpO1xuICB9XG5cbiAgb25SYWYoKSB7XG4gICAgdGhpcy5zY2VuZVJlbmRlcmVyLnJlbmRlcigpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gVGhyZWVMaWdodFRlc3QyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/three-light-test2.js\n");

/***/ }),

/***/ "./examples/three-object-viewer.js":
/*!*****************************************!*\
  !*** ./examples/three-object-viewer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _GLTFLoader = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n// https://github.com/KhronosGroup/glTF-Blender-Exporter/blob/master/docs/user.md\n// https://threejs.org/docs/#manual/en/introduction/Loading-3D-models\n// https://threejs.org/examples/#webgl_loader_gltf\n// https://gist.github.com/bellbind/c4f8c502fcacbe29422e5ac315273858\n// https://github.com/funwithtriangles/blender-to-threejs-export-guide/blob/master/readme.md\n// https://threejsfundamentals.org/threejs/lessons/threejs-load-gltf.html\n// https://discoverthreejs.com/book/first-steps/load-models/\n// https://www.pentacreation.com/blog/2019/09/190916.html\n// https://www.pentacreation.com/blog/2019/10/191016.html\n// https://gltf-viewer.donmccurdy.com/\n// https://github.com/donmccurdy/three-gltf-viewer\n// https://qiita.com/adrs2002/items/dc6416d6fd2389c75ab5\n// https://qiita.com/cx20/items/2b86cb5052cd7c36038a\n// https://discoverthreejs.com/book/first-steps/load-models/\n// The glTF format does not allow bump maps.  Use normal maps.\n// https://discourse.threejs.org/t/three-js-gltf-model-exported-from-editor-bump-map-not-rendering/10835\n// PBR Exporting in blender\n// https://www.youtube.com/watch?v=wWyBXt565eE&t=318s\n\n/**\n * Just a crude example of adding a gltf object file in three.js.\n *\n * Basic steps.\n * Take your blender file and export it out as a gtlf and set it the path\n *    in the code below.\n *\n * https://docs.blender.org/manual/ja/latest/addons/io_scene_gltf2.html\n * https://github.com/KhronosGroup/glTF-Blender-Exporter/blob/master/docs/user.md#pbr-materials\n *\n * To export, in Blender 2.8 to go:\n * File -> Export glTF2.0 -> save your file.\n * Make sure you have the following checked under the export settings.\n * - General -> Apply Modifiers\n * - General -> +Y up\n * - Meshes -> Uvs, Normals, Vertex Colors, Materials\n * - Objects -> Cameras, Punctual Lights\n * - Animations -> Animations, Limit Playback Range, Always Sample Animations, SKinning, Shape Keys, Shape Keys Normals.\n *\n * Save file as glb.\n *\n *\n * Lights\n * - Area lights don't seem to export correctly out of blender.\n * - Sun lights turn into directional lights.  This means, if there is an object\n *   obstructing, in three.js it will block the light.\n *   https://threejs.org/docs/#api/en/lights/RectAreaLight could be an alternative option\n *\n * - Shadows\n * Light shadow values are not respected in three.js\n *\n * - It's easier if you don't have an HDRI.\n * - Also in Shading to go background set color strength to 0.\n *\n *\n * Renderer Specifics\n * - Things like bloom in eevee won't carry over.\n *\n *\n * Multi UV mapping\n * - not supported?\n *\n * Materials\n * - Seems like just Princpled BSDF is the main supported (okay with images)\n * - No support for bump maps (although you could maybe convert or load it on three.js side and apply a bump map)\n *\n * UV Editing and Baking\n * https://docs.blender.org/manual/en/latest/render/cycles/baking.html\n * Blender Baking Three.js\n * https://www.youtube.com/watch?v=yqF77-M3RVY\n * https://www.youtube.com/watch?v=XI-pZshRp8g (PBR)\n * https://youtu.be/X39iQ6P3CQw\n * https://youtu.be/R2YkbzObdB0 (high rez to low poly normal maps)\n * https://youtu.be/Atz4vT3UYAQ\n *\n * - https://www.youtube.com/watch?v=sB09T--_ZvU&t=193s\n * - https://www.youtube.com/watch?v=o568T79egTs\n * - https://www.youtube.com/watch?v=c2ut0Trcdi0\n * - https://www.youtube.com/watch?v=ejSVHuHOb7U\n *\n * To smooth out lines, you need to select all vertices.  Select the object -> tab (edit mdoe) ->\n * mesh -> shading --> smooth edges and smooth vertices.\n *\n * 1) Create UV Map\n * 2) Add image node to material and add the map (not hooked up)\n * 3) Make sure that when you turn off all lights, the world is dark (so the render is exact)\n * 4) Bake\n * 5) Go back to material and add Emission.  Hook image node -> emmission -> Material output Surfact\n * 6) Now your object will be using the baked material.\n * 7) Export out.\n *\n * IMPORTANT:\n * - If shadows are not showing up or lighting is off, it's possible because you have emission on the ground\n * or the world contains emits color (white is up to strength 1) which doens't get included in the bake.\n * In other words, if lighting is too strong it won't work.   Test it by turning all lights off.\n * If it is correct, your world will be pitch dark.        If you see like, that\n * could be a source of shadows and lighting going off.\n *\n * - If you see banding, it's likely you need more margins in the UV map.  0.5 or even 1 worked in tests.\n *\n *\n * Using Shadow Catchers:\n * https://blender.stackexchange.com/questions/47569/render-shadows-over-a-transparent-background-in-cycles\n * - go to object and under visibility -> check shadow catcher\n * - under cycles ensure film -> transparent is enabled.\n *\n *\n *\n *\n * Camera Movement.  If you are exporting camera movement, note the following.\n * - You can't use path animation since even if you bake the animations,\n *  they don't get included.  This means that beizer-curve path animations\n *  like done here: https://www.youtube.com/watch?v=-2dd_qK54pg\n *  won't work.\n * - Instead, you have to animate the camera.  Prior to exporting as gltf,\n *  you MUST, bake the animation.  To do this, go to the Camera,\n *  Object -> Animation -> Bake Action.  Make sure the \"Clear Constraints\"\n *  and \"Clear Parents\" options are selected.\n *  @see /examples/public/blender-three/baking-instructions.mov for\n *  further insturctions.\n *\n *\n * More limitations:\n * https://github.com/KhronosGroup/glTF-Blender-Exporter/blob/master/docs/user.md#pbr-materials*\n */\nclass ThreeObjectViewer {\n  constructor() {\n    console.log('ThreeJS Object Viewer Demo');\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.canvasContainer = document.getElementById('canvas-container'); // Noraml camera.\n    // this.camera = new THREE.PerspectiveCamera(45, this.width / this.height, 0.25, 1000);\n    // this.camera.position.set( - 50, 10, 2.7 );\n\n    this.scene = new THREE.Scene(); // var ambient = new THREE.AmbientLight(0x222222);\n    // this.scene.add(ambient);\n    // this.scene.background = new THREE.Color(0x222222);\n    // this.scene.add(new THREE.AmbientLight(0xFFFFFF));\n    // var light = new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );\n    // this.scene.add( light );\n\n    var loader = new _GLTFLoader.GLTFLoader(); // const path = 'https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf';\n    // const path = './public/dude.glb';\n\n    const path = './public/monster-scene3.glb';\n    loader.load(path, gltf => {\n      this.clock = new THREE.Clock();\n      const scene = gltf.scenes[0];\n      this.activeScene = scene;\n      this.animations = gltf.animations; // Animation Mixer\n\n      this.mixer = new THREE.AnimationMixer(scene); //Animation Clip\n\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i]; //Animation Action\n\n        var action = this.mixer.clipAction(animation);\n        console.log('added', animation); // //1\n        // action.setLoop(THREE.LoopOnce);\n        // //\n        // action.clampWhenFinished = true;\n        //\n\n        action.play();\n      }\n\n      this.scene.add(scene);\n      console.log(this.mixer); // http://learningthreejs.com/blog/2012/01/20/casting-shadows/\n\n      this.scene.traverse(child => {\n        if (child instanceof THREE.Light) {\n          child.castShadow = true;\n          console.log('cast', child); // Debugging light positions.\n\n          child.shadowCameraVisible = true; // Adjust shadow bias.\n\n          child.shadowBias = -0.005;\n          child.shadowDarkness = 0.1; // child.shadow.camera.near = 0;\n          // child.shadow.camera.far = 1000;\n          // Lights come off a bit stronger compared to Eevee, so\n          // lower the intensity.\n\n          child.intensity = child.intensity * 0.2; // var helper = new THREE.CameraHelper( child.shadow.camera );\n          // scene.add( helper );\n        } else if (child instanceof THREE.Mesh) {\n          child.castShadow = true;\n          child.receiveShadow = true;\n          console.log('receive', child);\n        } else {\n          console.log('nothing', child);\n        } // if(child.name.startsWith('Cube003')) {\n        //     child.receiveShadow = true;\n        // }\n        // Fix eyes\n\n\n        if (child.name.startsWith('Cube006')) {\n          child.castShadow = false;\n          child.receiveShadow = false;\n        }\n      }); // Set the camera exported in gltf.\n      // Requires camera to be exported for gltf.\n\n      this.camera = gltf.cameras[0];\n      console.log(this.camera);\n      this.resize();\n      this.raf.start();\n    }, undefined, error => {\n      console.error(error);\n    });\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: true\n    });\n    this.canvasContainer.appendChild(this.renderer.domElement);\n    window.addEventListener('resize', this.resize.bind(this), false);\n  }\n\n  resize() {\n    this.width = this.canvasContainer.parentElement.offsetWidth;\n    this.height = this.canvasContainer.parentElement.offsetHeight;\n    console.log('resizing', this.width); // https://github.com/donmccurdy/three-gltf-viewer/blob/master/src/viewer.js\n\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n    this.renderer.setSize(this.width, this.height); // Important to get the correct colors.\n\n    this.renderer.physicallyCorrectLights = true;\n    this.renderer.setClearColor(0x000000); // this.renderer.setClearColor(0xFFFFFF, 1.0);\n    // Affects how strongly lights come exposed.\n    // this.renderer.toneMappingExposure = 0.4;\n\n    this.renderer.shadowMap.enabled = true;\n    this.renderer.gammaOutput = true;\n    this.renderer.gammaFactor = 2.2; // The camera aspect goes off since it could be exported at a different\n    // ratio.  Force update the aspect ratio.\n    // this.camera.fov = this.width / this.height;\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n  }\n\n  getAnimationByName(name) {\n    return this.animations.filter(animationClip => {\n      return animationClip.name == name;\n    })[0];\n  }\n\n  getObjectByName(name) {\n    return this.activeScene.children.filter(object3d => {\n      return object3d.name == name;\n    })[0];\n  }\n\n  onRaf() {\n    //Animation Mixer\n    if (this.mixer) {\n      this.mixer.update(this.clock.getDelta());\n    } // const cameraAnimation = this.getAnimationByName('camera-action');\n    // const animationAction = this.mixer.clipAction(cameraAnimation);\n    // console.log(animationAction);\n    // console.log(this.mixer);\n    // const camera = this.getObjectByName('Camera');\n    // console.log(camera.position);\n    // const camera = this.camera.parent;\n    // if(cameraPosition) {\n    //   this.camera.position.set(this.camera.parent.position);\n    //   this.camera.scale.set(camera.scale);\n    //   this.camera.setRotationFromEuler(this.camera.rotation);\n    // }\n    // Make camera follow target object.\n    // const cameraTarget = this.getObjectByName('camera-target');\n    // if (cameraTarget) {\n    //     this.camera.lookAt(cameraTarget.position);\n    // }\n    // this.camera.scale.set(this.camera.parent.scale);\n    // console.log(this.camera.position);\n\n\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = ThreeObjectViewer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1vYmplY3Qtdmlld2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvdGhyZWUtb2JqZWN0LXZpZXdlci5qcz8zMWRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX0dMVEZMb2FkZXIgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvR0xURkxvYWRlclwiKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGLUJsZW5kZXItRXhwb3J0ZXIvYmxvYi9tYXN0ZXIvZG9jcy91c2VyLm1kXG4vLyBodHRwczovL3RocmVlanMub3JnL2RvY3MvI21hbnVhbC9lbi9pbnRyb2R1Y3Rpb24vTG9hZGluZy0zRC1tb2RlbHNcbi8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZXhhbXBsZXMvI3dlYmdsX2xvYWRlcl9nbHRmXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9iZWxsYmluZC9jNGY4YzUwMmZjYWNiZTI5NDIyZTVhYzMxNTI3Mzg1OFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bndpdGh0cmlhbmdsZXMvYmxlbmRlci10by10aHJlZWpzLWV4cG9ydC1ndWlkZS9ibG9iL21hc3Rlci9yZWFkbWUubWRcbi8vIGh0dHBzOi8vdGhyZWVqc2Z1bmRhbWVudGFscy5vcmcvdGhyZWVqcy9sZXNzb25zL3RocmVlanMtbG9hZC1nbHRmLmh0bWxcbi8vIGh0dHBzOi8vZGlzY292ZXJ0aHJlZWpzLmNvbS9ib29rL2ZpcnN0LXN0ZXBzL2xvYWQtbW9kZWxzL1xuLy8gaHR0cHM6Ly93d3cucGVudGFjcmVhdGlvbi5jb20vYmxvZy8yMDE5LzA5LzE5MDkxNi5odG1sXG4vLyBodHRwczovL3d3dy5wZW50YWNyZWF0aW9uLmNvbS9ibG9nLzIwMTkvMTAvMTkxMDE2Lmh0bWxcbi8vIGh0dHBzOi8vZ2x0Zi12aWV3ZXIuZG9ubWNjdXJkeS5jb20vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZG9ubWNjdXJkeS90aHJlZS1nbHRmLXZpZXdlclxuLy8gaHR0cHM6Ly9xaWl0YS5jb20vYWRyczIwMDIvaXRlbXMvZGM2NDE2ZDZmZDIzODljNzVhYjVcbi8vIGh0dHBzOi8vcWlpdGEuY29tL2N4MjAvaXRlbXMvMmI4NmNiNTA1MmNkN2MzNjAzOGFcbi8vIGh0dHBzOi8vZGlzY292ZXJ0aHJlZWpzLmNvbS9ib29rL2ZpcnN0LXN0ZXBzL2xvYWQtbW9kZWxzL1xuLy8gVGhlIGdsVEYgZm9ybWF0IGRvZXMgbm90IGFsbG93IGJ1bXAgbWFwcy4gIFVzZSBub3JtYWwgbWFwcy5cbi8vIGh0dHBzOi8vZGlzY291cnNlLnRocmVlanMub3JnL3QvdGhyZWUtanMtZ2x0Zi1tb2RlbC1leHBvcnRlZC1mcm9tLWVkaXRvci1idW1wLW1hcC1ub3QtcmVuZGVyaW5nLzEwODM1XG4vLyBQQlIgRXhwb3J0aW5nIGluIGJsZW5kZXJcbi8vIGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9d1d5Qlh0NTY1ZUUmdD0zMThzXG5cbi8qKlxuICogSnVzdCBhIGNydWRlIGV4YW1wbGUgb2YgYWRkaW5nIGEgZ2x0ZiBvYmplY3QgZmlsZSBpbiB0aHJlZS5qcy5cbiAqXG4gKiBCYXNpYyBzdGVwcy5cbiAqIFRha2UgeW91ciBibGVuZGVyIGZpbGUgYW5kIGV4cG9ydCBpdCBvdXQgYXMgYSBndGxmIGFuZCBzZXQgaXQgdGhlIHBhdGhcbiAqICAgIGluIHRoZSBjb2RlIGJlbG93LlxuICpcbiAqIGh0dHBzOi8vZG9jcy5ibGVuZGVyLm9yZy9tYW51YWwvamEvbGF0ZXN0L2FkZG9ucy9pb19zY2VuZV9nbHRmMi5odG1sXG4gKiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYtQmxlbmRlci1FeHBvcnRlci9ibG9iL21hc3Rlci9kb2NzL3VzZXIubWQjcGJyLW1hdGVyaWFsc1xuICpcbiAqIFRvIGV4cG9ydCwgaW4gQmxlbmRlciAyLjggdG8gZ286XG4gKiBGaWxlIC0+IEV4cG9ydCBnbFRGMi4wIC0+IHNhdmUgeW91ciBmaWxlLlxuICogTWFrZSBzdXJlIHlvdSBoYXZlIHRoZSBmb2xsb3dpbmcgY2hlY2tlZCB1bmRlciB0aGUgZXhwb3J0IHNldHRpbmdzLlxuICogLSBHZW5lcmFsIC0+IEFwcGx5IE1vZGlmaWVyc1xuICogLSBHZW5lcmFsIC0+ICtZIHVwXG4gKiAtIE1lc2hlcyAtPiBVdnMsIE5vcm1hbHMsIFZlcnRleCBDb2xvcnMsIE1hdGVyaWFsc1xuICogLSBPYmplY3RzIC0+IENhbWVyYXMsIFB1bmN0dWFsIExpZ2h0c1xuICogLSBBbmltYXRpb25zIC0+IEFuaW1hdGlvbnMsIExpbWl0IFBsYXliYWNrIFJhbmdlLCBBbHdheXMgU2FtcGxlIEFuaW1hdGlvbnMsIFNLaW5uaW5nLCBTaGFwZSBLZXlzLCBTaGFwZSBLZXlzIE5vcm1hbHMuXG4gKlxuICogU2F2ZSBmaWxlIGFzIGdsYi5cbiAqXG4gKlxuICogTGlnaHRzXG4gKiAtIEFyZWEgbGlnaHRzIGRvbid0IHNlZW0gdG8gZXhwb3J0IGNvcnJlY3RseSBvdXQgb2YgYmxlbmRlci5cbiAqIC0gU3VuIGxpZ2h0cyB0dXJuIGludG8gZGlyZWN0aW9uYWwgbGlnaHRzLiAgVGhpcyBtZWFucywgaWYgdGhlcmUgaXMgYW4gb2JqZWN0XG4gKiAgIG9ic3RydWN0aW5nLCBpbiB0aHJlZS5qcyBpdCB3aWxsIGJsb2NrIHRoZSBsaWdodC5cbiAqICAgaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNhcGkvZW4vbGlnaHRzL1JlY3RBcmVhTGlnaHQgY291bGQgYmUgYW4gYWx0ZXJuYXRpdmUgb3B0aW9uXG4gKlxuICogLSBTaGFkb3dzXG4gKiBMaWdodCBzaGFkb3cgdmFsdWVzIGFyZSBub3QgcmVzcGVjdGVkIGluIHRocmVlLmpzXG4gKlxuICogLSBJdCdzIGVhc2llciBpZiB5b3UgZG9uJ3QgaGF2ZSBhbiBIRFJJLlxuICogLSBBbHNvIGluIFNoYWRpbmcgdG8gZ28gYmFja2dyb3VuZCBzZXQgY29sb3Igc3RyZW5ndGggdG8gMC5cbiAqXG4gKlxuICogUmVuZGVyZXIgU3BlY2lmaWNzXG4gKiAtIFRoaW5ncyBsaWtlIGJsb29tIGluIGVldmVlIHdvbid0IGNhcnJ5IG92ZXIuXG4gKlxuICpcbiAqIE11bHRpIFVWIG1hcHBpbmdcbiAqIC0gbm90IHN1cHBvcnRlZD9cbiAqXG4gKiBNYXRlcmlhbHNcbiAqIC0gU2VlbXMgbGlrZSBqdXN0IFByaW5jcGxlZCBCU0RGIGlzIHRoZSBtYWluIHN1cHBvcnRlZCAob2theSB3aXRoIGltYWdlcylcbiAqIC0gTm8gc3VwcG9ydCBmb3IgYnVtcCBtYXBzIChhbHRob3VnaCB5b3UgY291bGQgbWF5YmUgY29udmVydCBvciBsb2FkIGl0IG9uIHRocmVlLmpzIHNpZGUgYW5kIGFwcGx5IGEgYnVtcCBtYXApXG4gKlxuICogVVYgRWRpdGluZyBhbmQgQmFraW5nXG4gKiBodHRwczovL2RvY3MuYmxlbmRlci5vcmcvbWFudWFsL2VuL2xhdGVzdC9yZW5kZXIvY3ljbGVzL2Jha2luZy5odG1sXG4gKiBCbGVuZGVyIEJha2luZyBUaHJlZS5qc1xuICogaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj15cUY3Ny1NM1JWWVxuICogaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1YSS1wWnNoUnA4ZyAoUEJSKVxuICogaHR0cHM6Ly95b3V0dS5iZS9YMzlpUTZQM0NRd1xuICogaHR0cHM6Ly95b3V0dS5iZS9SMllrYnpPYmRCMCAoaGlnaCByZXogdG8gbG93IHBvbHkgbm9ybWFsIG1hcHMpXG4gKiBodHRwczovL3lvdXR1LmJlL0F0ejR2VDNVWUFRXG4gKlxuICogLSBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PXNCMDlULS1fWnZVJnQ9MTkzc1xuICogLSBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PW81NjhUNzllZ1RzXG4gKiAtIGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9YzJ1dDBUcmNkaTBcbiAqIC0gaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1lalNWSHVIT2I3VVxuICpcbiAqIFRvIHNtb290aCBvdXQgbGluZXMsIHlvdSBuZWVkIHRvIHNlbGVjdCBhbGwgdmVydGljZXMuICBTZWxlY3QgdGhlIG9iamVjdCAtPiB0YWIgKGVkaXQgbWRvZSkgLT5cbiAqIG1lc2ggLT4gc2hhZGluZyAtLT4gc21vb3RoIGVkZ2VzIGFuZCBzbW9vdGggdmVydGljZXMuXG4gKlxuICogMSkgQ3JlYXRlIFVWIE1hcFxuICogMikgQWRkIGltYWdlIG5vZGUgdG8gbWF0ZXJpYWwgYW5kIGFkZCB0aGUgbWFwIChub3QgaG9va2VkIHVwKVxuICogMykgTWFrZSBzdXJlIHRoYXQgd2hlbiB5b3UgdHVybiBvZmYgYWxsIGxpZ2h0cywgdGhlIHdvcmxkIGlzIGRhcmsgKHNvIHRoZSByZW5kZXIgaXMgZXhhY3QpXG4gKiA0KSBCYWtlXG4gKiA1KSBHbyBiYWNrIHRvIG1hdGVyaWFsIGFuZCBhZGQgRW1pc3Npb24uICBIb29rIGltYWdlIG5vZGUgLT4gZW1taXNzaW9uIC0+IE1hdGVyaWFsIG91dHB1dCBTdXJmYWN0XG4gKiA2KSBOb3cgeW91ciBvYmplY3Qgd2lsbCBiZSB1c2luZyB0aGUgYmFrZWQgbWF0ZXJpYWwuXG4gKiA3KSBFeHBvcnQgb3V0LlxuICpcbiAqIElNUE9SVEFOVDpcbiAqIC0gSWYgc2hhZG93cyBhcmUgbm90IHNob3dpbmcgdXAgb3IgbGlnaHRpbmcgaXMgb2ZmLCBpdCdzIHBvc3NpYmxlIGJlY2F1c2UgeW91IGhhdmUgZW1pc3Npb24gb24gdGhlIGdyb3VuZFxuICogb3IgdGhlIHdvcmxkIGNvbnRhaW5zIGVtaXRzIGNvbG9yICh3aGl0ZSBpcyB1cCB0byBzdHJlbmd0aCAxKSB3aGljaCBkb2Vucyd0IGdldCBpbmNsdWRlZCBpbiB0aGUgYmFrZS5cbiAqIEluIG90aGVyIHdvcmRzLCBpZiBsaWdodGluZyBpcyB0b28gc3Ryb25nIGl0IHdvbid0IHdvcmsuICAgVGVzdCBpdCBieSB0dXJuaW5nIGFsbCBsaWdodHMgb2ZmLlxuICogSWYgaXQgaXMgY29ycmVjdCwgeW91ciB3b3JsZCB3aWxsIGJlIHBpdGNoIGRhcmsuICAgICAgICBJZiB5b3Ugc2VlIGxpa2UsIHRoYXRcbiAqIGNvdWxkIGJlIGEgc291cmNlIG9mIHNoYWRvd3MgYW5kIGxpZ2h0aW5nIGdvaW5nIG9mZi5cbiAqXG4gKiAtIElmIHlvdSBzZWUgYmFuZGluZywgaXQncyBsaWtlbHkgeW91IG5lZWQgbW9yZSBtYXJnaW5zIGluIHRoZSBVViBtYXAuICAwLjUgb3IgZXZlbiAxIHdvcmtlZCBpbiB0ZXN0cy5cbiAqXG4gKlxuICogVXNpbmcgU2hhZG93IENhdGNoZXJzOlxuICogaHR0cHM6Ly9ibGVuZGVyLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy80NzU2OS9yZW5kZXItc2hhZG93cy1vdmVyLWEtdHJhbnNwYXJlbnQtYmFja2dyb3VuZC1pbi1jeWNsZXNcbiAqIC0gZ28gdG8gb2JqZWN0IGFuZCB1bmRlciB2aXNpYmlsaXR5IC0+IGNoZWNrIHNoYWRvdyBjYXRjaGVyXG4gKiAtIHVuZGVyIGN5Y2xlcyBlbnN1cmUgZmlsbSAtPiB0cmFuc3BhcmVudCBpcyBlbmFibGVkLlxuICpcbiAqXG4gKlxuICpcbiAqIENhbWVyYSBNb3ZlbWVudC4gIElmIHlvdSBhcmUgZXhwb3J0aW5nIGNhbWVyYSBtb3ZlbWVudCwgbm90ZSB0aGUgZm9sbG93aW5nLlxuICogLSBZb3UgY2FuJ3QgdXNlIHBhdGggYW5pbWF0aW9uIHNpbmNlIGV2ZW4gaWYgeW91IGJha2UgdGhlIGFuaW1hdGlvbnMsXG4gKiAgdGhleSBkb24ndCBnZXQgaW5jbHVkZWQuICBUaGlzIG1lYW5zIHRoYXQgYmVpemVyLWN1cnZlIHBhdGggYW5pbWF0aW9uc1xuICogIGxpa2UgZG9uZSBoZXJlOiBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PS0yZGRfcUs1NHBnXG4gKiAgd29uJ3Qgd29yay5cbiAqIC0gSW5zdGVhZCwgeW91IGhhdmUgdG8gYW5pbWF0ZSB0aGUgY2FtZXJhLiAgUHJpb3IgdG8gZXhwb3J0aW5nIGFzIGdsdGYsXG4gKiAgeW91IE1VU1QsIGJha2UgdGhlIGFuaW1hdGlvbi4gIFRvIGRvIHRoaXMsIGdvIHRvIHRoZSBDYW1lcmEsXG4gKiAgT2JqZWN0IC0+IEFuaW1hdGlvbiAtPiBCYWtlIEFjdGlvbi4gIE1ha2Ugc3VyZSB0aGUgXCJDbGVhciBDb25zdHJhaW50c1wiXG4gKiAgYW5kIFwiQ2xlYXIgUGFyZW50c1wiIG9wdGlvbnMgYXJlIHNlbGVjdGVkLlxuICogIEBzZWUgL2V4YW1wbGVzL3B1YmxpYy9ibGVuZGVyLXRocmVlL2Jha2luZy1pbnN0cnVjdGlvbnMubW92IGZvclxuICogIGZ1cnRoZXIgaW5zdHVyY3Rpb25zLlxuICpcbiAqXG4gKiBNb3JlIGxpbWl0YXRpb25zOlxuICogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGLUJsZW5kZXItRXhwb3J0ZXIvYmxvYi9tYXN0ZXIvZG9jcy91c2VyLm1kI3Bici1tYXRlcmlhbHMqXG4gKi9cbmNsYXNzIFRocmVlT2JqZWN0Vmlld2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coJ1RocmVlSlMgT2JqZWN0IFZpZXdlciBEZW1vJyk7XG4gICAgdGhpcy5yYWYgPSBuZXcgX3JhZi5SYWYodGhpcy5vblJhZi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMtY29udGFpbmVyJyk7IC8vIE5vcmFtbCBjYW1lcmEuXG4gICAgLy8gdGhpcy5jYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNDUsIHRoaXMud2lkdGggLyB0aGlzLmhlaWdodCwgMC4yNSwgMTAwMCk7XG4gICAgLy8gdGhpcy5jYW1lcmEucG9zaXRpb24uc2V0KCAtIDUwLCAxMCwgMi43ICk7XG5cbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vIHZhciBhbWJpZW50ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCgweDIyMjIyMik7XG4gICAgLy8gdGhpcy5zY2VuZS5hZGQoYW1iaWVudCk7XG4gICAgLy8gdGhpcy5zY2VuZS5iYWNrZ3JvdW5kID0gbmV3IFRIUkVFLkNvbG9yKDB4MjIyMjIyKTtcbiAgICAvLyB0aGlzLnNjZW5lLmFkZChuZXcgVEhSRUUuQW1iaWVudExpZ2h0KDB4RkZGRkZGKSk7XG4gICAgLy8gdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCggMHhmZmZmYmIsIDB4MDgwODIwLCAxICk7XG4gICAgLy8gdGhpcy5zY2VuZS5hZGQoIGxpZ2h0ICk7XG5cbiAgICB2YXIgbG9hZGVyID0gbmV3IF9HTFRGTG9hZGVyLkdMVEZMb2FkZXIoKTsgLy8gY29uc3QgcGF0aCA9ICdodHRwczovL3RocmVlanMub3JnL2V4YW1wbGVzL21vZGVscy9nbHRmL0RhbWFnZWRIZWxtZXQvZ2xURi9EYW1hZ2VkSGVsbWV0LmdsdGYnO1xuICAgIC8vIGNvbnN0IHBhdGggPSAnLi9wdWJsaWMvZHVkZS5nbGInO1xuXG4gICAgY29uc3QgcGF0aCA9ICcuL3B1YmxpYy9tb25zdGVyLXNjZW5lMy5nbGInO1xuICAgIGxvYWRlci5sb2FkKHBhdGgsIGdsdGYgPT4ge1xuICAgICAgdGhpcy5jbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpO1xuICAgICAgY29uc3Qgc2NlbmUgPSBnbHRmLnNjZW5lc1swXTtcbiAgICAgIHRoaXMuYWN0aXZlU2NlbmUgPSBzY2VuZTtcbiAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGdsdGYuYW5pbWF0aW9uczsgLy8gQW5pbWF0aW9uIE1peGVy44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQXG5cbiAgICAgIHRoaXMubWl4ZXIgPSBuZXcgVEhSRUUuQW5pbWF0aW9uTWl4ZXIoc2NlbmUpOyAvL+WFqOOBpuOBrkFuaW1hdGlvbiBDbGlw44Gr5a++44GX44GmXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNbaV07IC8vQW5pbWF0aW9uIEFjdGlvbuOCkueUn+aIkFxuXG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLm1peGVyLmNsaXBBY3Rpb24oYW5pbWF0aW9uKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FkZGVkJywgYW5pbWF0aW9uKTsgLy8gLy/jg6vjg7zjg5foqK3lrprvvIgx5Zue44Gu44G/77yJXG4gICAgICAgIC8vIGFjdGlvbi5zZXRMb29wKFRIUkVFLkxvb3BPbmNlKTtcbiAgICAgICAgLy8gLy/jgqLjg4vjg6Hjg7zjgrfjg6fjg7Pjga7mnIDlvozjga7jg5Xjg6zjg7zjg6DjgafjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzntYLkuoZcbiAgICAgICAgLy8gYWN0aW9uLmNsYW1wV2hlbkZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy/jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLlho3nlJ9cblxuICAgICAgICBhY3Rpb24ucGxheSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjZW5lLmFkZChzY2VuZSk7XG4gICAgICBjb25zb2xlLmxvZyh0aGlzLm1peGVyKTsgLy8gaHR0cDovL2xlYXJuaW5ndGhyZWVqcy5jb20vYmxvZy8yMDEyLzAxLzIwL2Nhc3Rpbmctc2hhZG93cy9cblxuICAgICAgdGhpcy5zY2VuZS50cmF2ZXJzZShjaGlsZCA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLkxpZ2h0KSB7XG4gICAgICAgICAgY2hpbGQuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2Nhc3QnLCBjaGlsZCk7IC8vIERlYnVnZ2luZyBsaWdodCBwb3NpdGlvbnMuXG5cbiAgICAgICAgICBjaGlsZC5zaGFkb3dDYW1lcmFWaXNpYmxlID0gdHJ1ZTsgLy8gQWRqdXN0IHNoYWRvdyBiaWFzLlxuXG4gICAgICAgICAgY2hpbGQuc2hhZG93QmlhcyA9IC0wLjAwNTtcbiAgICAgICAgICBjaGlsZC5zaGFkb3dEYXJrbmVzcyA9IDAuMTsgLy8gY2hpbGQuc2hhZG93LmNhbWVyYS5uZWFyID0gMDtcbiAgICAgICAgICAvLyBjaGlsZC5zaGFkb3cuY2FtZXJhLmZhciA9IDEwMDA7XG4gICAgICAgICAgLy8gTGlnaHRzIGNvbWUgb2ZmIGEgYml0IHN0cm9uZ2VyIGNvbXBhcmVkIHRvIEVldmVlLCBzb1xuICAgICAgICAgIC8vIGxvd2VyIHRoZSBpbnRlbnNpdHkuXG5cbiAgICAgICAgICBjaGlsZC5pbnRlbnNpdHkgPSBjaGlsZC5pbnRlbnNpdHkgKiAwLjI7IC8vIHZhciBoZWxwZXIgPSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBjaGlsZC5zaGFkb3cuY2FtZXJhICk7XG4gICAgICAgICAgLy8gc2NlbmUuYWRkKCBoZWxwZXIgKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpIHtcbiAgICAgICAgICBjaGlsZC5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgICBjaGlsZC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgICBjb25zb2xlLmxvZygncmVjZWl2ZScsIGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnbm90aGluZycsIGNoaWxkKTtcbiAgICAgICAgfSAvLyBpZihjaGlsZC5uYW1lLnN0YXJ0c1dpdGgoJ0N1YmUwMDMnKSkge1xuICAgICAgICAvLyAgICAgY2hpbGQucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gRml4IGV5ZXNcblxuXG4gICAgICAgIGlmIChjaGlsZC5uYW1lLnN0YXJ0c1dpdGgoJ0N1YmUwMDYnKSkge1xuICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSBmYWxzZTtcbiAgICAgICAgICBjaGlsZC5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBTZXQgdGhlIGNhbWVyYSBleHBvcnRlZCBpbiBnbHRmLlxuICAgICAgLy8gUmVxdWlyZXMgY2FtZXJhIHRvIGJlIGV4cG9ydGVkIGZvciBnbHRmLlxuXG4gICAgICB0aGlzLmNhbWVyYSA9IGdsdGYuY2FtZXJhc1swXTtcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMuY2FtZXJhKTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICB0aGlzLnJhZi5zdGFydCgpO1xuICAgIH0sIHVuZGVmaW5lZCwgZXJyb3IgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICAgIGFudGlhbGlhczogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgfVxuXG4gIHJlc2l6ZSgpIHtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5jYW52YXNDb250YWluZXIucGFyZW50RWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FudmFzQ29udGFpbmVyLnBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIGNvbnNvbGUubG9nKCdyZXNpemluZycsIHRoaXMud2lkdGgpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZG9ubWNjdXJkeS90aHJlZS1nbHRmLXZpZXdlci9ibG9iL21hc3Rlci9zcmMvdmlld2VyLmpzXG5cbiAgICB0aGlzLnJlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7IC8vIEltcG9ydGFudCB0byBnZXQgdGhlIGNvcnJlY3QgY29sb3JzLlxuXG4gICAgdGhpcy5yZW5kZXJlci5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4MDAwMDAwKTsgLy8gdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4RkZGRkZGLCAxLjApO1xuICAgIC8vIEFmZmVjdHMgaG93IHN0cm9uZ2x5IGxpZ2h0cyBjb21lIGV4cG9zZWQuXG4gICAgLy8gdGhpcy5yZW5kZXJlci50b25lTWFwcGluZ0V4cG9zdXJlID0gMC40O1xuXG4gICAgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJlci5nYW1tYU91dHB1dCA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJlci5nYW1tYUZhY3RvciA9IDIuMjsgLy8gVGhlIGNhbWVyYSBhc3BlY3QgZ29lcyBvZmYgc2luY2UgaXQgY291bGQgYmUgZXhwb3J0ZWQgYXQgYSBkaWZmZXJlbnRcbiAgICAvLyByYXRpby4gIEZvcmNlIHVwZGF0ZSB0aGUgYXNwZWN0IHJhdGlvLlxuICAgIC8vIHRoaXMuY2FtZXJhLmZvdiA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcblxuICAgIHRoaXMuY2FtZXJhLmFzcGVjdCA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gIH1cblxuICBnZXRBbmltYXRpb25CeU5hbWUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnMuZmlsdGVyKGFuaW1hdGlvbkNsaXAgPT4ge1xuICAgICAgcmV0dXJuIGFuaW1hdGlvbkNsaXAubmFtZSA9PSBuYW1lO1xuICAgIH0pWzBdO1xuICB9XG5cbiAgZ2V0T2JqZWN0QnlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVTY2VuZS5jaGlsZHJlbi5maWx0ZXIob2JqZWN0M2QgPT4ge1xuICAgICAgcmV0dXJuIG9iamVjdDNkLm5hbWUgPT0gbmFtZTtcbiAgICB9KVswXTtcbiAgfVxuXG4gIG9uUmFmKCkge1xuICAgIC8vQW5pbWF0aW9uIE1peGVy44KS5a6f6KGMXG4gICAgaWYgKHRoaXMubWl4ZXIpIHtcbiAgICAgIHRoaXMubWl4ZXIudXBkYXRlKHRoaXMuY2xvY2suZ2V0RGVsdGEoKSk7XG4gICAgfSAvLyBjb25zdCBjYW1lcmFBbmltYXRpb24gPSB0aGlzLmdldEFuaW1hdGlvbkJ5TmFtZSgnY2FtZXJhLWFjdGlvbicpO1xuICAgIC8vIGNvbnN0IGFuaW1hdGlvbkFjdGlvbiA9IHRoaXMubWl4ZXIuY2xpcEFjdGlvbihjYW1lcmFBbmltYXRpb24pO1xuICAgIC8vIGNvbnNvbGUubG9nKGFuaW1hdGlvbkFjdGlvbik7XG4gICAgLy8gY29uc29sZS5sb2codGhpcy5taXhlcik7XG4gICAgLy8gY29uc3QgY2FtZXJhID0gdGhpcy5nZXRPYmplY3RCeU5hbWUoJ0NhbWVyYScpO1xuICAgIC8vIGNvbnNvbGUubG9nKGNhbWVyYS5wb3NpdGlvbik7XG4gICAgLy8gY29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmEucGFyZW50O1xuICAgIC8vIGlmKGNhbWVyYVBvc2l0aW9uKSB7XG4gICAgLy8gICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXQodGhpcy5jYW1lcmEucGFyZW50LnBvc2l0aW9uKTtcbiAgICAvLyAgIHRoaXMuY2FtZXJhLnNjYWxlLnNldChjYW1lcmEuc2NhbGUpO1xuICAgIC8vICAgdGhpcy5jYW1lcmEuc2V0Um90YXRpb25Gcm9tRXVsZXIodGhpcy5jYW1lcmEucm90YXRpb24pO1xuICAgIC8vIH1cbiAgICAvLyBNYWtlIGNhbWVyYSBmb2xsb3cgdGFyZ2V0IG9iamVjdC5cbiAgICAvLyBjb25zdCBjYW1lcmFUYXJnZXQgPSB0aGlzLmdldE9iamVjdEJ5TmFtZSgnY2FtZXJhLXRhcmdldCcpO1xuICAgIC8vIGlmIChjYW1lcmFUYXJnZXQpIHtcbiAgICAvLyAgICAgdGhpcy5jYW1lcmEubG9va0F0KGNhbWVyYVRhcmdldC5wb3NpdGlvbik7XG4gICAgLy8gfVxuICAgIC8vIHRoaXMuY2FtZXJhLnNjYWxlLnNldCh0aGlzLmNhbWVyYS5wYXJlbnQuc2NhbGUpO1xuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuY2FtZXJhLnBvc2l0aW9uKTtcblxuXG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gVGhyZWVPYmplY3RWaWV3ZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/three-object-viewer.js\n");

/***/ }),

/***/ "./examples/three-object-viewer10.js":
/*!*******************************************!*\
  !*** ./examples/three-object-viewer10.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _datguif = __webpack_require__(/*! ../lib/datguif/datguif */ \"./lib/datguif/datguif.js\");\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _GLTFLoader = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\nvar _EffectComposer = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _threef = __webpack_require__(/*! ../lib/threef/threef */ \"./lib/threef/threef.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n// https://svs.gsfc.nasa.gov/4720\n// https://threejs.org/docs/#api/en/materials/MeshStandardMaterial\n// https://qiita.com/adrs2002/items/dc6416d6fd2389c75ab5\n// https://qiita.com/cx20/items/2b86cb5052cd7c36038a\n// https://stackoverflow.com/questions/54283080/normal-map-values-with-threejs-gltf-blender-exporter?rq=1\n// The glTF format does not allow bump maps.  Use normal maps.\n// https://discourse.threejs.org/t/three-js-gltf-model-exported-from-editor-bump-map-not-rendering/10835\n//\n// - watch over exposure of normal map\n// - png based normal map works better? (jpg over exposed?)\n//\n// import { Raf } from '../lib/raf/raf';\nclass ThreeObjectViewer10 {\n  constructor() {\n    console.log('ThreeJS Object Viewer Demo');\n    this.parentElement = document.getElementById('parent');\n    this.canvasContainer = document.getElementById('canvas-container');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.rafProgress = new _rafProgress.RafProgress();\n    this.rafProgress.watch(this.onProgressUpdate.bind(this));\n    this.scrollLerp = 0.38;\n    this.scrollEase = 'easeInQuad';\n    this.textMarker1 = document.getElementById('text-marker1');\n    this.textMarker2 = document.getElementById('text-marker2');\n    this.textMarkers = [];\n    this.rendererConfig = {\n      clearColor: '#000000',\n      backgroundAlpha: 1.0\n    };\n    this.gui = new _datguif.Datguif({\n      load: JSON\n    });\n    this.gui.addFolder('Settings').open();\n    this.gui.addFolder('Renderer', 'Settings');\n    this.gui.addFolder('Camera', 'Settings');\n    this.gui.addFolder('Scroll', 'Settings');\n    this.gui.addFolder('Lights');\n    this.gui.addFolder('Objects');\n    this.gui.addObjectToFolder('Scroll', this, [{\n      keyName: 'scrollLerp',\n      min: 0,\n      max: 1,\n      step: 0.01\n    }, {\n      keyName: 'scrollEase',\n      options: ['linear', 'easeOutQuad', 'easeInQuad']\n    }]);\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight); //   this.rafProgress.easeTo(this.progress, 0.26, EASE.easeInOutExpo);\n        //   this.rafProgress.easeTo(this.progress, 0.08, EASE.linear);\n\n        this.rafProgress.easeTo(this.progress, this.scrollLerp, _ease.EASE[this.scrollEase]);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.scene = new THREE.Scene();\n    this.gui.onUpdate(prop => {\n      this.draw();\n    });\n    var loader = new _GLTFLoader.GLTFLoader();\n    const path = './public/moon/moon1.gltf';\n    loader.load(path, gltf => {\n      const gltfData = gltf.parser.json;\n\n      const getNodeByName = name => {\n        return gltfData.nodes.filter(node => {\n          return node.name = name;\n        })[0];\n      };\n\n      console.log('gltf data', gltfData);\n      this.clock = new THREE.Clock();\n      const scene = gltf.scenes[0];\n      this.activeScene = scene;\n      this.animations = gltf.animations; // Animation Mixer\n\n      this.mixer = new THREE.AnimationMixer(scene); //Animation Clip\n\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i]; //Animation Action\n\n        var action = this.mixer.clipAction(animation);\n        console.log('added', animation);\n        action.play();\n      }\n\n      this.scene.add(scene);\n      console.log('scene', scene);\n      console.log('mixer', this.mixer); // http://learningthreejs.com/blog/2012/01/20/casting-shadows/\n\n      this.scene.traverse(child => {\n        if (child instanceof THREE.Light) {\n          // child.castShadow = true;\n          console.log(child.name);\n          console.log('light', child); // Debugging light positions.\n          // child.shadowCameraVisible = false;\n\n          if (child.shadow) {\n            // Adjust shadow bias.\n            // child.shadow.bias = -0.002;\n            // Remove the rigged looking shadows.\n            child.shadow.mapSize.width = 1024;\n            child.shadow.mapSize.height = 1024;\n            child.shadowDarkness = 1; // child.shadow.camera.near = 0;\n            // child.shadow.camera.far = 1000;\n            // var helper = new THREE.CameraHelper( child.shadow.camera );\n            // scene.add( helper );\n          } // child.layers.set(1);\n          // // Point lights are defined in watts which goes waay off in three.js\n\n\n          if (child instanceof THREE.PointLight) {\n            child.intensity = child.intensity * 0.05;\n          } // If it's a spot light, it needs to go down even more.\n\n\n          if (child.type == \"SpotLight\") {\n            child.intensity = child.intensity * 0.003;\n          }\n\n          this.gui.addFolder(child.name, 'Lights');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'intensity',\n            min: 0,\n            max: 3000\n          }, {\n            keyName: 'color'\n          }]);\n\n          if (child.shadow) {\n            const shadowFolderId = child.name + ' shadow'; // console.log(child.shadow);\n\n            this.gui.addFolder(shadowFolderId, child.name);\n            this.gui.addObjectToFolder(shadowFolderId, child.shadow, [{\n              keyName: 'bias',\n              min: -1,\n              max: 1,\n              step: 0.00001\n            }, {\n              keyName: 'radius',\n              min: 0,\n              max: 100,\n              step: 0.01\n            }]);\n          }\n        } else if (child instanceof THREE.Mesh) {\n          // child.geometry.computeVertexNormals(true);\n          console.log(child.name);\n          console.log('mesh', child); // If an object starts with 'text-' by convension, it will\n          // be considered a marker.\n\n          if (child.name.startsWith('text')) {\n            // Hide the marker\n            // This is important\n            child.visible = false;\n            this.textMarkers.push(child);\n          }\n\n          this.gui.addFolder(child.name, 'Objects');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'receiveShadow'\n          }]);\n\n          if (child.material) {\n            console.log('material', child.material);\n            const materialId = child.name + ' material';\n            this.gui.addFolder(materialId, child.name);\n            this.gui.addObjectToFolder(materialId, child.material, [{\n              keyName: 'emissiveIntensity',\n              min: 0,\n              max: 1\n            }, {\n              keyName: 'flatShading',\n              callback: () => {\n                child.material.needsUpdate = true;\n              }\n            }, {\n              keyName: 'wireframe',\n              callback: () => {\n                child.material.needsUpdate = true;\n              }\n            }]);\n\n            if (child.material.normalMap) {\n              console.log('normal map');\n              console.log(child.material.normalMap);\n              console.log(child.material.normalScale);\n            } // Enable smooth shading.\n            // child.material.flatShading = false;\n            // child.material.wireframe = false;\n            // child.material.needsUpdate = true;\n            // child.geometry.computeFaceNormals();\n            // child.geometry.computeVertexNormals(true);\n\n          }\n\n          if (child.name == 'Plane001') {\n            console.log('mesh', child);\n          } // Get the image mappings.\n          // if(child.material && child.material.map) {\n          //   child.material.map.needsUpdate = true;\n          // }\n\n        } else {// console.log('other', child);\n          }\n      }); // Set the camera exported in gltf.\n      // Requires camera to be exported for gltf.\n\n      this.camera = gltf.cameras[0];\n      console.log('camera', this.camera);\n      this.resize(); // Use fog to cover far distances.\n      // const color = 0x00000;\n      // this.scene.fog = new THREE.Fog(color, 5, 8);\n      // Enable shadows.\n      // https://threejs.org/docs/#api/en/constants/Renderer\n\n      this.renderer.shadowMap.enabled = true; // To antialias the shadow\n\n      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n      this.renderer.gammaOutput = true; // this.renderer.gammaFactor = 2.2;\n      // Important to get the correct colors.\n\n      this.renderer.physicallyCorrectLights = true; // Background as black.\n      // this.renderer.setClearColor(0x4287f5);\n\n      this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha); // Affects how strongly lights come exposed.\n      // https://threejs.org/examples/#webgl_tonemapping\n\n      this.renderer.toneMappingExposure = 1; // this.renderer.toneMappingExposure = 0.3;\n\n      this.renderer.toneMapping = THREE.ACESFilmicToneMapping;\n      this.gui.addObjectToFolder('Renderer', this.renderer, [{\n        keyName: 'toneMappingExposure',\n        min: 0,\n        max: 5,\n        step: 0.01\n      }, {\n        keyName: 'gammaFactor',\n        min: 0,\n        max: 10,\n        step: 0.01\n      }]);\n      this.gui.addObjectToFolder('Renderer', this.rendererConfig, [{\n        keyName: 'clearColor',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }, {\n        keyName: 'backgroundAlpha',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }]);\n      this.gui.addObjectToFolder('Camera', this.camera, [{\n        keyName: 'fov',\n        min: 0,\n        max: 50,\n        step: 0.01,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }, {\n        keyName: 'zoom',\n        min: 0,\n        max: 10,\n        step: 0.0001,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }]);\n      this.gui.addFolder('General Lights');\n      this.generalLightConfig = {\n        ambientLightColor: '#7395b3',\n        ambientLightAlpha: 0\n      }; // Additional lighting outside the blender.\n      // var light = new THREE.HemisphereLight( 0xffffff, 0x000000, 1 );\n      // this.scene.add( light );\n\n      this.ambientLight = new THREE.AmbientLight(this.generalLightConfig.ambientLightColor);\n      this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n      scene.add(this.ambientLight);\n      this.gui.addObjectToFolder('General Lights', this.generalLightConfig, [{\n        keyName: 'ambientLightColor',\n        callback: () => {\n          this.ambientLight.color = new THREE.Color(this.generalLightConfig.ambientLightColor);\n        }\n      }, {\n        keyName: 'ambientLightAlpha',\n        callback: () => {\n          this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n        }\n      }]); // var width = 50;\n      // var height = 50;\n      // var intensity = 0;\n      // var rectLight = new THREE.RectAreaLight('#FFFFFF', intensity,  width, height );\n      // rectLight.position.set( 0, 0, 25 );\n      // // rectLight.lookAt( 0, 0, 0 );\n      // this.scene.add( rectLight );\n      // rectLightHelper = new THREE.RectAreaLightHelper( rectLight );\n      // rectLight.add( rectLightHelper );\n\n      this.gui.addButton('Refresh', this.refresh.bind(this));\n      this.addStars(scene);\n    }, undefined, error => {\n      console.error(error);\n    });\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      // precision: 'highp'\n      autoSize: true\n    });\n    this.composer = new _EffectComposer.EffectComposer(this.renderer);\n    this.canvasContainer.appendChild(this.renderer.domElement);\n    window.addEventListener('resize', this.resize.bind(this), false);\n  }\n\n  addStars(scene) {\n    for (var i = 0; i < 300; i++) {\n      var geometry = new THREE.SphereGeometry(0.5, 32, 32);\n      var material = new THREE.MeshBasicMaterial({\n        color: 0xffffff\n      });\n      var sphere = new THREE.Mesh(geometry, material);\n      sphere.position.x = _mathf.mathf.getRandomInt(-5, 5);\n      sphere.position.y = _mathf.mathf.getRandomInt(-5, 5);\n      sphere.position.z = _mathf.mathf.getRandomInt(-5, 5);\n      sphere.scale.x = sphere.scale.y = sphere.scale.z = 0.01;\n      scene.add(sphere);\n    }\n  }\n\n  resize() {\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.width = this.canvasContainer.parentElement.offsetWidth;\n    this.height = this.canvasContainer.parentElement.offsetHeight; // https://github.com/donmccurdy/three-gltf-viewer/blob/master/src/viewer.js\n    // https://threejs.org/docs/#api/en/constants/Renderer\n\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n    this.renderer.setSize(this.width, this.height); // Post processing\n    // this.composer.setSize( this.width, this.height);\n    // const fxaaPass = new ShaderPass( FXAAShader );\n    // fxaaPass.material.uniforms[ 'resolution' ].value.x = 1 / ( this.width * window.devicePixelRatio);\n    // fxaaPass.material.uniforms[ 'resolution' ].value.y = 1 / ( this.height * window.devicePixelRatio);\n    // this.composer.addPass(fxaaPass);\n    // this.composer.addPass(new RenderPass(this.scene, this.camera));\n    // var bloomPass = new Unr2.2mealBloomPass(1, 25, 5, 256);\n    // this.composer.addPass(bloomPass);\n    // The camera aspect goes off since it could be exported at a different\n    // ratio.  Force update the aspect ratio.\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n  }\n\n  refresh() {\n    this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n    this.resize();\n    this.draw();\n  }\n\n  getAnimationByName(name) {\n    return this.animations.filter(animationClip => {\n      return animationClip.name == name;\n    })[0];\n  }\n\n  getObjectByName(name) {\n    return this.activeScene.children.filter(object3d => {\n      return object3d.name == name;\n    })[0];\n  }\n\n  onProgressUpdate(progress) {\n    //Animation Mixer\n    if (this.mixer) {\n      // We need to find out how long the animation is.\n      // The mixer appears to have no knowledge oft this so we need to\n      // look up a specific animation and get the duration to\n      // get the total duration of the animation.\n      const cameraAnimation = this.getAnimationByName('CameraAction');\n      const duration = cameraAnimation.duration; // When duration hits it's max, animationMixer seems to hit the first\n      // frame so next allow it to reach the max value.\n\n      this.mixer.setTime(Math.min(duration * progress, duration - 1));\n    }\n\n    const getMarkerByName = name => {\n      return this.textMarkers.filter(marker => {\n        return marker.userData.name == name;\n      })[0];\n    }; // Text marker1.\n\n\n    const marker = getMarkerByName('text-marker1');\n\n    const domCoordinates = _threef.threef.toDomCoordinates(marker, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight); // Billboarded and not scaling.\n\n\n    domCoordinates.z = 1;\n\n    _threef.threef.applyVectorToDom(this.textMarker1, domCoordinates, null); // Text marker2.\n\n\n    const marker2 = getMarkerByName('text-marker2');\n\n    const domCoordinates2 = _threef.threef.toDomCoordinates(marker2, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight); // Billboarded and not scaling.\n\n\n    domCoordinates2.z = 1;\n\n    const domRotation2 = _threef.threef.toDomRotation(marker2, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight);\n\n    _threef.threef.applyVectorToDom(this.textMarker2, domCoordinates2, domRotation2);\n\n    this.draw();\n  }\n\n  draw() {\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = ThreeObjectViewer10;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1vYmplY3Qtdmlld2VyMTAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy90aHJlZS1vYmplY3Qtdmlld2VyMTAuanM/OWMwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9kYXRndWlmID0gcmVxdWlyZShcIi4uL2xpYi9kYXRndWlmL2RhdGd1aWZcIik7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfR0xURkxvYWRlciA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9HTFRGTG9hZGVyXCIpO1xuXG52YXIgX0VmZmVjdENvbXBvc2VyID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9FZmZlY3RDb21wb3NlclwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWYtcHJvZ3Jlc3NcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tXCIpO1xuXG52YXIgX2Vhc2UgPSByZXF1aXJlKFwiLi4vbGliL2Vhc2UvZWFzZVwiKTtcblxudmFyIF9tYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvbWF0aGZcIik7XG5cbnZhciBfdGhyZWVmID0gcmVxdWlyZShcIi4uL2xpYi90aHJlZWYvdGhyZWVmXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8vIGh0dHBzOi8vc3ZzLmdzZmMubmFzYS5nb3YvNDcyMFxuLy8gaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNhcGkvZW4vbWF0ZXJpYWxzL01lc2hTdGFuZGFyZE1hdGVyaWFsXG4vLyBodHRwczovL3FpaXRhLmNvbS9hZHJzMjAwMi9pdGVtcy9kYzY0MTZkNmZkMjM4OWM3NWFiNVxuLy8gaHR0cHM6Ly9xaWl0YS5jb20vY3gyMC9pdGVtcy8yYjg2Y2I1MDUyY2Q3YzM2MDM4YVxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTQyODMwODAvbm9ybWFsLW1hcC12YWx1ZXMtd2l0aC10aHJlZWpzLWdsdGYtYmxlbmRlci1leHBvcnRlcj9ycT0xXG4vLyBUaGUgZ2xURiBmb3JtYXQgZG9lcyBub3QgYWxsb3cgYnVtcCBtYXBzLiAgVXNlIG5vcm1hbCBtYXBzLlxuLy8gaHR0cHM6Ly9kaXNjb3Vyc2UudGhyZWVqcy5vcmcvdC90aHJlZS1qcy1nbHRmLW1vZGVsLWV4cG9ydGVkLWZyb20tZWRpdG9yLWJ1bXAtbWFwLW5vdC1yZW5kZXJpbmcvMTA4MzVcbi8vXG4vLyAtIHdhdGNoIG92ZXIgZXhwb3N1cmUgb2Ygbm9ybWFsIG1hcFxuLy8gLSBwbmcgYmFzZWQgbm9ybWFsIG1hcCB3b3JrcyBiZXR0ZXI/IChqcGcgb3ZlciBleHBvc2VkPylcbi8vXG4vLyBpbXBvcnQgeyBSYWYgfSBmcm9tICcuLi9saWIvcmFmL3JhZic7XG5jbGFzcyBUaHJlZU9iamVjdFZpZXdlcjEwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coJ1RocmVlSlMgT2JqZWN0IFZpZXdlciBEZW1vJyk7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcmVudCcpO1xuICAgIHRoaXMuY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcy1jb250YWluZXInKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIgPSBuZXcgX2RvbVdhdGNoZXIuRG9tV2F0Y2hlcigpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3MgPSBuZXcgX3JhZlByb2dyZXNzLlJhZlByb2dyZXNzKCk7XG4gICAgdGhpcy5yYWZQcm9ncmVzcy53YXRjaCh0aGlzLm9uUHJvZ3Jlc3NVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zY3JvbGxMZXJwID0gMC4zODtcbiAgICB0aGlzLnNjcm9sbEVhc2UgPSAnZWFzZUluUXVhZCc7XG4gICAgdGhpcy50ZXh0TWFya2VyMSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXh0LW1hcmtlcjEnKTtcbiAgICB0aGlzLnRleHRNYXJrZXIyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RleHQtbWFya2VyMicpO1xuICAgIHRoaXMudGV4dE1hcmtlcnMgPSBbXTtcbiAgICB0aGlzLnJlbmRlcmVyQ29uZmlnID0ge1xuICAgICAgY2xlYXJDb2xvcjogJyMwMDAwMDAnLFxuICAgICAgYmFja2dyb3VuZEFscGhhOiAxLjBcbiAgICB9O1xuICAgIHRoaXMuZ3VpID0gbmV3IF9kYXRndWlmLkRhdGd1aWYoe1xuICAgICAgbG9hZDogSlNPTlxuICAgIH0pO1xuICAgIHRoaXMuZ3VpLmFkZEZvbGRlcignU2V0dGluZ3MnKS5vcGVuKCk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdSZW5kZXJlcicsICdTZXR0aW5ncycpO1xuICAgIHRoaXMuZ3VpLmFkZEZvbGRlcignQ2FtZXJhJywgJ1NldHRpbmdzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdTY3JvbGwnLCAnU2V0dGluZ3MnKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ0xpZ2h0cycpO1xuICAgIHRoaXMuZ3VpLmFkZEZvbGRlcignT2JqZWN0cycpO1xuICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdTY3JvbGwnLCB0aGlzLCBbe1xuICAgICAga2V5TmFtZTogJ3Njcm9sbExlcnAnLFxuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxLFxuICAgICAgc3RlcDogMC4wMVxuICAgIH0sIHtcbiAgICAgIGtleU5hbWU6ICdzY3JvbGxFYXNlJyxcbiAgICAgIG9wdGlvbnM6IFsnbGluZWFyJywgJ2Vhc2VPdXRRdWFkJywgJ2Vhc2VJblF1YWQnXVxuICAgIH1dKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnc2Nyb2xsJyxcbiAgICAgIGNhbGxiYWNrOiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCwgd2luZG93LmlubmVySGVpZ2h0KTsgLy8gICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAwLjI2LCBFQVNFLmVhc2VJbk91dEV4cG8pO1xuICAgICAgICAvLyAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDAuMDgsIEVBU0UubGluZWFyKTtcblxuICAgICAgICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCB0aGlzLnNjcm9sbExlcnAsIF9lYXNlLkVBU0VbdGhpcy5zY3JvbGxFYXNlXSk7XG4gICAgICB9LFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgdGhpcy5ndWkub25VcGRhdGUocHJvcCA9PiB7XG4gICAgICB0aGlzLmRyYXcoKTtcbiAgICB9KTtcbiAgICB2YXIgbG9hZGVyID0gbmV3IF9HTFRGTG9hZGVyLkdMVEZMb2FkZXIoKTtcbiAgICBjb25zdCBwYXRoID0gJy4vcHVibGljL21vb24vbW9vbjEuZ2x0Zic7XG4gICAgbG9hZGVyLmxvYWQocGF0aCwgZ2x0ZiA9PiB7XG4gICAgICBjb25zdCBnbHRmRGF0YSA9IGdsdGYucGFyc2VyLmpzb247XG5cbiAgICAgIGNvbnN0IGdldE5vZGVCeU5hbWUgPSBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIGdsdGZEYXRhLm5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5uYW1lID0gbmFtZTtcbiAgICAgICAgfSlbMF07XG4gICAgICB9O1xuXG4gICAgICBjb25zb2xlLmxvZygnZ2x0ZiBkYXRhJywgZ2x0ZkRhdGEpO1xuICAgICAgdGhpcy5jbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpO1xuICAgICAgY29uc3Qgc2NlbmUgPSBnbHRmLnNjZW5lc1swXTtcbiAgICAgIHRoaXMuYWN0aXZlU2NlbmUgPSBzY2VuZTtcbiAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGdsdGYuYW5pbWF0aW9uczsgLy8gQW5pbWF0aW9uIE1peGVy44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQXG5cbiAgICAgIHRoaXMubWl4ZXIgPSBuZXcgVEhSRUUuQW5pbWF0aW9uTWl4ZXIoc2NlbmUpOyAvL+WFqOOBpuOBrkFuaW1hdGlvbiBDbGlw44Gr5a++44GX44GmXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNbaV07IC8vQW5pbWF0aW9uIEFjdGlvbuOCkueUn+aIkFxuXG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLm1peGVyLmNsaXBBY3Rpb24oYW5pbWF0aW9uKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FkZGVkJywgYW5pbWF0aW9uKTtcbiAgICAgICAgYWN0aW9uLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY2VuZS5hZGQoc2NlbmUpO1xuICAgICAgY29uc29sZS5sb2coJ3NjZW5lJywgc2NlbmUpO1xuICAgICAgY29uc29sZS5sb2coJ21peGVyJywgdGhpcy5taXhlcik7IC8vIGh0dHA6Ly9sZWFybmluZ3RocmVlanMuY29tL2Jsb2cvMjAxMi8wMS8yMC9jYXN0aW5nLXNoYWRvd3MvXG5cbiAgICAgIHRoaXMuc2NlbmUudHJhdmVyc2UoY2hpbGQgPT4ge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCkge1xuICAgICAgICAgIC8vIGNoaWxkLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGNoaWxkLm5hbWUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdsaWdodCcsIGNoaWxkKTsgLy8gRGVidWdnaW5nIGxpZ2h0IHBvc2l0aW9ucy5cbiAgICAgICAgICAvLyBjaGlsZC5zaGFkb3dDYW1lcmFWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoY2hpbGQuc2hhZG93KSB7XG4gICAgICAgICAgICAvLyBBZGp1c3Qgc2hhZG93IGJpYXMuXG4gICAgICAgICAgICAvLyBjaGlsZC5zaGFkb3cuYmlhcyA9IC0wLjAwMjtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgcmlnZ2VkIGxvb2tpbmcgc2hhZG93cy5cbiAgICAgICAgICAgIGNoaWxkLnNoYWRvdy5tYXBTaXplLndpZHRoID0gMTAyNDtcbiAgICAgICAgICAgIGNoaWxkLnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IDEwMjQ7XG4gICAgICAgICAgICBjaGlsZC5zaGFkb3dEYXJrbmVzcyA9IDE7IC8vIGNoaWxkLnNoYWRvdy5jYW1lcmEubmVhciA9IDA7XG4gICAgICAgICAgICAvLyBjaGlsZC5zaGFkb3cuY2FtZXJhLmZhciA9IDEwMDA7XG4gICAgICAgICAgICAvLyB2YXIgaGVscGVyID0gbmV3IFRIUkVFLkNhbWVyYUhlbHBlciggY2hpbGQuc2hhZG93LmNhbWVyYSApO1xuICAgICAgICAgICAgLy8gc2NlbmUuYWRkKCBoZWxwZXIgKTtcbiAgICAgICAgICB9IC8vIGNoaWxkLmxheWVycy5zZXQoMSk7XG4gICAgICAgICAgLy8gLy8gUG9pbnQgbGlnaHRzIGFyZSBkZWZpbmVkIGluIHdhdHRzIHdoaWNoIGdvZXMgd2FheSBvZmYgaW4gdGhyZWUuanNcblxuXG4gICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCkge1xuICAgICAgICAgICAgY2hpbGQuaW50ZW5zaXR5ID0gY2hpbGQuaW50ZW5zaXR5ICogMC4wNTtcbiAgICAgICAgICB9IC8vIElmIGl0J3MgYSBzcG90IGxpZ2h0LCBpdCBuZWVkcyB0byBnbyBkb3duIGV2ZW4gbW9yZS5cblxuXG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT0gXCJTcG90TGlnaHRcIikge1xuICAgICAgICAgICAgY2hpbGQuaW50ZW5zaXR5ID0gY2hpbGQuaW50ZW5zaXR5ICogMC4wMDM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKGNoaWxkLm5hbWUsICdMaWdodHMnKTtcbiAgICAgICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcihjaGlsZC5uYW1lLCBjaGlsZCwgW3tcbiAgICAgICAgICAgIGtleU5hbWU6ICdjYXN0U2hhZG93J1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleU5hbWU6ICdpbnRlbnNpdHknLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAzMDAwXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5TmFtZTogJ2NvbG9yJ1xuICAgICAgICAgIH1dKTtcblxuICAgICAgICAgIGlmIChjaGlsZC5zaGFkb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd0ZvbGRlcklkID0gY2hpbGQubmFtZSArICcgc2hhZG93JzsgLy8gY29uc29sZS5sb2coY2hpbGQuc2hhZG93KTtcblxuICAgICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKHNoYWRvd0ZvbGRlcklkLCBjaGlsZC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKHNoYWRvd0ZvbGRlcklkLCBjaGlsZC5zaGFkb3csIFt7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdiaWFzJyxcbiAgICAgICAgICAgICAgbWluOiAtMSxcbiAgICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgICAgICBzdGVwOiAwLjAwMDAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdyYWRpdXMnLFxuICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgIG1heDogMTAwLFxuICAgICAgICAgICAgICBzdGVwOiAwLjAxXG4gICAgICAgICAgICB9XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICAgIC8vIGNoaWxkLmdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKHRydWUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGNoaWxkLm5hbWUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdtZXNoJywgY2hpbGQpOyAvLyBJZiBhbiBvYmplY3Qgc3RhcnRzIHdpdGggJ3RleHQtJyBieSBjb252ZW5zaW9uLCBpdCB3aWxsXG4gICAgICAgICAgLy8gYmUgY29uc2lkZXJlZCBhIG1hcmtlci5cblxuICAgICAgICAgIGlmIChjaGlsZC5uYW1lLnN0YXJ0c1dpdGgoJ3RleHQnKSkge1xuICAgICAgICAgICAgLy8gSGlkZSB0aGUgbWFya2VyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudFxuICAgICAgICAgICAgY2hpbGQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy50ZXh0TWFya2Vycy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmd1aS5hZGRGb2xkZXIoY2hpbGQubmFtZSwgJ09iamVjdHMnKTtcbiAgICAgICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcihjaGlsZC5uYW1lLCBjaGlsZCwgW3tcbiAgICAgICAgICAgIGtleU5hbWU6ICdjYXN0U2hhZG93J1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleU5hbWU6ICdyZWNlaXZlU2hhZG93J1xuICAgICAgICAgIH1dKTtcblxuICAgICAgICAgIGlmIChjaGlsZC5tYXRlcmlhbCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ21hdGVyaWFsJywgY2hpbGQubWF0ZXJpYWwpO1xuICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWxJZCA9IGNoaWxkLm5hbWUgKyAnIG1hdGVyaWFsJztcbiAgICAgICAgICAgIHRoaXMuZ3VpLmFkZEZvbGRlcihtYXRlcmlhbElkLCBjaGlsZC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKG1hdGVyaWFsSWQsIGNoaWxkLm1hdGVyaWFsLCBbe1xuICAgICAgICAgICAgICBrZXlOYW1lOiAnZW1pc3NpdmVJbnRlbnNpdHknLFxuICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgIG1heDogMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXlOYW1lOiAnZmxhdFNoYWRpbmcnLFxuICAgICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXlOYW1lOiAnd2lyZWZyYW1lJyxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkLm1hdGVyaWFsLm5vcm1hbE1hcCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnbm9ybWFsIG1hcCcpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjaGlsZC5tYXRlcmlhbC5ub3JtYWxNYXApO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjaGlsZC5tYXRlcmlhbC5ub3JtYWxTY2FsZSk7XG4gICAgICAgICAgICB9IC8vIEVuYWJsZSBzbW9vdGggc2hhZGluZy5cbiAgICAgICAgICAgIC8vIGNoaWxkLm1hdGVyaWFsLmZsYXRTaGFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBjaGlsZC5tYXRlcmlhbC53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGNoaWxkLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGNoaWxkLmdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgICAgICAgICAgLy8gY2hpbGQuZ2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHModHJ1ZSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hpbGQubmFtZSA9PSAnUGxhbmUwMDEnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbWVzaCcsIGNoaWxkKTtcbiAgICAgICAgICB9IC8vIEdldCB0aGUgaW1hZ2UgbWFwcGluZ3MuXG4gICAgICAgICAgLy8gaWYoY2hpbGQubWF0ZXJpYWwgJiYgY2hpbGQubWF0ZXJpYWwubWFwKSB7XG4gICAgICAgICAgLy8gICBjaGlsZC5tYXRlcmlhbC5tYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIC8vIH1cblxuICAgICAgICB9IGVsc2Ugey8vIGNvbnNvbGUubG9nKCdvdGhlcicsIGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICB9KTsgLy8gU2V0IHRoZSBjYW1lcmEgZXhwb3J0ZWQgaW4gZ2x0Zi5cbiAgICAgIC8vIFJlcXVpcmVzIGNhbWVyYSB0byBiZSBleHBvcnRlZCBmb3IgZ2x0Zi5cblxuICAgICAgdGhpcy5jYW1lcmEgPSBnbHRmLmNhbWVyYXNbMF07XG4gICAgICBjb25zb2xlLmxvZygnY2FtZXJhJywgdGhpcy5jYW1lcmEpO1xuICAgICAgdGhpcy5yZXNpemUoKTsgLy8gVXNlIGZvZyB0byBjb3ZlciBmYXIgZGlzdGFuY2VzLlxuICAgICAgLy8gY29uc3QgY29sb3IgPSAweDAwMDAwO1xuICAgICAgLy8gdGhpcy5zY2VuZS5mb2cgPSBuZXcgVEhSRUUuRm9nKGNvbG9yLCA1LCA4KTtcbiAgICAgIC8vIEVuYWJsZSBzaGFkb3dzLlxuICAgICAgLy8gaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNhcGkvZW4vY29uc3RhbnRzL1JlbmRlcmVyXG5cbiAgICAgIHRoaXMucmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSB0cnVlOyAvLyBUbyBhbnRpYWxpYXMgdGhlIHNoYWRvd1xuXG4gICAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd01hcC50eXBlID0gVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2FtbWFPdXRwdXQgPSB0cnVlOyAvLyB0aGlzLnJlbmRlcmVyLmdhbW1hRmFjdG9yID0gMi4yO1xuICAgICAgLy8gSW1wb3J0YW50IHRvIGdldCB0aGUgY29ycmVjdCBjb2xvcnMuXG5cbiAgICAgIHRoaXMucmVuZGVyZXIucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgPSB0cnVlOyAvLyBCYWNrZ3JvdW5kIGFzIGJsYWNrLlxuICAgICAgLy8gdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4NDI4N2Y1KTtcblxuICAgICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMucmVuZGVyZXJDb25maWcuY2xlYXJDb2xvciwgdGhpcy5yZW5kZXJlckNvbmZpZy5iYWNrZ3JvdW5kQWxwaGEpOyAvLyBBZmZlY3RzIGhvdyBzdHJvbmdseSBsaWdodHMgY29tZSBleHBvc2VkLlxuICAgICAgLy8gaHR0cHM6Ly90aHJlZWpzLm9yZy9leGFtcGxlcy8jd2ViZ2xfdG9uZW1hcHBpbmdcblxuICAgICAgdGhpcy5yZW5kZXJlci50b25lTWFwcGluZ0V4cG9zdXJlID0gMTsgLy8gdGhpcy5yZW5kZXJlci50b25lTWFwcGluZ0V4cG9zdXJlID0gMC4zO1xuXG4gICAgICB0aGlzLnJlbmRlcmVyLnRvbmVNYXBwaW5nID0gVEhSRUUuQUNFU0ZpbG1pY1RvbmVNYXBwaW5nO1xuICAgICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoJ1JlbmRlcmVyJywgdGhpcy5yZW5kZXJlciwgW3tcbiAgICAgICAga2V5TmFtZTogJ3RvbmVNYXBwaW5nRXhwb3N1cmUnLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogNSxcbiAgICAgICAgc3RlcDogMC4wMVxuICAgICAgfSwge1xuICAgICAgICBrZXlOYW1lOiAnZ2FtbWFGYWN0b3InLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMTAsXG4gICAgICAgIHN0ZXA6IDAuMDFcbiAgICAgIH1dKTtcbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdSZW5kZXJlcicsIHRoaXMucmVuZGVyZXJDb25maWcsIFt7XG4gICAgICAgIGtleU5hbWU6ICdjbGVhckNvbG9yJyxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5yZW5kZXJlckNvbmZpZy5jbGVhckNvbG9yLCB0aGlzLnJlbmRlcmVyQ29uZmlnLmJhY2tncm91bmRBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5TmFtZTogJ2JhY2tncm91bmRBbHBoYScsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMucmVuZGVyZXJDb25maWcuY2xlYXJDb2xvciwgdGhpcy5yZW5kZXJlckNvbmZpZy5iYWNrZ3JvdW5kQWxwaGEpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcignQ2FtZXJhJywgdGhpcy5jYW1lcmEsIFt7XG4gICAgICAgIGtleU5hbWU6ICdmb3YnLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogNTAsXG4gICAgICAgIHN0ZXA6IDAuMDEsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleU5hbWU6ICd6b29tJyxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDEwLFxuICAgICAgICBzdGVwOiAwLjAwMDEsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ0dlbmVyYWwgTGlnaHRzJyk7XG4gICAgICB0aGlzLmdlbmVyYWxMaWdodENvbmZpZyA9IHtcbiAgICAgICAgYW1iaWVudExpZ2h0Q29sb3I6ICcjNzM5NWIzJyxcbiAgICAgICAgYW1iaWVudExpZ2h0QWxwaGE6IDBcbiAgICAgIH07IC8vIEFkZGl0aW9uYWwgbGlnaHRpbmcgb3V0c2lkZSB0aGUgYmxlbmRlci5cbiAgICAgIC8vIHZhciBsaWdodCA9IG5ldyBUSFJFRS5IZW1pc3BoZXJlTGlnaHQoIDB4ZmZmZmZmLCAweDAwMDAwMCwgMSApO1xuICAgICAgLy8gdGhpcy5zY2VuZS5hZGQoIGxpZ2h0ICk7XG5cbiAgICAgIHRoaXMuYW1iaWVudExpZ2h0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCh0aGlzLmdlbmVyYWxMaWdodENvbmZpZy5hbWJpZW50TGlnaHRDb2xvcik7XG4gICAgICB0aGlzLmFtYmllbnRMaWdodC5pbnRlbnNpdHkgPSB0aGlzLmdlbmVyYWxMaWdodENvbmZpZy5hbWJpZW50TGlnaHRBbHBoYTtcbiAgICAgIHNjZW5lLmFkZCh0aGlzLmFtYmllbnRMaWdodCk7XG4gICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcignR2VuZXJhbCBMaWdodHMnLCB0aGlzLmdlbmVyYWxMaWdodENvbmZpZywgW3tcbiAgICAgICAga2V5TmFtZTogJ2FtYmllbnRMaWdodENvbG9yJyxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFtYmllbnRMaWdodC5jb2xvciA9IG5ldyBUSFJFRS5Db2xvcih0aGlzLmdlbmVyYWxMaWdodENvbmZpZy5hbWJpZW50TGlnaHRDb2xvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5TmFtZTogJ2FtYmllbnRMaWdodEFscGhhJyxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFtYmllbnRMaWdodC5pbnRlbnNpdHkgPSB0aGlzLmdlbmVyYWxMaWdodENvbmZpZy5hbWJpZW50TGlnaHRBbHBoYTtcbiAgICAgICAgfVxuICAgICAgfV0pOyAvLyB2YXIgd2lkdGggPSA1MDtcbiAgICAgIC8vIHZhciBoZWlnaHQgPSA1MDtcbiAgICAgIC8vIHZhciBpbnRlbnNpdHkgPSAwO1xuICAgICAgLy8gdmFyIHJlY3RMaWdodCA9IG5ldyBUSFJFRS5SZWN0QXJlYUxpZ2h0KCcjRkZGRkZGJywgaW50ZW5zaXR5LCAgd2lkdGgsIGhlaWdodCApO1xuICAgICAgLy8gcmVjdExpZ2h0LnBvc2l0aW9uLnNldCggMCwgMCwgMjUgKTtcbiAgICAgIC8vIC8vIHJlY3RMaWdodC5sb29rQXQoIDAsIDAsIDAgKTtcbiAgICAgIC8vIHRoaXMuc2NlbmUuYWRkKCByZWN0TGlnaHQgKTtcbiAgICAgIC8vIHJlY3RMaWdodEhlbHBlciA9IG5ldyBUSFJFRS5SZWN0QXJlYUxpZ2h0SGVscGVyKCByZWN0TGlnaHQgKTtcbiAgICAgIC8vIHJlY3RMaWdodC5hZGQoIHJlY3RMaWdodEhlbHBlciApO1xuXG4gICAgICB0aGlzLmd1aS5hZGRCdXR0b24oJ1JlZnJlc2gnLCB0aGlzLnJlZnJlc2guYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmFkZFN0YXJzKHNjZW5lKTtcbiAgICB9LCB1bmRlZmluZWQsIGVycm9yID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICAvLyBwcmVjaXNpb246ICdoaWdocCdcbiAgICAgIGF1dG9TaXplOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb21wb3NlciA9IG5ldyBfRWZmZWN0Q29tcG9zZXIuRWZmZWN0Q29tcG9zZXIodGhpcy5yZW5kZXJlcik7XG4gICAgdGhpcy5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemUuYmluZCh0aGlzKSwgZmFsc2UpO1xuICB9XG5cbiAgYWRkU3RhcnMoc2NlbmUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMwMDsgaSsrKSB7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC41LCAzMiwgMzIpO1xuICAgICAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgY29sb3I6IDB4ZmZmZmZmXG4gICAgICB9KTtcbiAgICAgIHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgc3BoZXJlLnBvc2l0aW9uLnggPSBfbWF0aGYubWF0aGYuZ2V0UmFuZG9tSW50KC01LCA1KTtcbiAgICAgIHNwaGVyZS5wb3NpdGlvbi55ID0gX21hdGhmLm1hdGhmLmdldFJhbmRvbUludCgtNSwgNSk7XG4gICAgICBzcGhlcmUucG9zaXRpb24ueiA9IF9tYXRoZi5tYXRoZi5nZXRSYW5kb21JbnQoLTUsIDUpO1xuICAgICAgc3BoZXJlLnNjYWxlLnggPSBzcGhlcmUuc2NhbGUueSA9IHNwaGVyZS5zY2FsZS56ID0gMC4wMTtcbiAgICAgIHNjZW5lLmFkZChzcGhlcmUpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2l6ZSgpIHtcbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMSwgX2Vhc2UuRUFTRS5MaW5lYXIpO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhc0NvbnRhaW5lci5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXNDb250YWluZXIucGFyZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kb25tY2N1cmR5L3RocmVlLWdsdGYtdmlld2VyL2Jsb2IvbWFzdGVyL3NyYy92aWV3ZXIuanNcbiAgICAvLyBodHRwczovL3RocmVlanMub3JnL2RvY3MvI2FwaS9lbi9jb25zdGFudHMvUmVuZGVyZXJcblxuICAgIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTsgLy8gUG9zdCBwcm9jZXNzaW5nXG4gICAgLy8gdGhpcy5jb21wb3Nlci5zZXRTaXplKCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgLy8gY29uc3QgZnhhYVBhc3MgPSBuZXcgU2hhZGVyUGFzcyggRlhBQVNoYWRlciApO1xuICAgIC8vIGZ4YWFQYXNzLm1hdGVyaWFsLnVuaWZvcm1zWyAncmVzb2x1dGlvbicgXS52YWx1ZS54ID0gMSAvICggdGhpcy53aWR0aCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAvLyBmeGFhUGFzcy5tYXRlcmlhbC51bmlmb3Jtc1sgJ3Jlc29sdXRpb24nIF0udmFsdWUueSA9IDEgLyAoIHRoaXMuaGVpZ2h0ICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIC8vIHRoaXMuY29tcG9zZXIuYWRkUGFzcyhmeGFhUGFzcyk7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5hZGRQYXNzKG5ldyBSZW5kZXJQYXNzKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKSk7XG4gICAgLy8gdmFyIGJsb29tUGFzcyA9IG5ldyBVbnIyLjJtZWFsQmxvb21QYXNzKDEsIDI1LCA1LCAyNTYpO1xuICAgIC8vIHRoaXMuY29tcG9zZXIuYWRkUGFzcyhibG9vbVBhc3MpO1xuICAgIC8vIFRoZSBjYW1lcmEgYXNwZWN0IGdvZXMgb2ZmIHNpbmNlIGl0IGNvdWxkIGJlIGV4cG9ydGVkIGF0IGEgZGlmZmVyZW50XG4gICAgLy8gcmF0aW8uICBGb3JjZSB1cGRhdGUgdGhlIGFzcGVjdCByYXRpby5cblxuICAgIHRoaXMuY2FtZXJhLmFzcGVjdCA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcih0aGlzLnJlbmRlcmVyQ29uZmlnLmNsZWFyQ29sb3IsIHRoaXMucmVuZGVyZXJDb25maWcuYmFja2dyb3VuZEFscGhhKTtcbiAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIHRoaXMuZHJhdygpO1xuICB9XG5cbiAgZ2V0QW5pbWF0aW9uQnlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRpb25zLmZpbHRlcihhbmltYXRpb25DbGlwID0+IHtcbiAgICAgIHJldHVybiBhbmltYXRpb25DbGlwLm5hbWUgPT0gbmFtZTtcbiAgICB9KVswXTtcbiAgfVxuXG4gIGdldE9iamVjdEJ5TmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlU2NlbmUuY2hpbGRyZW4uZmlsdGVyKG9iamVjdDNkID0+IHtcbiAgICAgIHJldHVybiBvYmplY3QzZC5uYW1lID09IG5hbWU7XG4gICAgfSlbMF07XG4gIH1cblxuICBvblByb2dyZXNzVXBkYXRlKHByb2dyZXNzKSB7XG4gICAgLy9BbmltYXRpb24gTWl4ZXLjgpLlrp/ooYxcbiAgICBpZiAodGhpcy5taXhlcikge1xuICAgICAgLy8gV2UgbmVlZCB0byBmaW5kIG91dCBob3cgbG9uZyB0aGUgYW5pbWF0aW9uIGlzLlxuICAgICAgLy8gVGhlIG1peGVyIGFwcGVhcnMgdG8gaGF2ZSBubyBrbm93bGVkZ2Ugb2Z0IHRoaXMgc28gd2UgbmVlZCB0b1xuICAgICAgLy8gbG9vayB1cCBhIHNwZWNpZmljIGFuaW1hdGlvbiBhbmQgZ2V0IHRoZSBkdXJhdGlvbiB0b1xuICAgICAgLy8gZ2V0IHRoZSB0b3RhbCBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlxuICAgICAgY29uc3QgY2FtZXJhQW5pbWF0aW9uID0gdGhpcy5nZXRBbmltYXRpb25CeU5hbWUoJ0NhbWVyYUFjdGlvbicpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBjYW1lcmFBbmltYXRpb24uZHVyYXRpb247IC8vIFdoZW4gZHVyYXRpb24gaGl0cyBpdCdzIG1heCwgYW5pbWF0aW9uTWl4ZXIgc2VlbXMgdG8gaGl0IHRoZSBmaXJzdFxuICAgICAgLy8gZnJhbWUgc28gbmV4dCBhbGxvdyBpdCB0byByZWFjaCB0aGUgbWF4IHZhbHVlLlxuXG4gICAgICB0aGlzLm1peGVyLnNldFRpbWUoTWF0aC5taW4oZHVyYXRpb24gKiBwcm9ncmVzcywgZHVyYXRpb24gLSAxKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ2V0TWFya2VyQnlOYW1lID0gbmFtZSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0TWFya2Vycy5maWx0ZXIobWFya2VyID0+IHtcbiAgICAgICAgcmV0dXJuIG1hcmtlci51c2VyRGF0YS5uYW1lID09IG5hbWU7XG4gICAgICB9KVswXTtcbiAgICB9OyAvLyBUZXh0IG1hcmtlcjEuXG5cblxuICAgIGNvbnN0IG1hcmtlciA9IGdldE1hcmtlckJ5TmFtZSgndGV4dC1tYXJrZXIxJyk7XG5cbiAgICBjb25zdCBkb21Db29yZGluYXRlcyA9IF90aHJlZWYudGhyZWVmLnRvRG9tQ29vcmRpbmF0ZXMobWFya2VyLCB0aGlzLmNhbWVyYSwgdGhpcy5jYW52YXNDb250YWluZXIub2Zmc2V0V2lkdGgsIHRoaXMuY2FudmFzQ29udGFpbmVyLm9mZnNldEhlaWdodCk7IC8vIEJpbGxib2FyZGVkIGFuZCBub3Qgc2NhbGluZy5cblxuXG4gICAgZG9tQ29vcmRpbmF0ZXMueiA9IDE7XG5cbiAgICBfdGhyZWVmLnRocmVlZi5hcHBseVZlY3RvclRvRG9tKHRoaXMudGV4dE1hcmtlcjEsIGRvbUNvb3JkaW5hdGVzLCBudWxsKTsgLy8gVGV4dCBtYXJrZXIyLlxuXG5cbiAgICBjb25zdCBtYXJrZXIyID0gZ2V0TWFya2VyQnlOYW1lKCd0ZXh0LW1hcmtlcjInKTtcblxuICAgIGNvbnN0IGRvbUNvb3JkaW5hdGVzMiA9IF90aHJlZWYudGhyZWVmLnRvRG9tQ29vcmRpbmF0ZXMobWFya2VyMiwgdGhpcy5jYW1lcmEsIHRoaXMuY2FudmFzQ29udGFpbmVyLm9mZnNldFdpZHRoLCB0aGlzLmNhbnZhc0NvbnRhaW5lci5vZmZzZXRIZWlnaHQpOyAvLyBCaWxsYm9hcmRlZCBhbmQgbm90IHNjYWxpbmcuXG5cblxuICAgIGRvbUNvb3JkaW5hdGVzMi56ID0gMTtcblxuICAgIGNvbnN0IGRvbVJvdGF0aW9uMiA9IF90aHJlZWYudGhyZWVmLnRvRG9tUm90YXRpb24obWFya2VyMiwgdGhpcy5jYW1lcmEsIHRoaXMuY2FudmFzQ29udGFpbmVyLm9mZnNldFdpZHRoLCB0aGlzLmNhbnZhc0NvbnRhaW5lci5vZmZzZXRIZWlnaHQpO1xuXG4gICAgX3RocmVlZi50aHJlZWYuYXBwbHlWZWN0b3JUb0RvbSh0aGlzLnRleHRNYXJrZXIyLCBkb21Db29yZGluYXRlczIsIGRvbVJvdGF0aW9uMik7XG5cbiAgICB0aGlzLmRyYXcoKTtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gVGhyZWVPYmplY3RWaWV3ZXIxMDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/three-object-viewer10.js\n");

/***/ }),

/***/ "./examples/three-object-viewer11.js":
/*!*******************************************!*\
  !*** ./examples/three-object-viewer11.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _datguif = __webpack_require__(/*! ../lib/datguif/datguif */ \"./lib/datguif/datguif.js\");\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _GLTFLoader = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\nvar _EffectComposer = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n\nvar _RenderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n\nvar _UnrealBloomPass = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass.js */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n\nvar _FXAAShader = __webpack_require__(/*! three/examples/jsm/shaders/FXAAShader.js */ \"./node_modules/three/examples/jsm/shaders/FXAAShader.js\");\n\nvar _ShaderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/ShaderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/ShaderPass.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _threef = __webpack_require__(/*! ../lib/threef/threef */ \"./lib/threef/threef.js\");\n\nvar _minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n// https://svs.gsfc.nasa.gov/4720\n// https://threejs.org/docs/#api/en/materials/MeshStandardMaterial\n// https://qiita.com/adrs2002/items/dc6416d6fd2389c75ab5\n// https://qiita.com/cx20/items/2b86cb5052cd7c36038a\n// https://stackoverflow.com/questions/54283080/normal-map-values-with-threejs-gltf-blender-exporter?rq=1\n// The glTF format does not allow bump maps.  Use normal maps.\n// https://discourse.threejs.org/t/three-js-gltf-model-exported-from-editor-bump-map-not-rendering/10835\n//\n// - watch over exposure of normal map\n// - png based normal map works better? (jpg over exposed?)\n//\n// import { Raf } from '../lib/raf/raf';\nclass ThreeObjectViewer11 {\n  constructor() {\n    console.log('ThreeJS Object Viewer Demo');\n    this.parentElement = document.getElementById('parent');\n    this.canvasContainer = document.getElementById('canvas-container');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.rafProgress = new _rafProgress.RafProgress();\n    this.rafProgress.watch(this.onProgressUpdate.bind(this));\n    this.scrollLerp = 0.38;\n    this.scrollEase = 'easeInQuad';\n    this.domCamera = document.getElementById('canvas-dom-camera');\n    this.textMarker1 = document.getElementById('text-marker1');\n    this.textMarker2 = document.getElementById('text-marker2');\n    this.textMarker3 = document.getElementById('text-marker3');\n    this.textMarker4 = document.getElementById('text-marker4');\n    this.textMarker5 = document.getElementById('text-marker5');\n    this.textMarker6 = document.getElementById('text-marker6');\n    this.textMarkers = [];\n    this.rendererConfig = {\n      clearColor: '#000000',\n      backgroundAlpha: 1.0\n    };\n    this.gui = new _datguif.Datguif({\n      load: JSON\n    });\n    this.gui.addFolder('Settings').open();\n    this.gui.addFolder('Renderer', 'Settings');\n    this.gui.addFolder('Camera', 'Settings');\n    this.gui.addFolder('Scroll', 'Settings');\n    this.gui.addFolder('Lights');\n    this.gui.addFolder('Objects');\n    this.gui.addObjectToFolder('Scroll', this, [{\n      keyName: 'scrollLerp',\n      min: 0,\n      max: 1,\n      step: 0.01\n    }, {\n      keyName: 'scrollEase',\n      options: ['linear', 'easeOutQuad', 'easeInQuad']\n    }]);\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight); //   this.rafProgress.easeTo(this.progress, 0.26, EASE.easeInOutExpo);\n        //   this.rafProgress.easeTo(this.progress, 0.08, EASE.linear);\n\n        this.rafProgress.easeTo(this.progress, this.scrollLerp, _ease.EASE[this.scrollEase]);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.scene = new THREE.Scene();\n    this.gui.onUpdate(prop => {\n      this.draw();\n    });\n    var loader = new _GLTFLoader.GLTFLoader();\n    const path = './public/moon/three-object-viewer11.gltf';\n    loader.load(path, gltf => {\n      const gltfData = gltf.parser.json;\n\n      const getNodeByName = name => {\n        return gltfData.nodes.filter(node => {\n          return node.name = name;\n        })[0];\n      };\n\n      console.log('gltf data', gltfData);\n      this.clock = new THREE.Clock();\n      const scene = gltf.scenes[0];\n      this.activeScene = scene;\n      this.animations = gltf.animations; // Animation Mixer\n\n      this.mixer = new THREE.AnimationMixer(scene); //Animation Clip\n\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i]; //Animation Action\n\n        var action = this.mixer.clipAction(animation);\n        console.log('added', animation);\n        action.play();\n      }\n\n      this.scene.add(scene);\n      console.log('scene', scene);\n      console.log('mixer', this.mixer); // http://learningthreejs.com/blog/2012/01/20/casting-shadows/\n\n      this.scene.traverse(child => {\n        if (child instanceof THREE.Light) {\n          // child.castShadow = true;\n          console.log(child.name);\n          console.log('light', child); // Debugging light positions.\n          // child.shadowCameraVisible = false;\n\n          if (child.shadow) {\n            // Adjust shadow bias.\n            // child.shadow.bias = -0.002;\n            // Remove the rigged looking shadows.\n            child.shadow.mapSize.width = 1024;\n            child.shadow.mapSize.height = 1024;\n            child.shadowDarkness = 1; // child.shadow.camera.near = 0;\n            // child.shadow.camera.far = 1000;\n            // var helper = new THREE.CameraHelper( child.shadow.camera );\n            // scene.add( helper );\n          } // child.layers.set(1);\n          // // Point lights are defined in watts which goes waay off in three.js\n\n\n          if (child instanceof THREE.PointLight) {\n            child.intensity = child.intensity * 0.05;\n          } // If it's a spot light, it needs to go down even more.\n\n\n          if (child.type == \"SpotLight\") {\n            child.intensity = child.intensity * 0.003;\n          }\n\n          this.gui.addFolder(child.name, 'Lights');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'intensity',\n            min: 0,\n            max: 3000\n          }, {\n            keyName: 'color'\n          }]);\n\n          if (child.shadow) {\n            const shadowFolderId = child.name + ' shadow'; // console.log(child.shadow);\n\n            this.gui.addFolder(shadowFolderId, child.name);\n            this.gui.addObjectToFolder(shadowFolderId, child.shadow, [{\n              keyName: 'bias',\n              min: -1,\n              max: 1,\n              step: 0.00001\n            }, {\n              keyName: 'radius',\n              min: 0,\n              max: 100,\n              step: 0.01\n            }]);\n          }\n        } else if (child instanceof THREE.Mesh) {\n          // child.geometry.computeVertexNormals(true);\n          console.log(child.name);\n          console.log('mesh', child); // If an object starts with 'text-' by convension, it will\n          // be considered a marker.\n\n          if (child.name.startsWith('text')) {\n            // Hide the marker\n            // child.visible = false;\n            this.textMarkers.push(child);\n          }\n\n          this.gui.addFolder(child.name, 'Objects');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'receiveShadow'\n          }]);\n\n          if (child.material) {\n            console.log('material', child.material);\n            const materialId = child.name + ' material';\n            this.gui.addFolder(materialId, child.name);\n            this.gui.addObjectToFolder(materialId, child.material, [{\n              keyName: 'emissiveIntensity',\n              min: 0,\n              max: 1\n            }, {\n              keyName: 'flatShading',\n              callback: () => {\n                child.material.needsUpdate = true;\n              }\n            }, {\n              keyName: 'wireframe',\n              callback: () => {\n                child.material.needsUpdate = true;\n              }\n            }]);\n\n            if (child.material.normalMap) {\n              console.log('normal map');\n              console.log(child.material.normalMap);\n              console.log(child.material.normalScale);\n            } // Enable smooth shading.\n            // child.material.flatShading = false;\n            // child.material.wireframe = false;\n            // child.material.needsUpdate = true;\n            // child.geometry.computeFaceNormals();\n            // child.geometry.computeVertexNormals(true);\n\n          }\n\n          if (child.name == 'Plane001') {\n            console.log('mesh', child);\n          } // Get the image mappings.\n          // if(child.material && child.material.map) {\n          //   child.material.map.needsUpdate = true;\n          // }\n\n        } else {// console.log('other', child);\n          }\n      }); // Set the camera exported in gltf.\n      // Requires camera to be exported for gltf.\n\n      this.camera = gltf.cameras[0];\n      console.log('camera', this.camera);\n      this.resize(); // Use fog to cover far distances.\n      // const color = 0x00000;\n      // this.scene.fog = new THREE.Fog(color, 5, 8);\n      // Enable shadows.\n      // https://threejs.org/docs/#api/en/constants/Renderer\n\n      this.renderer.shadowMap.enabled = true; // To antialias the shadow\n\n      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n      this.renderer.gammaOutput = true; // this.renderer.gammaFactor = 2.2;\n      // Important to get the correct colors.\n\n      this.renderer.physicallyCorrectLights = true; // Background as black.\n      // this.renderer.setClearColor(0x4287f5);\n\n      this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha); // Affects how strongly lights come exposed.\n      // https://threejs.org/examples/#webgl_tonemapping\n\n      this.renderer.toneMappingExposure = 1; // this.renderer.toneMappingExposure = 0.3;\n\n      this.renderer.toneMapping = THREE.ACESFilmicToneMapping;\n      this.gui.addObjectToFolder('Renderer', this.renderer, [{\n        keyName: 'toneMappingExposure',\n        min: 0,\n        max: 5,\n        step: 0.01\n      }, {\n        keyName: 'gammaFactor',\n        min: 0,\n        max: 10,\n        step: 0.01\n      }]);\n      this.gui.addObjectToFolder('Renderer', this.rendererConfig, [{\n        keyName: 'clearColor',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }, {\n        keyName: 'backgroundAlpha',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }]);\n      this.gui.addObjectToFolder('Camera', this.camera, [{\n        keyName: 'fov',\n        min: 0,\n        max: 50,\n        step: 0.01,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }, {\n        keyName: 'zoom',\n        min: 0,\n        max: 10,\n        step: 0.0001,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }]);\n      this.gui.addFolder('General Lights');\n      this.generalLightConfig = {\n        ambientLightColor: '#FFFFFF',\n        ambientLightAlpha: 1\n      }; // Additional lighting outside the blender.\n      // var light = new THREE.HemisphereLight( 0xffffff, 0x000000, 1 );\n      // this.scene.add( light );\n\n      this.ambientLight = new THREE.AmbientLight(this.generalLightConfig.ambientLightColor);\n      this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n      scene.add(this.ambientLight);\n      this.gui.addObjectToFolder('General Lights', this.generalLightConfig, [{\n        keyName: 'ambientLightColor',\n        callback: () => {\n          this.ambientLight.color = new THREE.Color(this.generalLightConfig.ambientLightColor);\n        }\n      }, {\n        keyName: 'ambientLightAlpha',\n        callback: () => {\n          this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n        }\n      }]);\n      this.gui.addButton('Refresh', this.refresh.bind(this));\n    }, undefined, error => {\n      console.error(error);\n    });\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      // precision: 'highp'\n      autoSize: true\n    });\n    this.composer = new _EffectComposer.EffectComposer(this.renderer);\n    this.canvasContainer.appendChild(this.renderer.domElement);\n    window.addEventListener('resize', this.resize.bind(this), false);\n  }\n\n  resize() {\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.width = this.canvasContainer.parentElement.offsetWidth;\n    this.height = this.canvasContainer.parentElement.offsetHeight; // https://github.com/donmccurdy/three-gltf-viewer/blob/master/src/viewer.js\n    // https://threejs.org/docs/#api/en/constants/Renderer\n\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n    this.renderer.setSize(this.width, this.height); // Post processing\n    // this.composer.setSize( this.width, this.height);\n    // const fxaaPass = new ShaderPass( FXAAShader );\n    // fxaaPass.material.uniforms[ 'resolution' ].value.x = 1 / ( this.width * window.devicePixelRatio);\n    // fxaaPass.material.uniforms[ 'resolution' ].value.y = 1 / ( this.height * window.devicePixelRatio);\n    // this.composer.addPass(fxaaPass);\n    // this.composer.addPass(new RenderPass(this.scene, this.camera));\n    // var bloomPass = new Unr2.2mealBloomPass(1, 25, 5, 256);\n    // this.composer.addPass(bloomPass);\n    // The camera aspect goes off since it could be exported at a different\n    // ratio.  Force update the aspect ratio.\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n  }\n\n  refresh() {\n    this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n    this.resize();\n    this.draw();\n  }\n\n  getAnimationByName(name) {\n    return this.animations.filter(animationClip => {\n      return animationClip.name == name;\n    })[0];\n  }\n\n  getObjectByName(name) {\n    return this.activeScene.children.filter(object3d => {\n      return object3d.name == name;\n    })[0];\n  }\n\n  onProgressUpdate(progress) {\n    //Animation Mixer\n    if (this.mixer) {\n      // We need to find out how long the animation is.\n      // The mixer appears to have no knowledge oft this so we need to\n      // look up a specific animation and get the duration to\n      // get the total duration of the animation.\n      const cameraAnimation = this.getAnimationByName('CameraAction');\n      const duration = cameraAnimation.duration; // When duration hits it's max, animationMixer seems to hit the first\n      // frame so next allow it to reach the max value.\n\n      this.mixer.setTime(Math.min(duration * progress, duration - 0.01));\n    }\n\n    const getMarkerByName = name => {\n      return this.textMarkers.filter(marker => {\n        return marker.userData.name == name;\n      })[0];\n    };\n\n    this.draw(); // Text marker1.\n\n    const marker = getMarkerByName('text-marker1');\n\n    const domCoordinates = _threef.threef.toDomCoordinates(marker, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight); // Billboarded and not scaling.\n\n\n    const domRotation = _threef.threef.toDomRotation(marker, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight);\n\n    _threef.threef.applyVectorToDom(this.textMarker1, domCoordinates, domRotation); // Text marker2.\n\n\n    const marker2 = getMarkerByName('text-marker2');\n\n    const domCoordinates2 = _threef.threef.toDomCoordinates(marker2, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight);\n\n    const domRotation2 = _threef.threef.toDomRotation(marker2, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight);\n\n    _threef.threef.applyVectorToDom(this.textMarker2, domCoordinates2, domRotation2); // Text marker3.\n\n\n    const marker3 = getMarkerByName('text-marker3');\n\n    const domCoordinates3 = _threef.threef.toDomCoordinates(marker3, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight);\n\n    const domRotation3 = _threef.threef.toDomRotation(marker3, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight);\n\n    _threef.threef.applyVectorToDom(this.textMarker3, domCoordinates3, domRotation3);\n\n    const marker4 = getMarkerByName('text-marker4');\n\n    const domCoordinates4 = _threef.threef.toDomCoordinates(marker4, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight, 0.3);\n\n    const domRotation4 = _threef.threef.toDomRotation(marker4, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight);\n\n    _threef.threef.applyVectorToDom(this.textMarker4, domCoordinates4, domRotation4);\n\n    const marker5 = getMarkerByName('text-marker5');\n\n    const domCoordinates5 = _threef.threef.toDomCoordinates(marker5, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight, 0.3);\n\n    const domRotation5 = _threef.threef.toDomRotation(marker5, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight);\n\n    _threef.threef.applyVectorToDom(this.textMarker5, domCoordinates5, domRotation5); // Billboarding sample.\n    // Notice how rotation is not applied.\n    // domCoodinates also don't pass a scale value so the text maintains it's original scale.\n\n\n    const marker6 = getMarkerByName('text-marker6');\n\n    const domBoundingRect = _threef.threef.toDomBoundingRect(marker6, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight);\n\n    const domCoordinates6 = _threef.threef.toDomCoordinates(marker6, this.camera, this.canvasContainer.offsetWidth, this.canvasContainer.offsetHeight); // Set to the topRight corner of an element.\n\n\n    _threef.threef.applyVectorToDom(this.textMarker6, {\n      x: domBoundingRect.topRight.x,\n      y: domBoundingRect.topRight.y,\n      z: 1.0\n    });\n\n    console.log(domBoundingRect);\n  }\n\n  draw() {\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = ThreeObjectViewer11;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1vYmplY3Qtdmlld2VyMTEuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy90aHJlZS1vYmplY3Qtdmlld2VyMTEuanM/NzQyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9kYXRndWlmID0gcmVxdWlyZShcIi4uL2xpYi9kYXRndWlmL2RhdGd1aWZcIik7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfR0xURkxvYWRlciA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9HTFRGTG9hZGVyXCIpO1xuXG52YXIgX0VmZmVjdENvbXBvc2VyID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9FZmZlY3RDb21wb3NlclwiKTtcblxudmFyIF9SZW5kZXJQYXNzID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9SZW5kZXJQYXNzLmpzXCIpO1xuXG52YXIgX1VucmVhbEJsb29tUGFzcyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvVW5yZWFsQmxvb21QYXNzLmpzXCIpO1xuXG52YXIgX0ZYQUFTaGFkZXIgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL3NoYWRlcnMvRlhBQVNoYWRlci5qc1wiKTtcblxudmFyIF9TaGFkZXJQYXNzID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9TaGFkZXJQYXNzLmpzXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxudmFyIF9yYWZQcm9ncmVzcyA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZi1wcm9ncmVzc1wiKTtcblxudmFyIF9kb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb21cIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG52YXIgX21hdGhmID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi9tYXRoZlwiKTtcblxudmFyIF90aHJlZWYgPSByZXF1aXJlKFwiLi4vbGliL3RocmVlZi90aHJlZWZcIik7XG5cbnZhciBfbWluaW1hdGNoID0gcmVxdWlyZShcIm1pbmltYXRjaFwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vLyBodHRwczovL3N2cy5nc2ZjLm5hc2EuZ292LzQ3MjBcbi8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL21hdGVyaWFscy9NZXNoU3RhbmRhcmRNYXRlcmlhbFxuLy8gaHR0cHM6Ly9xaWl0YS5jb20vYWRyczIwMDIvaXRlbXMvZGM2NDE2ZDZmZDIzODljNzVhYjVcbi8vIGh0dHBzOi8vcWlpdGEuY29tL2N4MjAvaXRlbXMvMmI4NmNiNTA1MmNkN2MzNjAzOGFcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU0MjgzMDgwL25vcm1hbC1tYXAtdmFsdWVzLXdpdGgtdGhyZWVqcy1nbHRmLWJsZW5kZXItZXhwb3J0ZXI/cnE9MVxuLy8gVGhlIGdsVEYgZm9ybWF0IGRvZXMgbm90IGFsbG93IGJ1bXAgbWFwcy4gIFVzZSBub3JtYWwgbWFwcy5cbi8vIGh0dHBzOi8vZGlzY291cnNlLnRocmVlanMub3JnL3QvdGhyZWUtanMtZ2x0Zi1tb2RlbC1leHBvcnRlZC1mcm9tLWVkaXRvci1idW1wLW1hcC1ub3QtcmVuZGVyaW5nLzEwODM1XG4vL1xuLy8gLSB3YXRjaCBvdmVyIGV4cG9zdXJlIG9mIG5vcm1hbCBtYXBcbi8vIC0gcG5nIGJhc2VkIG5vcm1hbCBtYXAgd29ya3MgYmV0dGVyPyAoanBnIG92ZXIgZXhwb3NlZD8pXG4vL1xuLy8gaW1wb3J0IHsgUmFmIH0gZnJvbSAnLi4vbGliL3JhZi9yYWYnO1xuY2xhc3MgVGhyZWVPYmplY3RWaWV3ZXIxMSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdUaHJlZUpTIE9iamVjdCBWaWV3ZXIgRGVtbycpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJlbnQnKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMtY29udGFpbmVyJyk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcygpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3Mud2F0Y2godGhpcy5vblByb2dyZXNzVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc2Nyb2xsTGVycCA9IDAuMzg7XG4gICAgdGhpcy5zY3JvbGxFYXNlID0gJ2Vhc2VJblF1YWQnO1xuICAgIHRoaXMuZG9tQ2FtZXJhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcy1kb20tY2FtZXJhJyk7XG4gICAgdGhpcy50ZXh0TWFya2VyMSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXh0LW1hcmtlcjEnKTtcbiAgICB0aGlzLnRleHRNYXJrZXIyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RleHQtbWFya2VyMicpO1xuICAgIHRoaXMudGV4dE1hcmtlcjMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGV4dC1tYXJrZXIzJyk7XG4gICAgdGhpcy50ZXh0TWFya2VyNCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXh0LW1hcmtlcjQnKTtcbiAgICB0aGlzLnRleHRNYXJrZXI1ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RleHQtbWFya2VyNScpO1xuICAgIHRoaXMudGV4dE1hcmtlcjYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGV4dC1tYXJrZXI2Jyk7XG4gICAgdGhpcy50ZXh0TWFya2VycyA9IFtdO1xuICAgIHRoaXMucmVuZGVyZXJDb25maWcgPSB7XG4gICAgICBjbGVhckNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICBiYWNrZ3JvdW5kQWxwaGE6IDEuMFxuICAgIH07XG4gICAgdGhpcy5ndWkgPSBuZXcgX2RhdGd1aWYuRGF0Z3VpZih7XG4gICAgICBsb2FkOiBKU09OXG4gICAgfSk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdTZXR0aW5ncycpLm9wZW4oKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ1JlbmRlcmVyJywgJ1NldHRpbmdzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdDYW1lcmEnLCAnU2V0dGluZ3MnKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ1Njcm9sbCcsICdTZXR0aW5ncycpO1xuICAgIHRoaXMuZ3VpLmFkZEZvbGRlcignTGlnaHRzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdPYmplY3RzJyk7XG4gICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoJ1Njcm9sbCcsIHRoaXMsIFt7XG4gICAgICBrZXlOYW1lOiAnc2Nyb2xsTGVycCcsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEsXG4gICAgICBzdGVwOiAwLjAxXG4gICAgfSwge1xuICAgICAga2V5TmFtZTogJ3Njcm9sbEVhc2UnLFxuICAgICAgb3B0aW9uczogWydsaW5lYXInLCAnZWFzZU91dFF1YWQnLCAnZWFzZUluUXVhZCddXG4gICAgfV0pO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdzY3JvbGwnLFxuICAgICAgY2FsbGJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50LCB3aW5kb3cuaW5uZXJIZWlnaHQpOyAvLyAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDAuMjYsIEVBU0UuZWFzZUluT3V0RXhwbyk7XG4gICAgICAgIC8vICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMC4wOCwgRUFTRS5saW5lYXIpO1xuXG4gICAgICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIHRoaXMuc2Nyb2xsTGVycCwgX2Vhc2UuRUFTRVt0aGlzLnNjcm9sbEVhc2VdKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICB0aGlzLmd1aS5vblVwZGF0ZShwcm9wID0+IHtcbiAgICAgIHRoaXMuZHJhdygpO1xuICAgIH0pO1xuICAgIHZhciBsb2FkZXIgPSBuZXcgX0dMVEZMb2FkZXIuR0xURkxvYWRlcigpO1xuICAgIGNvbnN0IHBhdGggPSAnLi9wdWJsaWMvbW9vbi90aHJlZS1vYmplY3Qtdmlld2VyMTEuZ2x0Zic7XG4gICAgbG9hZGVyLmxvYWQocGF0aCwgZ2x0ZiA9PiB7XG4gICAgICBjb25zdCBnbHRmRGF0YSA9IGdsdGYucGFyc2VyLmpzb247XG5cbiAgICAgIGNvbnN0IGdldE5vZGVCeU5hbWUgPSBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIGdsdGZEYXRhLm5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5uYW1lID0gbmFtZTtcbiAgICAgICAgfSlbMF07XG4gICAgICB9O1xuXG4gICAgICBjb25zb2xlLmxvZygnZ2x0ZiBkYXRhJywgZ2x0ZkRhdGEpO1xuICAgICAgdGhpcy5jbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpO1xuICAgICAgY29uc3Qgc2NlbmUgPSBnbHRmLnNjZW5lc1swXTtcbiAgICAgIHRoaXMuYWN0aXZlU2NlbmUgPSBzY2VuZTtcbiAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGdsdGYuYW5pbWF0aW9uczsgLy8gQW5pbWF0aW9uIE1peGVy44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQXG5cbiAgICAgIHRoaXMubWl4ZXIgPSBuZXcgVEhSRUUuQW5pbWF0aW9uTWl4ZXIoc2NlbmUpOyAvL+WFqOOBpuOBrkFuaW1hdGlvbiBDbGlw44Gr5a++44GX44GmXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNbaV07IC8vQW5pbWF0aW9uIEFjdGlvbuOCkueUn+aIkFxuXG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLm1peGVyLmNsaXBBY3Rpb24oYW5pbWF0aW9uKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FkZGVkJywgYW5pbWF0aW9uKTtcbiAgICAgICAgYWN0aW9uLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY2VuZS5hZGQoc2NlbmUpO1xuICAgICAgY29uc29sZS5sb2coJ3NjZW5lJywgc2NlbmUpO1xuICAgICAgY29uc29sZS5sb2coJ21peGVyJywgdGhpcy5taXhlcik7IC8vIGh0dHA6Ly9sZWFybmluZ3RocmVlanMuY29tL2Jsb2cvMjAxMi8wMS8yMC9jYXN0aW5nLXNoYWRvd3MvXG5cbiAgICAgIHRoaXMuc2NlbmUudHJhdmVyc2UoY2hpbGQgPT4ge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCkge1xuICAgICAgICAgIC8vIGNoaWxkLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGNoaWxkLm5hbWUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdsaWdodCcsIGNoaWxkKTsgLy8gRGVidWdnaW5nIGxpZ2h0IHBvc2l0aW9ucy5cbiAgICAgICAgICAvLyBjaGlsZC5zaGFkb3dDYW1lcmFWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoY2hpbGQuc2hhZG93KSB7XG4gICAgICAgICAgICAvLyBBZGp1c3Qgc2hhZG93IGJpYXMuXG4gICAgICAgICAgICAvLyBjaGlsZC5zaGFkb3cuYmlhcyA9IC0wLjAwMjtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgcmlnZ2VkIGxvb2tpbmcgc2hhZG93cy5cbiAgICAgICAgICAgIGNoaWxkLnNoYWRvdy5tYXBTaXplLndpZHRoID0gMTAyNDtcbiAgICAgICAgICAgIGNoaWxkLnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IDEwMjQ7XG4gICAgICAgICAgICBjaGlsZC5zaGFkb3dEYXJrbmVzcyA9IDE7IC8vIGNoaWxkLnNoYWRvdy5jYW1lcmEubmVhciA9IDA7XG4gICAgICAgICAgICAvLyBjaGlsZC5zaGFkb3cuY2FtZXJhLmZhciA9IDEwMDA7XG4gICAgICAgICAgICAvLyB2YXIgaGVscGVyID0gbmV3IFRIUkVFLkNhbWVyYUhlbHBlciggY2hpbGQuc2hhZG93LmNhbWVyYSApO1xuICAgICAgICAgICAgLy8gc2NlbmUuYWRkKCBoZWxwZXIgKTtcbiAgICAgICAgICB9IC8vIGNoaWxkLmxheWVycy5zZXQoMSk7XG4gICAgICAgICAgLy8gLy8gUG9pbnQgbGlnaHRzIGFyZSBkZWZpbmVkIGluIHdhdHRzIHdoaWNoIGdvZXMgd2FheSBvZmYgaW4gdGhyZWUuanNcblxuXG4gICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCkge1xuICAgICAgICAgICAgY2hpbGQuaW50ZW5zaXR5ID0gY2hpbGQuaW50ZW5zaXR5ICogMC4wNTtcbiAgICAgICAgICB9IC8vIElmIGl0J3MgYSBzcG90IGxpZ2h0LCBpdCBuZWVkcyB0byBnbyBkb3duIGV2ZW4gbW9yZS5cblxuXG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT0gXCJTcG90TGlnaHRcIikge1xuICAgICAgICAgICAgY2hpbGQuaW50ZW5zaXR5ID0gY2hpbGQuaW50ZW5zaXR5ICogMC4wMDM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKGNoaWxkLm5hbWUsICdMaWdodHMnKTtcbiAgICAgICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcihjaGlsZC5uYW1lLCBjaGlsZCwgW3tcbiAgICAgICAgICAgIGtleU5hbWU6ICdjYXN0U2hhZG93J1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleU5hbWU6ICdpbnRlbnNpdHknLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAzMDAwXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5TmFtZTogJ2NvbG9yJ1xuICAgICAgICAgIH1dKTtcblxuICAgICAgICAgIGlmIChjaGlsZC5zaGFkb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd0ZvbGRlcklkID0gY2hpbGQubmFtZSArICcgc2hhZG93JzsgLy8gY29uc29sZS5sb2coY2hpbGQuc2hhZG93KTtcblxuICAgICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKHNoYWRvd0ZvbGRlcklkLCBjaGlsZC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKHNoYWRvd0ZvbGRlcklkLCBjaGlsZC5zaGFkb3csIFt7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdiaWFzJyxcbiAgICAgICAgICAgICAgbWluOiAtMSxcbiAgICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgICAgICBzdGVwOiAwLjAwMDAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdyYWRpdXMnLFxuICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgIG1heDogMTAwLFxuICAgICAgICAgICAgICBzdGVwOiAwLjAxXG4gICAgICAgICAgICB9XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICAgIC8vIGNoaWxkLmdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKHRydWUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGNoaWxkLm5hbWUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdtZXNoJywgY2hpbGQpOyAvLyBJZiBhbiBvYmplY3Qgc3RhcnRzIHdpdGggJ3RleHQtJyBieSBjb252ZW5zaW9uLCBpdCB3aWxsXG4gICAgICAgICAgLy8gYmUgY29uc2lkZXJlZCBhIG1hcmtlci5cblxuICAgICAgICAgIGlmIChjaGlsZC5uYW1lLnN0YXJ0c1dpdGgoJ3RleHQnKSkge1xuICAgICAgICAgICAgLy8gSGlkZSB0aGUgbWFya2VyXG4gICAgICAgICAgICAvLyBjaGlsZC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnRleHRNYXJrZXJzLnB1c2goY2hpbGQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZ3VpLmFkZEZvbGRlcihjaGlsZC5uYW1lLCAnT2JqZWN0cycpO1xuICAgICAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKGNoaWxkLm5hbWUsIGNoaWxkLCBbe1xuICAgICAgICAgICAga2V5TmFtZTogJ2Nhc3RTaGFkb3cnXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5TmFtZTogJ3JlY2VpdmVTaGFkb3cnXG4gICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgaWYgKGNoaWxkLm1hdGVyaWFsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbWF0ZXJpYWwnLCBjaGlsZC5tYXRlcmlhbCk7XG4gICAgICAgICAgICBjb25zdCBtYXRlcmlhbElkID0gY2hpbGQubmFtZSArICcgbWF0ZXJpYWwnO1xuICAgICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKG1hdGVyaWFsSWQsIGNoaWxkLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIobWF0ZXJpYWxJZCwgY2hpbGQubWF0ZXJpYWwsIFt7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdlbWlzc2l2ZUludGVuc2l0eScsXG4gICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgbWF4OiAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdmbGF0U2hhZGluZycsXG4gICAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICd3aXJlZnJhbWUnLFxuICAgICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQubWF0ZXJpYWwubm9ybWFsTWFwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdub3JtYWwgbWFwJyk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNoaWxkLm1hdGVyaWFsLm5vcm1hbE1hcCk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNoaWxkLm1hdGVyaWFsLm5vcm1hbFNjYWxlKTtcbiAgICAgICAgICAgIH0gLy8gRW5hYmxlIHNtb290aCBzaGFkaW5nLlxuICAgICAgICAgICAgLy8gY2hpbGQubWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGNoaWxkLm1hdGVyaWFsLndpcmVmcmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gY2hpbGQubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgLy8gY2hpbGQuZ2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gICAgICAgICAgICAvLyBjaGlsZC5nZW9tZXRyeS5jb21wdXRlVmVydGV4Tm9ybWFscyh0cnVlKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGlsZC5uYW1lID09ICdQbGFuZTAwMScpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtZXNoJywgY2hpbGQpO1xuICAgICAgICAgIH0gLy8gR2V0IHRoZSBpbWFnZSBtYXBwaW5ncy5cbiAgICAgICAgICAvLyBpZihjaGlsZC5tYXRlcmlhbCAmJiBjaGlsZC5tYXRlcmlhbC5tYXApIHtcbiAgICAgICAgICAvLyAgIGNoaWxkLm1hdGVyaWFsLm1hcC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgIH0gZWxzZSB7Ly8gY29uc29sZS5sb2coJ290aGVyJywgY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgIH0pOyAvLyBTZXQgdGhlIGNhbWVyYSBleHBvcnRlZCBpbiBnbHRmLlxuICAgICAgLy8gUmVxdWlyZXMgY2FtZXJhIHRvIGJlIGV4cG9ydGVkIGZvciBnbHRmLlxuXG4gICAgICB0aGlzLmNhbWVyYSA9IGdsdGYuY2FtZXJhc1swXTtcbiAgICAgIGNvbnNvbGUubG9nKCdjYW1lcmEnLCB0aGlzLmNhbWVyYSk7XG4gICAgICB0aGlzLnJlc2l6ZSgpOyAvLyBVc2UgZm9nIHRvIGNvdmVyIGZhciBkaXN0YW5jZXMuXG4gICAgICAvLyBjb25zdCBjb2xvciA9IDB4MDAwMDA7XG4gICAgICAvLyB0aGlzLnNjZW5lLmZvZyA9IG5ldyBUSFJFRS5Gb2coY29sb3IsIDUsIDgpO1xuICAgICAgLy8gRW5hYmxlIHNoYWRvd3MuXG4gICAgICAvLyBodHRwczovL3RocmVlanMub3JnL2RvY3MvI2FwaS9lbi9jb25zdGFudHMvUmVuZGVyZXJcblxuICAgICAgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9IHRydWU7IC8vIFRvIGFudGlhbGlhcyB0aGUgc2hhZG93XG5cbiAgICAgIHRoaXMucmVuZGVyZXIuc2hhZG93TWFwLnR5cGUgPSBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwO1xuICAgICAgdGhpcy5yZW5kZXJlci5nYW1tYU91dHB1dCA9IHRydWU7IC8vIHRoaXMucmVuZGVyZXIuZ2FtbWFGYWN0b3IgPSAyLjI7XG4gICAgICAvLyBJbXBvcnRhbnQgdG8gZ2V0IHRoZSBjb3JyZWN0IGNvbG9ycy5cblxuICAgICAgdGhpcy5yZW5kZXJlci5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyA9IHRydWU7IC8vIEJhY2tncm91bmQgYXMgYmxhY2suXG4gICAgICAvLyB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHg0Mjg3ZjUpO1xuXG4gICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5yZW5kZXJlckNvbmZpZy5jbGVhckNvbG9yLCB0aGlzLnJlbmRlcmVyQ29uZmlnLmJhY2tncm91bmRBbHBoYSk7IC8vIEFmZmVjdHMgaG93IHN0cm9uZ2x5IGxpZ2h0cyBjb21lIGV4cG9zZWQuXG4gICAgICAvLyBodHRwczovL3RocmVlanMub3JnL2V4YW1wbGVzLyN3ZWJnbF90b25lbWFwcGluZ1xuXG4gICAgICB0aGlzLnJlbmRlcmVyLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAxOyAvLyB0aGlzLnJlbmRlcmVyLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAwLjM7XG5cbiAgICAgIHRoaXMucmVuZGVyZXIudG9uZU1hcHBpbmcgPSBUSFJFRS5BQ0VTRmlsbWljVG9uZU1hcHBpbmc7XG4gICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcignUmVuZGVyZXInLCB0aGlzLnJlbmRlcmVyLCBbe1xuICAgICAgICBrZXlOYW1lOiAndG9uZU1hcHBpbmdFeHBvc3VyZScsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiA1LFxuICAgICAgICBzdGVwOiAwLjAxXG4gICAgICB9LCB7XG4gICAgICAgIGtleU5hbWU6ICdnYW1tYUZhY3RvcicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAxMCxcbiAgICAgICAgc3RlcDogMC4wMVxuICAgICAgfV0pO1xuICAgICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoJ1JlbmRlcmVyJywgdGhpcy5yZW5kZXJlckNvbmZpZywgW3tcbiAgICAgICAga2V5TmFtZTogJ2NsZWFyQ29sb3InLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcih0aGlzLnJlbmRlcmVyQ29uZmlnLmNsZWFyQ29sb3IsIHRoaXMucmVuZGVyZXJDb25maWcuYmFja2dyb3VuZEFscGhhKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXlOYW1lOiAnYmFja2dyb3VuZEFscGhhJyxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5yZW5kZXJlckNvbmZpZy5jbGVhckNvbG9yLCB0aGlzLnJlbmRlcmVyQ29uZmlnLmJhY2tncm91bmRBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdDYW1lcmEnLCB0aGlzLmNhbWVyYSwgW3tcbiAgICAgICAga2V5TmFtZTogJ2ZvdicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiA1MCxcbiAgICAgICAgc3RlcDogMC4wMSxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5TmFtZTogJ3pvb20nLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMTAsXG4gICAgICAgIHN0ZXA6IDAuMDAwMSxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICAgIHRoaXMuZ3VpLmFkZEZvbGRlcignR2VuZXJhbCBMaWdodHMnKTtcbiAgICAgIHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnID0ge1xuICAgICAgICBhbWJpZW50TGlnaHRDb2xvcjogJyNGRkZGRkYnLFxuICAgICAgICBhbWJpZW50TGlnaHRBbHBoYTogMVxuICAgICAgfTsgLy8gQWRkaXRpb25hbCBsaWdodGluZyBvdXRzaWRlIHRoZSBibGVuZGVyLlxuICAgICAgLy8gdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCggMHhmZmZmZmYsIDB4MDAwMDAwLCAxICk7XG4gICAgICAvLyB0aGlzLnNjZW5lLmFkZCggbGlnaHQgKTtcblxuICAgICAgdGhpcy5hbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodENvbG9yKTtcbiAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmludGVuc2l0eSA9IHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodEFscGhhO1xuICAgICAgc2NlbmUuYWRkKHRoaXMuYW1iaWVudExpZ2h0KTtcbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdHZW5lcmFsIExpZ2h0cycsIHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLCBbe1xuICAgICAgICBrZXlOYW1lOiAnYW1iaWVudExpZ2h0Q29sb3InLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodENvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXlOYW1lOiAnYW1iaWVudExpZ2h0QWxwaGEnLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmludGVuc2l0eSA9IHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodEFscGhhO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICB0aGlzLmd1aS5hZGRCdXR0b24oJ1JlZnJlc2gnLCB0aGlzLnJlZnJlc2guYmluZCh0aGlzKSk7XG4gICAgfSwgdW5kZWZpbmVkLCBlcnJvciA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgLy8gcHJlY2lzaW9uOiAnaGlnaHAnXG4gICAgICBhdXRvU2l6ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29tcG9zZXIgPSBuZXcgX0VmZmVjdENvbXBvc2VyLkVmZmVjdENvbXBvc2VyKHRoaXMucmVuZGVyZXIpO1xuICAgIHRoaXMuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgfVxuXG4gIHJlc2l6ZSgpIHtcbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMSwgX2Vhc2UuRUFTRS5MaW5lYXIpO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhc0NvbnRhaW5lci5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXNDb250YWluZXIucGFyZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kb25tY2N1cmR5L3RocmVlLWdsdGYtdmlld2VyL2Jsb2IvbWFzdGVyL3NyYy92aWV3ZXIuanNcbiAgICAvLyBodHRwczovL3RocmVlanMub3JnL2RvY3MvI2FwaS9lbi9jb25zdGFudHMvUmVuZGVyZXJcblxuICAgIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTsgLy8gUG9zdCBwcm9jZXNzaW5nXG4gICAgLy8gdGhpcy5jb21wb3Nlci5zZXRTaXplKCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgLy8gY29uc3QgZnhhYVBhc3MgPSBuZXcgU2hhZGVyUGFzcyggRlhBQVNoYWRlciApO1xuICAgIC8vIGZ4YWFQYXNzLm1hdGVyaWFsLnVuaWZvcm1zWyAncmVzb2x1dGlvbicgXS52YWx1ZS54ID0gMSAvICggdGhpcy53aWR0aCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAvLyBmeGFhUGFzcy5tYXRlcmlhbC51bmlmb3Jtc1sgJ3Jlc29sdXRpb24nIF0udmFsdWUueSA9IDEgLyAoIHRoaXMuaGVpZ2h0ICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIC8vIHRoaXMuY29tcG9zZXIuYWRkUGFzcyhmeGFhUGFzcyk7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5hZGRQYXNzKG5ldyBSZW5kZXJQYXNzKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKSk7XG4gICAgLy8gdmFyIGJsb29tUGFzcyA9IG5ldyBVbnIyLjJtZWFsQmxvb21QYXNzKDEsIDI1LCA1LCAyNTYpO1xuICAgIC8vIHRoaXMuY29tcG9zZXIuYWRkUGFzcyhibG9vbVBhc3MpO1xuICAgIC8vIFRoZSBjYW1lcmEgYXNwZWN0IGdvZXMgb2ZmIHNpbmNlIGl0IGNvdWxkIGJlIGV4cG9ydGVkIGF0IGEgZGlmZmVyZW50XG4gICAgLy8gcmF0aW8uICBGb3JjZSB1cGRhdGUgdGhlIGFzcGVjdCByYXRpby5cblxuICAgIHRoaXMuY2FtZXJhLmFzcGVjdCA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcih0aGlzLnJlbmRlcmVyQ29uZmlnLmNsZWFyQ29sb3IsIHRoaXMucmVuZGVyZXJDb25maWcuYmFja2dyb3VuZEFscGhhKTtcbiAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIHRoaXMuZHJhdygpO1xuICB9XG5cbiAgZ2V0QW5pbWF0aW9uQnlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRpb25zLmZpbHRlcihhbmltYXRpb25DbGlwID0+IHtcbiAgICAgIHJldHVybiBhbmltYXRpb25DbGlwLm5hbWUgPT0gbmFtZTtcbiAgICB9KVswXTtcbiAgfVxuXG4gIGdldE9iamVjdEJ5TmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlU2NlbmUuY2hpbGRyZW4uZmlsdGVyKG9iamVjdDNkID0+IHtcbiAgICAgIHJldHVybiBvYmplY3QzZC5uYW1lID09IG5hbWU7XG4gICAgfSlbMF07XG4gIH1cblxuICBvblByb2dyZXNzVXBkYXRlKHByb2dyZXNzKSB7XG4gICAgLy9BbmltYXRpb24gTWl4ZXLjgpLlrp/ooYxcbiAgICBpZiAodGhpcy5taXhlcikge1xuICAgICAgLy8gV2UgbmVlZCB0byBmaW5kIG91dCBob3cgbG9uZyB0aGUgYW5pbWF0aW9uIGlzLlxuICAgICAgLy8gVGhlIG1peGVyIGFwcGVhcnMgdG8gaGF2ZSBubyBrbm93bGVkZ2Ugb2Z0IHRoaXMgc28gd2UgbmVlZCB0b1xuICAgICAgLy8gbG9vayB1cCBhIHNwZWNpZmljIGFuaW1hdGlvbiBhbmQgZ2V0IHRoZSBkdXJhdGlvbiB0b1xuICAgICAgLy8gZ2V0IHRoZSB0b3RhbCBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlxuICAgICAgY29uc3QgY2FtZXJhQW5pbWF0aW9uID0gdGhpcy5nZXRBbmltYXRpb25CeU5hbWUoJ0NhbWVyYUFjdGlvbicpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBjYW1lcmFBbmltYXRpb24uZHVyYXRpb247IC8vIFdoZW4gZHVyYXRpb24gaGl0cyBpdCdzIG1heCwgYW5pbWF0aW9uTWl4ZXIgc2VlbXMgdG8gaGl0IHRoZSBmaXJzdFxuICAgICAgLy8gZnJhbWUgc28gbmV4dCBhbGxvdyBpdCB0byByZWFjaCB0aGUgbWF4IHZhbHVlLlxuXG4gICAgICB0aGlzLm1peGVyLnNldFRpbWUoTWF0aC5taW4oZHVyYXRpb24gKiBwcm9ncmVzcywgZHVyYXRpb24gLSAwLjAxKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ2V0TWFya2VyQnlOYW1lID0gbmFtZSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0TWFya2Vycy5maWx0ZXIobWFya2VyID0+IHtcbiAgICAgICAgcmV0dXJuIG1hcmtlci51c2VyRGF0YS5uYW1lID09IG5hbWU7XG4gICAgICB9KVswXTtcbiAgICB9O1xuXG4gICAgdGhpcy5kcmF3KCk7IC8vIFRleHQgbWFya2VyMS5cblxuICAgIGNvbnN0IG1hcmtlciA9IGdldE1hcmtlckJ5TmFtZSgndGV4dC1tYXJrZXIxJyk7XG5cbiAgICBjb25zdCBkb21Db29yZGluYXRlcyA9IF90aHJlZWYudGhyZWVmLnRvRG9tQ29vcmRpbmF0ZXMobWFya2VyLCB0aGlzLmNhbWVyYSwgdGhpcy5jYW52YXNDb250YWluZXIub2Zmc2V0V2lkdGgsIHRoaXMuY2FudmFzQ29udGFpbmVyLm9mZnNldEhlaWdodCk7IC8vIEJpbGxib2FyZGVkIGFuZCBub3Qgc2NhbGluZy5cblxuXG4gICAgY29uc3QgZG9tUm90YXRpb24gPSBfdGhyZWVmLnRocmVlZi50b0RvbVJvdGF0aW9uKG1hcmtlciwgdGhpcy5jYW1lcmEsIHRoaXMuY2FudmFzQ29udGFpbmVyLm9mZnNldFdpZHRoLCB0aGlzLmNhbnZhc0NvbnRhaW5lci5vZmZzZXRIZWlnaHQpO1xuXG4gICAgX3RocmVlZi50aHJlZWYuYXBwbHlWZWN0b3JUb0RvbSh0aGlzLnRleHRNYXJrZXIxLCBkb21Db29yZGluYXRlcywgZG9tUm90YXRpb24pOyAvLyBUZXh0IG1hcmtlcjIuXG5cblxuICAgIGNvbnN0IG1hcmtlcjIgPSBnZXRNYXJrZXJCeU5hbWUoJ3RleHQtbWFya2VyMicpO1xuXG4gICAgY29uc3QgZG9tQ29vcmRpbmF0ZXMyID0gX3RocmVlZi50aHJlZWYudG9Eb21Db29yZGluYXRlcyhtYXJrZXIyLCB0aGlzLmNhbWVyYSwgdGhpcy5jYW52YXNDb250YWluZXIub2Zmc2V0V2lkdGgsIHRoaXMuY2FudmFzQ29udGFpbmVyLm9mZnNldEhlaWdodCk7XG5cbiAgICBjb25zdCBkb21Sb3RhdGlvbjIgPSBfdGhyZWVmLnRocmVlZi50b0RvbVJvdGF0aW9uKG1hcmtlcjIsIHRoaXMuY2FtZXJhLCB0aGlzLmNhbnZhc0NvbnRhaW5lci5vZmZzZXRXaWR0aCwgdGhpcy5jYW52YXNDb250YWluZXIub2Zmc2V0SGVpZ2h0KTtcblxuICAgIF90aHJlZWYudGhyZWVmLmFwcGx5VmVjdG9yVG9Eb20odGhpcy50ZXh0TWFya2VyMiwgZG9tQ29vcmRpbmF0ZXMyLCBkb21Sb3RhdGlvbjIpOyAvLyBUZXh0IG1hcmtlcjMuXG5cblxuICAgIGNvbnN0IG1hcmtlcjMgPSBnZXRNYXJrZXJCeU5hbWUoJ3RleHQtbWFya2VyMycpO1xuXG4gICAgY29uc3QgZG9tQ29vcmRpbmF0ZXMzID0gX3RocmVlZi50aHJlZWYudG9Eb21Db29yZGluYXRlcyhtYXJrZXIzLCB0aGlzLmNhbWVyYSwgdGhpcy5jYW52YXNDb250YWluZXIub2Zmc2V0V2lkdGgsIHRoaXMuY2FudmFzQ29udGFpbmVyLm9mZnNldEhlaWdodCk7XG5cbiAgICBjb25zdCBkb21Sb3RhdGlvbjMgPSBfdGhyZWVmLnRocmVlZi50b0RvbVJvdGF0aW9uKG1hcmtlcjMsIHRoaXMuY2FtZXJhLCB0aGlzLmNhbnZhc0NvbnRhaW5lci5vZmZzZXRXaWR0aCwgdGhpcy5jYW52YXNDb250YWluZXIub2Zmc2V0SGVpZ2h0KTtcblxuICAgIF90aHJlZWYudGhyZWVmLmFwcGx5VmVjdG9yVG9Eb20odGhpcy50ZXh0TWFya2VyMywgZG9tQ29vcmRpbmF0ZXMzLCBkb21Sb3RhdGlvbjMpO1xuXG4gICAgY29uc3QgbWFya2VyNCA9IGdldE1hcmtlckJ5TmFtZSgndGV4dC1tYXJrZXI0Jyk7XG5cbiAgICBjb25zdCBkb21Db29yZGluYXRlczQgPSBfdGhyZWVmLnRocmVlZi50b0RvbUNvb3JkaW5hdGVzKG1hcmtlcjQsIHRoaXMuY2FtZXJhLCB0aGlzLmNhbnZhc0NvbnRhaW5lci5vZmZzZXRXaWR0aCwgdGhpcy5jYW52YXNDb250YWluZXIub2Zmc2V0SGVpZ2h0LCAwLjMpO1xuXG4gICAgY29uc3QgZG9tUm90YXRpb240ID0gX3RocmVlZi50aHJlZWYudG9Eb21Sb3RhdGlvbihtYXJrZXI0LCB0aGlzLmNhbWVyYSwgdGhpcy5jYW52YXNDb250YWluZXIub2Zmc2V0V2lkdGgsIHRoaXMuY2FudmFzQ29udGFpbmVyLm9mZnNldEhlaWdodCk7XG5cbiAgICBfdGhyZWVmLnRocmVlZi5hcHBseVZlY3RvclRvRG9tKHRoaXMudGV4dE1hcmtlcjQsIGRvbUNvb3JkaW5hdGVzNCwgZG9tUm90YXRpb240KTtcblxuICAgIGNvbnN0IG1hcmtlcjUgPSBnZXRNYXJrZXJCeU5hbWUoJ3RleHQtbWFya2VyNScpO1xuXG4gICAgY29uc3QgZG9tQ29vcmRpbmF0ZXM1ID0gX3RocmVlZi50aHJlZWYudG9Eb21Db29yZGluYXRlcyhtYXJrZXI1LCB0aGlzLmNhbWVyYSwgdGhpcy5jYW52YXNDb250YWluZXIub2Zmc2V0V2lkdGgsIHRoaXMuY2FudmFzQ29udGFpbmVyLm9mZnNldEhlaWdodCwgMC4zKTtcblxuICAgIGNvbnN0IGRvbVJvdGF0aW9uNSA9IF90aHJlZWYudGhyZWVmLnRvRG9tUm90YXRpb24obWFya2VyNSwgdGhpcy5jYW1lcmEsIHRoaXMuY2FudmFzQ29udGFpbmVyLm9mZnNldFdpZHRoLCB0aGlzLmNhbnZhc0NvbnRhaW5lci5vZmZzZXRIZWlnaHQpO1xuXG4gICAgX3RocmVlZi50aHJlZWYuYXBwbHlWZWN0b3JUb0RvbSh0aGlzLnRleHRNYXJrZXI1LCBkb21Db29yZGluYXRlczUsIGRvbVJvdGF0aW9uNSk7IC8vIEJpbGxib2FyZGluZyBzYW1wbGUuXG4gICAgLy8gTm90aWNlIGhvdyByb3RhdGlvbiBpcyBub3QgYXBwbGllZC5cbiAgICAvLyBkb21Db29kaW5hdGVzIGFsc28gZG9uJ3QgcGFzcyBhIHNjYWxlIHZhbHVlIHNvIHRoZSB0ZXh0IG1haW50YWlucyBpdCdzIG9yaWdpbmFsIHNjYWxlLlxuXG5cbiAgICBjb25zdCBtYXJrZXI2ID0gZ2V0TWFya2VyQnlOYW1lKCd0ZXh0LW1hcmtlcjYnKTtcblxuICAgIGNvbnN0IGRvbUJvdW5kaW5nUmVjdCA9IF90aHJlZWYudGhyZWVmLnRvRG9tQm91bmRpbmdSZWN0KG1hcmtlcjYsIHRoaXMuY2FtZXJhLCB0aGlzLmNhbnZhc0NvbnRhaW5lci5vZmZzZXRXaWR0aCwgdGhpcy5jYW52YXNDb250YWluZXIub2Zmc2V0SGVpZ2h0KTtcblxuICAgIGNvbnN0IGRvbUNvb3JkaW5hdGVzNiA9IF90aHJlZWYudGhyZWVmLnRvRG9tQ29vcmRpbmF0ZXMobWFya2VyNiwgdGhpcy5jYW1lcmEsIHRoaXMuY2FudmFzQ29udGFpbmVyLm9mZnNldFdpZHRoLCB0aGlzLmNhbnZhc0NvbnRhaW5lci5vZmZzZXRIZWlnaHQpOyAvLyBTZXQgdG8gdGhlIHRvcFJpZ2h0IGNvcm5lciBvZiBhbiBlbGVtZW50LlxuXG5cbiAgICBfdGhyZWVmLnRocmVlZi5hcHBseVZlY3RvclRvRG9tKHRoaXMudGV4dE1hcmtlcjYsIHtcbiAgICAgIHg6IGRvbUJvdW5kaW5nUmVjdC50b3BSaWdodC54LFxuICAgICAgeTogZG9tQm91bmRpbmdSZWN0LnRvcFJpZ2h0LnksXG4gICAgICB6OiAxLjBcbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKGRvbUJvdW5kaW5nUmVjdCk7XG4gIH1cblxuICBkcmF3KCkge1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRocmVlT2JqZWN0Vmlld2VyMTE7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/three-object-viewer11.js\n");

/***/ }),

/***/ "./examples/three-object-viewer2.js":
/*!******************************************!*\
  !*** ./examples/three-object-viewer2.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _GLTFLoader = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n// https://threejs.org/docs/#manual/en/introduction/Loading-3D-models\n// https://threejs.org/examples/#webgl_loader_gltf\n// https://gist.github.com/bellbind/c4f8c502fcacbe29422e5ac315273858\n// https://github.com/funwithtriangles/blender-to-threejs-export-guide/blob/master/readme.md\n// https://threejsfundamentals.org/threejs/lessons/threejs-load-gltf.html\n// https://discoverthreejs.com/book/first-steps/load-models/\n// https://www.pentacreation.com/blog/2019/09/190916.html\n// https://www.pentacreation.com/blog/2019/10/191016.html\n// https://gltf-viewer.donmccurdy.com/\n// https://github.com/donmccurdy/three-gltf-viewer\n// import { Raf } from '../lib/raf/raf';\nclass ThreeObjectViewer2 {\n  constructor() {\n    console.log('ThreeJS Object Viewer Demo');\n    this.parentElement = document.getElementById('parent');\n    this.canvasContainer = document.getElementById('canvas-container');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.rafProgress = new _rafProgress.RafProgress();\n    this.rafProgress.watch(this.onProgressUpdate.bind(this));\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        this.rafProgress.easeTo(this.progress, 0.18, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.scene = new THREE.Scene();\n    var loader = new _GLTFLoader.GLTFLoader(); // const path = 'https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf';\n    // const path = './public/dude.glb';\n\n    const path = './public/monster-scene3.glb';\n    loader.load(path, gltf => {\n      this.clock = new THREE.Clock();\n      const scene = gltf.scenes[0];\n      this.activeScene = scene;\n      this.animations = gltf.animations; // Animation Mixer\n\n      this.mixer = new THREE.AnimationMixer(scene); //Animation Clip\n\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i]; //Animation Action\n\n        var action = this.mixer.clipAction(animation);\n        console.log('added', animation);\n        action.play();\n      }\n\n      this.scene.add(scene);\n      console.log(this.mixer); // http://learningthreejs.com/blog/2012/01/20/casting-shadows/\n\n      this.scene.traverse(child => {\n        if (child instanceof THREE.Light) {\n          child.castShadow = true;\n          console.log('cast', child); // Debugging light positions.\n\n          child.shadowCameraVisible = true; // Adjust shadow bias.\n\n          child.shadowBias = -0.005;\n          child.shadowDarkness = 0.1; // child.shadow.camera.near = 0;\n          // child.shadow.camera.far = 1000;\n          // Lights come off a bit stronger compared to Eevee, so\n          // lower the intensity.\n\n          child.intensity = child.intensity * 0.3; // var helper = new THREE.CameraHelper( child.shadow.camera );\n          // scene.add( helper );\n        } else if (child instanceof THREE.Mesh) {\n          child.castShadow = true;\n          child.receiveShadow = true;\n          console.log('receive', child);\n        } else {\n          console.log('nothing', child);\n        } // if(child.name.startsWith('Cube003')) {\n        //     child.receiveShadow = true;\n        // }\n        // Fix eyes\n\n\n        if (child.name.startsWith('Cube006')) {\n          child.castShadow = false;\n          child.receiveShadow = false;\n        }\n      }); // Set the camera exported in gltf.\n      // Requires camera to be exported for gltf.\n\n      this.camera = gltf.cameras[0];\n      console.log(this.camera);\n      this.resize();\n    }, undefined, error => {\n      console.error(error);\n    });\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: true\n    });\n    this.canvasContainer.appendChild(this.renderer.domElement);\n    window.addEventListener('resize', this.resize.bind(this), false);\n  }\n\n  resize() {\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.width = this.canvasContainer.parentElement.offsetWidth;\n    this.height = this.canvasContainer.parentElement.offsetHeight; // https://github.com/donmccurdy/three-gltf-viewer/blob/master/src/viewer.js\n\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n    this.renderer.setSize(this.width, this.height); // Important to get the correct colors.\n\n    this.renderer.physicallyCorrectLights = true; // Background as black.\n\n    this.renderer.setClearColor(0x000000); // this.renderer.setClearColor(0xFFFFFF, 1.0);\n    // Affects how strongly lights come exposed.\n    // this.renderer.toneMappingExposure = 0.4;\n    // Enable shadows.\n\n    this.renderer.shadowMap.enabled = true; // To antialias the shadow\n\n    this.renderer.shadowMapType = THREE.PCFSoftShadowMap;\n    this.renderer.gammaOutput = true;\n    this.renderer.gammaFactor = 2.2; // The camera aspect goes off since it could be exported at a different\n    // ratio.  Force update the aspect ratio.\n    // this.camera.fov = this.width / this.height;\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n  }\n\n  getAnimationByName(name) {\n    return this.animations.filter(animationClip => {\n      return animationClip.name == name;\n    })[0];\n  }\n\n  getObjectByName(name) {\n    return this.activeScene.children.filter(object3d => {\n      return object3d.name == name;\n    })[0];\n  }\n\n  onProgressUpdate(progress) {\n    //Animation Mixer\n    if (this.mixer) {\n      // We need to find out how long the animation is.\n      // The mixer appears to have no knowledge oft this so we need to\n      // look up a specific animation and get the duration to\n      // get the total duration of the animation.\n      const cameraAnimation = this.getAnimationByName('Action');\n      const duration = cameraAnimation.duration; // When duration hits it's max, animationMixer seems to hit the first\n      // frame so next allow it to reach the max value.\n\n      this.mixer.setTime(Math.min(duration * progress, duration - 0.001));\n    }\n\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = ThreeObjectViewer2;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1vYmplY3Qtdmlld2VyMi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3RocmVlLW9iamVjdC12aWV3ZXIyLmpzPzBkY2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfR0xURkxvYWRlciA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9HTFRGTG9hZGVyXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxudmFyIF9yYWZQcm9ncmVzcyA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZi1wcm9ncmVzc1wiKTtcblxudmFyIF9kb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb21cIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jbWFudWFsL2VuL2ludHJvZHVjdGlvbi9Mb2FkaW5nLTNELW1vZGVsc1xuLy8gaHR0cHM6Ly90aHJlZWpzLm9yZy9leGFtcGxlcy8jd2ViZ2xfbG9hZGVyX2dsdGZcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2JlbGxiaW5kL2M0ZjhjNTAyZmNhY2JlMjk0MjJlNWFjMzE1MjczODU4XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZnVud2l0aHRyaWFuZ2xlcy9ibGVuZGVyLXRvLXRocmVlanMtZXhwb3J0LWd1aWRlL2Jsb2IvbWFzdGVyL3JlYWRtZS5tZFxuLy8gaHR0cHM6Ly90aHJlZWpzZnVuZGFtZW50YWxzLm9yZy90aHJlZWpzL2xlc3NvbnMvdGhyZWVqcy1sb2FkLWdsdGYuaHRtbFxuLy8gaHR0cHM6Ly9kaXNjb3ZlcnRocmVlanMuY29tL2Jvb2svZmlyc3Qtc3RlcHMvbG9hZC1tb2RlbHMvXG4vLyBodHRwczovL3d3dy5wZW50YWNyZWF0aW9uLmNvbS9ibG9nLzIwMTkvMDkvMTkwOTE2Lmh0bWxcbi8vIGh0dHBzOi8vd3d3LnBlbnRhY3JlYXRpb24uY29tL2Jsb2cvMjAxOS8xMC8xOTEwMTYuaHRtbFxuLy8gaHR0cHM6Ly9nbHRmLXZpZXdlci5kb25tY2N1cmR5LmNvbS9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kb25tY2N1cmR5L3RocmVlLWdsdGYtdmlld2VyXG4vLyBpbXBvcnQgeyBSYWYgfSBmcm9tICcuLi9saWIvcmFmL3JhZic7XG5jbGFzcyBUaHJlZU9iamVjdFZpZXdlcjIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygnVGhyZWVKUyBPYmplY3QgVmlld2VyIERlbW8nKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyZW50Jyk7XG4gICAgdGhpcy5jYW52YXNDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzLWNvbnRhaW5lcicpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5yYWZQcm9ncmVzcyA9IG5ldyBfcmFmUHJvZ3Jlc3MuUmFmUHJvZ3Jlc3MoKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzLndhdGNoKHRoaXMub25Qcm9ncmVzc1VwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnc2Nyb2xsJyxcbiAgICAgIGNhbGxiYWNrOiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDAuMTgsIF9lYXNlLkVBU0UuTGluZWFyKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICB2YXIgbG9hZGVyID0gbmV3IF9HTFRGTG9hZGVyLkdMVEZMb2FkZXIoKTsgLy8gY29uc3QgcGF0aCA9ICdodHRwczovL3RocmVlanMub3JnL2V4YW1wbGVzL21vZGVscy9nbHRmL0RhbWFnZWRIZWxtZXQvZ2xURi9EYW1hZ2VkSGVsbWV0LmdsdGYnO1xuICAgIC8vIGNvbnN0IHBhdGggPSAnLi9wdWJsaWMvZHVkZS5nbGInO1xuXG4gICAgY29uc3QgcGF0aCA9ICcuL3B1YmxpYy9tb25zdGVyLXNjZW5lMy5nbGInO1xuICAgIGxvYWRlci5sb2FkKHBhdGgsIGdsdGYgPT4ge1xuICAgICAgdGhpcy5jbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpO1xuICAgICAgY29uc3Qgc2NlbmUgPSBnbHRmLnNjZW5lc1swXTtcbiAgICAgIHRoaXMuYWN0aXZlU2NlbmUgPSBzY2VuZTtcbiAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGdsdGYuYW5pbWF0aW9uczsgLy8gQW5pbWF0aW9uIE1peGVy44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQXG5cbiAgICAgIHRoaXMubWl4ZXIgPSBuZXcgVEhSRUUuQW5pbWF0aW9uTWl4ZXIoc2NlbmUpOyAvL+WFqOOBpuOBrkFuaW1hdGlvbiBDbGlw44Gr5a++44GX44GmXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNbaV07IC8vQW5pbWF0aW9uIEFjdGlvbuOCkueUn+aIkFxuXG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLm1peGVyLmNsaXBBY3Rpb24oYW5pbWF0aW9uKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FkZGVkJywgYW5pbWF0aW9uKTtcbiAgICAgICAgYWN0aW9uLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY2VuZS5hZGQoc2NlbmUpO1xuICAgICAgY29uc29sZS5sb2codGhpcy5taXhlcik7IC8vIGh0dHA6Ly9sZWFybmluZ3RocmVlanMuY29tL2Jsb2cvMjAxMi8wMS8yMC9jYXN0aW5nLXNoYWRvd3MvXG5cbiAgICAgIHRoaXMuc2NlbmUudHJhdmVyc2UoY2hpbGQgPT4ge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCkge1xuICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdjYXN0JywgY2hpbGQpOyAvLyBEZWJ1Z2dpbmcgbGlnaHQgcG9zaXRpb25zLlxuXG4gICAgICAgICAgY2hpbGQuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IHRydWU7IC8vIEFkanVzdCBzaGFkb3cgYmlhcy5cblxuICAgICAgICAgIGNoaWxkLnNoYWRvd0JpYXMgPSAtMC4wMDU7XG4gICAgICAgICAgY2hpbGQuc2hhZG93RGFya25lc3MgPSAwLjE7IC8vIGNoaWxkLnNoYWRvdy5jYW1lcmEubmVhciA9IDA7XG4gICAgICAgICAgLy8gY2hpbGQuc2hhZG93LmNhbWVyYS5mYXIgPSAxMDAwO1xuICAgICAgICAgIC8vIExpZ2h0cyBjb21lIG9mZiBhIGJpdCBzdHJvbmdlciBjb21wYXJlZCB0byBFZXZlZSwgc29cbiAgICAgICAgICAvLyBsb3dlciB0aGUgaW50ZW5zaXR5LlxuXG4gICAgICAgICAgY2hpbGQuaW50ZW5zaXR5ID0gY2hpbGQuaW50ZW5zaXR5ICogMC4zOyAvLyB2YXIgaGVscGVyID0gbmV3IFRIUkVFLkNhbWVyYUhlbHBlciggY2hpbGQuc2hhZG93LmNhbWVyYSApO1xuICAgICAgICAgIC8vIHNjZW5lLmFkZCggaGVscGVyICk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG4gICAgICAgICAgY2hpbGQuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgICAgY2hpbGQucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gICAgICAgICAgY29uc29sZS5sb2coJ3JlY2VpdmUnLCBjaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ25vdGhpbmcnLCBjaGlsZCk7XG4gICAgICAgIH0gLy8gaWYoY2hpbGQubmFtZS5zdGFydHNXaXRoKCdDdWJlMDAzJykpIHtcbiAgICAgICAgLy8gICAgIGNoaWxkLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIEZpeCBleWVzXG5cblxuICAgICAgICBpZiAoY2hpbGQubmFtZS5zdGFydHNXaXRoKCdDdWJlMDA2JykpIHtcbiAgICAgICAgICBjaGlsZC5jYXN0U2hhZG93ID0gZmFsc2U7XG4gICAgICAgICAgY2hpbGQucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gU2V0IHRoZSBjYW1lcmEgZXhwb3J0ZWQgaW4gZ2x0Zi5cbiAgICAgIC8vIFJlcXVpcmVzIGNhbWVyYSB0byBiZSBleHBvcnRlZCBmb3IgZ2x0Zi5cblxuICAgICAgdGhpcy5jYW1lcmEgPSBnbHRmLmNhbWVyYXNbMF07XG4gICAgICBjb25zb2xlLmxvZyh0aGlzLmNhbWVyYSk7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH0sIHVuZGVmaW5lZCwgZXJyb3IgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICAgIGFudGlhbGlhczogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgfVxuXG4gIHJlc2l6ZSgpIHtcbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDEsIF9lYXNlLkVBU0UuTGluZWFyKTtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5jYW52YXNDb250YWluZXIucGFyZW50RWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FudmFzQ29udGFpbmVyLnBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0OyAvLyBodHRwczovL2dpdGh1Yi5jb20vZG9ubWNjdXJkeS90aHJlZS1nbHRmLXZpZXdlci9ibG9iL21hc3Rlci9zcmMvdmlld2VyLmpzXG5cbiAgICB0aGlzLnJlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7IC8vIEltcG9ydGFudCB0byBnZXQgdGhlIGNvcnJlY3QgY29sb3JzLlxuXG4gICAgdGhpcy5yZW5kZXJlci5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyA9IHRydWU7IC8vIEJhY2tncm91bmQgYXMgYmxhY2suXG5cbiAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHgwMDAwMDApOyAvLyB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHhGRkZGRkYsIDEuMCk7XG4gICAgLy8gQWZmZWN0cyBob3cgc3Ryb25nbHkgbGlnaHRzIGNvbWUgZXhwb3NlZC5cbiAgICAvLyB0aGlzLnJlbmRlcmVyLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAwLjQ7XG4gICAgLy8gRW5hYmxlIHNoYWRvd3MuXG5cbiAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkID0gdHJ1ZTsgLy8gVG8gYW50aWFsaWFzIHRoZSBzaGFkb3dcblxuICAgIHRoaXMucmVuZGVyZXIuc2hhZG93TWFwVHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgdGhpcy5yZW5kZXJlci5nYW1tYU91dHB1dCA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJlci5nYW1tYUZhY3RvciA9IDIuMjsgLy8gVGhlIGNhbWVyYSBhc3BlY3QgZ29lcyBvZmYgc2luY2UgaXQgY291bGQgYmUgZXhwb3J0ZWQgYXQgYSBkaWZmZXJlbnRcbiAgICAvLyByYXRpby4gIEZvcmNlIHVwZGF0ZSB0aGUgYXNwZWN0IHJhdGlvLlxuICAgIC8vIHRoaXMuY2FtZXJhLmZvdiA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcblxuICAgIHRoaXMuY2FtZXJhLmFzcGVjdCA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gIH1cblxuICBnZXRBbmltYXRpb25CeU5hbWUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnMuZmlsdGVyKGFuaW1hdGlvbkNsaXAgPT4ge1xuICAgICAgcmV0dXJuIGFuaW1hdGlvbkNsaXAubmFtZSA9PSBuYW1lO1xuICAgIH0pWzBdO1xuICB9XG5cbiAgZ2V0T2JqZWN0QnlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVTY2VuZS5jaGlsZHJlbi5maWx0ZXIob2JqZWN0M2QgPT4ge1xuICAgICAgcmV0dXJuIG9iamVjdDNkLm5hbWUgPT0gbmFtZTtcbiAgICB9KVswXTtcbiAgfVxuXG4gIG9uUHJvZ3Jlc3NVcGRhdGUocHJvZ3Jlc3MpIHtcbiAgICAvL0FuaW1hdGlvbiBNaXhlcuOCkuWun+ihjFxuICAgIGlmICh0aGlzLm1peGVyKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGZpbmQgb3V0IGhvdyBsb25nIHRoZSBhbmltYXRpb24gaXMuXG4gICAgICAvLyBUaGUgbWl4ZXIgYXBwZWFycyB0byBoYXZlIG5vIGtub3dsZWRnZSBvZnQgdGhpcyBzbyB3ZSBuZWVkIHRvXG4gICAgICAvLyBsb29rIHVwIGEgc3BlY2lmaWMgYW5pbWF0aW9uIGFuZCBnZXQgdGhlIGR1cmF0aW9uIHRvXG4gICAgICAvLyBnZXQgdGhlIHRvdGFsIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICBjb25zdCBjYW1lcmFBbmltYXRpb24gPSB0aGlzLmdldEFuaW1hdGlvbkJ5TmFtZSgnQWN0aW9uJyk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGNhbWVyYUFuaW1hdGlvbi5kdXJhdGlvbjsgLy8gV2hlbiBkdXJhdGlvbiBoaXRzIGl0J3MgbWF4LCBhbmltYXRpb25NaXhlciBzZWVtcyB0byBoaXQgdGhlIGZpcnN0XG4gICAgICAvLyBmcmFtZSBzbyBuZXh0IGFsbG93IGl0IHRvIHJlYWNoIHRoZSBtYXggdmFsdWUuXG5cbiAgICAgIHRoaXMubWl4ZXIuc2V0VGltZShNYXRoLm1pbihkdXJhdGlvbiAqIHByb2dyZXNzLCBkdXJhdGlvbiAtIDAuMDAxKSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gVGhyZWVPYmplY3RWaWV3ZXIyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/three-object-viewer2.js\n");

/***/ }),

/***/ "./examples/three-object-viewer3.js":
/*!******************************************!*\
  !*** ./examples/three-object-viewer3.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _GLTFLoader = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\nvar _EffectComposer = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n\nvar _RenderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n\nvar _UnrealBloomPass = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass.js */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n\nvar _FXAAShader = __webpack_require__(/*! three/examples/jsm/shaders/FXAAShader.js */ \"./node_modules/three/examples/jsm/shaders/FXAAShader.js\");\n\nvar _ShaderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/ShaderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/ShaderPass.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n// https://threejs.org/docs/#manual/en/introduction/Loading-3D-models\n// https://threejs.org/examples/#webgl_loader_gltf\n// https://gist.github.com/bellbind/c4f8c502fcacbe29422e5ac315273858\n// https://github.com/funwithtriangles/blender-to-threejs-export-guide/blob/master/readme.md\n// https://threejsfundamentals.org/threejs/lessons/threejs-load-gltf.html\n// https://discoverthreejs.com/book/first-steps/load-models/\n// https://www.pentacreation.com/blog/2019/09/190916.html\n// https://www.pentacreation.com/blog/2019/10/191016.html\n// https://docs.blender.org/manual/ja/latest/addons/io_scene_gltf2.html\n// https://gltf-viewer.donmccurdy.com/\n// https://github.com/donmccurdy/three-gltf-viewer\n// import { Raf } from '../lib/raf/raf';\nclass ThreeObjectViewer3 {\n  constructor() {\n    console.log('ThreeJS Object Viewer Demo');\n    this.parentElement = document.getElementById('parent');\n    this.canvasContainer = document.getElementById('canvas-container');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.rafProgress = new _rafProgress.RafProgress();\n    this.rafProgress.watch(this.onProgressUpdate.bind(this));\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight); //   this.rafProgress.easeTo(this.progress, 0.26, EASE.easeInOutExpo);\n        //   this.rafProgress.easeTo(this.progress, 0.08, EASE.linear);\n\n        this.rafProgress.easeTo(this.progress, 0.18, _ease.EASE.easeInOutQuad);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.scene = new THREE.Scene();\n    var loader = new _GLTFLoader.GLTFLoader(); // const path = 'https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf';\n    // const path = './public/dude.glb';\n\n    const path = './public/phone/phone.glb';\n    loader.load(path, gltf => {\n      this.clock = new THREE.Clock();\n      const scene = gltf.scenes[0];\n      this.activeScene = scene;\n      this.animations = gltf.animations; // Animation Mixer\n\n      this.mixer = new THREE.AnimationMixer(scene); //Animation Clip\n\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i]; //Animation Action\n\n        var action = this.mixer.clipAction(animation);\n        console.log('added', animation);\n        action.play();\n      }\n\n      this.scene.add(scene);\n      console.log(this.mixer); // http://learningthreejs.com/blog/2012/01/20/casting-shadows/\n\n      this.scene.traverse(child => {\n        if (child instanceof THREE.Light) {\n          child.castShadow = true; // Debugging light positions.\n\n          child.shadowCameraVisible = false; // Adjust shadow bias.\n\n          child.shadow.bias = -0.002; // Remove the rigged looking shadows.\n\n          child.shadow.mapSize.width = 1024;\n          child.shadow.mapSize.height = 1024; // child.shadowDarkness = 0.5;\n          // child.shadow.camera.near = 0;\n          // child.shadow.camera.far = 1000;\n          // Lights come off a bit stronger compared to Eevee, so\n          // lower the intensity. Stronger = less shadows.\n\n          child.intensity = child.intensity * 0.3; // var helper = new THREE.CameraHelper( child.shadow.camera );\n          // scene.add( helper );\n        } else if (child instanceof THREE.Mesh) {\n          child.castShadow = true;\n          child.receiveShadow = true; // child.geometry.computeVertexNormals(true);\n          // Get the image mappings.\n          // if(child.material && child.material.map) {\n          //   child.material.map.needsUpdate = true;\n          // }\n        } else {} // if(child.name.startsWith('Cube003')) {\n        //     child.receiveShadow = true;\n        // }\n        // Fix eyes\n\n\n        if (child.name.startsWith('Cylinder')) {\n          child.castShadow = false;\n          child.receiveShadow = true;\n        }\n      }); // Set the camera exported in gltf.\n      // Requires camera to be exported for gltf.\n\n      this.camera = gltf.cameras[0];\n      console.log(this.camera);\n      this.resize();\n    }, undefined, error => {\n      console.error(error);\n    });\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      // precision: 'highp'\n      autoSize: true\n    });\n    this.composer = new _EffectComposer.EffectComposer(this.renderer);\n    this.canvasContainer.appendChild(this.renderer.domElement);\n    window.addEventListener('resize', this.resize.bind(this), false);\n  }\n\n  resize() {\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.width = this.canvasContainer.parentElement.offsetWidth;\n    this.height = this.canvasContainer.parentElement.offsetHeight; // https://github.com/donmccurdy/three-gltf-viewer/blob/master/src/viewer.js\n    // https://threejs.org/docs/#api/en/constants/Renderer\n\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n    this.renderer.setSize(this.width, this.height); // Important to get the correct colors.\n\n    this.renderer.physicallyCorrectLights = true; // Background as black.\n\n    this.renderer.setClearColor(0x4287f5); // this.renderer.setClearColor(0xE7E7E7, 1.0);\n    // Affects how strongly lights come exposed.\n    // this.renderer.toneMappingExposure = 0.4;\n    // https://threejs.org/examples/#webgl_tonemapping\n\n    this.renderer.toneMappingExposure = 0.35;\n    this.renderer.toneMapping = THREE.ACESFilmicToneMapping; // Enable shadows.\n    // https://threejs.org/docs/#api/en/constants/Renderer\n\n    this.renderer.shadowMap.enabled = true; // To antialias the shadow\n\n    this.renderer.shadowMapType = THREE.PCFSoftShadowMap;\n    this.renderer.gammaOutput = true;\n    this.renderer.gammaFactor = 2.2; // Post processing\n\n    this.composer.setSize(this.width, this.height);\n    const fxaaPass = new _ShaderPass.ShaderPass(_FXAAShader.FXAAShader);\n    fxaaPass.material.uniforms['resolution'].value.x = 1 / (this.width * window.devicePixelRatio);\n    fxaaPass.material.uniforms['resolution'].value.y = 1 / (this.height * window.devicePixelRatio);\n    this.composer.addPass(fxaaPass);\n    this.composer.addPass(new _RenderPass.RenderPass(this.scene, this.camera)); // var bloomPass = new UnrealBloomPass(1, 25, 5, 256);\n    // this.composer.addPass(bloomPass);\n    // The camera aspect goes off since it could be exported at a different\n    // ratio.  Force update the aspect ratio.\n    // this.camera.fov = 25; // Update FOV.\n\n    this.camera.zoom = 1; // Update FOV.\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n  }\n\n  getAnimationByName(name) {\n    return this.animations.filter(animationClip => {\n      return animationClip.name == name;\n    })[0];\n  }\n\n  getObjectByName(name) {\n    return this.activeScene.children.filter(object3d => {\n      return object3d.name == name;\n    })[0];\n  }\n\n  onProgressUpdate(progress) {\n    //Animation Mixer\n    if (this.mixer) {\n      // We need to find out how long the animation is.\n      // The mixer appears to have no knowledge oft this so we need to\n      // look up a specific animation and get the duration to\n      // get the total duration of the animation.\n      const cameraAnimation = this.getAnimationByName('CubeAction');\n      const duration = cameraAnimation.duration; // When duration hits it's max, animationMixer seems to hit the first\n      // frame so next allow it to reach the max value.\n\n      this.mixer.setTime(Math.min(duration * progress, duration - 0.001));\n    } // this.renderer.render(this.scene, this.camera);\n\n\n    this.composer.render();\n  }\n\n}\n\nexports.default = ThreeObjectViewer3;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1vYmplY3Qtdmlld2VyMy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3RocmVlLW9iamVjdC12aWV3ZXIzLmpzP2ZkODgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfR0xURkxvYWRlciA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vbG9hZGVycy9HTFRGTG9hZGVyXCIpO1xuXG52YXIgX0VmZmVjdENvbXBvc2VyID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9FZmZlY3RDb21wb3NlclwiKTtcblxudmFyIF9SZW5kZXJQYXNzID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9SZW5kZXJQYXNzLmpzXCIpO1xuXG52YXIgX1VucmVhbEJsb29tUGFzcyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvVW5yZWFsQmxvb21QYXNzLmpzXCIpO1xuXG52YXIgX0ZYQUFTaGFkZXIgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL3NoYWRlcnMvRlhBQVNoYWRlci5qc1wiKTtcblxudmFyIF9TaGFkZXJQYXNzID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9TaGFkZXJQYXNzLmpzXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxudmFyIF9yYWZQcm9ncmVzcyA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZi1wcm9ncmVzc1wiKTtcblxudmFyIF9kb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb21cIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbi8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jbWFudWFsL2VuL2ludHJvZHVjdGlvbi9Mb2FkaW5nLTNELW1vZGVsc1xuLy8gaHR0cHM6Ly90aHJlZWpzLm9yZy9leGFtcGxlcy8jd2ViZ2xfbG9hZGVyX2dsdGZcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2JlbGxiaW5kL2M0ZjhjNTAyZmNhY2JlMjk0MjJlNWFjMzE1MjczODU4XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZnVud2l0aHRyaWFuZ2xlcy9ibGVuZGVyLXRvLXRocmVlanMtZXhwb3J0LWd1aWRlL2Jsb2IvbWFzdGVyL3JlYWRtZS5tZFxuLy8gaHR0cHM6Ly90aHJlZWpzZnVuZGFtZW50YWxzLm9yZy90aHJlZWpzL2xlc3NvbnMvdGhyZWVqcy1sb2FkLWdsdGYuaHRtbFxuLy8gaHR0cHM6Ly9kaXNjb3ZlcnRocmVlanMuY29tL2Jvb2svZmlyc3Qtc3RlcHMvbG9hZC1tb2RlbHMvXG4vLyBodHRwczovL3d3dy5wZW50YWNyZWF0aW9uLmNvbS9ibG9nLzIwMTkvMDkvMTkwOTE2Lmh0bWxcbi8vIGh0dHBzOi8vd3d3LnBlbnRhY3JlYXRpb24uY29tL2Jsb2cvMjAxOS8xMC8xOTEwMTYuaHRtbFxuLy8gaHR0cHM6Ly9kb2NzLmJsZW5kZXIub3JnL21hbnVhbC9qYS9sYXRlc3QvYWRkb25zL2lvX3NjZW5lX2dsdGYyLmh0bWxcbi8vIGh0dHBzOi8vZ2x0Zi12aWV3ZXIuZG9ubWNjdXJkeS5jb20vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZG9ubWNjdXJkeS90aHJlZS1nbHRmLXZpZXdlclxuLy8gaW1wb3J0IHsgUmFmIH0gZnJvbSAnLi4vbGliL3JhZi9yYWYnO1xuY2xhc3MgVGhyZWVPYmplY3RWaWV3ZXIzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coJ1RocmVlSlMgT2JqZWN0IFZpZXdlciBEZW1vJyk7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcmVudCcpO1xuICAgIHRoaXMuY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcy1jb250YWluZXInKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIgPSBuZXcgX2RvbVdhdGNoZXIuRG9tV2F0Y2hlcigpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3MgPSBuZXcgX3JhZlByb2dyZXNzLlJhZlByb2dyZXNzKCk7XG4gICAgdGhpcy5yYWZQcm9ncmVzcy53YXRjaCh0aGlzLm9uUHJvZ3Jlc3NVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Njcm9sbCcsXG4gICAgICBjYWxsYmFjazogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQsIHdpbmRvdy5pbm5lckhlaWdodCk7IC8vICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMC4yNiwgRUFTRS5lYXNlSW5PdXRFeHBvKTtcbiAgICAgICAgLy8gICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAwLjA4LCBFQVNFLmxpbmVhcik7XG5cbiAgICAgICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMC4xOCwgX2Vhc2UuRUFTRS5lYXNlSW5PdXRRdWFkKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICB2YXIgbG9hZGVyID0gbmV3IF9HTFRGTG9hZGVyLkdMVEZMb2FkZXIoKTsgLy8gY29uc3QgcGF0aCA9ICdodHRwczovL3RocmVlanMub3JnL2V4YW1wbGVzL21vZGVscy9nbHRmL0RhbWFnZWRIZWxtZXQvZ2xURi9EYW1hZ2VkSGVsbWV0LmdsdGYnO1xuICAgIC8vIGNvbnN0IHBhdGggPSAnLi9wdWJsaWMvZHVkZS5nbGInO1xuXG4gICAgY29uc3QgcGF0aCA9ICcuL3B1YmxpYy9waG9uZS9waG9uZS5nbGInO1xuICAgIGxvYWRlci5sb2FkKHBhdGgsIGdsdGYgPT4ge1xuICAgICAgdGhpcy5jbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpO1xuICAgICAgY29uc3Qgc2NlbmUgPSBnbHRmLnNjZW5lc1swXTtcbiAgICAgIHRoaXMuYWN0aXZlU2NlbmUgPSBzY2VuZTtcbiAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGdsdGYuYW5pbWF0aW9uczsgLy8gQW5pbWF0aW9uIE1peGVy44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQXG5cbiAgICAgIHRoaXMubWl4ZXIgPSBuZXcgVEhSRUUuQW5pbWF0aW9uTWl4ZXIoc2NlbmUpOyAvL+WFqOOBpuOBrkFuaW1hdGlvbiBDbGlw44Gr5a++44GX44GmXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNbaV07IC8vQW5pbWF0aW9uIEFjdGlvbuOCkueUn+aIkFxuXG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLm1peGVyLmNsaXBBY3Rpb24oYW5pbWF0aW9uKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FkZGVkJywgYW5pbWF0aW9uKTtcbiAgICAgICAgYWN0aW9uLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY2VuZS5hZGQoc2NlbmUpO1xuICAgICAgY29uc29sZS5sb2codGhpcy5taXhlcik7IC8vIGh0dHA6Ly9sZWFybmluZ3RocmVlanMuY29tL2Jsb2cvMjAxMi8wMS8yMC9jYXN0aW5nLXNoYWRvd3MvXG5cbiAgICAgIHRoaXMuc2NlbmUudHJhdmVyc2UoY2hpbGQgPT4ge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCkge1xuICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSB0cnVlOyAvLyBEZWJ1Z2dpbmcgbGlnaHQgcG9zaXRpb25zLlxuXG4gICAgICAgICAgY2hpbGQuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGZhbHNlOyAvLyBBZGp1c3Qgc2hhZG93IGJpYXMuXG5cbiAgICAgICAgICBjaGlsZC5zaGFkb3cuYmlhcyA9IC0wLjAwMjsgLy8gUmVtb3ZlIHRoZSByaWdnZWQgbG9va2luZyBzaGFkb3dzLlxuXG4gICAgICAgICAgY2hpbGQuc2hhZG93Lm1hcFNpemUud2lkdGggPSAxMDI0O1xuICAgICAgICAgIGNoaWxkLnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IDEwMjQ7IC8vIGNoaWxkLnNoYWRvd0RhcmtuZXNzID0gMC41O1xuICAgICAgICAgIC8vIGNoaWxkLnNoYWRvdy5jYW1lcmEubmVhciA9IDA7XG4gICAgICAgICAgLy8gY2hpbGQuc2hhZG93LmNhbWVyYS5mYXIgPSAxMDAwO1xuICAgICAgICAgIC8vIExpZ2h0cyBjb21lIG9mZiBhIGJpdCBzdHJvbmdlciBjb21wYXJlZCB0byBFZXZlZSwgc29cbiAgICAgICAgICAvLyBsb3dlciB0aGUgaW50ZW5zaXR5LiBTdHJvbmdlciA9IGxlc3Mgc2hhZG93cy5cblxuICAgICAgICAgIGNoaWxkLmludGVuc2l0eSA9IGNoaWxkLmludGVuc2l0eSAqIDAuMzsgLy8gdmFyIGhlbHBlciA9IG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGNoaWxkLnNoYWRvdy5jYW1lcmEgKTtcbiAgICAgICAgICAvLyBzY2VuZS5hZGQoIGhlbHBlciApO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIGNoaWxkLnJlY2VpdmVTaGFkb3cgPSB0cnVlOyAvLyBjaGlsZC5nZW9tZXRyeS5jb21wdXRlVmVydGV4Tm9ybWFscyh0cnVlKTtcbiAgICAgICAgICAvLyBHZXQgdGhlIGltYWdlIG1hcHBpbmdzLlxuICAgICAgICAgIC8vIGlmKGNoaWxkLm1hdGVyaWFsICYmIGNoaWxkLm1hdGVyaWFsLm1hcCkge1xuICAgICAgICAgIC8vICAgY2hpbGQubWF0ZXJpYWwubWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH0gZWxzZSB7fSAvLyBpZihjaGlsZC5uYW1lLnN0YXJ0c1dpdGgoJ0N1YmUwMDMnKSkge1xuICAgICAgICAvLyAgICAgY2hpbGQucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gRml4IGV5ZXNcblxuXG4gICAgICAgIGlmIChjaGlsZC5uYW1lLnN0YXJ0c1dpdGgoJ0N5bGluZGVyJykpIHtcbiAgICAgICAgICBjaGlsZC5jYXN0U2hhZG93ID0gZmFsc2U7XG4gICAgICAgICAgY2hpbGQucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBTZXQgdGhlIGNhbWVyYSBleHBvcnRlZCBpbiBnbHRmLlxuICAgICAgLy8gUmVxdWlyZXMgY2FtZXJhIHRvIGJlIGV4cG9ydGVkIGZvciBnbHRmLlxuXG4gICAgICB0aGlzLmNhbWVyYSA9IGdsdGYuY2FtZXJhc1swXTtcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMuY2FtZXJhKTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfSwgdW5kZWZpbmVkLCBlcnJvciA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgLy8gcHJlY2lzaW9uOiAnaGlnaHAnXG4gICAgICBhdXRvU2l6ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29tcG9zZXIgPSBuZXcgX0VmZmVjdENvbXBvc2VyLkVmZmVjdENvbXBvc2VyKHRoaXMucmVuZGVyZXIpO1xuICAgIHRoaXMuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgfVxuXG4gIHJlc2l6ZSgpIHtcbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMSwgX2Vhc2UuRUFTRS5MaW5lYXIpO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhc0NvbnRhaW5lci5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXNDb250YWluZXIucGFyZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kb25tY2N1cmR5L3RocmVlLWdsdGYtdmlld2VyL2Jsb2IvbWFzdGVyL3NyYy92aWV3ZXIuanNcbiAgICAvLyBodHRwczovL3RocmVlanMub3JnL2RvY3MvI2FwaS9lbi9jb25zdGFudHMvUmVuZGVyZXJcblxuICAgIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTsgLy8gSW1wb3J0YW50IHRvIGdldCB0aGUgY29ycmVjdCBjb2xvcnMuXG5cbiAgICB0aGlzLnJlbmRlcmVyLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzID0gdHJ1ZTsgLy8gQmFja2dyb3VuZCBhcyBibGFjay5cblxuICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigweDQyODdmNSk7IC8vIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigweEU3RTdFNywgMS4wKTtcbiAgICAvLyBBZmZlY3RzIGhvdyBzdHJvbmdseSBsaWdodHMgY29tZSBleHBvc2VkLlxuICAgIC8vIHRoaXMucmVuZGVyZXIudG9uZU1hcHBpbmdFeHBvc3VyZSA9IDAuNDtcbiAgICAvLyBodHRwczovL3RocmVlanMub3JnL2V4YW1wbGVzLyN3ZWJnbF90b25lbWFwcGluZ1xuXG4gICAgdGhpcy5yZW5kZXJlci50b25lTWFwcGluZ0V4cG9zdXJlID0gMC4zNTtcbiAgICB0aGlzLnJlbmRlcmVyLnRvbmVNYXBwaW5nID0gVEhSRUUuQUNFU0ZpbG1pY1RvbmVNYXBwaW5nOyAvLyBFbmFibGUgc2hhZG93cy5cbiAgICAvLyBodHRwczovL3RocmVlanMub3JnL2RvY3MvI2FwaS9lbi9jb25zdGFudHMvUmVuZGVyZXJcblxuICAgIHRoaXMucmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSB0cnVlOyAvLyBUbyBhbnRpYWxpYXMgdGhlIHNoYWRvd1xuXG4gICAgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXBUeXBlID0gVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICB0aGlzLnJlbmRlcmVyLmdhbW1hT3V0cHV0ID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcmVyLmdhbW1hRmFjdG9yID0gMi4yOyAvLyBQb3N0IHByb2Nlc3NpbmdcblxuICAgIHRoaXMuY29tcG9zZXIuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgY29uc3QgZnhhYVBhc3MgPSBuZXcgX1NoYWRlclBhc3MuU2hhZGVyUGFzcyhfRlhBQVNoYWRlci5GWEFBU2hhZGVyKTtcbiAgICBmeGFhUGFzcy5tYXRlcmlhbC51bmlmb3Jtc1sncmVzb2x1dGlvbiddLnZhbHVlLnggPSAxIC8gKHRoaXMud2lkdGggKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgZnhhYVBhc3MubWF0ZXJpYWwudW5pZm9ybXNbJ3Jlc29sdXRpb24nXS52YWx1ZS55ID0gMSAvICh0aGlzLmhlaWdodCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB0aGlzLmNvbXBvc2VyLmFkZFBhc3MoZnhhYVBhc3MpO1xuICAgIHRoaXMuY29tcG9zZXIuYWRkUGFzcyhuZXcgX1JlbmRlclBhc3MuUmVuZGVyUGFzcyh0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSkpOyAvLyB2YXIgYmxvb21QYXNzID0gbmV3IFVucmVhbEJsb29tUGFzcygxLCAyNSwgNSwgMjU2KTtcbiAgICAvLyB0aGlzLmNvbXBvc2VyLmFkZFBhc3MoYmxvb21QYXNzKTtcbiAgICAvLyBUaGUgY2FtZXJhIGFzcGVjdCBnb2VzIG9mZiBzaW5jZSBpdCBjb3VsZCBiZSBleHBvcnRlZCBhdCBhIGRpZmZlcmVudFxuICAgIC8vIHJhdGlvLiAgRm9yY2UgdXBkYXRlIHRoZSBhc3BlY3QgcmF0aW8uXG4gICAgLy8gdGhpcy5jYW1lcmEuZm92ID0gMjU7IC8vIFVwZGF0ZSBGT1YuXG5cbiAgICB0aGlzLmNhbWVyYS56b29tID0gMTsgLy8gVXBkYXRlIEZPVi5cblxuICAgIHRoaXMuY2FtZXJhLmFzcGVjdCA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gIH1cblxuICBnZXRBbmltYXRpb25CeU5hbWUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnMuZmlsdGVyKGFuaW1hdGlvbkNsaXAgPT4ge1xuICAgICAgcmV0dXJuIGFuaW1hdGlvbkNsaXAubmFtZSA9PSBuYW1lO1xuICAgIH0pWzBdO1xuICB9XG5cbiAgZ2V0T2JqZWN0QnlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVTY2VuZS5jaGlsZHJlbi5maWx0ZXIob2JqZWN0M2QgPT4ge1xuICAgICAgcmV0dXJuIG9iamVjdDNkLm5hbWUgPT0gbmFtZTtcbiAgICB9KVswXTtcbiAgfVxuXG4gIG9uUHJvZ3Jlc3NVcGRhdGUocHJvZ3Jlc3MpIHtcbiAgICAvL0FuaW1hdGlvbiBNaXhlcuOCkuWun+ihjFxuICAgIGlmICh0aGlzLm1peGVyKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGZpbmQgb3V0IGhvdyBsb25nIHRoZSBhbmltYXRpb24gaXMuXG4gICAgICAvLyBUaGUgbWl4ZXIgYXBwZWFycyB0byBoYXZlIG5vIGtub3dsZWRnZSBvZnQgdGhpcyBzbyB3ZSBuZWVkIHRvXG4gICAgICAvLyBsb29rIHVwIGEgc3BlY2lmaWMgYW5pbWF0aW9uIGFuZCBnZXQgdGhlIGR1cmF0aW9uIHRvXG4gICAgICAvLyBnZXQgdGhlIHRvdGFsIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICBjb25zdCBjYW1lcmFBbmltYXRpb24gPSB0aGlzLmdldEFuaW1hdGlvbkJ5TmFtZSgnQ3ViZUFjdGlvbicpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBjYW1lcmFBbmltYXRpb24uZHVyYXRpb247IC8vIFdoZW4gZHVyYXRpb24gaGl0cyBpdCdzIG1heCwgYW5pbWF0aW9uTWl4ZXIgc2VlbXMgdG8gaGl0IHRoZSBmaXJzdFxuICAgICAgLy8gZnJhbWUgc28gbmV4dCBhbGxvdyBpdCB0byByZWFjaCB0aGUgbWF4IHZhbHVlLlxuXG4gICAgICB0aGlzLm1peGVyLnNldFRpbWUoTWF0aC5taW4oZHVyYXRpb24gKiBwcm9ncmVzcywgZHVyYXRpb24gLSAwLjAwMSkpO1xuICAgIH0gLy8gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuXG5cbiAgICB0aGlzLmNvbXBvc2VyLnJlbmRlcigpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gVGhyZWVPYmplY3RWaWV3ZXIzOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/three-object-viewer3.js\n");

/***/ }),

/***/ "./examples/three-object-viewer4.js":
/*!******************************************!*\
  !*** ./examples/three-object-viewer4.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _datguif = __webpack_require__(/*! ../lib/datguif/datguif */ \"./lib/datguif/datguif.js\");\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _GLTFLoader = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\nvar _EffectComposer = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n\nvar _RenderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n\nvar _UnrealBloomPass = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass.js */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n\nvar _FXAAShader = __webpack_require__(/*! three/examples/jsm/shaders/FXAAShader.js */ \"./node_modules/three/examples/jsm/shaders/FXAAShader.js\");\n\nvar _ShaderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/ShaderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/ShaderPass.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n// https://threejs.org/docs/#manual/en/introduction/Loading-3D-models\n// https://threejs.org/examples/#webgl_loader_gltf\n// https://gist.github.com/bellbind/c4f8c502fcacbe29422e5ac315273858\n// https://github.com/funwithtriangles/blender-to-threejs-export-guide/blob/master/readme.md\n// https://threejsfundamentals.org/threejs/lessons/threejs-load-gltf.html\n// https://discoverthreejs.com/book/first-steps/load-models/\n// https://www.pentacreation.com/blog/2019/09/190916.html\n// https://www.pentacreation.com/blog/2019/10/191016.html\n// https://docs.blender.org/manual/ja/latest/addons/io_scene_gltf2.html\n// https://gltf-viewer.donmccurdy.com/\n// https://github.com/donmccurdy/three-gltf-viewer\n// import { Raf } from '../lib/raf/raf';\nclass ThreeObjectViewer4 {\n  constructor() {\n    console.log('ThreeJS Object Viewer Demo');\n    this.parentElement = document.getElementById('parent');\n    this.canvasContainer = document.getElementById('canvas-container');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.rafProgress = new _rafProgress.RafProgress();\n    this.rafProgress.watch(this.onProgressUpdate.bind(this));\n    this.scrollLerp = 0.38;\n    this.scrollEase = 'easeInQuad';\n    this.rendererConfig = {\n      clearColor: '#FFFFFF',\n      backgroundAlpha: 1.0\n    };\n    this.gui = new _datguif.Datguif({\n      load: JSON\n    });\n    this.gui.addFolder('Settings').open();\n    this.gui.addFolder('Renderer', 'Settings');\n    this.gui.addFolder('Camera', 'Settings');\n    this.gui.addFolder('Scroll', 'Settings');\n    this.gui.addFolder('Lights');\n    this.gui.addFolder('Objects');\n    this.gui.addObjectToFolder('Scroll', this, [{\n      keyName: 'scrollLerp',\n      min: 0,\n      max: 1,\n      step: 0.01\n    }, {\n      keyName: 'scrollEase',\n      options: ['linear', 'easeOutQuad', 'easeInQuad']\n    }]);\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight); //   this.rafProgress.easeTo(this.progress, 0.26, EASE.easeInOutExpo);\n        //   this.rafProgress.easeTo(this.progress, 0.08, EASE.linear);\n\n        this.rafProgress.easeTo(this.progress, this.scrollLerp, _ease.EASE[this.scrollEase]);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.scene = new THREE.Scene();\n    this.gui.onUpdate(prop => {\n      this.draw();\n    });\n    var loader = new _GLTFLoader.GLTFLoader(); // const path = 'https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf';\n    // const path = './public/dude.glb';\n\n    const path = './public/home/home3.gltf';\n    loader.load(path, gltf => {\n      const gltfData = gltf.parser.json;\n\n      const getNodeByName = name => {\n        return gltfData.nodes.filter(node => {\n          return node.name = name;\n        })[0];\n      };\n\n      console.log(gltfData);\n      this.clock = new THREE.Clock();\n      const scene = gltf.scenes[0];\n      this.activeScene = scene;\n      this.animations = gltf.animations; // Animation Mixer\n\n      this.mixer = new THREE.AnimationMixer(scene); //Animation Clip\n\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i]; //Animation Action\n\n        var action = this.mixer.clipAction(animation);\n        console.log('added', animation);\n        action.play();\n      }\n\n      this.scene.add(scene);\n      console.log(this.mixer); // http://learningthreejs.com/blog/2012/01/20/casting-shadows/\n\n      this.scene.traverse(child => {\n        if (child instanceof THREE.Light) {\n          child.castShadow = false;\n          console.log('light', child);\n          const shadowEnabledLights = ['Point013_Orientation', 'Point003_Orientation'];\n\n          if (~shadowEnabledLights.indexOf(child.name)) {\n            child.castShadow = true;\n          } // Debugging light positions.\n          // child.shadowCameraVisible = false;\n\n\n          if (child.shadow) {\n            // Adjust shadow bias.\n            child.shadow.bias = -0.002; // Remove the rigged looking shadows.\n\n            child.shadow.mapSize.width = 1024;\n            child.shadow.mapSize.height = 1024; // child.shadowDarkness = 0.5;\n            // child.shadow.camera.near = 0;\n            // child.shadow.camera.far = 1000;\n            // var helper = new THREE.CameraHelper( child.shadow.camera );\n            // scene.add( helper );\n          } // Point lights are defined in watts which goes waay off in three.js\n\n\n          if (child instanceof THREE.PointLight) {\n            child.intensity = child.intensity * 0.01;\n          } // If it's a spot light, it needs to go down even more.\n\n\n          if (child.type == \"SpotLight\") {\n            child.intensity = child.intensity * 0.001;\n          }\n\n          this.gui.addFolder(child.name, 'Lights');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'intensity',\n            min: 0,\n            max: 3000\n          }, {\n            keyName: 'color'\n          }]);\n\n          if (child.shadow) {\n            const shadowFolderId = child.name + ' shadow';\n            console.log(child.shadow);\n            this.gui.addFolder(shadowFolderId, child.name);\n            this.gui.addObjectToFolder(shadowFolderId, child.shadow, [{\n              keyName: 'bias',\n              min: -1,\n              max: 1,\n              step: 0.00001\n            }, {\n              keyName: 'radius',\n              min: 0,\n              max: 100,\n              step: 0.01\n            }]);\n          }\n        } else if (child instanceof THREE.Mesh) {\n          child.castShadow = true; // child.receiveShadow = true;\n          // child.geometry.computeVertexNormals(true);\n\n          this.gui.addFolder(child.name, 'Objects');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'receiveShadow'\n          }]); // Get the image mappings.\n          // if(child.material && child.material.map) {\n          //   child.material.map.needsUpdate = true;\n          // }\n        } else {} // if(child.name.startsWith('Cube003')) {\n        //     child.receiveShadow = true;\n        // }\n        // Fix eyes\n\n\n        if (child.name.startsWith('Plane')) {\n          child.castShadow = false;\n          child.receiveShadow = true;\n        }\n      }); // Set the camera exported in gltf.\n      // Requires camera to be exported for gltf.\n\n      this.camera = gltf.cameras[0];\n      console.log(this.camera);\n      this.resize(); // Use fog to cover far distances.\n\n      const color = 0xFFFFFF;\n      this.scene.fog = new THREE.Fog(color, 20, 24); // Enable shadows.\n      // https://threejs.org/docs/#api/en/constants/Renderer\n\n      this.renderer.shadowMap.enabled = true; // To antialias the shadow\n\n      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n      this.renderer.gammaOutput = true;\n      this.renderer.gammaFactor = 2.2; // Important to get the correct colors.\n\n      this.renderer.physicallyCorrectLights = true; // Background as black.\n      // this.renderer.setClearColor(0x4287f5);\n\n      this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha); // Affects how strongly lights come exposed.\n      // https://threejs.org/examples/#webgl_tonemapping\n\n      this.renderer.toneMappingExposure = 1; // this.renderer.toneMapping = THREE.ACESFilmicToneMapping;\n\n      this.gui.addObjectToFolder('Renderer', this.renderer, [{\n        keyName: 'toneMappingExposure',\n        min: 0,\n        max: 5,\n        step: 0.01\n      }]);\n      this.gui.addObjectToFolder('Renderer', this.rendererConfig, [{\n        keyName: 'clearColor',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }, {\n        keyName: 'backgroundAlpha',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }]);\n      this.gui.addObjectToFolder('Camera', this.camera, [{\n        keyName: 'fov',\n        min: 0,\n        max: 50,\n        step: 0.01,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }, {\n        keyName: 'zoom',\n        min: 0,\n        max: 10,\n        step: 0.0001,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }]);\n      this.gui.addFolder('General Lights');\n      this.generalLightConfig = {\n        ambientLightColor: '#FFFFFF',\n        ambientLightAlpha: 1.2\n      }; // Additional lighting outside the blender.\n      // var light = new THREE.HemisphereLight( 0xffffbb, 0xffffff, 1 );\n      // this.scene.add( light );\n\n      this.ambientLight = new THREE.AmbientLight(this.generalLightConfig.ambientLightColor);\n      this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n      scene.add(this.ambientLight);\n      this.gui.addObjectToFolder('General Lights', this.generalLightConfig, [{\n        keyName: 'ambientLightColor',\n        callback: () => {\n          this.ambientLight.color = new THREE.Color(this.generalLightConfig.ambientLightColor);\n        }\n      }, {\n        keyName: 'ambientLightAlpha',\n        callback: () => {\n          this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n        }\n      }]);\n      var width = 50;\n      var height = 50;\n      var intensity = 0;\n      var rectLight = new THREE.RectAreaLight('#FFFFFF', intensity, width, height);\n      rectLight.position.set(0, 0, 25); // rectLight.lookAt( 0, 0, 0 );\n\n      this.scene.add(rectLight);\n      rectLightHelper = new THREE.RectAreaLightHelper(rectLight);\n      rectLight.add(rectLightHelper);\n      this.gui.addButton('Refresh', this.refresh.bind(this));\n    }, undefined, error => {\n      console.error(error);\n    });\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      // precision: 'highp'\n      autoSize: true\n    });\n    this.composer = new _EffectComposer.EffectComposer(this.renderer);\n    this.canvasContainer.appendChild(this.renderer.domElement);\n    window.addEventListener('resize', this.resize.bind(this), false);\n  }\n\n  resize() {\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.width = this.canvasContainer.parentElement.offsetWidth;\n    this.height = this.canvasContainer.parentElement.offsetHeight; // https://github.com/donmccurdy/three-gltf-viewer/blob/master/src/viewer.js\n    // https://threejs.org/docs/#api/en/constants/Renderer\n\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n    this.renderer.setSize(this.width, this.height); // Post processing\n    // this.composer.setSize( this.width, this.height);\n    // const fxaaPass = new ShaderPass( FXAAShader );\n    // fxaaPass.material.uniforms[ 'resolution' ].value.x = 1 / ( this.width * window.devicePixelRatio);\n    // fxaaPass.material.uniforms[ 'resolution' ].value.y = 1 / ( this.height * window.devicePixelRatio);\n    // this.composer.addPass(fxaaPass);\n    // this.composer.addPass(new RenderPass(this.scene, this.camera));\n    // var bloomPass = new UnrealBloomPass(1, 25, 5, 256);\n    // this.composer.addPass(bloomPass);\n    // The camera aspect goes off since it could be exported at a different\n    // ratio.  Force update the aspect ratio.\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n  }\n\n  refresh() {\n    this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n    this.resize();\n    this.draw();\n  }\n\n  getAnimationByName(name) {\n    return this.animations.filter(animationClip => {\n      return animationClip.name == name;\n    })[0];\n  }\n\n  getObjectByName(name) {\n    return this.activeScene.children.filter(object3d => {\n      return object3d.name == name;\n    })[0];\n  }\n\n  onProgressUpdate(progress) {\n    //Animation Mixer\n    if (this.mixer) {\n      // We need to find out how long the animation is.\n      // The mixer appears to have no knowledge oft this so we need to\n      // look up a specific animation and get the duration to\n      // get the total duration of the animation.\n      const cameraAnimation = this.getAnimationByName('Action');\n      const duration = cameraAnimation.duration; // When duration hits it's max, animationMixer seems to hit the first\n      // frame so next allow it to reach the max value.\n\n      this.mixer.setTime(Math.min(duration * progress, duration - 0.001));\n    }\n\n    this.draw(); // this.renderer.render(this.scene, this.camera);\n    // this.composer.render();\n  }\n\n  draw() {\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = ThreeObjectViewer4;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1vYmplY3Qtdmlld2VyNC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3RocmVlLW9iamVjdC12aWV3ZXI0LmpzPzJmY2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZGF0Z3VpZiA9IHJlcXVpcmUoXCIuLi9saWIvZGF0Z3VpZi9kYXRndWlmXCIpO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX0dMVEZMb2FkZXIgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvR0xURkxvYWRlclwiKTtcblxudmFyIF9FZmZlY3RDb21wb3NlciA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvRWZmZWN0Q29tcG9zZXJcIik7XG5cbnZhciBfUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvUmVuZGVyUGFzcy5qc1wiKTtcblxudmFyIF9VbnJlYWxCbG9vbVBhc3MgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL1VucmVhbEJsb29tUGFzcy5qc1wiKTtcblxudmFyIF9GWEFBU2hhZGVyID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9zaGFkZXJzL0ZYQUFTaGFkZXIuanNcIik7XG5cbnZhciBfU2hhZGVyUGFzcyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvU2hhZGVyUGFzcy5qc1wiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWYtcHJvZ3Jlc3NcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tXCIpO1xuXG52YXIgX2Vhc2UgPSByZXF1aXJlKFwiLi4vbGliL2Vhc2UvZWFzZVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vLyBodHRwczovL3RocmVlanMub3JnL2RvY3MvI21hbnVhbC9lbi9pbnRyb2R1Y3Rpb24vTG9hZGluZy0zRC1tb2RlbHNcbi8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZXhhbXBsZXMvI3dlYmdsX2xvYWRlcl9nbHRmXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9iZWxsYmluZC9jNGY4YzUwMmZjYWNiZTI5NDIyZTVhYzMxNTI3Mzg1OFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bndpdGh0cmlhbmdsZXMvYmxlbmRlci10by10aHJlZWpzLWV4cG9ydC1ndWlkZS9ibG9iL21hc3Rlci9yZWFkbWUubWRcbi8vIGh0dHBzOi8vdGhyZWVqc2Z1bmRhbWVudGFscy5vcmcvdGhyZWVqcy9sZXNzb25zL3RocmVlanMtbG9hZC1nbHRmLmh0bWxcbi8vIGh0dHBzOi8vZGlzY292ZXJ0aHJlZWpzLmNvbS9ib29rL2ZpcnN0LXN0ZXBzL2xvYWQtbW9kZWxzL1xuLy8gaHR0cHM6Ly93d3cucGVudGFjcmVhdGlvbi5jb20vYmxvZy8yMDE5LzA5LzE5MDkxNi5odG1sXG4vLyBodHRwczovL3d3dy5wZW50YWNyZWF0aW9uLmNvbS9ibG9nLzIwMTkvMTAvMTkxMDE2Lmh0bWxcbi8vIGh0dHBzOi8vZG9jcy5ibGVuZGVyLm9yZy9tYW51YWwvamEvbGF0ZXN0L2FkZG9ucy9pb19zY2VuZV9nbHRmMi5odG1sXG4vLyBodHRwczovL2dsdGYtdmlld2VyLmRvbm1jY3VyZHkuY29tL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rvbm1jY3VyZHkvdGhyZWUtZ2x0Zi12aWV3ZXJcbi8vIGltcG9ydCB7IFJhZiB9IGZyb20gJy4uL2xpYi9yYWYvcmFmJztcbmNsYXNzIFRocmVlT2JqZWN0Vmlld2VyNCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdUaHJlZUpTIE9iamVjdCBWaWV3ZXIgRGVtbycpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJlbnQnKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMtY29udGFpbmVyJyk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcygpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3Mud2F0Y2godGhpcy5vblByb2dyZXNzVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc2Nyb2xsTGVycCA9IDAuMzg7XG4gICAgdGhpcy5zY3JvbGxFYXNlID0gJ2Vhc2VJblF1YWQnO1xuICAgIHRoaXMucmVuZGVyZXJDb25maWcgPSB7XG4gICAgICBjbGVhckNvbG9yOiAnI0ZGRkZGRicsXG4gICAgICBiYWNrZ3JvdW5kQWxwaGE6IDEuMFxuICAgIH07XG4gICAgdGhpcy5ndWkgPSBuZXcgX2RhdGd1aWYuRGF0Z3VpZih7XG4gICAgICBsb2FkOiBKU09OXG4gICAgfSk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdTZXR0aW5ncycpLm9wZW4oKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ1JlbmRlcmVyJywgJ1NldHRpbmdzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdDYW1lcmEnLCAnU2V0dGluZ3MnKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ1Njcm9sbCcsICdTZXR0aW5ncycpO1xuICAgIHRoaXMuZ3VpLmFkZEZvbGRlcignTGlnaHRzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdPYmplY3RzJyk7XG4gICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoJ1Njcm9sbCcsIHRoaXMsIFt7XG4gICAgICBrZXlOYW1lOiAnc2Nyb2xsTGVycCcsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEsXG4gICAgICBzdGVwOiAwLjAxXG4gICAgfSwge1xuICAgICAga2V5TmFtZTogJ3Njcm9sbEVhc2UnLFxuICAgICAgb3B0aW9uczogWydsaW5lYXInLCAnZWFzZU91dFF1YWQnLCAnZWFzZUluUXVhZCddXG4gICAgfV0pO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdzY3JvbGwnLFxuICAgICAgY2FsbGJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50LCB3aW5kb3cuaW5uZXJIZWlnaHQpOyAvLyAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDAuMjYsIEVBU0UuZWFzZUluT3V0RXhwbyk7XG4gICAgICAgIC8vICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMC4wOCwgRUFTRS5saW5lYXIpO1xuXG4gICAgICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIHRoaXMuc2Nyb2xsTGVycCwgX2Vhc2UuRUFTRVt0aGlzLnNjcm9sbEVhc2VdKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICB0aGlzLmd1aS5vblVwZGF0ZShwcm9wID0+IHtcbiAgICAgIHRoaXMuZHJhdygpO1xuICAgIH0pO1xuICAgIHZhciBsb2FkZXIgPSBuZXcgX0dMVEZMb2FkZXIuR0xURkxvYWRlcigpOyAvLyBjb25zdCBwYXRoID0gJ2h0dHBzOi8vdGhyZWVqcy5vcmcvZXhhbXBsZXMvbW9kZWxzL2dsdGYvRGFtYWdlZEhlbG1ldC9nbFRGL0RhbWFnZWRIZWxtZXQuZ2x0Zic7XG4gICAgLy8gY29uc3QgcGF0aCA9ICcuL3B1YmxpYy9kdWRlLmdsYic7XG5cbiAgICBjb25zdCBwYXRoID0gJy4vcHVibGljL2hvbWUvaG9tZTMuZ2x0Zic7XG4gICAgbG9hZGVyLmxvYWQocGF0aCwgZ2x0ZiA9PiB7XG4gICAgICBjb25zdCBnbHRmRGF0YSA9IGdsdGYucGFyc2VyLmpzb247XG5cbiAgICAgIGNvbnN0IGdldE5vZGVCeU5hbWUgPSBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIGdsdGZEYXRhLm5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5uYW1lID0gbmFtZTtcbiAgICAgICAgfSlbMF07XG4gICAgICB9O1xuXG4gICAgICBjb25zb2xlLmxvZyhnbHRmRGF0YSk7XG4gICAgICB0aGlzLmNsb2NrID0gbmV3IFRIUkVFLkNsb2NrKCk7XG4gICAgICBjb25zdCBzY2VuZSA9IGdsdGYuc2NlbmVzWzBdO1xuICAgICAgdGhpcy5hY3RpdmVTY2VuZSA9IHNjZW5lO1xuICAgICAgdGhpcy5hbmltYXRpb25zID0gZ2x0Zi5hbmltYXRpb25zOyAvLyBBbmltYXRpb24gTWl4ZXLjgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJBcblxuICAgICAgdGhpcy5taXhlciA9IG5ldyBUSFJFRS5BbmltYXRpb25NaXhlcihzY2VuZSk7IC8v5YWo44Gm44GuQW5pbWF0aW9uIENsaXDjgavlr77jgZfjgaZcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc1tpXTsgLy9BbmltYXRpb24gQWN0aW9u44KS55Sf5oiQXG5cbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMubWl4ZXIuY2xpcEFjdGlvbihhbmltYXRpb24pO1xuICAgICAgICBjb25zb2xlLmxvZygnYWRkZWQnLCBhbmltYXRpb24pO1xuICAgICAgICBhY3Rpb24ucGxheSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjZW5lLmFkZChzY2VuZSk7XG4gICAgICBjb25zb2xlLmxvZyh0aGlzLm1peGVyKTsgLy8gaHR0cDovL2xlYXJuaW5ndGhyZWVqcy5jb20vYmxvZy8yMDEyLzAxLzIwL2Nhc3Rpbmctc2hhZG93cy9cblxuICAgICAgdGhpcy5zY2VuZS50cmF2ZXJzZShjaGlsZCA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLkxpZ2h0KSB7XG4gICAgICAgICAgY2hpbGQuY2FzdFNoYWRvdyA9IGZhbHNlO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdsaWdodCcsIGNoaWxkKTtcbiAgICAgICAgICBjb25zdCBzaGFkb3dFbmFibGVkTGlnaHRzID0gWydQb2ludDAxM19PcmllbnRhdGlvbicsICdQb2ludDAwM19PcmllbnRhdGlvbiddO1xuXG4gICAgICAgICAgaWYgKH5zaGFkb3dFbmFibGVkTGlnaHRzLmluZGV4T2YoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIH0gLy8gRGVidWdnaW5nIGxpZ2h0IHBvc2l0aW9ucy5cbiAgICAgICAgICAvLyBjaGlsZC5zaGFkb3dDYW1lcmFWaXNpYmxlID0gZmFsc2U7XG5cblxuICAgICAgICAgIGlmIChjaGlsZC5zaGFkb3cpIHtcbiAgICAgICAgICAgIC8vIEFkanVzdCBzaGFkb3cgYmlhcy5cbiAgICAgICAgICAgIGNoaWxkLnNoYWRvdy5iaWFzID0gLTAuMDAyOyAvLyBSZW1vdmUgdGhlIHJpZ2dlZCBsb29raW5nIHNoYWRvd3MuXG5cbiAgICAgICAgICAgIGNoaWxkLnNoYWRvdy5tYXBTaXplLndpZHRoID0gMTAyNDtcbiAgICAgICAgICAgIGNoaWxkLnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IDEwMjQ7IC8vIGNoaWxkLnNoYWRvd0RhcmtuZXNzID0gMC41O1xuICAgICAgICAgICAgLy8gY2hpbGQuc2hhZG93LmNhbWVyYS5uZWFyID0gMDtcbiAgICAgICAgICAgIC8vIGNoaWxkLnNoYWRvdy5jYW1lcmEuZmFyID0gMTAwMDtcbiAgICAgICAgICAgIC8vIHZhciBoZWxwZXIgPSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBjaGlsZC5zaGFkb3cuY2FtZXJhICk7XG4gICAgICAgICAgICAvLyBzY2VuZS5hZGQoIGhlbHBlciApO1xuICAgICAgICAgIH0gLy8gUG9pbnQgbGlnaHRzIGFyZSBkZWZpbmVkIGluIHdhdHRzIHdoaWNoIGdvZXMgd2FheSBvZmYgaW4gdGhyZWUuanNcblxuXG4gICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCkge1xuICAgICAgICAgICAgY2hpbGQuaW50ZW5zaXR5ID0gY2hpbGQuaW50ZW5zaXR5ICogMC4wMTtcbiAgICAgICAgICB9IC8vIElmIGl0J3MgYSBzcG90IGxpZ2h0LCBpdCBuZWVkcyB0byBnbyBkb3duIGV2ZW4gbW9yZS5cblxuXG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT0gXCJTcG90TGlnaHRcIikge1xuICAgICAgICAgICAgY2hpbGQuaW50ZW5zaXR5ID0gY2hpbGQuaW50ZW5zaXR5ICogMC4wMDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKGNoaWxkLm5hbWUsICdMaWdodHMnKTtcbiAgICAgICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcihjaGlsZC5uYW1lLCBjaGlsZCwgW3tcbiAgICAgICAgICAgIGtleU5hbWU6ICdjYXN0U2hhZG93J1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleU5hbWU6ICdpbnRlbnNpdHknLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAzMDAwXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5TmFtZTogJ2NvbG9yJ1xuICAgICAgICAgIH1dKTtcblxuICAgICAgICAgIGlmIChjaGlsZC5zaGFkb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd0ZvbGRlcklkID0gY2hpbGQubmFtZSArICcgc2hhZG93JztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGNoaWxkLnNoYWRvdyk7XG4gICAgICAgICAgICB0aGlzLmd1aS5hZGRGb2xkZXIoc2hhZG93Rm9sZGVySWQsIGNoaWxkLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoc2hhZG93Rm9sZGVySWQsIGNoaWxkLnNoYWRvdywgW3tcbiAgICAgICAgICAgICAga2V5TmFtZTogJ2JpYXMnLFxuICAgICAgICAgICAgICBtaW46IC0xLFxuICAgICAgICAgICAgICBtYXg6IDEsXG4gICAgICAgICAgICAgIHN0ZXA6IDAuMDAwMDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5TmFtZTogJ3JhZGl1cycsXG4gICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgbWF4OiAxMDAsXG4gICAgICAgICAgICAgIHN0ZXA6IDAuMDFcbiAgICAgICAgICAgIH1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoKSB7XG4gICAgICAgICAgY2hpbGQuY2FzdFNoYWRvdyA9IHRydWU7IC8vIGNoaWxkLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIC8vIGNoaWxkLmdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKHRydWUpO1xuXG4gICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKGNoaWxkLm5hbWUsICdPYmplY3RzJyk7XG4gICAgICAgICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoY2hpbGQubmFtZSwgY2hpbGQsIFt7XG4gICAgICAgICAgICBrZXlOYW1lOiAnY2FzdFNoYWRvdydcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXlOYW1lOiAncmVjZWl2ZVNoYWRvdydcbiAgICAgICAgICB9XSk7IC8vIEdldCB0aGUgaW1hZ2UgbWFwcGluZ3MuXG4gICAgICAgICAgLy8gaWYoY2hpbGQubWF0ZXJpYWwgJiYgY2hpbGQubWF0ZXJpYWwubWFwKSB7XG4gICAgICAgICAgLy8gICBjaGlsZC5tYXRlcmlhbC5tYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgfSBlbHNlIHt9IC8vIGlmKGNoaWxkLm5hbWUuc3RhcnRzV2l0aCgnQ3ViZTAwMycpKSB7XG4gICAgICAgIC8vICAgICBjaGlsZC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBGaXggZXllc1xuXG5cbiAgICAgICAgaWYgKGNoaWxkLm5hbWUuc3RhcnRzV2l0aCgnUGxhbmUnKSkge1xuICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSBmYWxzZTtcbiAgICAgICAgICBjaGlsZC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIFNldCB0aGUgY2FtZXJhIGV4cG9ydGVkIGluIGdsdGYuXG4gICAgICAvLyBSZXF1aXJlcyBjYW1lcmEgdG8gYmUgZXhwb3J0ZWQgZm9yIGdsdGYuXG5cbiAgICAgIHRoaXMuY2FtZXJhID0gZ2x0Zi5jYW1lcmFzWzBdO1xuICAgICAgY29uc29sZS5sb2codGhpcy5jYW1lcmEpO1xuICAgICAgdGhpcy5yZXNpemUoKTsgLy8gVXNlIGZvZyB0byBjb3ZlciBmYXIgZGlzdGFuY2VzLlxuXG4gICAgICBjb25zdCBjb2xvciA9IDB4RkZGRkZGO1xuICAgICAgdGhpcy5zY2VuZS5mb2cgPSBuZXcgVEhSRUUuRm9nKGNvbG9yLCAyMCwgMjQpOyAvLyBFbmFibGUgc2hhZG93cy5cbiAgICAgIC8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL2NvbnN0YW50cy9SZW5kZXJlclxuXG4gICAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkID0gdHJ1ZTsgLy8gVG8gYW50aWFsaWFzIHRoZSBzaGFkb3dcblxuICAgICAgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdhbW1hT3V0cHV0ID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2FtbWFGYWN0b3IgPSAyLjI7IC8vIEltcG9ydGFudCB0byBnZXQgdGhlIGNvcnJlY3QgY29sb3JzLlxuXG4gICAgICB0aGlzLnJlbmRlcmVyLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzID0gdHJ1ZTsgLy8gQmFja2dyb3VuZCBhcyBibGFjay5cbiAgICAgIC8vIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigweDQyODdmNSk7XG5cbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcih0aGlzLnJlbmRlcmVyQ29uZmlnLmNsZWFyQ29sb3IsIHRoaXMucmVuZGVyZXJDb25maWcuYmFja2dyb3VuZEFscGhhKTsgLy8gQWZmZWN0cyBob3cgc3Ryb25nbHkgbGlnaHRzIGNvbWUgZXhwb3NlZC5cbiAgICAgIC8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZXhhbXBsZXMvI3dlYmdsX3RvbmVtYXBwaW5nXG5cbiAgICAgIHRoaXMucmVuZGVyZXIudG9uZU1hcHBpbmdFeHBvc3VyZSA9IDE7IC8vIHRoaXMucmVuZGVyZXIudG9uZU1hcHBpbmcgPSBUSFJFRS5BQ0VTRmlsbWljVG9uZU1hcHBpbmc7XG5cbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdSZW5kZXJlcicsIHRoaXMucmVuZGVyZXIsIFt7XG4gICAgICAgIGtleU5hbWU6ICd0b25lTWFwcGluZ0V4cG9zdXJlJyxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDUsXG4gICAgICAgIHN0ZXA6IDAuMDFcbiAgICAgIH1dKTtcbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdSZW5kZXJlcicsIHRoaXMucmVuZGVyZXJDb25maWcsIFt7XG4gICAgICAgIGtleU5hbWU6ICdjbGVhckNvbG9yJyxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5yZW5kZXJlckNvbmZpZy5jbGVhckNvbG9yLCB0aGlzLnJlbmRlcmVyQ29uZmlnLmJhY2tncm91bmRBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5TmFtZTogJ2JhY2tncm91bmRBbHBoYScsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMucmVuZGVyZXJDb25maWcuY2xlYXJDb2xvciwgdGhpcy5yZW5kZXJlckNvbmZpZy5iYWNrZ3JvdW5kQWxwaGEpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcignQ2FtZXJhJywgdGhpcy5jYW1lcmEsIFt7XG4gICAgICAgIGtleU5hbWU6ICdmb3YnLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogNTAsXG4gICAgICAgIHN0ZXA6IDAuMDEsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleU5hbWU6ICd6b29tJyxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDEwLFxuICAgICAgICBzdGVwOiAwLjAwMDEsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ0dlbmVyYWwgTGlnaHRzJyk7XG4gICAgICB0aGlzLmdlbmVyYWxMaWdodENvbmZpZyA9IHtcbiAgICAgICAgYW1iaWVudExpZ2h0Q29sb3I6ICcjRkZGRkZGJyxcbiAgICAgICAgYW1iaWVudExpZ2h0QWxwaGE6IDEuMlxuICAgICAgfTsgLy8gQWRkaXRpb25hbCBsaWdodGluZyBvdXRzaWRlIHRoZSBibGVuZGVyLlxuICAgICAgLy8gdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCggMHhmZmZmYmIsIDB4ZmZmZmZmLCAxICk7XG4gICAgICAvLyB0aGlzLnNjZW5lLmFkZCggbGlnaHQgKTtcblxuICAgICAgdGhpcy5hbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodENvbG9yKTtcbiAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmludGVuc2l0eSA9IHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodEFscGhhO1xuICAgICAgc2NlbmUuYWRkKHRoaXMuYW1iaWVudExpZ2h0KTtcbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdHZW5lcmFsIExpZ2h0cycsIHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLCBbe1xuICAgICAgICBrZXlOYW1lOiAnYW1iaWVudExpZ2h0Q29sb3InLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodENvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXlOYW1lOiAnYW1iaWVudExpZ2h0QWxwaGEnLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmludGVuc2l0eSA9IHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodEFscGhhO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICB2YXIgd2lkdGggPSA1MDtcbiAgICAgIHZhciBoZWlnaHQgPSA1MDtcbiAgICAgIHZhciBpbnRlbnNpdHkgPSAwO1xuICAgICAgdmFyIHJlY3RMaWdodCA9IG5ldyBUSFJFRS5SZWN0QXJlYUxpZ2h0KCcjRkZGRkZGJywgaW50ZW5zaXR5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJlY3RMaWdodC5wb3NpdGlvbi5zZXQoMCwgMCwgMjUpOyAvLyByZWN0TGlnaHQubG9va0F0KCAwLCAwLCAwICk7XG5cbiAgICAgIHRoaXMuc2NlbmUuYWRkKHJlY3RMaWdodCk7XG4gICAgICByZWN0TGlnaHRIZWxwZXIgPSBuZXcgVEhSRUUuUmVjdEFyZWFMaWdodEhlbHBlcihyZWN0TGlnaHQpO1xuICAgICAgcmVjdExpZ2h0LmFkZChyZWN0TGlnaHRIZWxwZXIpO1xuICAgICAgdGhpcy5ndWkuYWRkQnV0dG9uKCdSZWZyZXNoJywgdGhpcy5yZWZyZXNoLmJpbmQodGhpcykpO1xuICAgIH0sIHVuZGVmaW5lZCwgZXJyb3IgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICAgIC8vIHByZWNpc2lvbjogJ2hpZ2hwJ1xuICAgICAgYXV0b1NpemU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbXBvc2VyID0gbmV3IF9FZmZlY3RDb21wb3Nlci5FZmZlY3RDb21wb3Nlcih0aGlzLnJlbmRlcmVyKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gIH1cblxuICByZXNpemUoKSB7XG4gICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50LCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDEsIF9lYXNlLkVBU0UuTGluZWFyKTtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5jYW52YXNDb250YWluZXIucGFyZW50RWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FudmFzQ29udGFpbmVyLnBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0OyAvLyBodHRwczovL2dpdGh1Yi5jb20vZG9ubWNjdXJkeS90aHJlZS1nbHRmLXZpZXdlci9ibG9iL21hc3Rlci9zcmMvdmlld2VyLmpzXG4gICAgLy8gaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNhcGkvZW4vY29uc3RhbnRzL1JlbmRlcmVyXG5cbiAgICB0aGlzLnJlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7IC8vIFBvc3QgcHJvY2Vzc2luZ1xuICAgIC8vIHRoaXMuY29tcG9zZXIuc2V0U2l6ZSggdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIC8vIGNvbnN0IGZ4YWFQYXNzID0gbmV3IFNoYWRlclBhc3MoIEZYQUFTaGFkZXIgKTtcbiAgICAvLyBmeGFhUGFzcy5tYXRlcmlhbC51bmlmb3Jtc1sgJ3Jlc29sdXRpb24nIF0udmFsdWUueCA9IDEgLyAoIHRoaXMud2lkdGggKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgLy8gZnhhYVBhc3MubWF0ZXJpYWwudW5pZm9ybXNbICdyZXNvbHV0aW9uJyBdLnZhbHVlLnkgPSAxIC8gKCB0aGlzLmhlaWdodCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAvLyB0aGlzLmNvbXBvc2VyLmFkZFBhc3MoZnhhYVBhc3MpO1xuICAgIC8vIHRoaXMuY29tcG9zZXIuYWRkUGFzcyhuZXcgUmVuZGVyUGFzcyh0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSkpO1xuICAgIC8vIHZhciBibG9vbVBhc3MgPSBuZXcgVW5yZWFsQmxvb21QYXNzKDEsIDI1LCA1LCAyNTYpO1xuICAgIC8vIHRoaXMuY29tcG9zZXIuYWRkUGFzcyhibG9vbVBhc3MpO1xuICAgIC8vIFRoZSBjYW1lcmEgYXNwZWN0IGdvZXMgb2ZmIHNpbmNlIGl0IGNvdWxkIGJlIGV4cG9ydGVkIGF0IGEgZGlmZmVyZW50XG4gICAgLy8gcmF0aW8uICBGb3JjZSB1cGRhdGUgdGhlIGFzcGVjdCByYXRpby5cblxuICAgIHRoaXMuY2FtZXJhLmFzcGVjdCA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcbiAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcih0aGlzLnJlbmRlcmVyQ29uZmlnLmNsZWFyQ29sb3IsIHRoaXMucmVuZGVyZXJDb25maWcuYmFja2dyb3VuZEFscGhhKTtcbiAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIHRoaXMuZHJhdygpO1xuICB9XG5cbiAgZ2V0QW5pbWF0aW9uQnlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRpb25zLmZpbHRlcihhbmltYXRpb25DbGlwID0+IHtcbiAgICAgIHJldHVybiBhbmltYXRpb25DbGlwLm5hbWUgPT0gbmFtZTtcbiAgICB9KVswXTtcbiAgfVxuXG4gIGdldE9iamVjdEJ5TmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlU2NlbmUuY2hpbGRyZW4uZmlsdGVyKG9iamVjdDNkID0+IHtcbiAgICAgIHJldHVybiBvYmplY3QzZC5uYW1lID09IG5hbWU7XG4gICAgfSlbMF07XG4gIH1cblxuICBvblByb2dyZXNzVXBkYXRlKHByb2dyZXNzKSB7XG4gICAgLy9BbmltYXRpb24gTWl4ZXLjgpLlrp/ooYxcbiAgICBpZiAodGhpcy5taXhlcikge1xuICAgICAgLy8gV2UgbmVlZCB0byBmaW5kIG91dCBob3cgbG9uZyB0aGUgYW5pbWF0aW9uIGlzLlxuICAgICAgLy8gVGhlIG1peGVyIGFwcGVhcnMgdG8gaGF2ZSBubyBrbm93bGVkZ2Ugb2Z0IHRoaXMgc28gd2UgbmVlZCB0b1xuICAgICAgLy8gbG9vayB1cCBhIHNwZWNpZmljIGFuaW1hdGlvbiBhbmQgZ2V0IHRoZSBkdXJhdGlvbiB0b1xuICAgICAgLy8gZ2V0IHRoZSB0b3RhbCBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlxuICAgICAgY29uc3QgY2FtZXJhQW5pbWF0aW9uID0gdGhpcy5nZXRBbmltYXRpb25CeU5hbWUoJ0FjdGlvbicpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBjYW1lcmFBbmltYXRpb24uZHVyYXRpb247IC8vIFdoZW4gZHVyYXRpb24gaGl0cyBpdCdzIG1heCwgYW5pbWF0aW9uTWl4ZXIgc2VlbXMgdG8gaGl0IHRoZSBmaXJzdFxuICAgICAgLy8gZnJhbWUgc28gbmV4dCBhbGxvdyBpdCB0byByZWFjaCB0aGUgbWF4IHZhbHVlLlxuXG4gICAgICB0aGlzLm1peGVyLnNldFRpbWUoTWF0aC5taW4oZHVyYXRpb24gKiBwcm9ncmVzcywgZHVyYXRpb24gLSAwLjAwMSkpO1xuICAgIH1cblxuICAgIHRoaXMuZHJhdygpOyAvLyB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5yZW5kZXIoKTtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gVGhyZWVPYmplY3RWaWV3ZXI0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/three-object-viewer4.js\n");

/***/ }),

/***/ "./examples/three-object-viewer5.js":
/*!******************************************!*\
  !*** ./examples/three-object-viewer5.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _datguif = __webpack_require__(/*! ../lib/datguif/datguif */ \"./lib/datguif/datguif.js\");\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _GLTFLoader = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\nvar _EffectComposer = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n\nvar _RenderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n\nvar _UnrealBloomPass = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass.js */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n\nvar _FXAAShader = __webpack_require__(/*! three/examples/jsm/shaders/FXAAShader.js */ \"./node_modules/three/examples/jsm/shaders/FXAAShader.js\");\n\nvar _ShaderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/ShaderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/ShaderPass.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n// https://threejs.org/docs/#manual/en/introduction/Loading-3D-models\n// https://threejs.org/examples/#webgl_loader_gltf\n// https://gist.github.com/bellbind/c4f8c502fcacbe29422e5ac315273858\n// https://github.com/funwithtriangles/blender-to-threejs-export-guide/blob/master/readme.md\n// https://threejsfundamentals.org/threejs/lessons/threejs-load-gltf.html\n// https://discoverthreejs.com/book/first-steps/load-models/\n// https://www.pentacreation.com/blog/2019/09/190916.html\n// https://www.pentacreation.com/blog/2019/10/191016.html\n// https://docs.blender.org/manual/ja/latest/addons/io_scene_gltf2.html\n// https://gltf-viewer.donmccurdy.com/\n// https://github.com/donmccurdy/three-gltf-viewer\n// import { Raf } from '../lib/raf/raf';\nclass ThreeObjectViewer5 {\n  constructor() {\n    console.log('ThreeJS Object Viewer Demo');\n    this.parentElement = document.getElementById('parent');\n    this.canvasContainer = document.getElementById('canvas-container');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.rafProgress = new _rafProgress.RafProgress();\n    this.rafProgress.watch(this.onProgressUpdate.bind(this));\n    this.scrollLerp = 0.38;\n    this.scrollEase = 'easeInQuad';\n    this.rendererConfig = {\n      clearColor: '#FFFFFF',\n      backgroundAlpha: 1.0\n    };\n    this.gui = new _datguif.Datguif({\n      load: JSON\n    });\n    this.gui.addFolder('Settings').open();\n    this.gui.addFolder('Renderer', 'Settings');\n    this.gui.addFolder('Camera', 'Settings');\n    this.gui.addFolder('Scroll', 'Settings');\n    this.gui.addFolder('Lights');\n    this.gui.addFolder('Objects');\n    this.gui.addObjectToFolder('Scroll', this, [{\n      keyName: 'scrollLerp',\n      min: 0,\n      max: 1,\n      step: 0.01\n    }, {\n      keyName: 'scrollEase',\n      options: ['linear', 'easeOutQuad', 'easeInQuad']\n    }]);\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight); //   this.rafProgress.easeTo(this.progress, 0.26, EASE.easeInOutExpo);\n        //   this.rafProgress.easeTo(this.progress, 0.08, EASE.linear);\n\n        this.rafProgress.easeTo(this.progress, this.scrollLerp, _ease.EASE[this.scrollEase]);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.scene = new THREE.Scene();\n    this.gui.onUpdate(prop => {\n      this.draw();\n    });\n    var loader = new _GLTFLoader.GLTFLoader();\n    const path = './public/home/demo.gltf';\n    loader.load(path, gltf => {\n      const gltfData = gltf.parser.json;\n\n      const getNodeByName = name => {\n        return gltfData.nodes.filter(node => {\n          return node.name = name;\n        })[0];\n      };\n\n      console.log('gltf data', gltfData);\n      this.clock = new THREE.Clock();\n      const scene = gltf.scenes[0];\n      this.activeScene = scene;\n      this.animations = gltf.animations; // Animation Mixer\n\n      this.mixer = new THREE.AnimationMixer(scene); //Animation Clip\n\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i]; //Animation Action\n\n        var action = this.mixer.clipAction(animation);\n        console.log('added', animation);\n        action.play();\n      }\n\n      this.scene.add(scene);\n      console.log('scene', scene);\n      console.log('mixer', this.mixer); // http://learningthreejs.com/blog/2012/01/20/casting-shadows/\n\n      this.scene.traverse(child => {\n        if (child instanceof THREE.Light) {\n          // child.castShadow = false;\n          // console.log('light', child);\n          const shadowEnabledLights = ['Point013_Orientation', 'Point003_Orientation'];\n\n          if (~shadowEnabledLights.indexOf(child.name)) {\n            child.castShadow = true;\n          } // Debugging light positions.\n          // child.shadowCameraVisible = false;\n\n\n          if (child.shadow) {} // Adjust shadow bias.\n          // child.shadow.bias = -0.002;\n          // Remove the rigged looking shadows.\n          // child.shadow.mapSize.width = 1024;\n          // child.shadow.mapSize.height = 1024;\n          // child.shadowDarkness = 0.5;\n          // child.shadow.camera.near = 0;\n          // child.shadow.camera.far = 1000;\n          // var helper = new THREE.CameraHelper( child.shadow.camera );\n          // scene.add( helper );\n          // Point lights are defined in watts which goes waay off in three.js\n\n\n          if (child instanceof THREE.PointLight) {\n            child.intensity = child.intensity * 0.01;\n          } // If it's a spot light, it needs to go down even more.\n\n\n          if (child.type == \"SpotLight\") {\n            child.intensity = child.intensity * 0.001;\n          } // No lights.\n\n\n          child.intensity = 0;\n          this.gui.addFolder(child.name, 'Lights');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'intensity',\n            min: 0,\n            max: 3000\n          }, {\n            keyName: 'color'\n          }]);\n\n          if (child.shadow) {\n            const shadowFolderId = child.name + ' shadow'; // console.log(child.shadow);\n\n            this.gui.addFolder(shadowFolderId, child.name);\n            this.gui.addObjectToFolder(shadowFolderId, child.shadow, [{\n              keyName: 'bias',\n              min: -1,\n              max: 1,\n              step: 0.00001\n            }, {\n              keyName: 'radius',\n              min: 0,\n              max: 100,\n              step: 0.01\n            }]);\n          }\n        } else if (child instanceof THREE.Mesh) {\n          // child.castShadow = true;\n          // child.receiveShadow = true;\n          // child.geometry.computeVertexNormals(true);\n          console.log('mesh', child);\n          this.gui.addFolder(child.name, 'Objects');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'receiveShadow'\n          }]);\n\n          if (child.material) {\n            const materialId = child.name + ' material';\n            this.gui.addFolder(materialId, child.name);\n            this.gui.addObjectToFolder(materialId, child.material, [{\n              keyName: 'emissiveIntensity',\n              min: 0,\n              max: 1\n            }, {\n              keyName: 'flatShading',\n              callback: () => {\n                child.material.needsUpdate = true;\n              }\n            }, {\n              keyName: 'wireframe',\n              callback: () => {\n                child.material.needsUpdate = true;\n              }\n            }]); // Enable smooth shading.\n            // child.material.flatShading = false;\n            // child.material.wireframe = false;\n            // child.material.needsUpdate = true;\n            // child.geometry.computeFaceNormals();\n            // child.geometry.computeVertexNormals(true);\n          } // Get the image mappings.\n          // if(child.material && child.material.map) {\n          //   child.material.map.needsUpdate = true;\n          // }\n\n        } else {\n          console.log('other', child);\n        }\n      }); // Set the camera exported in gltf.\n      // Requires camera to be exported for gltf.\n\n      this.camera = gltf.cameras[0];\n      console.log('camera', this.camera);\n      this.resize(); // Use fog to cover far distances.\n\n      const color = 0xFFFFFF;\n      this.scene.fog = new THREE.Fog(color, 20, 24); // Enable shadows.\n      // https://threejs.org/docs/#api/en/constants/Renderer\n      // this.renderer.shadowMap.enabled = true;\n      // To antialias the shadow\n      // this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n      this.renderer.gammaOutput = true;\n      this.renderer.gammaFactor = 2.2; // Important to get the correct colors.\n      // this.renderer.physicallyCorrectLights = true;\n      // Background as black.\n      // this.renderer.setClearColor(0x4287f5);\n\n      this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha); // Affects how strongly lights come exposed.\n      // https://threejs.org/examples/#webgl_tonemapping\n\n      this.renderer.toneMappingExposure = 1.7; // this.renderer.toneMappingExposure = 0.6;\n      // this.renderer.toneMapping = THREE.ACESFilmicToneMapping;\n\n      this.gui.addObjectToFolder('Renderer', this.renderer, [{\n        keyName: 'toneMappingExposure',\n        min: 0,\n        max: 5,\n        step: 0.01\n      }]);\n      this.gui.addObjectToFolder('Renderer', this.rendererConfig, [{\n        keyName: 'clearColor',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }, {\n        keyName: 'backgroundAlpha',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }]);\n      this.gui.addObjectToFolder('Camera', this.camera, [{\n        keyName: 'fov',\n        min: 0,\n        max: 50,\n        step: 0.01,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }, {\n        keyName: 'zoom',\n        min: 0,\n        max: 10,\n        step: 0.0001,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }]);\n      this.gui.addFolder('General Lights');\n      this.generalLightConfig = {\n        ambientLightColor: '#FFFFFF',\n        ambientLightAlpha: 1\n      }; // Additional lighting outside the blender.\n      // var light = new THREE.HemisphereLight( 0xffffbb, 0xffffff, 1 );\n      // this.scene.add( light );\n\n      this.ambientLight = new THREE.AmbientLight(this.generalLightConfig.ambientLightColor);\n      this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n      scene.add(this.ambientLight);\n      this.gui.addObjectToFolder('General Lights', this.generalLightConfig, [{\n        keyName: 'ambientLightColor',\n        callback: () => {\n          this.ambientLight.color = new THREE.Color(this.generalLightConfig.ambientLightColor);\n        }\n      }, {\n        keyName: 'ambientLightAlpha',\n        callback: () => {\n          this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n        }\n      }]); // var width = 50;\n      // var height = 50;\n      // var intensity = 0;\n      // var rectLight = new THREE.RectAreaLight('#FFFFFF', intensity,  width, height );\n      // rectLight.position.set( 0, 0, 25 );\n      // // rectLight.lookAt( 0, 0, 0 );\n      // this.scene.add( rectLight );\n      // rectLightHelper = new THREE.RectAreaLightHelper( rectLight );\n      // rectLight.add( rectLightHelper );\n\n      this.gui.addButton('Refresh', this.refresh.bind(this));\n    }, undefined, error => {\n      console.error(error);\n    });\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      // precision: 'highp'\n      autoSize: true\n    });\n    this.composer = new _EffectComposer.EffectComposer(this.renderer);\n    this.canvasContainer.appendChild(this.renderer.domElement);\n    window.addEventListener('resize', this.resize.bind(this), false);\n  }\n\n  resize() {\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.width = this.canvasContainer.parentElement.offsetWidth;\n    this.height = this.canvasContainer.parentElement.offsetHeight; // https://github.com/donmccurdy/three-gltf-viewer/blob/master/src/viewer.js\n    // https://threejs.org/docs/#api/en/constants/Renderer\n\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n    this.renderer.setSize(this.width, this.height); // Post processing\n    // this.composer.setSize( this.width, this.height);\n    // const fxaaPass = new ShaderPass( FXAAShader );\n    // fxaaPass.material.uniforms[ 'resolution' ].value.x = 1 / ( this.width * window.devicePixelRatio);\n    // fxaaPass.material.uniforms[ 'resolution' ].value.y = 1 / ( this.height * window.devicePixelRatio);\n    // this.composer.addPass(fxaaPass);\n    // this.composer.addPass(new RenderPass(this.scene, this.camera));\n    // var bloomPass = new UnrealBloomPass(1, 25, 5, 256);\n    // this.composer.addPass(bloomPass);\n    // The camera aspect goes off since it could be exported at a different\n    // ratio.  Force update the aspect ratio.\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n  }\n\n  refresh() {\n    this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n    this.resize();\n    this.draw();\n  }\n\n  getAnimationByName(name) {\n    return this.animations.filter(animationClip => {\n      return animationClip.name == name;\n    })[0];\n  }\n\n  getObjectByName(name) {\n    return this.activeScene.children.filter(object3d => {\n      return object3d.name == name;\n    })[0];\n  }\n\n  onProgressUpdate(progress) {\n    //Animation Mixer\n    if (this.mixer) {\n      // We need to find out how long the animation is.\n      // The mixer appears to have no knowledge oft this so we need to\n      // look up a specific animation and get the duration to\n      // get the total duration of the animation.\n      const cameraAnimation = this.getAnimationByName('Action.001');\n      const duration = cameraAnimation.duration; // When duration hits it's max, animationMixer seems to hit the first\n      // frame so next allow it to reach the max value.\n\n      this.mixer.setTime(Math.min(duration * progress, duration - 0.001));\n    }\n\n    this.draw(); // this.renderer.render(this.scene, this.camera);\n    // this.composer.render();\n  }\n\n  draw() {\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = ThreeObjectViewer5;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1vYmplY3Qtdmlld2VyNS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3RocmVlLW9iamVjdC12aWV3ZXI1LmpzPzI5N2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZGF0Z3VpZiA9IHJlcXVpcmUoXCIuLi9saWIvZGF0Z3VpZi9kYXRndWlmXCIpO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX0dMVEZMb2FkZXIgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvR0xURkxvYWRlclwiKTtcblxudmFyIF9FZmZlY3RDb21wb3NlciA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvRWZmZWN0Q29tcG9zZXJcIik7XG5cbnZhciBfUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvUmVuZGVyUGFzcy5qc1wiKTtcblxudmFyIF9VbnJlYWxCbG9vbVBhc3MgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL1VucmVhbEJsb29tUGFzcy5qc1wiKTtcblxudmFyIF9GWEFBU2hhZGVyID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9zaGFkZXJzL0ZYQUFTaGFkZXIuanNcIik7XG5cbnZhciBfU2hhZGVyUGFzcyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvU2hhZGVyUGFzcy5qc1wiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWYtcHJvZ3Jlc3NcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tXCIpO1xuXG52YXIgX2Vhc2UgPSByZXF1aXJlKFwiLi4vbGliL2Vhc2UvZWFzZVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vLyBodHRwczovL3RocmVlanMub3JnL2RvY3MvI21hbnVhbC9lbi9pbnRyb2R1Y3Rpb24vTG9hZGluZy0zRC1tb2RlbHNcbi8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZXhhbXBsZXMvI3dlYmdsX2xvYWRlcl9nbHRmXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9iZWxsYmluZC9jNGY4YzUwMmZjYWNiZTI5NDIyZTVhYzMxNTI3Mzg1OFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bndpdGh0cmlhbmdsZXMvYmxlbmRlci10by10aHJlZWpzLWV4cG9ydC1ndWlkZS9ibG9iL21hc3Rlci9yZWFkbWUubWRcbi8vIGh0dHBzOi8vdGhyZWVqc2Z1bmRhbWVudGFscy5vcmcvdGhyZWVqcy9sZXNzb25zL3RocmVlanMtbG9hZC1nbHRmLmh0bWxcbi8vIGh0dHBzOi8vZGlzY292ZXJ0aHJlZWpzLmNvbS9ib29rL2ZpcnN0LXN0ZXBzL2xvYWQtbW9kZWxzL1xuLy8gaHR0cHM6Ly93d3cucGVudGFjcmVhdGlvbi5jb20vYmxvZy8yMDE5LzA5LzE5MDkxNi5odG1sXG4vLyBodHRwczovL3d3dy5wZW50YWNyZWF0aW9uLmNvbS9ibG9nLzIwMTkvMTAvMTkxMDE2Lmh0bWxcbi8vIGh0dHBzOi8vZG9jcy5ibGVuZGVyLm9yZy9tYW51YWwvamEvbGF0ZXN0L2FkZG9ucy9pb19zY2VuZV9nbHRmMi5odG1sXG4vLyBodHRwczovL2dsdGYtdmlld2VyLmRvbm1jY3VyZHkuY29tL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rvbm1jY3VyZHkvdGhyZWUtZ2x0Zi12aWV3ZXJcbi8vIGltcG9ydCB7IFJhZiB9IGZyb20gJy4uL2xpYi9yYWYvcmFmJztcbmNsYXNzIFRocmVlT2JqZWN0Vmlld2VyNSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdUaHJlZUpTIE9iamVjdCBWaWV3ZXIgRGVtbycpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJlbnQnKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMtY29udGFpbmVyJyk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcygpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3Mud2F0Y2godGhpcy5vblByb2dyZXNzVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc2Nyb2xsTGVycCA9IDAuMzg7XG4gICAgdGhpcy5zY3JvbGxFYXNlID0gJ2Vhc2VJblF1YWQnO1xuICAgIHRoaXMucmVuZGVyZXJDb25maWcgPSB7XG4gICAgICBjbGVhckNvbG9yOiAnI0ZGRkZGRicsXG4gICAgICBiYWNrZ3JvdW5kQWxwaGE6IDEuMFxuICAgIH07XG4gICAgdGhpcy5ndWkgPSBuZXcgX2RhdGd1aWYuRGF0Z3VpZih7XG4gICAgICBsb2FkOiBKU09OXG4gICAgfSk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdTZXR0aW5ncycpLm9wZW4oKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ1JlbmRlcmVyJywgJ1NldHRpbmdzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdDYW1lcmEnLCAnU2V0dGluZ3MnKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ1Njcm9sbCcsICdTZXR0aW5ncycpO1xuICAgIHRoaXMuZ3VpLmFkZEZvbGRlcignTGlnaHRzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdPYmplY3RzJyk7XG4gICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoJ1Njcm9sbCcsIHRoaXMsIFt7XG4gICAgICBrZXlOYW1lOiAnc2Nyb2xsTGVycCcsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEsXG4gICAgICBzdGVwOiAwLjAxXG4gICAgfSwge1xuICAgICAga2V5TmFtZTogJ3Njcm9sbEVhc2UnLFxuICAgICAgb3B0aW9uczogWydsaW5lYXInLCAnZWFzZU91dFF1YWQnLCAnZWFzZUluUXVhZCddXG4gICAgfV0pO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdzY3JvbGwnLFxuICAgICAgY2FsbGJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50LCB3aW5kb3cuaW5uZXJIZWlnaHQpOyAvLyAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDAuMjYsIEVBU0UuZWFzZUluT3V0RXhwbyk7XG4gICAgICAgIC8vICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMC4wOCwgRUFTRS5saW5lYXIpO1xuXG4gICAgICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIHRoaXMuc2Nyb2xsTGVycCwgX2Vhc2UuRUFTRVt0aGlzLnNjcm9sbEVhc2VdKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICB0aGlzLmd1aS5vblVwZGF0ZShwcm9wID0+IHtcbiAgICAgIHRoaXMuZHJhdygpO1xuICAgIH0pO1xuICAgIHZhciBsb2FkZXIgPSBuZXcgX0dMVEZMb2FkZXIuR0xURkxvYWRlcigpO1xuICAgIGNvbnN0IHBhdGggPSAnLi9wdWJsaWMvaG9tZS9kZW1vLmdsdGYnO1xuICAgIGxvYWRlci5sb2FkKHBhdGgsIGdsdGYgPT4ge1xuICAgICAgY29uc3QgZ2x0ZkRhdGEgPSBnbHRmLnBhcnNlci5qc29uO1xuXG4gICAgICBjb25zdCBnZXROb2RlQnlOYW1lID0gbmFtZSA9PiB7XG4gICAgICAgIHJldHVybiBnbHRmRGF0YS5ub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgICAgIH0pWzBdO1xuICAgICAgfTtcblxuICAgICAgY29uc29sZS5sb2coJ2dsdGYgZGF0YScsIGdsdGZEYXRhKTtcbiAgICAgIHRoaXMuY2xvY2sgPSBuZXcgVEhSRUUuQ2xvY2soKTtcbiAgICAgIGNvbnN0IHNjZW5lID0gZ2x0Zi5zY2VuZXNbMF07XG4gICAgICB0aGlzLmFjdGl2ZVNjZW5lID0gc2NlbmU7XG4gICAgICB0aGlzLmFuaW1hdGlvbnMgPSBnbHRmLmFuaW1hdGlvbnM7IC8vIEFuaW1hdGlvbiBNaXhlcuOCpOODs+OCueOCv+ODs+OCueOCkueUn+aIkFxuXG4gICAgICB0aGlzLm1peGVyID0gbmV3IFRIUkVFLkFuaW1hdGlvbk1peGVyKHNjZW5lKTsgLy/lhajjgabjga5BbmltYXRpb24gQ2xpcOOBq+WvvuOBl+OBplxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zW2ldOyAvL0FuaW1hdGlvbiBBY3Rpb27jgpLnlJ/miJBcblxuICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5taXhlci5jbGlwQWN0aW9uKGFuaW1hdGlvbik7XG4gICAgICAgIGNvbnNvbGUubG9nKCdhZGRlZCcsIGFuaW1hdGlvbik7XG4gICAgICAgIGFjdGlvbi5wbGF5KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2NlbmUuYWRkKHNjZW5lKTtcbiAgICAgIGNvbnNvbGUubG9nKCdzY2VuZScsIHNjZW5lKTtcbiAgICAgIGNvbnNvbGUubG9nKCdtaXhlcicsIHRoaXMubWl4ZXIpOyAvLyBodHRwOi8vbGVhcm5pbmd0aHJlZWpzLmNvbS9ibG9nLzIwMTIvMDEvMjAvY2FzdGluZy1zaGFkb3dzL1xuXG4gICAgICB0aGlzLnNjZW5lLnRyYXZlcnNlKGNoaWxkID0+IHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTGlnaHQpIHtcbiAgICAgICAgICAvLyBjaGlsZC5jYXN0U2hhZG93ID0gZmFsc2U7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2xpZ2h0JywgY2hpbGQpO1xuICAgICAgICAgIGNvbnN0IHNoYWRvd0VuYWJsZWRMaWdodHMgPSBbJ1BvaW50MDEzX09yaWVudGF0aW9uJywgJ1BvaW50MDAzX09yaWVudGF0aW9uJ107XG5cbiAgICAgICAgICBpZiAofnNoYWRvd0VuYWJsZWRMaWdodHMuaW5kZXhPZihjaGlsZC5uYW1lKSkge1xuICAgICAgICAgICAgY2hpbGQuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgICAgfSAvLyBEZWJ1Z2dpbmcgbGlnaHQgcG9zaXRpb25zLlxuICAgICAgICAgIC8vIGNoaWxkLnNoYWRvd0NhbWVyYVZpc2libGUgPSBmYWxzZTtcblxuXG4gICAgICAgICAgaWYgKGNoaWxkLnNoYWRvdykge30gLy8gQWRqdXN0IHNoYWRvdyBiaWFzLlxuICAgICAgICAgIC8vIGNoaWxkLnNoYWRvdy5iaWFzID0gLTAuMDAyO1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgcmlnZ2VkIGxvb2tpbmcgc2hhZG93cy5cbiAgICAgICAgICAvLyBjaGlsZC5zaGFkb3cubWFwU2l6ZS53aWR0aCA9IDEwMjQ7XG4gICAgICAgICAgLy8gY2hpbGQuc2hhZG93Lm1hcFNpemUuaGVpZ2h0ID0gMTAyNDtcbiAgICAgICAgICAvLyBjaGlsZC5zaGFkb3dEYXJrbmVzcyA9IDAuNTtcbiAgICAgICAgICAvLyBjaGlsZC5zaGFkb3cuY2FtZXJhLm5lYXIgPSAwO1xuICAgICAgICAgIC8vIGNoaWxkLnNoYWRvdy5jYW1lcmEuZmFyID0gMTAwMDtcbiAgICAgICAgICAvLyB2YXIgaGVscGVyID0gbmV3IFRIUkVFLkNhbWVyYUhlbHBlciggY2hpbGQuc2hhZG93LmNhbWVyYSApO1xuICAgICAgICAgIC8vIHNjZW5lLmFkZCggaGVscGVyICk7XG4gICAgICAgICAgLy8gUG9pbnQgbGlnaHRzIGFyZSBkZWZpbmVkIGluIHdhdHRzIHdoaWNoIGdvZXMgd2FheSBvZmYgaW4gdGhyZWUuanNcblxuXG4gICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCkge1xuICAgICAgICAgICAgY2hpbGQuaW50ZW5zaXR5ID0gY2hpbGQuaW50ZW5zaXR5ICogMC4wMTtcbiAgICAgICAgICB9IC8vIElmIGl0J3MgYSBzcG90IGxpZ2h0LCBpdCBuZWVkcyB0byBnbyBkb3duIGV2ZW4gbW9yZS5cblxuXG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT0gXCJTcG90TGlnaHRcIikge1xuICAgICAgICAgICAgY2hpbGQuaW50ZW5zaXR5ID0gY2hpbGQuaW50ZW5zaXR5ICogMC4wMDE7XG4gICAgICAgICAgfSAvLyBObyBsaWdodHMuXG5cblxuICAgICAgICAgIGNoaWxkLmludGVuc2l0eSA9IDA7XG4gICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKGNoaWxkLm5hbWUsICdMaWdodHMnKTtcbiAgICAgICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcihjaGlsZC5uYW1lLCBjaGlsZCwgW3tcbiAgICAgICAgICAgIGtleU5hbWU6ICdjYXN0U2hhZG93J1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleU5hbWU6ICdpbnRlbnNpdHknLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAzMDAwXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5TmFtZTogJ2NvbG9yJ1xuICAgICAgICAgIH1dKTtcblxuICAgICAgICAgIGlmIChjaGlsZC5zaGFkb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd0ZvbGRlcklkID0gY2hpbGQubmFtZSArICcgc2hhZG93JzsgLy8gY29uc29sZS5sb2coY2hpbGQuc2hhZG93KTtcblxuICAgICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKHNoYWRvd0ZvbGRlcklkLCBjaGlsZC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKHNoYWRvd0ZvbGRlcklkLCBjaGlsZC5zaGFkb3csIFt7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdiaWFzJyxcbiAgICAgICAgICAgICAgbWluOiAtMSxcbiAgICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgICAgICBzdGVwOiAwLjAwMDAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdyYWRpdXMnLFxuICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgIG1heDogMTAwLFxuICAgICAgICAgICAgICBzdGVwOiAwLjAxXG4gICAgICAgICAgICB9XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICAgIC8vIGNoaWxkLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIC8vIGNoaWxkLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIC8vIGNoaWxkLmdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKHRydWUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdtZXNoJywgY2hpbGQpO1xuICAgICAgICAgIHRoaXMuZ3VpLmFkZEZvbGRlcihjaGlsZC5uYW1lLCAnT2JqZWN0cycpO1xuICAgICAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKGNoaWxkLm5hbWUsIGNoaWxkLCBbe1xuICAgICAgICAgICAga2V5TmFtZTogJ2Nhc3RTaGFkb3cnXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5TmFtZTogJ3JlY2VpdmVTaGFkb3cnXG4gICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgaWYgKGNoaWxkLm1hdGVyaWFsKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRlcmlhbElkID0gY2hpbGQubmFtZSArICcgbWF0ZXJpYWwnO1xuICAgICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKG1hdGVyaWFsSWQsIGNoaWxkLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIobWF0ZXJpYWxJZCwgY2hpbGQubWF0ZXJpYWwsIFt7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdlbWlzc2l2ZUludGVuc2l0eScsXG4gICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgbWF4OiAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdmbGF0U2hhZGluZycsXG4gICAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICd3aXJlZnJhbWUnLFxuICAgICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pOyAvLyBFbmFibGUgc21vb3RoIHNoYWRpbmcuXG4gICAgICAgICAgICAvLyBjaGlsZC5tYXRlcmlhbC5mbGF0U2hhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gY2hpbGQubWF0ZXJpYWwud2lyZWZyYW1lID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBjaGlsZC5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAvLyBjaGlsZC5nZW9tZXRyeS5jb21wdXRlRmFjZU5vcm1hbHMoKTtcbiAgICAgICAgICAgIC8vIGNoaWxkLmdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKHRydWUpO1xuICAgICAgICAgIH0gLy8gR2V0IHRoZSBpbWFnZSBtYXBwaW5ncy5cbiAgICAgICAgICAvLyBpZihjaGlsZC5tYXRlcmlhbCAmJiBjaGlsZC5tYXRlcmlhbC5tYXApIHtcbiAgICAgICAgICAvLyAgIGNoaWxkLm1hdGVyaWFsLm1hcC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ290aGVyJywgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gU2V0IHRoZSBjYW1lcmEgZXhwb3J0ZWQgaW4gZ2x0Zi5cbiAgICAgIC8vIFJlcXVpcmVzIGNhbWVyYSB0byBiZSBleHBvcnRlZCBmb3IgZ2x0Zi5cblxuICAgICAgdGhpcy5jYW1lcmEgPSBnbHRmLmNhbWVyYXNbMF07XG4gICAgICBjb25zb2xlLmxvZygnY2FtZXJhJywgdGhpcy5jYW1lcmEpO1xuICAgICAgdGhpcy5yZXNpemUoKTsgLy8gVXNlIGZvZyB0byBjb3ZlciBmYXIgZGlzdGFuY2VzLlxuXG4gICAgICBjb25zdCBjb2xvciA9IDB4RkZGRkZGO1xuICAgICAgdGhpcy5zY2VuZS5mb2cgPSBuZXcgVEhSRUUuRm9nKGNvbG9yLCAyMCwgMjQpOyAvLyBFbmFibGUgc2hhZG93cy5cbiAgICAgIC8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL2NvbnN0YW50cy9SZW5kZXJlclxuICAgICAgLy8gdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCA9IHRydWU7XG4gICAgICAvLyBUbyBhbnRpYWxpYXMgdGhlIHNoYWRvd1xuICAgICAgLy8gdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG5cbiAgICAgIHRoaXMucmVuZGVyZXIuZ2FtbWFPdXRwdXQgPSB0cnVlO1xuICAgICAgdGhpcy5yZW5kZXJlci5nYW1tYUZhY3RvciA9IDIuMjsgLy8gSW1wb3J0YW50IHRvIGdldCB0aGUgY29ycmVjdCBjb2xvcnMuXG4gICAgICAvLyB0aGlzLnJlbmRlcmVyLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzID0gdHJ1ZTtcbiAgICAgIC8vIEJhY2tncm91bmQgYXMgYmxhY2suXG4gICAgICAvLyB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHg0Mjg3ZjUpO1xuXG4gICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5yZW5kZXJlckNvbmZpZy5jbGVhckNvbG9yLCB0aGlzLnJlbmRlcmVyQ29uZmlnLmJhY2tncm91bmRBbHBoYSk7IC8vIEFmZmVjdHMgaG93IHN0cm9uZ2x5IGxpZ2h0cyBjb21lIGV4cG9zZWQuXG4gICAgICAvLyBodHRwczovL3RocmVlanMub3JnL2V4YW1wbGVzLyN3ZWJnbF90b25lbWFwcGluZ1xuXG4gICAgICB0aGlzLnJlbmRlcmVyLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAxLjc7IC8vIHRoaXMucmVuZGVyZXIudG9uZU1hcHBpbmdFeHBvc3VyZSA9IDAuNjtcbiAgICAgIC8vIHRoaXMucmVuZGVyZXIudG9uZU1hcHBpbmcgPSBUSFJFRS5BQ0VTRmlsbWljVG9uZU1hcHBpbmc7XG5cbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdSZW5kZXJlcicsIHRoaXMucmVuZGVyZXIsIFt7XG4gICAgICAgIGtleU5hbWU6ICd0b25lTWFwcGluZ0V4cG9zdXJlJyxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDUsXG4gICAgICAgIHN0ZXA6IDAuMDFcbiAgICAgIH1dKTtcbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdSZW5kZXJlcicsIHRoaXMucmVuZGVyZXJDb25maWcsIFt7XG4gICAgICAgIGtleU5hbWU6ICdjbGVhckNvbG9yJyxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5yZW5kZXJlckNvbmZpZy5jbGVhckNvbG9yLCB0aGlzLnJlbmRlcmVyQ29uZmlnLmJhY2tncm91bmRBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5TmFtZTogJ2JhY2tncm91bmRBbHBoYScsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMucmVuZGVyZXJDb25maWcuY2xlYXJDb2xvciwgdGhpcy5yZW5kZXJlckNvbmZpZy5iYWNrZ3JvdW5kQWxwaGEpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcignQ2FtZXJhJywgdGhpcy5jYW1lcmEsIFt7XG4gICAgICAgIGtleU5hbWU6ICdmb3YnLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogNTAsXG4gICAgICAgIHN0ZXA6IDAuMDEsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleU5hbWU6ICd6b29tJyxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDEwLFxuICAgICAgICBzdGVwOiAwLjAwMDEsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ0dlbmVyYWwgTGlnaHRzJyk7XG4gICAgICB0aGlzLmdlbmVyYWxMaWdodENvbmZpZyA9IHtcbiAgICAgICAgYW1iaWVudExpZ2h0Q29sb3I6ICcjRkZGRkZGJyxcbiAgICAgICAgYW1iaWVudExpZ2h0QWxwaGE6IDFcbiAgICAgIH07IC8vIEFkZGl0aW9uYWwgbGlnaHRpbmcgb3V0c2lkZSB0aGUgYmxlbmRlci5cbiAgICAgIC8vIHZhciBsaWdodCA9IG5ldyBUSFJFRS5IZW1pc3BoZXJlTGlnaHQoIDB4ZmZmZmJiLCAweGZmZmZmZiwgMSApO1xuICAgICAgLy8gdGhpcy5zY2VuZS5hZGQoIGxpZ2h0ICk7XG5cbiAgICAgIHRoaXMuYW1iaWVudExpZ2h0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCh0aGlzLmdlbmVyYWxMaWdodENvbmZpZy5hbWJpZW50TGlnaHRDb2xvcik7XG4gICAgICB0aGlzLmFtYmllbnRMaWdodC5pbnRlbnNpdHkgPSB0aGlzLmdlbmVyYWxMaWdodENvbmZpZy5hbWJpZW50TGlnaHRBbHBoYTtcbiAgICAgIHNjZW5lLmFkZCh0aGlzLmFtYmllbnRMaWdodCk7XG4gICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcignR2VuZXJhbCBMaWdodHMnLCB0aGlzLmdlbmVyYWxMaWdodENvbmZpZywgW3tcbiAgICAgICAga2V5TmFtZTogJ2FtYmllbnRMaWdodENvbG9yJyxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFtYmllbnRMaWdodC5jb2xvciA9IG5ldyBUSFJFRS5Db2xvcih0aGlzLmdlbmVyYWxMaWdodENvbmZpZy5hbWJpZW50TGlnaHRDb2xvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5TmFtZTogJ2FtYmllbnRMaWdodEFscGhhJyxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFtYmllbnRMaWdodC5pbnRlbnNpdHkgPSB0aGlzLmdlbmVyYWxMaWdodENvbmZpZy5hbWJpZW50TGlnaHRBbHBoYTtcbiAgICAgICAgfVxuICAgICAgfV0pOyAvLyB2YXIgd2lkdGggPSA1MDtcbiAgICAgIC8vIHZhciBoZWlnaHQgPSA1MDtcbiAgICAgIC8vIHZhciBpbnRlbnNpdHkgPSAwO1xuICAgICAgLy8gdmFyIHJlY3RMaWdodCA9IG5ldyBUSFJFRS5SZWN0QXJlYUxpZ2h0KCcjRkZGRkZGJywgaW50ZW5zaXR5LCAgd2lkdGgsIGhlaWdodCApO1xuICAgICAgLy8gcmVjdExpZ2h0LnBvc2l0aW9uLnNldCggMCwgMCwgMjUgKTtcbiAgICAgIC8vIC8vIHJlY3RMaWdodC5sb29rQXQoIDAsIDAsIDAgKTtcbiAgICAgIC8vIHRoaXMuc2NlbmUuYWRkKCByZWN0TGlnaHQgKTtcbiAgICAgIC8vIHJlY3RMaWdodEhlbHBlciA9IG5ldyBUSFJFRS5SZWN0QXJlYUxpZ2h0SGVscGVyKCByZWN0TGlnaHQgKTtcbiAgICAgIC8vIHJlY3RMaWdodC5hZGQoIHJlY3RMaWdodEhlbHBlciApO1xuXG4gICAgICB0aGlzLmd1aS5hZGRCdXR0b24oJ1JlZnJlc2gnLCB0aGlzLnJlZnJlc2guYmluZCh0aGlzKSk7XG4gICAgfSwgdW5kZWZpbmVkLCBlcnJvciA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgLy8gcHJlY2lzaW9uOiAnaGlnaHAnXG4gICAgICBhdXRvU2l6ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29tcG9zZXIgPSBuZXcgX0VmZmVjdENvbXBvc2VyLkVmZmVjdENvbXBvc2VyKHRoaXMucmVuZGVyZXIpO1xuICAgIHRoaXMuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgfVxuXG4gIHJlc2l6ZSgpIHtcbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMSwgX2Vhc2UuRUFTRS5MaW5lYXIpO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhc0NvbnRhaW5lci5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXNDb250YWluZXIucGFyZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kb25tY2N1cmR5L3RocmVlLWdsdGYtdmlld2VyL2Jsb2IvbWFzdGVyL3NyYy92aWV3ZXIuanNcbiAgICAvLyBodHRwczovL3RocmVlanMub3JnL2RvY3MvI2FwaS9lbi9jb25zdGFudHMvUmVuZGVyZXJcblxuICAgIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTsgLy8gUG9zdCBwcm9jZXNzaW5nXG4gICAgLy8gdGhpcy5jb21wb3Nlci5zZXRTaXplKCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgLy8gY29uc3QgZnhhYVBhc3MgPSBuZXcgU2hhZGVyUGFzcyggRlhBQVNoYWRlciApO1xuICAgIC8vIGZ4YWFQYXNzLm1hdGVyaWFsLnVuaWZvcm1zWyAncmVzb2x1dGlvbicgXS52YWx1ZS54ID0gMSAvICggdGhpcy53aWR0aCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAvLyBmeGFhUGFzcy5tYXRlcmlhbC51bmlmb3Jtc1sgJ3Jlc29sdXRpb24nIF0udmFsdWUueSA9IDEgLyAoIHRoaXMuaGVpZ2h0ICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIC8vIHRoaXMuY29tcG9zZXIuYWRkUGFzcyhmeGFhUGFzcyk7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5hZGRQYXNzKG5ldyBSZW5kZXJQYXNzKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKSk7XG4gICAgLy8gdmFyIGJsb29tUGFzcyA9IG5ldyBVbnJlYWxCbG9vbVBhc3MoMSwgMjUsIDUsIDI1Nik7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5hZGRQYXNzKGJsb29tUGFzcyk7XG4gICAgLy8gVGhlIGNhbWVyYSBhc3BlY3QgZ29lcyBvZmYgc2luY2UgaXQgY291bGQgYmUgZXhwb3J0ZWQgYXQgYSBkaWZmZXJlbnRcbiAgICAvLyByYXRpby4gIEZvcmNlIHVwZGF0ZSB0aGUgYXNwZWN0IHJhdGlvLlxuXG4gICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMucmVuZGVyZXJDb25maWcuY2xlYXJDb2xvciwgdGhpcy5yZW5kZXJlckNvbmZpZy5iYWNrZ3JvdW5kQWxwaGEpO1xuICAgIHRoaXMucmVzaXplKCk7XG4gICAgdGhpcy5kcmF3KCk7XG4gIH1cblxuICBnZXRBbmltYXRpb25CeU5hbWUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnMuZmlsdGVyKGFuaW1hdGlvbkNsaXAgPT4ge1xuICAgICAgcmV0dXJuIGFuaW1hdGlvbkNsaXAubmFtZSA9PSBuYW1lO1xuICAgIH0pWzBdO1xuICB9XG5cbiAgZ2V0T2JqZWN0QnlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVTY2VuZS5jaGlsZHJlbi5maWx0ZXIob2JqZWN0M2QgPT4ge1xuICAgICAgcmV0dXJuIG9iamVjdDNkLm5hbWUgPT0gbmFtZTtcbiAgICB9KVswXTtcbiAgfVxuXG4gIG9uUHJvZ3Jlc3NVcGRhdGUocHJvZ3Jlc3MpIHtcbiAgICAvL0FuaW1hdGlvbiBNaXhlcuOCkuWun+ihjFxuICAgIGlmICh0aGlzLm1peGVyKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGZpbmQgb3V0IGhvdyBsb25nIHRoZSBhbmltYXRpb24gaXMuXG4gICAgICAvLyBUaGUgbWl4ZXIgYXBwZWFycyB0byBoYXZlIG5vIGtub3dsZWRnZSBvZnQgdGhpcyBzbyB3ZSBuZWVkIHRvXG4gICAgICAvLyBsb29rIHVwIGEgc3BlY2lmaWMgYW5pbWF0aW9uIGFuZCBnZXQgdGhlIGR1cmF0aW9uIHRvXG4gICAgICAvLyBnZXQgdGhlIHRvdGFsIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICBjb25zdCBjYW1lcmFBbmltYXRpb24gPSB0aGlzLmdldEFuaW1hdGlvbkJ5TmFtZSgnQWN0aW9uLjAwMScpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBjYW1lcmFBbmltYXRpb24uZHVyYXRpb247IC8vIFdoZW4gZHVyYXRpb24gaGl0cyBpdCdzIG1heCwgYW5pbWF0aW9uTWl4ZXIgc2VlbXMgdG8gaGl0IHRoZSBmaXJzdFxuICAgICAgLy8gZnJhbWUgc28gbmV4dCBhbGxvdyBpdCB0byByZWFjaCB0aGUgbWF4IHZhbHVlLlxuXG4gICAgICB0aGlzLm1peGVyLnNldFRpbWUoTWF0aC5taW4oZHVyYXRpb24gKiBwcm9ncmVzcywgZHVyYXRpb24gLSAwLjAwMSkpO1xuICAgIH1cblxuICAgIHRoaXMuZHJhdygpOyAvLyB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5yZW5kZXIoKTtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gVGhyZWVPYmplY3RWaWV3ZXI1OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/three-object-viewer5.js\n");

/***/ }),

/***/ "./examples/three-object-viewer6.js":
/*!******************************************!*\
  !*** ./examples/three-object-viewer6.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _datguif = __webpack_require__(/*! ../lib/datguif/datguif */ \"./lib/datguif/datguif.js\");\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _GLTFLoader = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\nvar _EffectComposer = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n\nvar _RenderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n\nvar _UnrealBloomPass = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass.js */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n\nvar _FXAAShader = __webpack_require__(/*! three/examples/jsm/shaders/FXAAShader.js */ \"./node_modules/three/examples/jsm/shaders/FXAAShader.js\");\n\nvar _ShaderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/ShaderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/ShaderPass.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n// https://threejs.org/docs/#manual/en/introduction/Loading-3D-models\n// https://threejs.org/examples/#webgl_loader_gltf\n// https://gist.github.com/bellbind/c4f8c502fcacbe29422e5ac315273858\n// https://github.com/funwithtriangles/blender-to-threejs-export-guide/blob/master/readme.md\n// https://threejsfundamentals.org/threejs/lessons/threejs-load-gltf.html\n// https://discoverthreejs.com/book/first-steps/load-models/\n// https://www.pentacreation.com/blog/2019/09/190916.html\n// https://www.pentacreation.com/blog/2019/10/191016.html\n// https://docs.blender.org/manual/ja/latest/addons/io_scene_gltf2.html\n// https://gltf-viewer.donmccurdy.com/\n// https://github.com/donmccurdy/three-gltf-viewer\n// import { Raf } from '../lib/raf/raf';\nclass ThreeObjectViewer6 {\n  constructor() {\n    console.log('ThreeJS Object Viewer Demo');\n    this.parentElement = document.getElementById('parent');\n    this.canvasContainer = document.getElementById('canvas-container');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.rafProgress = new _rafProgress.RafProgress();\n    this.rafProgress.watch(this.onProgressUpdate.bind(this));\n    this.scrollLerp = 0.38;\n    this.scrollEase = 'easeInQuad';\n    this.rendererConfig = {\n      clearColor: '#EAE8E7',\n      backgroundAlpha: 1.0\n    };\n    this.gui = new _datguif.Datguif({\n      load: JSON\n    });\n    this.gui.addFolder('Settings').open();\n    this.gui.addFolder('Renderer', 'Settings');\n    this.gui.addFolder('Camera', 'Settings');\n    this.gui.addFolder('Scroll', 'Settings');\n    this.gui.addFolder('Lights');\n    this.gui.addFolder('Objects');\n    this.gui.addObjectToFolder('Scroll', this, [{\n      keyName: 'scrollLerp',\n      min: 0,\n      max: 1,\n      step: 0.01\n    }, {\n      keyName: 'scrollEase',\n      options: ['linear', 'easeOutQuad', 'easeInQuad']\n    }]);\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight); //   this.rafProgress.easeTo(this.progress, 0.26, EASE.easeInOutExpo);\n        //   this.rafProgress.easeTo(this.progress, 0.08, EASE.linear);\n\n        this.rafProgress.easeTo(this.progress, this.scrollLerp, _ease.EASE[this.scrollEase]);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.scene = new THREE.Scene();\n    this.gui.onUpdate(prop => {\n      this.draw();\n    });\n    var loader = new _GLTFLoader.GLTFLoader();\n    const path = './public/home/demo5.gltf';\n    loader.load(path, gltf => {\n      const gltfData = gltf.parser.json;\n\n      const getNodeByName = name => {\n        return gltfData.nodes.filter(node => {\n          return node.name = name;\n        })[0];\n      };\n\n      console.log('gltf data', gltfData);\n      this.clock = new THREE.Clock();\n      const scene = gltf.scenes[0];\n      this.activeScene = scene;\n      this.animations = gltf.animations; // Animation Mixer\n\n      this.mixer = new THREE.AnimationMixer(scene); //Animation Clip\n\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i]; //Animation Action\n\n        var action = this.mixer.clipAction(animation);\n        console.log('added', animation);\n        action.play();\n      }\n\n      this.scene.add(scene);\n      console.log('scene', scene);\n      console.log('mixer', this.mixer); // http://learningthreejs.com/blog/2012/01/20/casting-shadows/\n\n      this.scene.traverse(child => {\n        if (child instanceof THREE.Light) {\n          // child.castShadow = false;\n          // console.log('light', child);\n          const shadowEnabledLights = ['Point013_Orientation', 'Point003_Orientation'];\n\n          if (~shadowEnabledLights.indexOf(child.name)) {\n            child.castShadow = true;\n          } // Debugging light positions.\n          // child.shadowCameraVisible = false;\n\n\n          if (child.shadow) {} // Adjust shadow bias.\n          // child.shadow.bias = -0.002;\n          // Remove the rigged looking shadows.\n          // child.shadow.mapSize.width = 1024;\n          // child.shadow.mapSize.height = 1024;\n          // child.shadowDarkness = 0.5;\n          // child.shadow.camera.near = 0;\n          // child.shadow.camera.far = 1000;\n          // var helper = new THREE.CameraHelper( child.shadow.camera );\n          // scene.add( helper );\n          // Point lights are defined in watts which goes waay off in three.js\n\n\n          if (child instanceof THREE.PointLight) {\n            child.intensity = child.intensity * 0.01;\n          } // If it's a spot light, it needs to go down even more.\n\n\n          if (child.type == \"SpotLight\") {\n            child.intensity = child.intensity * 0.001;\n          } // No lights.\n\n\n          child.intensity = 0;\n          this.gui.addFolder(child.name, 'Lights');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'intensity',\n            min: 0,\n            max: 3000\n          }, {\n            keyName: 'color'\n          }]);\n\n          if (child.shadow) {\n            const shadowFolderId = child.name + ' shadow'; // console.log(child.shadow);\n\n            this.gui.addFolder(shadowFolderId, child.name);\n            this.gui.addObjectToFolder(shadowFolderId, child.shadow, [{\n              keyName: 'bias',\n              min: -1,\n              max: 1,\n              step: 0.00001\n            }, {\n              keyName: 'radius',\n              min: 0,\n              max: 100,\n              step: 0.01\n            }]);\n          }\n        } else if (child instanceof THREE.Mesh) {\n          // child.castShadow = true;\n          // child.receiveShadow = true;\n          // child.geometry.computeVertexNormals(true);\n          console.log('mesh', child);\n          this.gui.addFolder(child.name, 'Objects');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'receiveShadow'\n          }]);\n\n          if (child.material) {\n            const materialId = child.name + ' material';\n            this.gui.addFolder(materialId, child.name);\n            this.gui.addObjectToFolder(materialId, child.material, [{\n              keyName: 'emissiveIntensity',\n              min: 0,\n              max: 1\n            }, {\n              keyName: 'flatShading',\n              callback: () => {\n                child.material.needsUpdate = true;\n              }\n            }, {\n              keyName: 'wireframe',\n              callback: () => {\n                child.material.needsUpdate = true;\n              }\n            }]); // Enable smooth shading.\n            // child.material.flatShading = false;\n            // child.material.wireframe = false;\n            // child.material.needsUpdate = true;\n            // child.geometry.computeFaceNormals();\n            // child.geometry.computeVertexNormals(true);\n          } // Get the image mappings.\n          // if(child.material && child.material.map) {\n          //   child.material.map.needsUpdate = true;\n          // }\n\n        } else {\n          console.log('other', child);\n        }\n      }); // Set the camera exported in gltf.\n      // Requires camera to be exported for gltf.\n\n      this.camera = gltf.cameras[0];\n      console.log('camera', this.camera);\n      this.resize(); // Use fog to cover far distances.\n\n      const color = 0xEAE8E7;\n      this.scene.fog = new THREE.Fog(color, 5, 10); // Enable shadows.\n      // https://threejs.org/docs/#api/en/constants/Renderer\n\n      this.renderer.shadowMap.enabled = true; // To antialias the shadow\n\n      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n      this.renderer.gammaOutput = true;\n      this.renderer.gammaFactor = 3; // Important to get the correct colors.\n      // this.renderer.physicallyCorrectLigts = true;\n      // Background as black.\n      // this.renderer.setClearColor(0x4287f5);\n\n      this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha); // Affects how strongly lights come exposed.\n      // https://threejs.org/examples/#webgl_tonemapping\n\n      this.renderer.toneMappingExposure = 1; // this.renderer.toneMappingExposure = 0.6;\n\n      this.renderer.toneMapping = THREE.ACESFilmicToneMapping;\n      this.gui.addObjectToFolder('Renderer', this.renderer, [{\n        keyName: 'toneMappingExposure',\n        min: 0,\n        max: 5,\n        step: 0.01\n      }, {\n        keyName: 'gammaFactor',\n        min: 0,\n        max: 10,\n        step: 0.01\n      }]);\n      this.gui.addObjectToFolder('Renderer', this.rendererConfig, [{\n        keyName: 'clearColor',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }, {\n        keyName: 'backgroundAlpha',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }]);\n      this.gui.addObjectToFolder('Camera', this.camera, [{\n        keyName: 'fov',\n        min: 0,\n        max: 50,\n        step: 0.01,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }, {\n        keyName: 'zoom',\n        min: 0,\n        max: 10,\n        step: 0.0001,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }]);\n      this.gui.addFolder('General Lights');\n      this.generalLightConfig = {\n        ambientLightColor: '#FFFFFF',\n        ambientLightAlpha: 0\n      }; // Additional lighting outside the blender.\n      // var light = new THREE.HemisphereLight( 0xffffbb, 0xffffff, 1 );\n      // this.scene.add( light );\n\n      this.ambientLight = new THREE.AmbientLight(this.generalLightConfig.ambientLightColor);\n      this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n      scene.add(this.ambientLight);\n      this.gui.addObjectToFolder('General Lights', this.generalLightConfig, [{\n        keyName: 'ambientLightColor',\n        callback: () => {\n          this.ambientLight.color = new THREE.Color(this.generalLightConfig.ambientLightColor);\n        }\n      }, {\n        keyName: 'ambientLightAlpha',\n        callback: () => {\n          this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n        }\n      }]); // var width = 50;\n      // var height = 50;\n      // var intensity = 0;\n      // var rectLight = new THREE.RectAreaLight('#FFFFFF', intensity,  width, height );\n      // rectLight.position.set( 0, 0, 25 );\n      // // rectLight.lookAt( 0, 0, 0 );\n      // this.scene.add( rectLight );\n      // rectLightHelper = new THREE.RectAreaLightHelper( rectLight );\n      // rectLight.add( rectLightHelper );\n\n      this.gui.addButton('Refresh', this.refresh.bind(this));\n    }, undefined, error => {\n      console.error(error);\n    });\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      // precision: 'highp'\n      autoSize: true\n    });\n    this.composer = new _EffectComposer.EffectComposer(this.renderer);\n    this.canvasContainer.appendChild(this.renderer.domElement);\n    window.addEventListener('resize', this.resize.bind(this), false);\n  }\n\n  resize() {\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.width = this.canvasContainer.parentElement.offsetWidth;\n    this.height = this.canvasContainer.parentElement.offsetHeight; // https://github.com/donmccurdy/three-gltf-viewer/blob/master/src/viewer.js\n    // https://threejs.org/docs/#api/en/constants/Renderer\n\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n    this.renderer.setSize(this.width, this.height); // Post processing\n    // this.composer.setSize( this.width, this.height);\n    // const fxaaPass = new ShaderPass( FXAAShader );\n    // fxaaPass.material.uniforms[ 'resolution' ].value.x = 1 / ( this.width * window.devicePixelRatio);\n    // fxaaPass.material.uniforms[ 'resolution' ].value.y = 1 / ( this.height * window.devicePixelRatio);\n    // this.composer.addPass(fxaaPass);\n    // this.composer.addPass(new RenderPass(this.scene, this.camera));\n    // var bloomPass = new UnrealBloomPass(1, 25, 5, 256);\n    // this.composer.addPass(bloomPass);\n    // The camera aspect goes off since it could be exported at a different\n    // ratio.  Force update the aspect ratio.\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n  }\n\n  refresh() {\n    this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n    this.resize();\n    this.draw();\n  }\n\n  getAnimationByName(name) {\n    return this.animations.filter(animationClip => {\n      return animationClip.name == name;\n    })[0];\n  }\n\n  getObjectByName(name) {\n    return this.activeScene.children.filter(object3d => {\n      return object3d.name == name;\n    })[0];\n  }\n\n  onProgressUpdate(progress) {\n    //Animation Mixer\n    if (this.mixer) {\n      // We need to find out how long the animation is.\n      // The mixer appears to have no knowledge oft this so we need to\n      // look up a specific animation and get the duration to\n      // get the total duration of the animation.\n      const cameraAnimation = this.getAnimationByName('Action.001');\n      const duration = cameraAnimation.duration; // When duration hits it's max, animationMixer seems to hit the first\n      // frame so next allow it to reach the max value.\n\n      this.mixer.setTime(Math.min(duration * progress, duration - 0.001));\n    }\n\n    this.draw(); // this.renderer.render(this.scene, this.camera);\n    // this.composer.render();\n  }\n\n  draw() {\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = ThreeObjectViewer6;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1vYmplY3Qtdmlld2VyNi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3RocmVlLW9iamVjdC12aWV3ZXI2LmpzP2MwMzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZGF0Z3VpZiA9IHJlcXVpcmUoXCIuLi9saWIvZGF0Z3VpZi9kYXRndWlmXCIpO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX0dMVEZMb2FkZXIgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvR0xURkxvYWRlclwiKTtcblxudmFyIF9FZmZlY3RDb21wb3NlciA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvRWZmZWN0Q29tcG9zZXJcIik7XG5cbnZhciBfUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvUmVuZGVyUGFzcy5qc1wiKTtcblxudmFyIF9VbnJlYWxCbG9vbVBhc3MgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL1VucmVhbEJsb29tUGFzcy5qc1wiKTtcblxudmFyIF9GWEFBU2hhZGVyID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9zaGFkZXJzL0ZYQUFTaGFkZXIuanNcIik7XG5cbnZhciBfU2hhZGVyUGFzcyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvU2hhZGVyUGFzcy5qc1wiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWYtcHJvZ3Jlc3NcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tXCIpO1xuXG52YXIgX2Vhc2UgPSByZXF1aXJlKFwiLi4vbGliL2Vhc2UvZWFzZVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vLyBodHRwczovL3RocmVlanMub3JnL2RvY3MvI21hbnVhbC9lbi9pbnRyb2R1Y3Rpb24vTG9hZGluZy0zRC1tb2RlbHNcbi8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZXhhbXBsZXMvI3dlYmdsX2xvYWRlcl9nbHRmXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9iZWxsYmluZC9jNGY4YzUwMmZjYWNiZTI5NDIyZTVhYzMxNTI3Mzg1OFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bndpdGh0cmlhbmdsZXMvYmxlbmRlci10by10aHJlZWpzLWV4cG9ydC1ndWlkZS9ibG9iL21hc3Rlci9yZWFkbWUubWRcbi8vIGh0dHBzOi8vdGhyZWVqc2Z1bmRhbWVudGFscy5vcmcvdGhyZWVqcy9sZXNzb25zL3RocmVlanMtbG9hZC1nbHRmLmh0bWxcbi8vIGh0dHBzOi8vZGlzY292ZXJ0aHJlZWpzLmNvbS9ib29rL2ZpcnN0LXN0ZXBzL2xvYWQtbW9kZWxzL1xuLy8gaHR0cHM6Ly93d3cucGVudGFjcmVhdGlvbi5jb20vYmxvZy8yMDE5LzA5LzE5MDkxNi5odG1sXG4vLyBodHRwczovL3d3dy5wZW50YWNyZWF0aW9uLmNvbS9ibG9nLzIwMTkvMTAvMTkxMDE2Lmh0bWxcbi8vIGh0dHBzOi8vZG9jcy5ibGVuZGVyLm9yZy9tYW51YWwvamEvbGF0ZXN0L2FkZG9ucy9pb19zY2VuZV9nbHRmMi5odG1sXG4vLyBodHRwczovL2dsdGYtdmlld2VyLmRvbm1jY3VyZHkuY29tL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rvbm1jY3VyZHkvdGhyZWUtZ2x0Zi12aWV3ZXJcbi8vIGltcG9ydCB7IFJhZiB9IGZyb20gJy4uL2xpYi9yYWYvcmFmJztcbmNsYXNzIFRocmVlT2JqZWN0Vmlld2VyNiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdUaHJlZUpTIE9iamVjdCBWaWV3ZXIgRGVtbycpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJlbnQnKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMtY29udGFpbmVyJyk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcygpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3Mud2F0Y2godGhpcy5vblByb2dyZXNzVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc2Nyb2xsTGVycCA9IDAuMzg7XG4gICAgdGhpcy5zY3JvbGxFYXNlID0gJ2Vhc2VJblF1YWQnO1xuICAgIHRoaXMucmVuZGVyZXJDb25maWcgPSB7XG4gICAgICBjbGVhckNvbG9yOiAnI0VBRThFNycsXG4gICAgICBiYWNrZ3JvdW5kQWxwaGE6IDEuMFxuICAgIH07XG4gICAgdGhpcy5ndWkgPSBuZXcgX2RhdGd1aWYuRGF0Z3VpZih7XG4gICAgICBsb2FkOiBKU09OXG4gICAgfSk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdTZXR0aW5ncycpLm9wZW4oKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ1JlbmRlcmVyJywgJ1NldHRpbmdzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdDYW1lcmEnLCAnU2V0dGluZ3MnKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ1Njcm9sbCcsICdTZXR0aW5ncycpO1xuICAgIHRoaXMuZ3VpLmFkZEZvbGRlcignTGlnaHRzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdPYmplY3RzJyk7XG4gICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoJ1Njcm9sbCcsIHRoaXMsIFt7XG4gICAgICBrZXlOYW1lOiAnc2Nyb2xsTGVycCcsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEsXG4gICAgICBzdGVwOiAwLjAxXG4gICAgfSwge1xuICAgICAga2V5TmFtZTogJ3Njcm9sbEVhc2UnLFxuICAgICAgb3B0aW9uczogWydsaW5lYXInLCAnZWFzZU91dFF1YWQnLCAnZWFzZUluUXVhZCddXG4gICAgfV0pO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdzY3JvbGwnLFxuICAgICAgY2FsbGJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50LCB3aW5kb3cuaW5uZXJIZWlnaHQpOyAvLyAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDAuMjYsIEVBU0UuZWFzZUluT3V0RXhwbyk7XG4gICAgICAgIC8vICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMC4wOCwgRUFTRS5saW5lYXIpO1xuXG4gICAgICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIHRoaXMuc2Nyb2xsTGVycCwgX2Vhc2UuRUFTRVt0aGlzLnNjcm9sbEVhc2VdKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICB0aGlzLmd1aS5vblVwZGF0ZShwcm9wID0+IHtcbiAgICAgIHRoaXMuZHJhdygpO1xuICAgIH0pO1xuICAgIHZhciBsb2FkZXIgPSBuZXcgX0dMVEZMb2FkZXIuR0xURkxvYWRlcigpO1xuICAgIGNvbnN0IHBhdGggPSAnLi9wdWJsaWMvaG9tZS9kZW1vNS5nbHRmJztcbiAgICBsb2FkZXIubG9hZChwYXRoLCBnbHRmID0+IHtcbiAgICAgIGNvbnN0IGdsdGZEYXRhID0gZ2x0Zi5wYXJzZXIuanNvbjtcblxuICAgICAgY29uc3QgZ2V0Tm9kZUJ5TmFtZSA9IG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gZ2x0ZkRhdGEubm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgICAgIHJldHVybiBub2RlLm5hbWUgPSBuYW1lO1xuICAgICAgICB9KVswXTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnNvbGUubG9nKCdnbHRmIGRhdGEnLCBnbHRmRGF0YSk7XG4gICAgICB0aGlzLmNsb2NrID0gbmV3IFRIUkVFLkNsb2NrKCk7XG4gICAgICBjb25zdCBzY2VuZSA9IGdsdGYuc2NlbmVzWzBdO1xuICAgICAgdGhpcy5hY3RpdmVTY2VuZSA9IHNjZW5lO1xuICAgICAgdGhpcy5hbmltYXRpb25zID0gZ2x0Zi5hbmltYXRpb25zOyAvLyBBbmltYXRpb24gTWl4ZXLjgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJBcblxuICAgICAgdGhpcy5taXhlciA9IG5ldyBUSFJFRS5BbmltYXRpb25NaXhlcihzY2VuZSk7IC8v5YWo44Gm44GuQW5pbWF0aW9uIENsaXDjgavlr77jgZfjgaZcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc1tpXTsgLy9BbmltYXRpb24gQWN0aW9u44KS55Sf5oiQXG5cbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMubWl4ZXIuY2xpcEFjdGlvbihhbmltYXRpb24pO1xuICAgICAgICBjb25zb2xlLmxvZygnYWRkZWQnLCBhbmltYXRpb24pO1xuICAgICAgICBhY3Rpb24ucGxheSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjZW5lLmFkZChzY2VuZSk7XG4gICAgICBjb25zb2xlLmxvZygnc2NlbmUnLCBzY2VuZSk7XG4gICAgICBjb25zb2xlLmxvZygnbWl4ZXInLCB0aGlzLm1peGVyKTsgLy8gaHR0cDovL2xlYXJuaW5ndGhyZWVqcy5jb20vYmxvZy8yMDEyLzAxLzIwL2Nhc3Rpbmctc2hhZG93cy9cblxuICAgICAgdGhpcy5zY2VuZS50cmF2ZXJzZShjaGlsZCA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLkxpZ2h0KSB7XG4gICAgICAgICAgLy8gY2hpbGQuY2FzdFNoYWRvdyA9IGZhbHNlO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdsaWdodCcsIGNoaWxkKTtcbiAgICAgICAgICBjb25zdCBzaGFkb3dFbmFibGVkTGlnaHRzID0gWydQb2ludDAxM19PcmllbnRhdGlvbicsICdQb2ludDAwM19PcmllbnRhdGlvbiddO1xuXG4gICAgICAgICAgaWYgKH5zaGFkb3dFbmFibGVkTGlnaHRzLmluZGV4T2YoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgICAgIGNoaWxkLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIH0gLy8gRGVidWdnaW5nIGxpZ2h0IHBvc2l0aW9ucy5cbiAgICAgICAgICAvLyBjaGlsZC5zaGFkb3dDYW1lcmFWaXNpYmxlID0gZmFsc2U7XG5cblxuICAgICAgICAgIGlmIChjaGlsZC5zaGFkb3cpIHt9IC8vIEFkanVzdCBzaGFkb3cgYmlhcy5cbiAgICAgICAgICAvLyBjaGlsZC5zaGFkb3cuYmlhcyA9IC0wLjAwMjtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIHJpZ2dlZCBsb29raW5nIHNoYWRvd3MuXG4gICAgICAgICAgLy8gY2hpbGQuc2hhZG93Lm1hcFNpemUud2lkdGggPSAxMDI0O1xuICAgICAgICAgIC8vIGNoaWxkLnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IDEwMjQ7XG4gICAgICAgICAgLy8gY2hpbGQuc2hhZG93RGFya25lc3MgPSAwLjU7XG4gICAgICAgICAgLy8gY2hpbGQuc2hhZG93LmNhbWVyYS5uZWFyID0gMDtcbiAgICAgICAgICAvLyBjaGlsZC5zaGFkb3cuY2FtZXJhLmZhciA9IDEwMDA7XG4gICAgICAgICAgLy8gdmFyIGhlbHBlciA9IG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGNoaWxkLnNoYWRvdy5jYW1lcmEgKTtcbiAgICAgICAgICAvLyBzY2VuZS5hZGQoIGhlbHBlciApO1xuICAgICAgICAgIC8vIFBvaW50IGxpZ2h0cyBhcmUgZGVmaW5lZCBpbiB3YXR0cyB3aGljaCBnb2VzIHdhYXkgb2ZmIGluIHRocmVlLmpzXG5cblxuICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQpIHtcbiAgICAgICAgICAgIGNoaWxkLmludGVuc2l0eSA9IGNoaWxkLmludGVuc2l0eSAqIDAuMDE7XG4gICAgICAgICAgfSAvLyBJZiBpdCdzIGEgc3BvdCBsaWdodCwgaXQgbmVlZHMgdG8gZ28gZG93biBldmVuIG1vcmUuXG5cblxuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09IFwiU3BvdExpZ2h0XCIpIHtcbiAgICAgICAgICAgIGNoaWxkLmludGVuc2l0eSA9IGNoaWxkLmludGVuc2l0eSAqIDAuMDAxO1xuICAgICAgICAgIH0gLy8gTm8gbGlnaHRzLlxuXG5cbiAgICAgICAgICBjaGlsZC5pbnRlbnNpdHkgPSAwO1xuICAgICAgICAgIHRoaXMuZ3VpLmFkZEZvbGRlcihjaGlsZC5uYW1lLCAnTGlnaHRzJyk7XG4gICAgICAgICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoY2hpbGQubmFtZSwgY2hpbGQsIFt7XG4gICAgICAgICAgICBrZXlOYW1lOiAnY2FzdFNoYWRvdydcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXlOYW1lOiAnaW50ZW5zaXR5JyxcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogMzAwMFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleU5hbWU6ICdjb2xvcidcbiAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICBpZiAoY2hpbGQuc2hhZG93KSB7XG4gICAgICAgICAgICBjb25zdCBzaGFkb3dGb2xkZXJJZCA9IGNoaWxkLm5hbWUgKyAnIHNoYWRvdyc7IC8vIGNvbnNvbGUubG9nKGNoaWxkLnNoYWRvdyk7XG5cbiAgICAgICAgICAgIHRoaXMuZ3VpLmFkZEZvbGRlcihzaGFkb3dGb2xkZXJJZCwgY2hpbGQubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcihzaGFkb3dGb2xkZXJJZCwgY2hpbGQuc2hhZG93LCBbe1xuICAgICAgICAgICAgICBrZXlOYW1lOiAnYmlhcycsXG4gICAgICAgICAgICAgIG1pbjogLTEsXG4gICAgICAgICAgICAgIG1heDogMSxcbiAgICAgICAgICAgICAgc3RlcDogMC4wMDAwMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXlOYW1lOiAncmFkaXVzJyxcbiAgICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgICBtYXg6IDEwMCxcbiAgICAgICAgICAgICAgc3RlcDogMC4wMVxuICAgICAgICAgICAgfV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpIHtcbiAgICAgICAgICAvLyBjaGlsZC5jYXN0U2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgICAvLyBjaGlsZC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcbiAgICAgICAgICAvLyBjaGlsZC5nZW9tZXRyeS5jb21wdXRlVmVydGV4Tm9ybWFscyh0cnVlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnbWVzaCcsIGNoaWxkKTtcbiAgICAgICAgICB0aGlzLmd1aS5hZGRGb2xkZXIoY2hpbGQubmFtZSwgJ09iamVjdHMnKTtcbiAgICAgICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcihjaGlsZC5uYW1lLCBjaGlsZCwgW3tcbiAgICAgICAgICAgIGtleU5hbWU6ICdjYXN0U2hhZG93J1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleU5hbWU6ICdyZWNlaXZlU2hhZG93J1xuICAgICAgICAgIH1dKTtcblxuICAgICAgICAgIGlmIChjaGlsZC5tYXRlcmlhbCkge1xuICAgICAgICAgICAgY29uc3QgbWF0ZXJpYWxJZCA9IGNoaWxkLm5hbWUgKyAnIG1hdGVyaWFsJztcbiAgICAgICAgICAgIHRoaXMuZ3VpLmFkZEZvbGRlcihtYXRlcmlhbElkLCBjaGlsZC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKG1hdGVyaWFsSWQsIGNoaWxkLm1hdGVyaWFsLCBbe1xuICAgICAgICAgICAgICBrZXlOYW1lOiAnZW1pc3NpdmVJbnRlbnNpdHknLFxuICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgIG1heDogMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXlOYW1lOiAnZmxhdFNoYWRpbmcnLFxuICAgICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBrZXlOYW1lOiAnd2lyZWZyYW1lJyxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKTsgLy8gRW5hYmxlIHNtb290aCBzaGFkaW5nLlxuICAgICAgICAgICAgLy8gY2hpbGQubWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGNoaWxkLm1hdGVyaWFsLndpcmVmcmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gY2hpbGQubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgLy8gY2hpbGQuZ2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gICAgICAgICAgICAvLyBjaGlsZC5nZW9tZXRyeS5jb21wdXRlVmVydGV4Tm9ybWFscyh0cnVlKTtcbiAgICAgICAgICB9IC8vIEdldCB0aGUgaW1hZ2UgbWFwcGluZ3MuXG4gICAgICAgICAgLy8gaWYoY2hpbGQubWF0ZXJpYWwgJiYgY2hpbGQubWF0ZXJpYWwubWFwKSB7XG4gICAgICAgICAgLy8gICBjaGlsZC5tYXRlcmlhbC5tYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIC8vIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdvdGhlcicsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIFNldCB0aGUgY2FtZXJhIGV4cG9ydGVkIGluIGdsdGYuXG4gICAgICAvLyBSZXF1aXJlcyBjYW1lcmEgdG8gYmUgZXhwb3J0ZWQgZm9yIGdsdGYuXG5cbiAgICAgIHRoaXMuY2FtZXJhID0gZ2x0Zi5jYW1lcmFzWzBdO1xuICAgICAgY29uc29sZS5sb2coJ2NhbWVyYScsIHRoaXMuY2FtZXJhKTtcbiAgICAgIHRoaXMucmVzaXplKCk7IC8vIFVzZSBmb2cgdG8gY292ZXIgZmFyIGRpc3RhbmNlcy5cblxuICAgICAgY29uc3QgY29sb3IgPSAweEVBRThFNztcbiAgICAgIHRoaXMuc2NlbmUuZm9nID0gbmV3IFRIUkVFLkZvZyhjb2xvciwgNSwgMTApOyAvLyBFbmFibGUgc2hhZG93cy5cbiAgICAgIC8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL2NvbnN0YW50cy9SZW5kZXJlclxuXG4gICAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkID0gdHJ1ZTsgLy8gVG8gYW50aWFsaWFzIHRoZSBzaGFkb3dcblxuICAgICAgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdhbW1hT3V0cHV0ID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2FtbWFGYWN0b3IgPSAzOyAvLyBJbXBvcnRhbnQgdG8gZ2V0IHRoZSBjb3JyZWN0IGNvbG9ycy5cbiAgICAgIC8vIHRoaXMucmVuZGVyZXIucGh5c2ljYWxseUNvcnJlY3RMaWd0cyA9IHRydWU7XG4gICAgICAvLyBCYWNrZ3JvdW5kIGFzIGJsYWNrLlxuICAgICAgLy8gdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4NDI4N2Y1KTtcblxuICAgICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMucmVuZGVyZXJDb25maWcuY2xlYXJDb2xvciwgdGhpcy5yZW5kZXJlckNvbmZpZy5iYWNrZ3JvdW5kQWxwaGEpOyAvLyBBZmZlY3RzIGhvdyBzdHJvbmdseSBsaWdodHMgY29tZSBleHBvc2VkLlxuICAgICAgLy8gaHR0cHM6Ly90aHJlZWpzLm9yZy9leGFtcGxlcy8jd2ViZ2xfdG9uZW1hcHBpbmdcblxuICAgICAgdGhpcy5yZW5kZXJlci50b25lTWFwcGluZ0V4cG9zdXJlID0gMTsgLy8gdGhpcy5yZW5kZXJlci50b25lTWFwcGluZ0V4cG9zdXJlID0gMC42O1xuXG4gICAgICB0aGlzLnJlbmRlcmVyLnRvbmVNYXBwaW5nID0gVEhSRUUuQUNFU0ZpbG1pY1RvbmVNYXBwaW5nO1xuICAgICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoJ1JlbmRlcmVyJywgdGhpcy5yZW5kZXJlciwgW3tcbiAgICAgICAga2V5TmFtZTogJ3RvbmVNYXBwaW5nRXhwb3N1cmUnLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogNSxcbiAgICAgICAgc3RlcDogMC4wMVxuICAgICAgfSwge1xuICAgICAgICBrZXlOYW1lOiAnZ2FtbWFGYWN0b3InLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMTAsXG4gICAgICAgIHN0ZXA6IDAuMDFcbiAgICAgIH1dKTtcbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdSZW5kZXJlcicsIHRoaXMucmVuZGVyZXJDb25maWcsIFt7XG4gICAgICAgIGtleU5hbWU6ICdjbGVhckNvbG9yJyxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5yZW5kZXJlckNvbmZpZy5jbGVhckNvbG9yLCB0aGlzLnJlbmRlcmVyQ29uZmlnLmJhY2tncm91bmRBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5TmFtZTogJ2JhY2tncm91bmRBbHBoYScsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMucmVuZGVyZXJDb25maWcuY2xlYXJDb2xvciwgdGhpcy5yZW5kZXJlckNvbmZpZy5iYWNrZ3JvdW5kQWxwaGEpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcignQ2FtZXJhJywgdGhpcy5jYW1lcmEsIFt7XG4gICAgICAgIGtleU5hbWU6ICdmb3YnLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogNTAsXG4gICAgICAgIHN0ZXA6IDAuMDEsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleU5hbWU6ICd6b29tJyxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDEwLFxuICAgICAgICBzdGVwOiAwLjAwMDEsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG4gICAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ0dlbmVyYWwgTGlnaHRzJyk7XG4gICAgICB0aGlzLmdlbmVyYWxMaWdodENvbmZpZyA9IHtcbiAgICAgICAgYW1iaWVudExpZ2h0Q29sb3I6ICcjRkZGRkZGJyxcbiAgICAgICAgYW1iaWVudExpZ2h0QWxwaGE6IDBcbiAgICAgIH07IC8vIEFkZGl0aW9uYWwgbGlnaHRpbmcgb3V0c2lkZSB0aGUgYmxlbmRlci5cbiAgICAgIC8vIHZhciBsaWdodCA9IG5ldyBUSFJFRS5IZW1pc3BoZXJlTGlnaHQoIDB4ZmZmZmJiLCAweGZmZmZmZiwgMSApO1xuICAgICAgLy8gdGhpcy5zY2VuZS5hZGQoIGxpZ2h0ICk7XG5cbiAgICAgIHRoaXMuYW1iaWVudExpZ2h0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCh0aGlzLmdlbmVyYWxMaWdodENvbmZpZy5hbWJpZW50TGlnaHRDb2xvcik7XG4gICAgICB0aGlzLmFtYmllbnRMaWdodC5pbnRlbnNpdHkgPSB0aGlzLmdlbmVyYWxMaWdodENvbmZpZy5hbWJpZW50TGlnaHRBbHBoYTtcbiAgICAgIHNjZW5lLmFkZCh0aGlzLmFtYmllbnRMaWdodCk7XG4gICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcignR2VuZXJhbCBMaWdodHMnLCB0aGlzLmdlbmVyYWxMaWdodENvbmZpZywgW3tcbiAgICAgICAga2V5TmFtZTogJ2FtYmllbnRMaWdodENvbG9yJyxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFtYmllbnRMaWdodC5jb2xvciA9IG5ldyBUSFJFRS5Db2xvcih0aGlzLmdlbmVyYWxMaWdodENvbmZpZy5hbWJpZW50TGlnaHRDb2xvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5TmFtZTogJ2FtYmllbnRMaWdodEFscGhhJyxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmFtYmllbnRMaWdodC5pbnRlbnNpdHkgPSB0aGlzLmdlbmVyYWxMaWdodENvbmZpZy5hbWJpZW50TGlnaHRBbHBoYTtcbiAgICAgICAgfVxuICAgICAgfV0pOyAvLyB2YXIgd2lkdGggPSA1MDtcbiAgICAgIC8vIHZhciBoZWlnaHQgPSA1MDtcbiAgICAgIC8vIHZhciBpbnRlbnNpdHkgPSAwO1xuICAgICAgLy8gdmFyIHJlY3RMaWdodCA9IG5ldyBUSFJFRS5SZWN0QXJlYUxpZ2h0KCcjRkZGRkZGJywgaW50ZW5zaXR5LCAgd2lkdGgsIGhlaWdodCApO1xuICAgICAgLy8gcmVjdExpZ2h0LnBvc2l0aW9uLnNldCggMCwgMCwgMjUgKTtcbiAgICAgIC8vIC8vIHJlY3RMaWdodC5sb29rQXQoIDAsIDAsIDAgKTtcbiAgICAgIC8vIHRoaXMuc2NlbmUuYWRkKCByZWN0TGlnaHQgKTtcbiAgICAgIC8vIHJlY3RMaWdodEhlbHBlciA9IG5ldyBUSFJFRS5SZWN0QXJlYUxpZ2h0SGVscGVyKCByZWN0TGlnaHQgKTtcbiAgICAgIC8vIHJlY3RMaWdodC5hZGQoIHJlY3RMaWdodEhlbHBlciApO1xuXG4gICAgICB0aGlzLmd1aS5hZGRCdXR0b24oJ1JlZnJlc2gnLCB0aGlzLnJlZnJlc2guYmluZCh0aGlzKSk7XG4gICAgfSwgdW5kZWZpbmVkLCBlcnJvciA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgLy8gcHJlY2lzaW9uOiAnaGlnaHAnXG4gICAgICBhdXRvU2l6ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29tcG9zZXIgPSBuZXcgX0VmZmVjdENvbXBvc2VyLkVmZmVjdENvbXBvc2VyKHRoaXMucmVuZGVyZXIpO1xuICAgIHRoaXMuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgfVxuXG4gIHJlc2l6ZSgpIHtcbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMSwgX2Vhc2UuRUFTRS5MaW5lYXIpO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhc0NvbnRhaW5lci5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXNDb250YWluZXIucGFyZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kb25tY2N1cmR5L3RocmVlLWdsdGYtdmlld2VyL2Jsb2IvbWFzdGVyL3NyYy92aWV3ZXIuanNcbiAgICAvLyBodHRwczovL3RocmVlanMub3JnL2RvY3MvI2FwaS9lbi9jb25zdGFudHMvUmVuZGVyZXJcblxuICAgIHRoaXMucmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTsgLy8gUG9zdCBwcm9jZXNzaW5nXG4gICAgLy8gdGhpcy5jb21wb3Nlci5zZXRTaXplKCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgLy8gY29uc3QgZnhhYVBhc3MgPSBuZXcgU2hhZGVyUGFzcyggRlhBQVNoYWRlciApO1xuICAgIC8vIGZ4YWFQYXNzLm1hdGVyaWFsLnVuaWZvcm1zWyAncmVzb2x1dGlvbicgXS52YWx1ZS54ID0gMSAvICggdGhpcy53aWR0aCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAvLyBmeGFhUGFzcy5tYXRlcmlhbC51bmlmb3Jtc1sgJ3Jlc29sdXRpb24nIF0udmFsdWUueSA9IDEgLyAoIHRoaXMuaGVpZ2h0ICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIC8vIHRoaXMuY29tcG9zZXIuYWRkUGFzcyhmeGFhUGFzcyk7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5hZGRQYXNzKG5ldyBSZW5kZXJQYXNzKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKSk7XG4gICAgLy8gdmFyIGJsb29tUGFzcyA9IG5ldyBVbnJlYWxCbG9vbVBhc3MoMSwgMjUsIDUsIDI1Nik7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5hZGRQYXNzKGJsb29tUGFzcyk7XG4gICAgLy8gVGhlIGNhbWVyYSBhc3BlY3QgZ29lcyBvZmYgc2luY2UgaXQgY291bGQgYmUgZXhwb3J0ZWQgYXQgYSBkaWZmZXJlbnRcbiAgICAvLyByYXRpby4gIEZvcmNlIHVwZGF0ZSB0aGUgYXNwZWN0IHJhdGlvLlxuXG4gICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMucmVuZGVyZXJDb25maWcuY2xlYXJDb2xvciwgdGhpcy5yZW5kZXJlckNvbmZpZy5iYWNrZ3JvdW5kQWxwaGEpO1xuICAgIHRoaXMucmVzaXplKCk7XG4gICAgdGhpcy5kcmF3KCk7XG4gIH1cblxuICBnZXRBbmltYXRpb25CeU5hbWUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnMuZmlsdGVyKGFuaW1hdGlvbkNsaXAgPT4ge1xuICAgICAgcmV0dXJuIGFuaW1hdGlvbkNsaXAubmFtZSA9PSBuYW1lO1xuICAgIH0pWzBdO1xuICB9XG5cbiAgZ2V0T2JqZWN0QnlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVTY2VuZS5jaGlsZHJlbi5maWx0ZXIob2JqZWN0M2QgPT4ge1xuICAgICAgcmV0dXJuIG9iamVjdDNkLm5hbWUgPT0gbmFtZTtcbiAgICB9KVswXTtcbiAgfVxuXG4gIG9uUHJvZ3Jlc3NVcGRhdGUocHJvZ3Jlc3MpIHtcbiAgICAvL0FuaW1hdGlvbiBNaXhlcuOCkuWun+ihjFxuICAgIGlmICh0aGlzLm1peGVyKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGZpbmQgb3V0IGhvdyBsb25nIHRoZSBhbmltYXRpb24gaXMuXG4gICAgICAvLyBUaGUgbWl4ZXIgYXBwZWFycyB0byBoYXZlIG5vIGtub3dsZWRnZSBvZnQgdGhpcyBzbyB3ZSBuZWVkIHRvXG4gICAgICAvLyBsb29rIHVwIGEgc3BlY2lmaWMgYW5pbWF0aW9uIGFuZCBnZXQgdGhlIGR1cmF0aW9uIHRvXG4gICAgICAvLyBnZXQgdGhlIHRvdGFsIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICBjb25zdCBjYW1lcmFBbmltYXRpb24gPSB0aGlzLmdldEFuaW1hdGlvbkJ5TmFtZSgnQWN0aW9uLjAwMScpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBjYW1lcmFBbmltYXRpb24uZHVyYXRpb247IC8vIFdoZW4gZHVyYXRpb24gaGl0cyBpdCdzIG1heCwgYW5pbWF0aW9uTWl4ZXIgc2VlbXMgdG8gaGl0IHRoZSBmaXJzdFxuICAgICAgLy8gZnJhbWUgc28gbmV4dCBhbGxvdyBpdCB0byByZWFjaCB0aGUgbWF4IHZhbHVlLlxuXG4gICAgICB0aGlzLm1peGVyLnNldFRpbWUoTWF0aC5taW4oZHVyYXRpb24gKiBwcm9ncmVzcywgZHVyYXRpb24gLSAwLjAwMSkpO1xuICAgIH1cblxuICAgIHRoaXMuZHJhdygpOyAvLyB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5yZW5kZXIoKTtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gVGhyZWVPYmplY3RWaWV3ZXI2OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/three-object-viewer6.js\n");

/***/ }),

/***/ "./examples/three-object-viewer7.js":
/*!******************************************!*\
  !*** ./examples/three-object-viewer7.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _datguif = __webpack_require__(/*! ../lib/datguif/datguif */ \"./lib/datguif/datguif.js\");\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _GLTFLoader = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\nvar _EffectComposer = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n\nvar _RenderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n\nvar _UnrealBloomPass = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass.js */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n\nvar _FXAAShader = __webpack_require__(/*! three/examples/jsm/shaders/FXAAShader.js */ \"./node_modules/three/examples/jsm/shaders/FXAAShader.js\");\n\nvar _ShaderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/ShaderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/ShaderPass.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n// https://threejs.org/docs/#manual/en/introduction/Loading-3D-models\n// https://threejs.org/examples/#webgl_loader_gltf\n// https://gist.github.com/bellbind/c4f8c502fcacbe29422e5ac315273858\n// https://github.com/funwithtriangles/blender-to-threejs-export-guide/blob/master/readme.md\n// https://threejsfundamentals.org/threejs/lessons/threejs-load-gltf.html\n// https://discoverthreejs.com/book/first-steps/load-models/\n// https://www.pentacreation.com/blog/2019/09/190916.html\n// https://www.pentacreation.com/blog/2019/10/191016.html\n// https://docs.blender.org/manual/ja/latest/addons/io_scene_gltf2.html\n// https://gltf-viewer.donmccurdy.com/\n// https://github.com/donmccurdy/three-gltf-viewer\n// import { Raf } from '../lib/raf/raf';\nclass ThreeObjectViewer7 {\n  constructor() {\n    console.log('ThreeJS Object Viewer Demo');\n    this.parentElement = document.getElementById('parent');\n    this.canvasContainer = document.getElementById('canvas-container');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.rafProgress = new _rafProgress.RafProgress();\n    this.rafProgress.watch(this.onProgressUpdate.bind(this));\n    this.scrollLerp = 0.38;\n    this.scrollEase = 'easeInQuad';\n    this.rendererConfig = {\n      clearColor: '#000000',\n      backgroundAlpha: 1.0\n    };\n    this.gui = new _datguif.Datguif({\n      load: JSON\n    });\n    this.gui.addFolder('Settings').open();\n    this.gui.addFolder('Renderer', 'Settings');\n    this.gui.addFolder('Camera', 'Settings');\n    this.gui.addFolder('Scroll', 'Settings');\n    this.gui.addFolder('Lights');\n    this.gui.addFolder('Objects');\n    this.gui.addObjectToFolder('Scroll', this, [{\n      keyName: 'scrollLerp',\n      min: 0,\n      max: 1,\n      step: 0.01\n    }, {\n      keyName: 'scrollEase',\n      options: ['linear', 'easeOutQuad', 'easeInQuad']\n    }]);\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight); //   this.rafProgress.easeTo(this.progress, 0.26, EASE.easeInOutExpo);\n        //   this.rafProgress.easeTo(this.progress, 0.08, EASE.linear);\n\n        this.rafProgress.easeTo(this.progress, this.scrollLerp, _ease.EASE[this.scrollEase]);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.scene = new THREE.Scene();\n    this.gui.onUpdate(prop => {\n      this.draw();\n    });\n    var loader = new _GLTFLoader.GLTFLoader();\n    const path = './public/home/demo7.gltf';\n    loader.load(path, gltf => {\n      const gltfData = gltf.parser.json;\n\n      const getNodeByName = name => {\n        return gltfData.nodes.filter(node => {\n          return node.name = name;\n        })[0];\n      };\n\n      console.log('gltf data', gltfData);\n      this.clock = new THREE.Clock();\n      const scene = gltf.scenes[0];\n      this.activeScene = scene;\n      this.animations = gltf.animations; // Animation Mixer\n\n      this.mixer = new THREE.AnimationMixer(scene); //Animation Clip\n\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i]; //Animation Action\n\n        var action = this.mixer.clipAction(animation);\n        console.log('added', animation);\n        action.play();\n      }\n\n      this.scene.add(scene);\n      console.log('scene', scene);\n      console.log('mixer', this.mixer); // http://learningthreejs.com/blog/2012/01/20/casting-shadows/\n\n      this.scene.traverse(child => {\n        if (child instanceof THREE.Light) {\n          // child.castShadow = false;\n          // console.log('light', child);\n          // Set all lights to layer 1.\n          child.layers.set(1); // Debugging light positions.\n          // child.shadowCameraVisible = false;\n          // if(child.shadow) {\n          //     // Adjust shadow bias.\n          //     // child.shadow.bias = -0.002;\n          //     // Remove the rigged looking shadows.\n          //     // child.shadow.mapSize.width = 1024;\n          //     // child.shadow.mapSize.height = 1024;\n          //     // child.shadowDarkness = 0.5;\n          //     // child.shadow.camera.near = 0;\n          //     // child.shadow.camera.far = 1000;\n          //     // var helper = new THREE.CameraHelper( child.shadow.camera );\n          //     // scene.add( helper );\n          // }\n          // // Point lights are defined in watts which goes waay off in three.js\n          // if (child instanceof THREE.PointLight) {\n          //     child.intensity = child.intensity * 0.01;\n          // }\n          // // If it's a spot light, it needs to go down even more.\n          // if (child.type == \"SpotLight\") {\n          //     child.intensity = child.intensity * 0.001;\n          // }\n\n          child.intensity = 0;\n\n          if (child.name == 'Point004_Orientation') {\n            child.intensity = 1.3;\n          }\n\n          this.gui.addFolder(child.name, 'Lights');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'intensity',\n            min: 0,\n            max: 3000\n          }, {\n            keyName: 'color'\n          }]);\n\n          if (child.shadow) {\n            const shadowFolderId = child.name + ' shadow'; // console.log(child.shadow);\n\n            this.gui.addFolder(shadowFolderId, child.name);\n            this.gui.addObjectToFolder(shadowFolderId, child.shadow, [{\n              keyName: 'bias',\n              min: -1,\n              max: 1,\n              step: 0.00001\n            }, {\n              keyName: 'radius',\n              min: 0,\n              max: 100,\n              step: 0.01\n            }]);\n          }\n        } else if (child instanceof THREE.Mesh) {\n          // child.castShadow = true;\n          // child.receiveShadow = true;\n          // child.geometry.computeVertexNormals(true);\n          console.log('mesh', child);\n          const lightEnabled = ['p4-super-sm', 'p4-super-sm001', 'p4-super-sm002'];\n\n          if (~lightEnabled.indexOf(child.name)) {\n            child.layers.set(1);\n          }\n\n          this.gui.addFolder(child.name, 'Objects');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'receiveShadow'\n          }]);\n\n          if (child.material) {\n            const materialId = child.name + ' material';\n            this.gui.addFolder(materialId, child.name);\n            this.gui.addObjectToFolder(materialId, child.material, [{\n              keyName: 'emissiveIntensity',\n              min: 0,\n              max: 1\n            }, {\n              keyName: 'flatShading',\n              callback: () => {\n                child.material.needsUpdate = true;\n              }\n            }, {\n              keyName: 'wireframe',\n              callback: () => {\n                child.material.needsUpdate = true;\n              }\n            }]); // Enable smooth shading.\n            // child.material.flatShading = false;\n            // child.material.wireframe = false;\n            // child.material.needsUpdate = true;\n            // child.geometry.computeFaceNormals();\n            // child.geometry.computeVertexNormals(true);\n          } // Get the image mappings.\n          // if(child.material && child.material.map) {\n          //   child.material.map.needsUpdate = true;\n          // }\n\n        } else {\n          console.log('other', child);\n        }\n      }); // Set the camera exported in gltf.\n      // Requires camera to be exported for gltf.\n\n      this.camera = gltf.cameras[0];\n      console.log('camera', this.camera);\n      this.resize(); // Use fog to cover far distances.\n\n      const color = 0x00000;\n      this.scene.fog = new THREE.Fog(color, 5, 8); // Enable shadows.\n      // https://threejs.org/docs/#api/en/constants/Renderer\n\n      this.renderer.shadowMap.enabled = true; // To antialias the shadow\n\n      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n      this.renderer.gammaOutput = true;\n      this.renderer.gammaFactor = 3; // Important to get the correct colors.\n      // this.renderer.physicallyCorrectLigts = true;\n      // Background as black.\n      // this.renderer.setClearColor(0x4287f5);\n\n      this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha); // Affects how strongly lights come exposed.\n      // https://threejs.org/examples/#webgl_tonemapping\n\n      this.renderer.toneMappingExposure = 1; // this.renderer.toneMappingExposure = 0.6;\n\n      this.renderer.toneMapping = THREE.ACESFilmicToneMapping;\n      this.gui.addObjectToFolder('Renderer', this.renderer, [{\n        keyName: 'toneMappingExposure',\n        min: 0,\n        max: 5,\n        step: 0.01\n      }, {\n        keyName: 'gammaFactor',\n        min: 0,\n        max: 10,\n        step: 0.01\n      }]);\n      this.gui.addObjectToFolder('Renderer', this.rendererConfig, [{\n        keyName: 'clearColor',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }, {\n        keyName: 'backgroundAlpha',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }]);\n      this.gui.addObjectToFolder('Camera', this.camera, [{\n        keyName: 'fov',\n        min: 0,\n        max: 50,\n        step: 0.01,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }, {\n        keyName: 'zoom',\n        min: 0,\n        max: 10,\n        step: 0.0001,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }]);\n      this.gui.addFolder('General Lights');\n      this.generalLightConfig = {\n        ambientLightColor: '#FFFFFF',\n        ambientLightAlpha: 0\n      }; // Additional lighting outside the blender.\n      // var light = new THREE.HemisphereLight( 0xffffbb, 0xffffff, 1 );\n      // this.scene.add( light );\n\n      this.ambientLight = new THREE.AmbientLight(this.generalLightConfig.ambientLightColor);\n      this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n      scene.add(this.ambientLight);\n      this.gui.addObjectToFolder('General Lights', this.generalLightConfig, [{\n        keyName: 'ambientLightColor',\n        callback: () => {\n          this.ambientLight.color = new THREE.Color(this.generalLightConfig.ambientLightColor);\n        }\n      }, {\n        keyName: 'ambientLightAlpha',\n        callback: () => {\n          this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n        }\n      }]); // var width = 50;\n      // var height = 50;\n      // var intensity = 0;\n      // var rectLight = new THREE.RectAreaLight('#FFFFFF', intensity,  width, height );\n      // rectLight.position.set( 0, 0, 25 );\n      // // rectLight.lookAt( 0, 0, 0 );\n      // this.scene.add( rectLight );\n      // rectLightHelper = new THREE.RectAreaLightHelper( rectLight );\n      // rectLight.add( rectLightHelper );\n\n      this.gui.addButton('Refresh', this.refresh.bind(this));\n    }, undefined, error => {\n      console.error(error);\n    });\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      // precision: 'highp'\n      autoSize: true\n    });\n    this.composer = new _EffectComposer.EffectComposer(this.renderer);\n    this.canvasContainer.appendChild(this.renderer.domElement);\n    window.addEventListener('resize', this.resize.bind(this), false);\n  }\n\n  resize() {\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.width = this.canvasContainer.parentElement.offsetWidth;\n    this.height = this.canvasContainer.parentElement.offsetHeight; // https://github.com/donmccurdy/three-gltf-viewer/blob/master/src/viewer.js\n    // https://threejs.org/docs/#api/en/constants/Renderer\n\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n    this.renderer.setSize(this.width, this.height); // Post processing\n    // this.composer.setSize( this.width, this.height);\n    // const fxaaPass = new ShaderPass( FXAAShader );\n    // fxaaPass.material.uniforms[ 'resolution' ].value.x = 1 / ( this.width * window.devicePixelRatio);\n    // fxaaPass.material.uniforms[ 'resolution' ].value.y = 1 / ( this.height * window.devicePixelRatio);\n    // this.composer.addPass(fxaaPass);\n    // this.composer.addPass(new RenderPass(this.scene, this.camera));\n    // var bloomPass = new UnrealBloomPass(1, 25, 5, 256);\n    // this.composer.addPass(bloomPass);\n    // The camera aspect goes off since it could be exported at a different\n    // ratio.  Force update the aspect ratio.\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n  }\n\n  refresh() {\n    this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n    this.resize();\n    this.draw();\n  }\n\n  getAnimationByName(name) {\n    return this.animations.filter(animationClip => {\n      return animationClip.name == name;\n    })[0];\n  }\n\n  getObjectByName(name) {\n    return this.activeScene.children.filter(object3d => {\n      return object3d.name == name;\n    })[0];\n  }\n\n  onProgressUpdate(progress) {\n    //Animation Mixer\n    if (this.mixer) {\n      // We need to find out how long the animation is.\n      // The mixer appears to have no knowledge oft this so we need to\n      // look up a specific animation and get the duration to\n      // get the total duration of the animation.\n      const cameraAnimation = this.getAnimationByName('Action.001');\n      const duration = cameraAnimation.duration; // When duration hits it's max, animationMixer seems to hit the first\n      // frame so next allow it to reach the max value.\n\n      this.mixer.setTime(Math.min(duration * progress, duration - 0.001));\n    }\n\n    this.draw(); // this.renderer.render(this.scene, this.camera);\n    // this.composer.render();\n  }\n\n  draw() {\n    this.renderer.autoClear = true;\n    this.camera.layers.set(0);\n    this.renderer.render(this.scene, this.camera);\n    this.renderer.autoClear = false; // Don't clear\n\n    this.camera.layers.set(1);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = ThreeObjectViewer7;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1vYmplY3Qtdmlld2VyNy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3RocmVlLW9iamVjdC12aWV3ZXI3LmpzPzVkZTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZGF0Z3VpZiA9IHJlcXVpcmUoXCIuLi9saWIvZGF0Z3VpZi9kYXRndWlmXCIpO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX0dMVEZMb2FkZXIgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvR0xURkxvYWRlclwiKTtcblxudmFyIF9FZmZlY3RDb21wb3NlciA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvRWZmZWN0Q29tcG9zZXJcIik7XG5cbnZhciBfUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvUmVuZGVyUGFzcy5qc1wiKTtcblxudmFyIF9VbnJlYWxCbG9vbVBhc3MgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL1VucmVhbEJsb29tUGFzcy5qc1wiKTtcblxudmFyIF9GWEFBU2hhZGVyID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9zaGFkZXJzL0ZYQUFTaGFkZXIuanNcIik7XG5cbnZhciBfU2hhZGVyUGFzcyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvU2hhZGVyUGFzcy5qc1wiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWYtcHJvZ3Jlc3NcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tXCIpO1xuXG52YXIgX2Vhc2UgPSByZXF1aXJlKFwiLi4vbGliL2Vhc2UvZWFzZVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vLyBodHRwczovL3RocmVlanMub3JnL2RvY3MvI21hbnVhbC9lbi9pbnRyb2R1Y3Rpb24vTG9hZGluZy0zRC1tb2RlbHNcbi8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZXhhbXBsZXMvI3dlYmdsX2xvYWRlcl9nbHRmXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9iZWxsYmluZC9jNGY4YzUwMmZjYWNiZTI5NDIyZTVhYzMxNTI3Mzg1OFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bndpdGh0cmlhbmdsZXMvYmxlbmRlci10by10aHJlZWpzLWV4cG9ydC1ndWlkZS9ibG9iL21hc3Rlci9yZWFkbWUubWRcbi8vIGh0dHBzOi8vdGhyZWVqc2Z1bmRhbWVudGFscy5vcmcvdGhyZWVqcy9sZXNzb25zL3RocmVlanMtbG9hZC1nbHRmLmh0bWxcbi8vIGh0dHBzOi8vZGlzY292ZXJ0aHJlZWpzLmNvbS9ib29rL2ZpcnN0LXN0ZXBzL2xvYWQtbW9kZWxzL1xuLy8gaHR0cHM6Ly93d3cucGVudGFjcmVhdGlvbi5jb20vYmxvZy8yMDE5LzA5LzE5MDkxNi5odG1sXG4vLyBodHRwczovL3d3dy5wZW50YWNyZWF0aW9uLmNvbS9ibG9nLzIwMTkvMTAvMTkxMDE2Lmh0bWxcbi8vIGh0dHBzOi8vZG9jcy5ibGVuZGVyLm9yZy9tYW51YWwvamEvbGF0ZXN0L2FkZG9ucy9pb19zY2VuZV9nbHRmMi5odG1sXG4vLyBodHRwczovL2dsdGYtdmlld2VyLmRvbm1jY3VyZHkuY29tL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rvbm1jY3VyZHkvdGhyZWUtZ2x0Zi12aWV3ZXJcbi8vIGltcG9ydCB7IFJhZiB9IGZyb20gJy4uL2xpYi9yYWYvcmFmJztcbmNsYXNzIFRocmVlT2JqZWN0Vmlld2VyNyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdUaHJlZUpTIE9iamVjdCBWaWV3ZXIgRGVtbycpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJlbnQnKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMtY29udGFpbmVyJyk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcygpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3Mud2F0Y2godGhpcy5vblByb2dyZXNzVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc2Nyb2xsTGVycCA9IDAuMzg7XG4gICAgdGhpcy5zY3JvbGxFYXNlID0gJ2Vhc2VJblF1YWQnO1xuICAgIHRoaXMucmVuZGVyZXJDb25maWcgPSB7XG4gICAgICBjbGVhckNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICBiYWNrZ3JvdW5kQWxwaGE6IDEuMFxuICAgIH07XG4gICAgdGhpcy5ndWkgPSBuZXcgX2RhdGd1aWYuRGF0Z3VpZih7XG4gICAgICBsb2FkOiBKU09OXG4gICAgfSk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdTZXR0aW5ncycpLm9wZW4oKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ1JlbmRlcmVyJywgJ1NldHRpbmdzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdDYW1lcmEnLCAnU2V0dGluZ3MnKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ1Njcm9sbCcsICdTZXR0aW5ncycpO1xuICAgIHRoaXMuZ3VpLmFkZEZvbGRlcignTGlnaHRzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdPYmplY3RzJyk7XG4gICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoJ1Njcm9sbCcsIHRoaXMsIFt7XG4gICAgICBrZXlOYW1lOiAnc2Nyb2xsTGVycCcsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEsXG4gICAgICBzdGVwOiAwLjAxXG4gICAgfSwge1xuICAgICAga2V5TmFtZTogJ3Njcm9sbEVhc2UnLFxuICAgICAgb3B0aW9uczogWydsaW5lYXInLCAnZWFzZU91dFF1YWQnLCAnZWFzZUluUXVhZCddXG4gICAgfV0pO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdzY3JvbGwnLFxuICAgICAgY2FsbGJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50LCB3aW5kb3cuaW5uZXJIZWlnaHQpOyAvLyAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDAuMjYsIEVBU0UuZWFzZUluT3V0RXhwbyk7XG4gICAgICAgIC8vICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMC4wOCwgRUFTRS5saW5lYXIpO1xuXG4gICAgICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIHRoaXMuc2Nyb2xsTGVycCwgX2Vhc2UuRUFTRVt0aGlzLnNjcm9sbEVhc2VdKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICB0aGlzLmd1aS5vblVwZGF0ZShwcm9wID0+IHtcbiAgICAgIHRoaXMuZHJhdygpO1xuICAgIH0pO1xuICAgIHZhciBsb2FkZXIgPSBuZXcgX0dMVEZMb2FkZXIuR0xURkxvYWRlcigpO1xuICAgIGNvbnN0IHBhdGggPSAnLi9wdWJsaWMvaG9tZS9kZW1vNy5nbHRmJztcbiAgICBsb2FkZXIubG9hZChwYXRoLCBnbHRmID0+IHtcbiAgICAgIGNvbnN0IGdsdGZEYXRhID0gZ2x0Zi5wYXJzZXIuanNvbjtcblxuICAgICAgY29uc3QgZ2V0Tm9kZUJ5TmFtZSA9IG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gZ2x0ZkRhdGEubm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgICAgIHJldHVybiBub2RlLm5hbWUgPSBuYW1lO1xuICAgICAgICB9KVswXTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnNvbGUubG9nKCdnbHRmIGRhdGEnLCBnbHRmRGF0YSk7XG4gICAgICB0aGlzLmNsb2NrID0gbmV3IFRIUkVFLkNsb2NrKCk7XG4gICAgICBjb25zdCBzY2VuZSA9IGdsdGYuc2NlbmVzWzBdO1xuICAgICAgdGhpcy5hY3RpdmVTY2VuZSA9IHNjZW5lO1xuICAgICAgdGhpcy5hbmltYXRpb25zID0gZ2x0Zi5hbmltYXRpb25zOyAvLyBBbmltYXRpb24gTWl4ZXLjgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJBcblxuICAgICAgdGhpcy5taXhlciA9IG5ldyBUSFJFRS5BbmltYXRpb25NaXhlcihzY2VuZSk7IC8v5YWo44Gm44GuQW5pbWF0aW9uIENsaXDjgavlr77jgZfjgaZcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc1tpXTsgLy9BbmltYXRpb24gQWN0aW9u44KS55Sf5oiQXG5cbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMubWl4ZXIuY2xpcEFjdGlvbihhbmltYXRpb24pO1xuICAgICAgICBjb25zb2xlLmxvZygnYWRkZWQnLCBhbmltYXRpb24pO1xuICAgICAgICBhY3Rpb24ucGxheSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjZW5lLmFkZChzY2VuZSk7XG4gICAgICBjb25zb2xlLmxvZygnc2NlbmUnLCBzY2VuZSk7XG4gICAgICBjb25zb2xlLmxvZygnbWl4ZXInLCB0aGlzLm1peGVyKTsgLy8gaHR0cDovL2xlYXJuaW5ndGhyZWVqcy5jb20vYmxvZy8yMDEyLzAxLzIwL2Nhc3Rpbmctc2hhZG93cy9cblxuICAgICAgdGhpcy5zY2VuZS50cmF2ZXJzZShjaGlsZCA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLkxpZ2h0KSB7XG4gICAgICAgICAgLy8gY2hpbGQuY2FzdFNoYWRvdyA9IGZhbHNlO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdsaWdodCcsIGNoaWxkKTtcbiAgICAgICAgICAvLyBTZXQgYWxsIGxpZ2h0cyB0byBsYXllciAxLlxuICAgICAgICAgIGNoaWxkLmxheWVycy5zZXQoMSk7IC8vIERlYnVnZ2luZyBsaWdodCBwb3NpdGlvbnMuXG4gICAgICAgICAgLy8gY2hpbGQuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgIC8vIGlmKGNoaWxkLnNoYWRvdykge1xuICAgICAgICAgIC8vICAgICAvLyBBZGp1c3Qgc2hhZG93IGJpYXMuXG4gICAgICAgICAgLy8gICAgIC8vIGNoaWxkLnNoYWRvdy5iaWFzID0gLTAuMDAyO1xuICAgICAgICAgIC8vICAgICAvLyBSZW1vdmUgdGhlIHJpZ2dlZCBsb29raW5nIHNoYWRvd3MuXG4gICAgICAgICAgLy8gICAgIC8vIGNoaWxkLnNoYWRvdy5tYXBTaXplLndpZHRoID0gMTAyNDtcbiAgICAgICAgICAvLyAgICAgLy8gY2hpbGQuc2hhZG93Lm1hcFNpemUuaGVpZ2h0ID0gMTAyNDtcbiAgICAgICAgICAvLyAgICAgLy8gY2hpbGQuc2hhZG93RGFya25lc3MgPSAwLjU7XG4gICAgICAgICAgLy8gICAgIC8vIGNoaWxkLnNoYWRvdy5jYW1lcmEubmVhciA9IDA7XG4gICAgICAgICAgLy8gICAgIC8vIGNoaWxkLnNoYWRvdy5jYW1lcmEuZmFyID0gMTAwMDtcbiAgICAgICAgICAvLyAgICAgLy8gdmFyIGhlbHBlciA9IG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGNoaWxkLnNoYWRvdy5jYW1lcmEgKTtcbiAgICAgICAgICAvLyAgICAgLy8gc2NlbmUuYWRkKCBoZWxwZXIgKTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgICAgLy8gLy8gUG9pbnQgbGlnaHRzIGFyZSBkZWZpbmVkIGluIHdhdHRzIHdoaWNoIGdvZXMgd2FheSBvZmYgaW4gdGhyZWUuanNcbiAgICAgICAgICAvLyBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0KSB7XG4gICAgICAgICAgLy8gICAgIGNoaWxkLmludGVuc2l0eSA9IGNoaWxkLmludGVuc2l0eSAqIDAuMDE7XG4gICAgICAgICAgLy8gfVxuICAgICAgICAgIC8vIC8vIElmIGl0J3MgYSBzcG90IGxpZ2h0LCBpdCBuZWVkcyB0byBnbyBkb3duIGV2ZW4gbW9yZS5cbiAgICAgICAgICAvLyBpZiAoY2hpbGQudHlwZSA9PSBcIlNwb3RMaWdodFwiKSB7XG4gICAgICAgICAgLy8gICAgIGNoaWxkLmludGVuc2l0eSA9IGNoaWxkLmludGVuc2l0eSAqIDAuMDAxO1xuICAgICAgICAgIC8vIH1cblxuICAgICAgICAgIGNoaWxkLmludGVuc2l0eSA9IDA7XG5cbiAgICAgICAgICBpZiAoY2hpbGQubmFtZSA9PSAnUG9pbnQwMDRfT3JpZW50YXRpb24nKSB7XG4gICAgICAgICAgICBjaGlsZC5pbnRlbnNpdHkgPSAxLjM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKGNoaWxkLm5hbWUsICdMaWdodHMnKTtcbiAgICAgICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcihjaGlsZC5uYW1lLCBjaGlsZCwgW3tcbiAgICAgICAgICAgIGtleU5hbWU6ICdjYXN0U2hhZG93J1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleU5hbWU6ICdpbnRlbnNpdHknLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAzMDAwXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5TmFtZTogJ2NvbG9yJ1xuICAgICAgICAgIH1dKTtcblxuICAgICAgICAgIGlmIChjaGlsZC5zaGFkb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd0ZvbGRlcklkID0gY2hpbGQubmFtZSArICcgc2hhZG93JzsgLy8gY29uc29sZS5sb2coY2hpbGQuc2hhZG93KTtcblxuICAgICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKHNoYWRvd0ZvbGRlcklkLCBjaGlsZC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKHNoYWRvd0ZvbGRlcklkLCBjaGlsZC5zaGFkb3csIFt7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdiaWFzJyxcbiAgICAgICAgICAgICAgbWluOiAtMSxcbiAgICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgICAgICBzdGVwOiAwLjAwMDAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdyYWRpdXMnLFxuICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgIG1heDogMTAwLFxuICAgICAgICAgICAgICBzdGVwOiAwLjAxXG4gICAgICAgICAgICB9XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICAgIC8vIGNoaWxkLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIC8vIGNoaWxkLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIC8vIGNoaWxkLmdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKHRydWUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdtZXNoJywgY2hpbGQpO1xuICAgICAgICAgIGNvbnN0IGxpZ2h0RW5hYmxlZCA9IFsncDQtc3VwZXItc20nLCAncDQtc3VwZXItc20wMDEnLCAncDQtc3VwZXItc20wMDInXTtcblxuICAgICAgICAgIGlmICh+bGlnaHRFbmFibGVkLmluZGV4T2YoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgICAgIGNoaWxkLmxheWVycy5zZXQoMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKGNoaWxkLm5hbWUsICdPYmplY3RzJyk7XG4gICAgICAgICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoY2hpbGQubmFtZSwgY2hpbGQsIFt7XG4gICAgICAgICAgICBrZXlOYW1lOiAnY2FzdFNoYWRvdydcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXlOYW1lOiAncmVjZWl2ZVNoYWRvdydcbiAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICBpZiAoY2hpbGQubWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsSWQgPSBjaGlsZC5uYW1lICsgJyBtYXRlcmlhbCc7XG4gICAgICAgICAgICB0aGlzLmd1aS5hZGRGb2xkZXIobWF0ZXJpYWxJZCwgY2hpbGQubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcihtYXRlcmlhbElkLCBjaGlsZC5tYXRlcmlhbCwgW3tcbiAgICAgICAgICAgICAga2V5TmFtZTogJ2VtaXNzaXZlSW50ZW5zaXR5JyxcbiAgICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgICBtYXg6IDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5TmFtZTogJ2ZsYXRTaGFkaW5nJyxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5TmFtZTogJ3dpcmVmcmFtZScsXG4gICAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7IC8vIEVuYWJsZSBzbW9vdGggc2hhZGluZy5cbiAgICAgICAgICAgIC8vIGNoaWxkLm1hdGVyaWFsLmZsYXRTaGFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBjaGlsZC5tYXRlcmlhbC53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGNoaWxkLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGNoaWxkLmdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgICAgICAgICAgLy8gY2hpbGQuZ2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHModHJ1ZSk7XG4gICAgICAgICAgfSAvLyBHZXQgdGhlIGltYWdlIG1hcHBpbmdzLlxuICAgICAgICAgIC8vIGlmKGNoaWxkLm1hdGVyaWFsICYmIGNoaWxkLm1hdGVyaWFsLm1hcCkge1xuICAgICAgICAgIC8vICAgY2hpbGQubWF0ZXJpYWwubWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnb3RoZXInLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBTZXQgdGhlIGNhbWVyYSBleHBvcnRlZCBpbiBnbHRmLlxuICAgICAgLy8gUmVxdWlyZXMgY2FtZXJhIHRvIGJlIGV4cG9ydGVkIGZvciBnbHRmLlxuXG4gICAgICB0aGlzLmNhbWVyYSA9IGdsdGYuY2FtZXJhc1swXTtcbiAgICAgIGNvbnNvbGUubG9nKCdjYW1lcmEnLCB0aGlzLmNhbWVyYSk7XG4gICAgICB0aGlzLnJlc2l6ZSgpOyAvLyBVc2UgZm9nIHRvIGNvdmVyIGZhciBkaXN0YW5jZXMuXG5cbiAgICAgIGNvbnN0IGNvbG9yID0gMHgwMDAwMDtcbiAgICAgIHRoaXMuc2NlbmUuZm9nID0gbmV3IFRIUkVFLkZvZyhjb2xvciwgNSwgOCk7IC8vIEVuYWJsZSBzaGFkb3dzLlxuICAgICAgLy8gaHR0cHM6Ly90aHJlZWpzLm9yZy9kb2NzLyNhcGkvZW4vY29uc3RhbnRzL1JlbmRlcmVyXG5cbiAgICAgIHRoaXMucmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgPSB0cnVlOyAvLyBUbyBhbnRpYWxpYXMgdGhlIHNoYWRvd1xuXG4gICAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd01hcC50eXBlID0gVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2FtbWFPdXRwdXQgPSB0cnVlO1xuICAgICAgdGhpcy5yZW5kZXJlci5nYW1tYUZhY3RvciA9IDM7IC8vIEltcG9ydGFudCB0byBnZXQgdGhlIGNvcnJlY3QgY29sb3JzLlxuICAgICAgLy8gdGhpcy5yZW5kZXJlci5waHlzaWNhbGx5Q29ycmVjdExpZ3RzID0gdHJ1ZTtcbiAgICAgIC8vIEJhY2tncm91bmQgYXMgYmxhY2suXG4gICAgICAvLyB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHg0Mjg3ZjUpO1xuXG4gICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5yZW5kZXJlckNvbmZpZy5jbGVhckNvbG9yLCB0aGlzLnJlbmRlcmVyQ29uZmlnLmJhY2tncm91bmRBbHBoYSk7IC8vIEFmZmVjdHMgaG93IHN0cm9uZ2x5IGxpZ2h0cyBjb21lIGV4cG9zZWQuXG4gICAgICAvLyBodHRwczovL3RocmVlanMub3JnL2V4YW1wbGVzLyN3ZWJnbF90b25lbWFwcGluZ1xuXG4gICAgICB0aGlzLnJlbmRlcmVyLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAxOyAvLyB0aGlzLnJlbmRlcmVyLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAwLjY7XG5cbiAgICAgIHRoaXMucmVuZGVyZXIudG9uZU1hcHBpbmcgPSBUSFJFRS5BQ0VTRmlsbWljVG9uZU1hcHBpbmc7XG4gICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcignUmVuZGVyZXInLCB0aGlzLnJlbmRlcmVyLCBbe1xuICAgICAgICBrZXlOYW1lOiAndG9uZU1hcHBpbmdFeHBvc3VyZScsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiA1LFxuICAgICAgICBzdGVwOiAwLjAxXG4gICAgICB9LCB7XG4gICAgICAgIGtleU5hbWU6ICdnYW1tYUZhY3RvcicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAxMCxcbiAgICAgICAgc3RlcDogMC4wMVxuICAgICAgfV0pO1xuICAgICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoJ1JlbmRlcmVyJywgdGhpcy5yZW5kZXJlckNvbmZpZywgW3tcbiAgICAgICAga2V5TmFtZTogJ2NsZWFyQ29sb3InLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcih0aGlzLnJlbmRlcmVyQ29uZmlnLmNsZWFyQ29sb3IsIHRoaXMucmVuZGVyZXJDb25maWcuYmFja2dyb3VuZEFscGhhKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXlOYW1lOiAnYmFja2dyb3VuZEFscGhhJyxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5yZW5kZXJlckNvbmZpZy5jbGVhckNvbG9yLCB0aGlzLnJlbmRlcmVyQ29uZmlnLmJhY2tncm91bmRBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdDYW1lcmEnLCB0aGlzLmNhbWVyYSwgW3tcbiAgICAgICAga2V5TmFtZTogJ2ZvdicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiA1MCxcbiAgICAgICAgc3RlcDogMC4wMSxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5TmFtZTogJ3pvb20nLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMTAsXG4gICAgICAgIHN0ZXA6IDAuMDAwMSxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICAgIHRoaXMuZ3VpLmFkZEZvbGRlcignR2VuZXJhbCBMaWdodHMnKTtcbiAgICAgIHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnID0ge1xuICAgICAgICBhbWJpZW50TGlnaHRDb2xvcjogJyNGRkZGRkYnLFxuICAgICAgICBhbWJpZW50TGlnaHRBbHBoYTogMFxuICAgICAgfTsgLy8gQWRkaXRpb25hbCBsaWdodGluZyBvdXRzaWRlIHRoZSBibGVuZGVyLlxuICAgICAgLy8gdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCggMHhmZmZmYmIsIDB4ZmZmZmZmLCAxICk7XG4gICAgICAvLyB0aGlzLnNjZW5lLmFkZCggbGlnaHQgKTtcblxuICAgICAgdGhpcy5hbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodENvbG9yKTtcbiAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmludGVuc2l0eSA9IHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodEFscGhhO1xuICAgICAgc2NlbmUuYWRkKHRoaXMuYW1iaWVudExpZ2h0KTtcbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdHZW5lcmFsIExpZ2h0cycsIHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLCBbe1xuICAgICAgICBrZXlOYW1lOiAnYW1iaWVudExpZ2h0Q29sb3InLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodENvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXlOYW1lOiAnYW1iaWVudExpZ2h0QWxwaGEnLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmludGVuc2l0eSA9IHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodEFscGhhO1xuICAgICAgICB9XG4gICAgICB9XSk7IC8vIHZhciB3aWR0aCA9IDUwO1xuICAgICAgLy8gdmFyIGhlaWdodCA9IDUwO1xuICAgICAgLy8gdmFyIGludGVuc2l0eSA9IDA7XG4gICAgICAvLyB2YXIgcmVjdExpZ2h0ID0gbmV3IFRIUkVFLlJlY3RBcmVhTGlnaHQoJyNGRkZGRkYnLCBpbnRlbnNpdHksICB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgICAvLyByZWN0TGlnaHQucG9zaXRpb24uc2V0KCAwLCAwLCAyNSApO1xuICAgICAgLy8gLy8gcmVjdExpZ2h0Lmxvb2tBdCggMCwgMCwgMCApO1xuICAgICAgLy8gdGhpcy5zY2VuZS5hZGQoIHJlY3RMaWdodCApO1xuICAgICAgLy8gcmVjdExpZ2h0SGVscGVyID0gbmV3IFRIUkVFLlJlY3RBcmVhTGlnaHRIZWxwZXIoIHJlY3RMaWdodCApO1xuICAgICAgLy8gcmVjdExpZ2h0LmFkZCggcmVjdExpZ2h0SGVscGVyICk7XG5cbiAgICAgIHRoaXMuZ3VpLmFkZEJ1dHRvbignUmVmcmVzaCcsIHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpKTtcbiAgICB9LCB1bmRlZmluZWQsIGVycm9yID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICAvLyBwcmVjaXNpb246ICdoaWdocCdcbiAgICAgIGF1dG9TaXplOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb21wb3NlciA9IG5ldyBfRWZmZWN0Q29tcG9zZXIuRWZmZWN0Q29tcG9zZXIodGhpcy5yZW5kZXJlcik7XG4gICAgdGhpcy5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemUuYmluZCh0aGlzKSwgZmFsc2UpO1xuICB9XG5cbiAgcmVzaXplKCkge1xuICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAxLCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuY2FudmFzQ29udGFpbmVyLnBhcmVudEVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbnZhc0NvbnRhaW5lci5wYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rvbm1jY3VyZHkvdGhyZWUtZ2x0Zi12aWV3ZXIvYmxvYi9tYXN0ZXIvc3JjL3ZpZXdlci5qc1xuICAgIC8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL2NvbnN0YW50cy9SZW5kZXJlclxuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpOyAvLyBQb3N0IHByb2Nlc3NpbmdcbiAgICAvLyB0aGlzLmNvbXBvc2VyLnNldFNpemUoIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAvLyBjb25zdCBmeGFhUGFzcyA9IG5ldyBTaGFkZXJQYXNzKCBGWEFBU2hhZGVyICk7XG4gICAgLy8gZnhhYVBhc3MubWF0ZXJpYWwudW5pZm9ybXNbICdyZXNvbHV0aW9uJyBdLnZhbHVlLnggPSAxIC8gKCB0aGlzLndpZHRoICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIC8vIGZ4YWFQYXNzLm1hdGVyaWFsLnVuaWZvcm1zWyAncmVzb2x1dGlvbicgXS52YWx1ZS55ID0gMSAvICggdGhpcy5oZWlnaHQgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5hZGRQYXNzKGZ4YWFQYXNzKTtcbiAgICAvLyB0aGlzLmNvbXBvc2VyLmFkZFBhc3MobmV3IFJlbmRlclBhc3ModGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpKTtcbiAgICAvLyB2YXIgYmxvb21QYXNzID0gbmV3IFVucmVhbEJsb29tUGFzcygxLCAyNSwgNSwgMjU2KTtcbiAgICAvLyB0aGlzLmNvbXBvc2VyLmFkZFBhc3MoYmxvb21QYXNzKTtcbiAgICAvLyBUaGUgY2FtZXJhIGFzcGVjdCBnb2VzIG9mZiBzaW5jZSBpdCBjb3VsZCBiZSBleHBvcnRlZCBhdCBhIGRpZmZlcmVudFxuICAgIC8vIHJhdGlvLiAgRm9yY2UgdXBkYXRlIHRoZSBhc3BlY3QgcmF0aW8uXG5cbiAgICB0aGlzLmNhbWVyYS5hc3BlY3QgPSB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICB9XG5cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5yZW5kZXJlckNvbmZpZy5jbGVhckNvbG9yLCB0aGlzLnJlbmRlcmVyQ29uZmlnLmJhY2tncm91bmRBbHBoYSk7XG4gICAgdGhpcy5yZXNpemUoKTtcbiAgICB0aGlzLmRyYXcoKTtcbiAgfVxuXG4gIGdldEFuaW1hdGlvbkJ5TmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9ucy5maWx0ZXIoYW5pbWF0aW9uQ2xpcCA9PiB7XG4gICAgICByZXR1cm4gYW5pbWF0aW9uQ2xpcC5uYW1lID09IG5hbWU7XG4gICAgfSlbMF07XG4gIH1cblxuICBnZXRPYmplY3RCeU5hbWUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZVNjZW5lLmNoaWxkcmVuLmZpbHRlcihvYmplY3QzZCA9PiB7XG4gICAgICByZXR1cm4gb2JqZWN0M2QubmFtZSA9PSBuYW1lO1xuICAgIH0pWzBdO1xuICB9XG5cbiAgb25Qcm9ncmVzc1VwZGF0ZShwcm9ncmVzcykge1xuICAgIC8vQW5pbWF0aW9uIE1peGVy44KS5a6f6KGMXG4gICAgaWYgKHRoaXMubWl4ZXIpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZmluZCBvdXQgaG93IGxvbmcgdGhlIGFuaW1hdGlvbiBpcy5cbiAgICAgIC8vIFRoZSBtaXhlciBhcHBlYXJzIHRvIGhhdmUgbm8ga25vd2xlZGdlIG9mdCB0aGlzIHNvIHdlIG5lZWQgdG9cbiAgICAgIC8vIGxvb2sgdXAgYSBzcGVjaWZpYyBhbmltYXRpb24gYW5kIGdldCB0aGUgZHVyYXRpb24gdG9cbiAgICAgIC8vIGdldCB0aGUgdG90YWwgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgIGNvbnN0IGNhbWVyYUFuaW1hdGlvbiA9IHRoaXMuZ2V0QW5pbWF0aW9uQnlOYW1lKCdBY3Rpb24uMDAxJyk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGNhbWVyYUFuaW1hdGlvbi5kdXJhdGlvbjsgLy8gV2hlbiBkdXJhdGlvbiBoaXRzIGl0J3MgbWF4LCBhbmltYXRpb25NaXhlciBzZWVtcyB0byBoaXQgdGhlIGZpcnN0XG4gICAgICAvLyBmcmFtZSBzbyBuZXh0IGFsbG93IGl0IHRvIHJlYWNoIHRoZSBtYXggdmFsdWUuXG5cbiAgICAgIHRoaXMubWl4ZXIuc2V0VGltZShNYXRoLm1pbihkdXJhdGlvbiAqIHByb2dyZXNzLCBkdXJhdGlvbiAtIDAuMDAxKSk7XG4gICAgfVxuXG4gICAgdGhpcy5kcmF3KCk7IC8vIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgICAvLyB0aGlzLmNvbXBvc2VyLnJlbmRlcigpO1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICB0aGlzLnJlbmRlcmVyLmF1dG9DbGVhciA9IHRydWU7XG4gICAgdGhpcy5jYW1lcmEubGF5ZXJzLnNldCgwKTtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgdGhpcy5yZW5kZXJlci5hdXRvQ2xlYXIgPSBmYWxzZTsgLy8gRG9uJ3QgY2xlYXJcblxuICAgIHRoaXMuY2FtZXJhLmxheWVycy5zZXQoMSk7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gVGhyZWVPYmplY3RWaWV3ZXI3OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/three-object-viewer7.js\n");

/***/ }),

/***/ "./examples/three-object-viewer8.js":
/*!******************************************!*\
  !*** ./examples/three-object-viewer8.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _datguif = __webpack_require__(/*! ../lib/datguif/datguif */ \"./lib/datguif/datguif.js\");\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _GLTFLoader = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\nvar _EffectComposer = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n\nvar _RenderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n\nvar _UnrealBloomPass = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass.js */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n\nvar _FXAAShader = __webpack_require__(/*! three/examples/jsm/shaders/FXAAShader.js */ \"./node_modules/three/examples/jsm/shaders/FXAAShader.js\");\n\nvar _ShaderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/ShaderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/ShaderPass.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n// https://threejs.org/docs/#manual/en/introduction/Loading-3D-models\n// https://threejs.org/examples/#webgl_loader_gltf\n// https://gist.github.com/bellbind/c4f8c502fcacbe29422e5ac315273858\n// https://github.com/funwithtriangles/blender-to-threejs-export-guide/blob/master/readme.md\n// https://threejsfundamentals.org/threejs/lessons/threejs-load-gltf.html\n// https://discoverthreejs.com/book/first-steps/load-models/\n// https://www.pentacreation.com/blog/2019/09/190916.html\n// https://www.pentacreation.com/blog/2019/10/191016.html\n// https://docs.blender.org/manual/ja/latest/addons/io_scene_gltf2.html\n// https://gltf-viewer.donmccurdy.com/\n// https://github.com/donmccurdy/three-gltf-viewer\n// import { Raf } from '../lib/raf/raf';\nclass ThreeObjectViewer8 {\n  constructor() {\n    console.log('ThreeJS Object Viewer Demo');\n    this.parentElement = document.getElementById('parent');\n    this.canvasContainer = document.getElementById('canvas-container');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.rafProgress = new _rafProgress.RafProgress();\n    this.rafProgress.watch(this.onProgressUpdate.bind(this));\n    this.scrollLerp = 0.38;\n    this.scrollEase = 'easeInQuad';\n    this.rendererConfig = {\n      clearColor: '#000000',\n      backgroundAlpha: 1.0\n    };\n    this.gui = new _datguif.Datguif({\n      load: JSON\n    });\n    this.gui.addFolder('Settings').open();\n    this.gui.addFolder('Renderer', 'Settings');\n    this.gui.addFolder('Camera', 'Settings');\n    this.gui.addFolder('Scroll', 'Settings');\n    this.gui.addFolder('Lights');\n    this.gui.addFolder('Objects');\n    this.gui.addObjectToFolder('Scroll', this, [{\n      keyName: 'scrollLerp',\n      min: 0,\n      max: 1,\n      step: 0.01\n    }, {\n      keyName: 'scrollEase',\n      options: ['linear', 'easeOutQuad', 'easeInQuad']\n    }]);\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight); //   this.rafProgress.easeTo(this.progress, 0.26, EASE.easeInOutExpo);\n        //   this.rafProgress.easeTo(this.progress, 0.08, EASE.linear);\n\n        this.rafProgress.easeTo(this.progress, this.scrollLerp, _ease.EASE[this.scrollEase]);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.scene = new THREE.Scene();\n    this.gui.onUpdate(prop => {\n      this.draw();\n    });\n    var loader = new _GLTFLoader.GLTFLoader();\n    const path = './public/home/demo9.gltf';\n    loader.load(path, gltf => {\n      const gltfData = gltf.parser.json;\n\n      const getNodeByName = name => {\n        return gltfData.nodes.filter(node => {\n          return node.name = name;\n        })[0];\n      };\n\n      console.log('gltf data', gltfData);\n      this.clock = new THREE.Clock();\n      const scene = gltf.scenes[0];\n      this.activeScene = scene;\n      this.animations = gltf.animations; // Animation Mixer\n\n      this.mixer = new THREE.AnimationMixer(scene); //Animation Clip\n\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i]; //Animation Action\n\n        var action = this.mixer.clipAction(animation);\n        console.log('added', animation);\n        action.play();\n      }\n\n      this.scene.add(scene);\n      console.log('scene', scene);\n      console.log('mixer', this.mixer); // http://learningthreejs.com/blog/2012/01/20/casting-shadows/\n\n      this.scene.traverse(child => {\n        if (child instanceof THREE.Light) {\n          // child.castShadow = true;\n          // console.log('light', child);\n          // Debugging light positions.\n          // child.shadowCameraVisible = false;\n          // if(child.shadow) {\n          //     // Adjust shadow bias.\n          //     // child.shadow.bias = -0.002;\n          //     // Remove the rigged looking shadows.\n          //     // child.shadow.mapSize.width = 1024;\n          //     // child.shadow.mapSize.height = 1024;\n          //     // child.shadowDarkness = 0.5;\n          //     // child.shadow.camera.near = 0;\n          //     // child.shadow.camera.far = 1000;\n          //     // var helper = new THREE.CameraHelper( child.shadow.camera );\n          //     // scene.add( helper );\n          // }\n          // // Point lights are defined in watts which goes waay off in three.js\n          if (child instanceof THREE.PointLight) {\n            child.intensity = child.intensity * 0.0005;\n          } // If it's a spot light, it needs to go down even more.\n\n\n          if (child.type == \"SpotLight\") {\n            child.intensity = child.intensity * 0.001;\n          } // child.intensity = 0;\n\n\n          if (child.name == 'Point003_Orientation') {\n            // child.castShadow = true;\n            child.intensity = 0.6;\n          }\n\n          this.gui.addFolder(child.name, 'Lights');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'intensity',\n            min: 0,\n            max: 3000\n          }, {\n            keyName: 'color'\n          }]);\n\n          if (child.shadow) {\n            const shadowFolderId = child.name + ' shadow'; // console.log(child.shadow);\n\n            this.gui.addFolder(shadowFolderId, child.name);\n            this.gui.addObjectToFolder(shadowFolderId, child.shadow, [{\n              keyName: 'bias',\n              min: -1,\n              max: 1,\n              step: 0.00001\n            }, {\n              keyName: 'radius',\n              min: 0,\n              max: 100,\n              step: 0.01\n            }]);\n          }\n        } else if (child instanceof THREE.Mesh) {\n          // child.castShadow = true;\n          // child.receiveShadow = true;\n          // child.geometry.computeVertexNormals(true);\n          //    const lightEnabled = [\n          //         'p4-super-sm',\n          //         'p4-super-sm001',\n          //         'p4-super-sm002',\n          //     ];\n          //     if(~lightEnabled.indexOf(child.name)) {\n          //         child.layers.set(1);\n          //     }\n          this.gui.addFolder(child.name, 'Objects');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'receiveShadow'\n          }]);\n\n          if (child.material) {\n            const materialId = child.name + ' material';\n            this.gui.addFolder(materialId, child.name);\n            this.gui.addObjectToFolder(materialId, child.material, [{\n              keyName: 'emissiveIntensity',\n              min: 0,\n              max: 1\n            }, {\n              keyName: 'flatShading',\n              callback: () => {\n                child.material.needsUpdate = true;\n              }\n            }, {\n              keyName: 'wireframe',\n              callback: () => {\n                child.material.needsUpdate = true;\n              }\n            }]); // Enable smooth shading.\n            // child.material.flatShading = false;\n            // child.material.wireframe = false;\n            // child.material.needsUpdate = true;\n            // child.geometry.computeFaceNormals();\n            // child.geometry.computeVertexNormals(true);\n          }\n\n          if (child.name == 'Plane001') {\n            console.log('mesh', child);\n          } // Get the image mappings.\n          // if(child.material && child.material.map) {\n          //   child.material.map.needsUpdate = true;\n          // }\n\n        } else {// console.log('other', child);\n          }\n      }); // Set the camera exported in gltf.\n      // Requires camera to be exported for gltf.\n\n      this.camera = gltf.cameras[0];\n      console.log('camera', this.camera);\n      this.resize(); // Use fog to cover far distances.\n      // const color = 0x00000;\n      // this.scene.fog = new THREE.Fog(color, 5, 8);\n      // Enable shadows.\n      // https://threejs.org/docs/#api/en/constants/Renderer\n\n      this.renderer.shadowMap.enabled = true; // To antialias the shadow\n\n      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n      this.renderer.gammaOutput = true;\n      this.renderer.gammaFactor = 2.2; // Important to get the correct colors.\n      // this.renderer.physicallyCorrectLigts = true;\n      // Background as black.\n      // this.renderer.setClearColor(0x4287f5);\n\n      this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha); // Affects how strongly lights come exposed.\n      // https://threejs.org/examples/#webgl_tonemapping\n\n      this.renderer.toneMappingExposure = 1; // this.renderer.toneMappingExposure = 0.6;\n\n      this.renderer.toneMapping = THREE.ACESFilmicToneMapping;\n      this.gui.addObjectToFolder('Renderer', this.renderer, [{\n        keyName: 'toneMappingExposure',\n        min: 0,\n        max: 5,\n        step: 0.01\n      }, {\n        keyName: 'gammaFactor',\n        min: 0,\n        max: 10,\n        step: 0.01\n      }]);\n      this.gui.addObjectToFolder('Renderer', this.rendererConfig, [{\n        keyName: 'clearColor',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }, {\n        keyName: 'backgroundAlpha',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }]);\n      this.gui.addObjectToFolder('Camera', this.camera, [{\n        keyName: 'fov',\n        min: 0,\n        max: 50,\n        step: 0.01,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }, {\n        keyName: 'zoom',\n        min: 0,\n        max: 10,\n        step: 0.0001,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }]);\n      this.gui.addFolder('General Lights');\n      this.generalLightConfig = {\n        ambientLightColor: '##7395b3',\n        ambientLightAlpha: 1.3\n      }; // Additional lighting outside the blender.\n      // var light = new THREE.HemisphereLight( 0xffffbb, 0xffffff, 1 );\n      // this.scene.add( light );\n\n      this.ambientLight = new THREE.AmbientLight(this.generalLightConfig.ambientLightColor);\n      this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n      scene.add(this.ambientLight);\n      this.gui.addObjectToFolder('General Lights', this.generalLightConfig, [{\n        keyName: 'ambientLightColor',\n        callback: () => {\n          this.ambientLight.color = new THREE.Color(this.generalLightConfig.ambientLightColor);\n        }\n      }, {\n        keyName: 'ambientLightAlpha',\n        callback: () => {\n          this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n        }\n      }]); // var width = 50;\n      // var height = 50;\n      // var intensity = 0;\n      // var rectLight = new THREE.RectAreaLight('#FFFFFF', intensity,  width, height );\n      // rectLight.position.set( 0, 0, 25 );\n      // // rectLight.lookAt( 0, 0, 0 );\n      // this.scene.add( rectLight );\n      // rectLightHelper = new THREE.RectAreaLightHelper( rectLight );\n      // rectLight.add( rectLightHelper );\n\n      this.gui.addButton('Refresh', this.refresh.bind(this));\n    }, undefined, error => {\n      console.error(error);\n    });\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      // precision: 'highp'\n      autoSize: true\n    });\n    this.composer = new _EffectComposer.EffectComposer(this.renderer);\n    this.canvasContainer.appendChild(this.renderer.domElement);\n    window.addEventListener('resize', this.resize.bind(this), false);\n  }\n\n  resize() {\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.width = this.canvasContainer.parentElement.offsetWidth;\n    this.height = this.canvasContainer.parentElement.offsetHeight; // https://github.com/donmccurdy/three-gltf-viewer/blob/master/src/viewer.js\n    // https://threejs.org/docs/#api/en/constants/Renderer\n\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n    this.renderer.setSize(this.width, this.height); // Post processing\n    // this.composer.setSize( this.width, this.height);\n    // const fxaaPass = new ShaderPass( FXAAShader );\n    // fxaaPass.material.uniforms[ 'resolution' ].value.x = 1 / ( this.width * window.devicePixelRatio);\n    // fxaaPass.material.uniforms[ 'resolution' ].value.y = 1 / ( this.height * window.devicePixelRatio);\n    // this.composer.addPass(fxaaPass);\n    // this.composer.addPass(new RenderPass(this.scene, this.camera));\n    // var bloomPass = new Unr2.2mealBloomPass(1, 25, 5, 256);\n    // this.composer.addPass(bloomPass);\n    // The camera aspect goes off since it could be exported at a different\n    // ratio.  Force update the aspect ratio.\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n  }\n\n  refresh() {\n    this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n    this.resize();\n    this.draw();\n  }\n\n  getAnimationByName(name) {\n    return this.animations.filter(animationClip => {\n      return animationClip.name == name;\n    })[0];\n  }\n\n  getObjectByName(name) {\n    return this.activeScene.children.filter(object3d => {\n      return object3d.name == name;\n    })[0];\n  }\n\n  onProgressUpdate(progress) {\n    //Animation Mixer\n    if (this.mixer) {\n      // We need to find out how long the animation is.\n      // The mixer appears to have no knowledge oft this so we need to\n      // look up a specific animation and get the duration to\n      // get the total duration of the animation.\n      const cameraAnimation = this.getAnimationByName('Action.003');\n      const duration = cameraAnimation.duration; // When duration hits it's max, animationMixer seems to hit the first\n      // frame so next allow it to reach the max value.\n\n      this.mixer.setTime(Math.min(duration * progress, duration - 0.001));\n    }\n\n    this.draw(); // this.renderer.render(this.scene, this.camera);\n    // this.composer.render();\n  }\n\n  draw() {\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = ThreeObjectViewer8;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1vYmplY3Qtdmlld2VyOC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3RocmVlLW9iamVjdC12aWV3ZXI4LmpzP2VhMjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZGF0Z3VpZiA9IHJlcXVpcmUoXCIuLi9saWIvZGF0Z3VpZi9kYXRndWlmXCIpO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX0dMVEZMb2FkZXIgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvR0xURkxvYWRlclwiKTtcblxudmFyIF9FZmZlY3RDb21wb3NlciA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvRWZmZWN0Q29tcG9zZXJcIik7XG5cbnZhciBfUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvUmVuZGVyUGFzcy5qc1wiKTtcblxudmFyIF9VbnJlYWxCbG9vbVBhc3MgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL1VucmVhbEJsb29tUGFzcy5qc1wiKTtcblxudmFyIF9GWEFBU2hhZGVyID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9zaGFkZXJzL0ZYQUFTaGFkZXIuanNcIik7XG5cbnZhciBfU2hhZGVyUGFzcyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvU2hhZGVyUGFzcy5qc1wiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWYtcHJvZ3Jlc3NcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tXCIpO1xuXG52YXIgX2Vhc2UgPSByZXF1aXJlKFwiLi4vbGliL2Vhc2UvZWFzZVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vLyBodHRwczovL3RocmVlanMub3JnL2RvY3MvI21hbnVhbC9lbi9pbnRyb2R1Y3Rpb24vTG9hZGluZy0zRC1tb2RlbHNcbi8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZXhhbXBsZXMvI3dlYmdsX2xvYWRlcl9nbHRmXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9iZWxsYmluZC9jNGY4YzUwMmZjYWNiZTI5NDIyZTVhYzMxNTI3Mzg1OFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bndpdGh0cmlhbmdsZXMvYmxlbmRlci10by10aHJlZWpzLWV4cG9ydC1ndWlkZS9ibG9iL21hc3Rlci9yZWFkbWUubWRcbi8vIGh0dHBzOi8vdGhyZWVqc2Z1bmRhbWVudGFscy5vcmcvdGhyZWVqcy9sZXNzb25zL3RocmVlanMtbG9hZC1nbHRmLmh0bWxcbi8vIGh0dHBzOi8vZGlzY292ZXJ0aHJlZWpzLmNvbS9ib29rL2ZpcnN0LXN0ZXBzL2xvYWQtbW9kZWxzL1xuLy8gaHR0cHM6Ly93d3cucGVudGFjcmVhdGlvbi5jb20vYmxvZy8yMDE5LzA5LzE5MDkxNi5odG1sXG4vLyBodHRwczovL3d3dy5wZW50YWNyZWF0aW9uLmNvbS9ibG9nLzIwMTkvMTAvMTkxMDE2Lmh0bWxcbi8vIGh0dHBzOi8vZG9jcy5ibGVuZGVyLm9yZy9tYW51YWwvamEvbGF0ZXN0L2FkZG9ucy9pb19zY2VuZV9nbHRmMi5odG1sXG4vLyBodHRwczovL2dsdGYtdmlld2VyLmRvbm1jY3VyZHkuY29tL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rvbm1jY3VyZHkvdGhyZWUtZ2x0Zi12aWV3ZXJcbi8vIGltcG9ydCB7IFJhZiB9IGZyb20gJy4uL2xpYi9yYWYvcmFmJztcbmNsYXNzIFRocmVlT2JqZWN0Vmlld2VyOCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdUaHJlZUpTIE9iamVjdCBWaWV3ZXIgRGVtbycpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJlbnQnKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMtY29udGFpbmVyJyk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcygpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3Mud2F0Y2godGhpcy5vblByb2dyZXNzVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc2Nyb2xsTGVycCA9IDAuMzg7XG4gICAgdGhpcy5zY3JvbGxFYXNlID0gJ2Vhc2VJblF1YWQnO1xuICAgIHRoaXMucmVuZGVyZXJDb25maWcgPSB7XG4gICAgICBjbGVhckNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICBiYWNrZ3JvdW5kQWxwaGE6IDEuMFxuICAgIH07XG4gICAgdGhpcy5ndWkgPSBuZXcgX2RhdGd1aWYuRGF0Z3VpZih7XG4gICAgICBsb2FkOiBKU09OXG4gICAgfSk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdTZXR0aW5ncycpLm9wZW4oKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ1JlbmRlcmVyJywgJ1NldHRpbmdzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdDYW1lcmEnLCAnU2V0dGluZ3MnKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ1Njcm9sbCcsICdTZXR0aW5ncycpO1xuICAgIHRoaXMuZ3VpLmFkZEZvbGRlcignTGlnaHRzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdPYmplY3RzJyk7XG4gICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoJ1Njcm9sbCcsIHRoaXMsIFt7XG4gICAgICBrZXlOYW1lOiAnc2Nyb2xsTGVycCcsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEsXG4gICAgICBzdGVwOiAwLjAxXG4gICAgfSwge1xuICAgICAga2V5TmFtZTogJ3Njcm9sbEVhc2UnLFxuICAgICAgb3B0aW9uczogWydsaW5lYXInLCAnZWFzZU91dFF1YWQnLCAnZWFzZUluUXVhZCddXG4gICAgfV0pO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdzY3JvbGwnLFxuICAgICAgY2FsbGJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50LCB3aW5kb3cuaW5uZXJIZWlnaHQpOyAvLyAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDAuMjYsIEVBU0UuZWFzZUluT3V0RXhwbyk7XG4gICAgICAgIC8vICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMC4wOCwgRUFTRS5saW5lYXIpO1xuXG4gICAgICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIHRoaXMuc2Nyb2xsTGVycCwgX2Vhc2UuRUFTRVt0aGlzLnNjcm9sbEVhc2VdKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICB0aGlzLmd1aS5vblVwZGF0ZShwcm9wID0+IHtcbiAgICAgIHRoaXMuZHJhdygpO1xuICAgIH0pO1xuICAgIHZhciBsb2FkZXIgPSBuZXcgX0dMVEZMb2FkZXIuR0xURkxvYWRlcigpO1xuICAgIGNvbnN0IHBhdGggPSAnLi9wdWJsaWMvaG9tZS9kZW1vOS5nbHRmJztcbiAgICBsb2FkZXIubG9hZChwYXRoLCBnbHRmID0+IHtcbiAgICAgIGNvbnN0IGdsdGZEYXRhID0gZ2x0Zi5wYXJzZXIuanNvbjtcblxuICAgICAgY29uc3QgZ2V0Tm9kZUJ5TmFtZSA9IG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gZ2x0ZkRhdGEubm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgICAgIHJldHVybiBub2RlLm5hbWUgPSBuYW1lO1xuICAgICAgICB9KVswXTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnNvbGUubG9nKCdnbHRmIGRhdGEnLCBnbHRmRGF0YSk7XG4gICAgICB0aGlzLmNsb2NrID0gbmV3IFRIUkVFLkNsb2NrKCk7XG4gICAgICBjb25zdCBzY2VuZSA9IGdsdGYuc2NlbmVzWzBdO1xuICAgICAgdGhpcy5hY3RpdmVTY2VuZSA9IHNjZW5lO1xuICAgICAgdGhpcy5hbmltYXRpb25zID0gZ2x0Zi5hbmltYXRpb25zOyAvLyBBbmltYXRpb24gTWl4ZXLjgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJBcblxuICAgICAgdGhpcy5taXhlciA9IG5ldyBUSFJFRS5BbmltYXRpb25NaXhlcihzY2VuZSk7IC8v5YWo44Gm44GuQW5pbWF0aW9uIENsaXDjgavlr77jgZfjgaZcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc1tpXTsgLy9BbmltYXRpb24gQWN0aW9u44KS55Sf5oiQXG5cbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMubWl4ZXIuY2xpcEFjdGlvbihhbmltYXRpb24pO1xuICAgICAgICBjb25zb2xlLmxvZygnYWRkZWQnLCBhbmltYXRpb24pO1xuICAgICAgICBhY3Rpb24ucGxheSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjZW5lLmFkZChzY2VuZSk7XG4gICAgICBjb25zb2xlLmxvZygnc2NlbmUnLCBzY2VuZSk7XG4gICAgICBjb25zb2xlLmxvZygnbWl4ZXInLCB0aGlzLm1peGVyKTsgLy8gaHR0cDovL2xlYXJuaW5ndGhyZWVqcy5jb20vYmxvZy8yMDEyLzAxLzIwL2Nhc3Rpbmctc2hhZG93cy9cblxuICAgICAgdGhpcy5zY2VuZS50cmF2ZXJzZShjaGlsZCA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLkxpZ2h0KSB7XG4gICAgICAgICAgLy8gY2hpbGQuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2xpZ2h0JywgY2hpbGQpO1xuICAgICAgICAgIC8vIERlYnVnZ2luZyBsaWdodCBwb3NpdGlvbnMuXG4gICAgICAgICAgLy8gY2hpbGQuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgIC8vIGlmKGNoaWxkLnNoYWRvdykge1xuICAgICAgICAgIC8vICAgICAvLyBBZGp1c3Qgc2hhZG93IGJpYXMuXG4gICAgICAgICAgLy8gICAgIC8vIGNoaWxkLnNoYWRvdy5iaWFzID0gLTAuMDAyO1xuICAgICAgICAgIC8vICAgICAvLyBSZW1vdmUgdGhlIHJpZ2dlZCBsb29raW5nIHNoYWRvd3MuXG4gICAgICAgICAgLy8gICAgIC8vIGNoaWxkLnNoYWRvdy5tYXBTaXplLndpZHRoID0gMTAyNDtcbiAgICAgICAgICAvLyAgICAgLy8gY2hpbGQuc2hhZG93Lm1hcFNpemUuaGVpZ2h0ID0gMTAyNDtcbiAgICAgICAgICAvLyAgICAgLy8gY2hpbGQuc2hhZG93RGFya25lc3MgPSAwLjU7XG4gICAgICAgICAgLy8gICAgIC8vIGNoaWxkLnNoYWRvdy5jYW1lcmEubmVhciA9IDA7XG4gICAgICAgICAgLy8gICAgIC8vIGNoaWxkLnNoYWRvdy5jYW1lcmEuZmFyID0gMTAwMDtcbiAgICAgICAgICAvLyAgICAgLy8gdmFyIGhlbHBlciA9IG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGNoaWxkLnNoYWRvdy5jYW1lcmEgKTtcbiAgICAgICAgICAvLyAgICAgLy8gc2NlbmUuYWRkKCBoZWxwZXIgKTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgICAgLy8gLy8gUG9pbnQgbGlnaHRzIGFyZSBkZWZpbmVkIGluIHdhdHRzIHdoaWNoIGdvZXMgd2FheSBvZmYgaW4gdGhyZWUuanNcbiAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0KSB7XG4gICAgICAgICAgICBjaGlsZC5pbnRlbnNpdHkgPSBjaGlsZC5pbnRlbnNpdHkgKiAwLjAwMDU7XG4gICAgICAgICAgfSAvLyBJZiBpdCdzIGEgc3BvdCBsaWdodCwgaXQgbmVlZHMgdG8gZ28gZG93biBldmVuIG1vcmUuXG5cblxuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09IFwiU3BvdExpZ2h0XCIpIHtcbiAgICAgICAgICAgIGNoaWxkLmludGVuc2l0eSA9IGNoaWxkLmludGVuc2l0eSAqIDAuMDAxO1xuICAgICAgICAgIH0gLy8gY2hpbGQuaW50ZW5zaXR5ID0gMDtcblxuXG4gICAgICAgICAgaWYgKGNoaWxkLm5hbWUgPT0gJ1BvaW50MDAzX09yaWVudGF0aW9uJykge1xuICAgICAgICAgICAgLy8gY2hpbGQuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgICAgICBjaGlsZC5pbnRlbnNpdHkgPSAwLjY7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKGNoaWxkLm5hbWUsICdMaWdodHMnKTtcbiAgICAgICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcihjaGlsZC5uYW1lLCBjaGlsZCwgW3tcbiAgICAgICAgICAgIGtleU5hbWU6ICdjYXN0U2hhZG93J1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleU5hbWU6ICdpbnRlbnNpdHknLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAzMDAwXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5TmFtZTogJ2NvbG9yJ1xuICAgICAgICAgIH1dKTtcblxuICAgICAgICAgIGlmIChjaGlsZC5zaGFkb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd0ZvbGRlcklkID0gY2hpbGQubmFtZSArICcgc2hhZG93JzsgLy8gY29uc29sZS5sb2coY2hpbGQuc2hhZG93KTtcblxuICAgICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKHNoYWRvd0ZvbGRlcklkLCBjaGlsZC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKHNoYWRvd0ZvbGRlcklkLCBjaGlsZC5zaGFkb3csIFt7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdiaWFzJyxcbiAgICAgICAgICAgICAgbWluOiAtMSxcbiAgICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgICAgICBzdGVwOiAwLjAwMDAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdyYWRpdXMnLFxuICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgIG1heDogMTAwLFxuICAgICAgICAgICAgICBzdGVwOiAwLjAxXG4gICAgICAgICAgICB9XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICAgIC8vIGNoaWxkLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIC8vIGNoaWxkLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIC8vIGNoaWxkLmdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKHRydWUpO1xuICAgICAgICAgIC8vICAgIGNvbnN0IGxpZ2h0RW5hYmxlZCA9IFtcbiAgICAgICAgICAvLyAgICAgICAgICdwNC1zdXBlci1zbScsXG4gICAgICAgICAgLy8gICAgICAgICAncDQtc3VwZXItc20wMDEnLFxuICAgICAgICAgIC8vICAgICAgICAgJ3A0LXN1cGVyLXNtMDAyJyxcbiAgICAgICAgICAvLyAgICAgXTtcbiAgICAgICAgICAvLyAgICAgaWYofmxpZ2h0RW5hYmxlZC5pbmRleE9mKGNoaWxkLm5hbWUpKSB7XG4gICAgICAgICAgLy8gICAgICAgICBjaGlsZC5sYXllcnMuc2V0KDEpO1xuICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKGNoaWxkLm5hbWUsICdPYmplY3RzJyk7XG4gICAgICAgICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoY2hpbGQubmFtZSwgY2hpbGQsIFt7XG4gICAgICAgICAgICBrZXlOYW1lOiAnY2FzdFNoYWRvdydcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXlOYW1lOiAncmVjZWl2ZVNoYWRvdydcbiAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICBpZiAoY2hpbGQubWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsSWQgPSBjaGlsZC5uYW1lICsgJyBtYXRlcmlhbCc7XG4gICAgICAgICAgICB0aGlzLmd1aS5hZGRGb2xkZXIobWF0ZXJpYWxJZCwgY2hpbGQubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcihtYXRlcmlhbElkLCBjaGlsZC5tYXRlcmlhbCwgW3tcbiAgICAgICAgICAgICAga2V5TmFtZTogJ2VtaXNzaXZlSW50ZW5zaXR5JyxcbiAgICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgICBtYXg6IDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5TmFtZTogJ2ZsYXRTaGFkaW5nJyxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5TmFtZTogJ3dpcmVmcmFtZScsXG4gICAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7IC8vIEVuYWJsZSBzbW9vdGggc2hhZGluZy5cbiAgICAgICAgICAgIC8vIGNoaWxkLm1hdGVyaWFsLmZsYXRTaGFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBjaGlsZC5tYXRlcmlhbC53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGNoaWxkLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGNoaWxkLmdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgICAgICAgICAgLy8gY2hpbGQuZ2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHModHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoaWxkLm5hbWUgPT0gJ1BsYW5lMDAxJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ21lc2gnLCBjaGlsZCk7XG4gICAgICAgICAgfSAvLyBHZXQgdGhlIGltYWdlIG1hcHBpbmdzLlxuICAgICAgICAgIC8vIGlmKGNoaWxkLm1hdGVyaWFsICYmIGNoaWxkLm1hdGVyaWFsLm1hcCkge1xuICAgICAgICAgIC8vICAgY2hpbGQubWF0ZXJpYWwubWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgfSBlbHNlIHsvLyBjb25zb2xlLmxvZygnb3RoZXInLCBjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgfSk7IC8vIFNldCB0aGUgY2FtZXJhIGV4cG9ydGVkIGluIGdsdGYuXG4gICAgICAvLyBSZXF1aXJlcyBjYW1lcmEgdG8gYmUgZXhwb3J0ZWQgZm9yIGdsdGYuXG5cbiAgICAgIHRoaXMuY2FtZXJhID0gZ2x0Zi5jYW1lcmFzWzBdO1xuICAgICAgY29uc29sZS5sb2coJ2NhbWVyYScsIHRoaXMuY2FtZXJhKTtcbiAgICAgIHRoaXMucmVzaXplKCk7IC8vIFVzZSBmb2cgdG8gY292ZXIgZmFyIGRpc3RhbmNlcy5cbiAgICAgIC8vIGNvbnN0IGNvbG9yID0gMHgwMDAwMDtcbiAgICAgIC8vIHRoaXMuc2NlbmUuZm9nID0gbmV3IFRIUkVFLkZvZyhjb2xvciwgNSwgOCk7XG4gICAgICAvLyBFbmFibGUgc2hhZG93cy5cbiAgICAgIC8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL2NvbnN0YW50cy9SZW5kZXJlclxuXG4gICAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkID0gdHJ1ZTsgLy8gVG8gYW50aWFsaWFzIHRoZSBzaGFkb3dcblxuICAgICAgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdhbW1hT3V0cHV0ID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2FtbWFGYWN0b3IgPSAyLjI7IC8vIEltcG9ydGFudCB0byBnZXQgdGhlIGNvcnJlY3QgY29sb3JzLlxuICAgICAgLy8gdGhpcy5yZW5kZXJlci5waHlzaWNhbGx5Q29ycmVjdExpZ3RzID0gdHJ1ZTtcbiAgICAgIC8vIEJhY2tncm91bmQgYXMgYmxhY2suXG4gICAgICAvLyB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHg0Mjg3ZjUpO1xuXG4gICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5yZW5kZXJlckNvbmZpZy5jbGVhckNvbG9yLCB0aGlzLnJlbmRlcmVyQ29uZmlnLmJhY2tncm91bmRBbHBoYSk7IC8vIEFmZmVjdHMgaG93IHN0cm9uZ2x5IGxpZ2h0cyBjb21lIGV4cG9zZWQuXG4gICAgICAvLyBodHRwczovL3RocmVlanMub3JnL2V4YW1wbGVzLyN3ZWJnbF90b25lbWFwcGluZ1xuXG4gICAgICB0aGlzLnJlbmRlcmVyLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAxOyAvLyB0aGlzLnJlbmRlcmVyLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAwLjY7XG5cbiAgICAgIHRoaXMucmVuZGVyZXIudG9uZU1hcHBpbmcgPSBUSFJFRS5BQ0VTRmlsbWljVG9uZU1hcHBpbmc7XG4gICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcignUmVuZGVyZXInLCB0aGlzLnJlbmRlcmVyLCBbe1xuICAgICAgICBrZXlOYW1lOiAndG9uZU1hcHBpbmdFeHBvc3VyZScsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiA1LFxuICAgICAgICBzdGVwOiAwLjAxXG4gICAgICB9LCB7XG4gICAgICAgIGtleU5hbWU6ICdnYW1tYUZhY3RvcicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAxMCxcbiAgICAgICAgc3RlcDogMC4wMVxuICAgICAgfV0pO1xuICAgICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoJ1JlbmRlcmVyJywgdGhpcy5yZW5kZXJlckNvbmZpZywgW3tcbiAgICAgICAga2V5TmFtZTogJ2NsZWFyQ29sb3InLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcih0aGlzLnJlbmRlcmVyQ29uZmlnLmNsZWFyQ29sb3IsIHRoaXMucmVuZGVyZXJDb25maWcuYmFja2dyb3VuZEFscGhhKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXlOYW1lOiAnYmFja2dyb3VuZEFscGhhJyxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5yZW5kZXJlckNvbmZpZy5jbGVhckNvbG9yLCB0aGlzLnJlbmRlcmVyQ29uZmlnLmJhY2tncm91bmRBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdDYW1lcmEnLCB0aGlzLmNhbWVyYSwgW3tcbiAgICAgICAga2V5TmFtZTogJ2ZvdicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiA1MCxcbiAgICAgICAgc3RlcDogMC4wMSxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5TmFtZTogJ3pvb20nLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMTAsXG4gICAgICAgIHN0ZXA6IDAuMDAwMSxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICAgIHRoaXMuZ3VpLmFkZEZvbGRlcignR2VuZXJhbCBMaWdodHMnKTtcbiAgICAgIHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnID0ge1xuICAgICAgICBhbWJpZW50TGlnaHRDb2xvcjogJyMjNzM5NWIzJyxcbiAgICAgICAgYW1iaWVudExpZ2h0QWxwaGE6IDEuM1xuICAgICAgfTsgLy8gQWRkaXRpb25hbCBsaWdodGluZyBvdXRzaWRlIHRoZSBibGVuZGVyLlxuICAgICAgLy8gdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCggMHhmZmZmYmIsIDB4ZmZmZmZmLCAxICk7XG4gICAgICAvLyB0aGlzLnNjZW5lLmFkZCggbGlnaHQgKTtcblxuICAgICAgdGhpcy5hbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodENvbG9yKTtcbiAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmludGVuc2l0eSA9IHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodEFscGhhO1xuICAgICAgc2NlbmUuYWRkKHRoaXMuYW1iaWVudExpZ2h0KTtcbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdHZW5lcmFsIExpZ2h0cycsIHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLCBbe1xuICAgICAgICBrZXlOYW1lOiAnYW1iaWVudExpZ2h0Q29sb3InLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodENvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXlOYW1lOiAnYW1iaWVudExpZ2h0QWxwaGEnLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmludGVuc2l0eSA9IHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodEFscGhhO1xuICAgICAgICB9XG4gICAgICB9XSk7IC8vIHZhciB3aWR0aCA9IDUwO1xuICAgICAgLy8gdmFyIGhlaWdodCA9IDUwO1xuICAgICAgLy8gdmFyIGludGVuc2l0eSA9IDA7XG4gICAgICAvLyB2YXIgcmVjdExpZ2h0ID0gbmV3IFRIUkVFLlJlY3RBcmVhTGlnaHQoJyNGRkZGRkYnLCBpbnRlbnNpdHksICB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgICAvLyByZWN0TGlnaHQucG9zaXRpb24uc2V0KCAwLCAwLCAyNSApO1xuICAgICAgLy8gLy8gcmVjdExpZ2h0Lmxvb2tBdCggMCwgMCwgMCApO1xuICAgICAgLy8gdGhpcy5zY2VuZS5hZGQoIHJlY3RMaWdodCApO1xuICAgICAgLy8gcmVjdExpZ2h0SGVscGVyID0gbmV3IFRIUkVFLlJlY3RBcmVhTGlnaHRIZWxwZXIoIHJlY3RMaWdodCApO1xuICAgICAgLy8gcmVjdExpZ2h0LmFkZCggcmVjdExpZ2h0SGVscGVyICk7XG5cbiAgICAgIHRoaXMuZ3VpLmFkZEJ1dHRvbignUmVmcmVzaCcsIHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpKTtcbiAgICB9LCB1bmRlZmluZWQsIGVycm9yID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICAvLyBwcmVjaXNpb246ICdoaWdocCdcbiAgICAgIGF1dG9TaXplOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb21wb3NlciA9IG5ldyBfRWZmZWN0Q29tcG9zZXIuRWZmZWN0Q29tcG9zZXIodGhpcy5yZW5kZXJlcik7XG4gICAgdGhpcy5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemUuYmluZCh0aGlzKSwgZmFsc2UpO1xuICB9XG5cbiAgcmVzaXplKCkge1xuICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAxLCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuY2FudmFzQ29udGFpbmVyLnBhcmVudEVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbnZhc0NvbnRhaW5lci5wYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rvbm1jY3VyZHkvdGhyZWUtZ2x0Zi12aWV3ZXIvYmxvYi9tYXN0ZXIvc3JjL3ZpZXdlci5qc1xuICAgIC8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL2NvbnN0YW50cy9SZW5kZXJlclxuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpOyAvLyBQb3N0IHByb2Nlc3NpbmdcbiAgICAvLyB0aGlzLmNvbXBvc2VyLnNldFNpemUoIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAvLyBjb25zdCBmeGFhUGFzcyA9IG5ldyBTaGFkZXJQYXNzKCBGWEFBU2hhZGVyICk7XG4gICAgLy8gZnhhYVBhc3MubWF0ZXJpYWwudW5pZm9ybXNbICdyZXNvbHV0aW9uJyBdLnZhbHVlLnggPSAxIC8gKCB0aGlzLndpZHRoICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIC8vIGZ4YWFQYXNzLm1hdGVyaWFsLnVuaWZvcm1zWyAncmVzb2x1dGlvbicgXS52YWx1ZS55ID0gMSAvICggdGhpcy5oZWlnaHQgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5hZGRQYXNzKGZ4YWFQYXNzKTtcbiAgICAvLyB0aGlzLmNvbXBvc2VyLmFkZFBhc3MobmV3IFJlbmRlclBhc3ModGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpKTtcbiAgICAvLyB2YXIgYmxvb21QYXNzID0gbmV3IFVucjIuMm1lYWxCbG9vbVBhc3MoMSwgMjUsIDUsIDI1Nik7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5hZGRQYXNzKGJsb29tUGFzcyk7XG4gICAgLy8gVGhlIGNhbWVyYSBhc3BlY3QgZ29lcyBvZmYgc2luY2UgaXQgY291bGQgYmUgZXhwb3J0ZWQgYXQgYSBkaWZmZXJlbnRcbiAgICAvLyByYXRpby4gIEZvcmNlIHVwZGF0ZSB0aGUgYXNwZWN0IHJhdGlvLlxuXG4gICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMucmVuZGVyZXJDb25maWcuY2xlYXJDb2xvciwgdGhpcy5yZW5kZXJlckNvbmZpZy5iYWNrZ3JvdW5kQWxwaGEpO1xuICAgIHRoaXMucmVzaXplKCk7XG4gICAgdGhpcy5kcmF3KCk7XG4gIH1cblxuICBnZXRBbmltYXRpb25CeU5hbWUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnMuZmlsdGVyKGFuaW1hdGlvbkNsaXAgPT4ge1xuICAgICAgcmV0dXJuIGFuaW1hdGlvbkNsaXAubmFtZSA9PSBuYW1lO1xuICAgIH0pWzBdO1xuICB9XG5cbiAgZ2V0T2JqZWN0QnlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVTY2VuZS5jaGlsZHJlbi5maWx0ZXIob2JqZWN0M2QgPT4ge1xuICAgICAgcmV0dXJuIG9iamVjdDNkLm5hbWUgPT0gbmFtZTtcbiAgICB9KVswXTtcbiAgfVxuXG4gIG9uUHJvZ3Jlc3NVcGRhdGUocHJvZ3Jlc3MpIHtcbiAgICAvL0FuaW1hdGlvbiBNaXhlcuOCkuWun+ihjFxuICAgIGlmICh0aGlzLm1peGVyKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGZpbmQgb3V0IGhvdyBsb25nIHRoZSBhbmltYXRpb24gaXMuXG4gICAgICAvLyBUaGUgbWl4ZXIgYXBwZWFycyB0byBoYXZlIG5vIGtub3dsZWRnZSBvZnQgdGhpcyBzbyB3ZSBuZWVkIHRvXG4gICAgICAvLyBsb29rIHVwIGEgc3BlY2lmaWMgYW5pbWF0aW9uIGFuZCBnZXQgdGhlIGR1cmF0aW9uIHRvXG4gICAgICAvLyBnZXQgdGhlIHRvdGFsIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICBjb25zdCBjYW1lcmFBbmltYXRpb24gPSB0aGlzLmdldEFuaW1hdGlvbkJ5TmFtZSgnQWN0aW9uLjAwMycpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBjYW1lcmFBbmltYXRpb24uZHVyYXRpb247IC8vIFdoZW4gZHVyYXRpb24gaGl0cyBpdCdzIG1heCwgYW5pbWF0aW9uTWl4ZXIgc2VlbXMgdG8gaGl0IHRoZSBmaXJzdFxuICAgICAgLy8gZnJhbWUgc28gbmV4dCBhbGxvdyBpdCB0byByZWFjaCB0aGUgbWF4IHZhbHVlLlxuXG4gICAgICB0aGlzLm1peGVyLnNldFRpbWUoTWF0aC5taW4oZHVyYXRpb24gKiBwcm9ncmVzcywgZHVyYXRpb24gLSAwLjAwMSkpO1xuICAgIH1cblxuICAgIHRoaXMuZHJhdygpOyAvLyB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5yZW5kZXIoKTtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gVGhyZWVPYmplY3RWaWV3ZXI4OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/three-object-viewer8.js\n");

/***/ }),

/***/ "./examples/three-object-viewer9.js":
/*!******************************************!*\
  !*** ./examples/three-object-viewer9.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _datguif = __webpack_require__(/*! ../lib/datguif/datguif */ \"./lib/datguif/datguif.js\");\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _GLTFLoader = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\nvar _EffectComposer = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n\nvar _RenderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n\nvar _UnrealBloomPass = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass.js */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n\nvar _FXAAShader = __webpack_require__(/*! three/examples/jsm/shaders/FXAAShader.js */ \"./node_modules/three/examples/jsm/shaders/FXAAShader.js\");\n\nvar _ShaderPass = __webpack_require__(/*! three/examples/jsm/postprocessing/ShaderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/ShaderPass.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n// https://threejs.org/docs/#manual/en/introduction/Loading-3D-models\n// https://threejs.org/examples/#webgl_loader_gltf\n// https://gist.github.com/bellbind/c4f8c502fcacbe29422e5ac315273858\n// https://github.com/funwithtriangles/blender-to-threejs-export-guide/blob/master/readme.md\n// https://threejsfundamentals.org/threejs/lessons/threejs-load-gltf.html\n// https://discoverthreejs.com/book/first-steps/load-models/\n// https://www.pentacreation.com/blog/2019/09/190916.html\n// https://www.pentacreation.com/blog/2019/10/191016.html\n// https://docs.blender.org/manual/ja/latest/addons/io_scene_gltf2.html\n// https://gltf-viewer.donmccurdy.com/\n// https://github.com/donmccurdy/three-gltf-viewer\n// import { Raf } from '../lib/raf/raf';\nclass ThreeObjectViewer9 {\n  constructor() {\n    console.log('ThreeJS Object Viewer Demo');\n    this.parentElement = document.getElementById('parent');\n    this.canvasContainer = document.getElementById('canvas-container');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.rafProgress = new _rafProgress.RafProgress();\n    this.rafProgress.watch(this.onProgressUpdate.bind(this));\n    this.scrollLerp = 0.38;\n    this.scrollEase = 'easeInQuad';\n    this.rendererConfig = {\n      clearColor: '#C7C5B8',\n      backgroundAlpha: 1.0\n    };\n    this.gui = new _datguif.Datguif({\n      load: JSON\n    });\n    this.gui.addFolder('Settings').open();\n    this.gui.addFolder('Renderer', 'Settings');\n    this.gui.addFolder('Camera', 'Settings');\n    this.gui.addFolder('Scroll', 'Settings');\n    this.gui.addFolder('Lights');\n    this.gui.addFolder('Objects');\n    this.gui.addObjectToFolder('Scroll', this, [{\n      keyName: 'scrollLerp',\n      min: 0,\n      max: 1,\n      step: 0.01\n    }, {\n      keyName: 'scrollEase',\n      options: ['linear', 'easeOutQuad', 'easeInQuad']\n    }]);\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight); //   this.rafProgress.easeTo(this.progress, 0.26, EASE.easeInOutExpo);\n        //   this.rafProgress.easeTo(this.progress, 0.08, EASE.linear);\n\n        this.rafProgress.easeTo(this.progress, this.scrollLerp, _ease.EASE[this.scrollEase]);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    this.scene = new THREE.Scene();\n    this.gui.onUpdate(prop => {\n      this.draw();\n    });\n    var loader = new _GLTFLoader.GLTFLoader();\n    const path = './public/home/demo10.gltf';\n    loader.load(path, gltf => {\n      const gltfData = gltf.parser.json;\n\n      const getNodeByName = name => {\n        return gltfData.nodes.filter(node => {\n          return node.name = name;\n        })[0];\n      };\n\n      console.log('gltf data', gltfData);\n      this.clock = new THREE.Clock();\n      const scene = gltf.scenes[0];\n      this.activeScene = scene;\n      this.animations = gltf.animations; // Animation Mixer\n\n      this.mixer = new THREE.AnimationMixer(scene); //Animation Clip\n\n      for (var i = 0; i < this.animations.length; i++) {\n        var animation = this.animations[i]; //Animation Action\n\n        var action = this.mixer.clipAction(animation);\n        console.log('added', animation);\n        action.play();\n      }\n\n      this.scene.add(scene);\n      console.log('scene', scene);\n      console.log('mixer', this.mixer); // http://learningthreejs.com/blog/2012/01/20/casting-shadows/\n\n      this.scene.traverse(child => {\n        if (child instanceof THREE.Light) {\n          // child.castShadow = true;\n          // console.log('light', child);\n          // Debugging light positions.\n          // child.shadowCameraVisible = false;\n          // if(child.shadow) {\n          //     // Adjust shadow bias.\n          //     // child.shadow.bias = -0.002;\n          //     // Remove the rigged looking shadows.\n          //     // child.shadow.mapSize.width = 1024;\n          //     // child.shadow.mapSize.height = 1024;\n          //     // child.shadowDarkness = 0.5;\n          //     // child.shadow.camera.near = 0;\n          //     // child.shadow.camera.far = 1000;\n          //     // var helper = new THREE.CameraHelper( child.shadow.camera );\n          //     // scene.add( helper );\n          // }\n          child.layers.set(1); // // Point lights are defined in watts which goes waay off in three.js\n\n          if (child instanceof THREE.PointLight) {\n            child.intensity = child.intensity * 0.0005;\n          } // If it's a spot light, it needs to go down even more.\n\n\n          if (child.type == \"SpotLight\") {\n            child.intensity = child.intensity * 0.001;\n          } // child.intensity = 0;\n\n\n          if (child.name == 'Point_Orientation') {\n            // child.castShadow = true;\n            child.intensity = 4.6;\n          }\n\n          this.gui.addFolder(child.name, 'Lights');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'intensity',\n            min: 0,\n            max: 3000\n          }, {\n            keyName: 'color'\n          }]);\n\n          if (child.shadow) {\n            const shadowFolderId = child.name + ' shadow'; // console.log(child.shadow);\n\n            this.gui.addFolder(shadowFolderId, child.name);\n            this.gui.addObjectToFolder(shadowFolderId, child.shadow, [{\n              keyName: 'bias',\n              min: -1,\n              max: 1,\n              step: 0.00001\n            }, {\n              keyName: 'radius',\n              min: 0,\n              max: 100,\n              step: 0.01\n            }]);\n          }\n        } else if (child instanceof THREE.Mesh) {\n          // child.castShadow = true;\n          // child.receiveShadow = true;\n          // child.geometry.computeVertexNormals(true);\n          const lightEnabled = ['p4-super-sm', 'p4-super-sm001', 'p4-super-sm002'];\n\n          if (~lightEnabled.indexOf(child.name)) {\n            child.layers.set(1);\n          }\n\n          this.gui.addFolder(child.name, 'Objects');\n          this.gui.addObjectToFolder(child.name, child, [{\n            keyName: 'castShadow'\n          }, {\n            keyName: 'receiveShadow'\n          }]);\n\n          if (child.material) {\n            const materialId = child.name + ' material';\n            this.gui.addFolder(materialId, child.name);\n            this.gui.addObjectToFolder(materialId, child.material, [{\n              keyName: 'emissiveIntensity',\n              min: 0,\n              max: 1\n            }, {\n              keyName: 'flatShading',\n              callback: () => {\n                child.material.needsUpdate = true;\n              }\n            }, {\n              keyName: 'wireframe',\n              callback: () => {\n                child.material.needsUpdate = true;\n              }\n            }]); // Enable smooth shading.\n            // child.material.flatShading = false;\n            // child.material.wireframe = false;\n            // child.material.needsUpdate = true;\n            // child.geometry.computeFaceNormals();\n            // child.geometry.computeVertexNormals(true);\n          }\n\n          if (child.name == 'Plane001') {\n            console.log('mesh', child);\n          } // Get the image mappings.\n          // if(child.material && child.material.map) {\n          //   child.material.map.needsUpdate = true;\n          // }\n\n        } else {// console.log('other', child);\n          }\n      }); // Set the camera exported in gltf.\n      // Requires camera to be exported for gltf.\n\n      this.camera = gltf.cameras[0];\n      console.log('camera', this.camera);\n      this.resize(); // Use fog to cover far distances.\n      // const color = 0x00000;\n      // this.scene.fog = new THREE.Fog(color, 5, 8);\n      // Enable shadows.\n      // https://threejs.org/docs/#api/en/constants/Renderer\n\n      this.renderer.shadowMap.enabled = true; // To antialias the shadow\n\n      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n      this.renderer.gammaOutput = true;\n      this.renderer.gammaFactor = 2.2; // Important to get the correct colors.\n      // this.renderer.physicallyCorrectLigts = true;\n      // Background as black.\n      // this.renderer.setClearColor(0x4287f5);\n\n      this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha); // Affects how strongly lights come exposed.\n      // https://threejs.org/examples/#webgl_tonemapping\n\n      this.renderer.toneMappingExposure = 1; // this.renderer.toneMappingExposure = 0.6;\n\n      this.renderer.toneMapping = THREE.ACESFilmicToneMapping;\n      this.gui.addObjectToFolder('Renderer', this.renderer, [{\n        keyName: 'toneMappingExposure',\n        min: 0,\n        max: 5,\n        step: 0.01\n      }, {\n        keyName: 'gammaFactor',\n        min: 0,\n        max: 10,\n        step: 0.01\n      }]);\n      this.gui.addObjectToFolder('Renderer', this.rendererConfig, [{\n        keyName: 'clearColor',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }, {\n        keyName: 'backgroundAlpha',\n        callback: () => {\n          this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n        }\n      }]);\n      this.gui.addObjectToFolder('Camera', this.camera, [{\n        keyName: 'fov',\n        min: 0,\n        max: 50,\n        step: 0.01,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }, {\n        keyName: 'zoom',\n        min: 0,\n        max: 10,\n        step: 0.0001,\n        callback: () => {\n          this.camera.updateProjectionMatrix();\n        }\n      }]);\n      this.gui.addFolder('General Lights');\n      this.generalLightConfig = {\n        ambientLightColor: '#7395b3',\n        ambientLightAlpha: 0\n      }; // Additional lighting outside the blender.\n      // var light = new THREE.HemisphereLight( 0xffffbb, 0xffffff, 1 );\n      // this.scene.add( light );\n\n      this.ambientLight = new THREE.AmbientLight(this.generalLightConfig.ambientLightColor);\n      this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n      scene.add(this.ambientLight);\n      this.gui.addObjectToFolder('General Lights', this.generalLightConfig, [{\n        keyName: 'ambientLightColor',\n        callback: () => {\n          this.ambientLight.color = new THREE.Color(this.generalLightConfig.ambientLightColor);\n        }\n      }, {\n        keyName: 'ambientLightAlpha',\n        callback: () => {\n          this.ambientLight.intensity = this.generalLightConfig.ambientLightAlpha;\n        }\n      }]); // var width = 50;\n      // var height = 50;\n      // var intensity = 0;\n      // var rectLight = new THREE.RectAreaLight('#FFFFFF', intensity,  width, height );\n      // rectLight.position.set( 0, 0, 25 );\n      // // rectLight.lookAt( 0, 0, 0 );\n      // this.scene.add( rectLight );\n      // rectLightHelper = new THREE.RectAreaLightHelper( rectLight );\n      // rectLight.add( rectLightHelper );\n\n      this.gui.addButton('Refresh', this.refresh.bind(this));\n    }, undefined, error => {\n      console.error(error);\n    });\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      // precision: 'highp'\n      autoSize: true\n    });\n    this.composer = new _EffectComposer.EffectComposer(this.renderer);\n    this.canvasContainer.appendChild(this.renderer.domElement);\n    window.addEventListener('resize', this.resize.bind(this), false);\n  }\n\n  resize() {\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement, window.innerHeight);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.width = this.canvasContainer.parentElement.offsetWidth;\n    this.height = this.canvasContainer.parentElement.offsetHeight; // https://github.com/donmccurdy/three-gltf-viewer/blob/master/src/viewer.js\n    // https://threejs.org/docs/#api/en/constants/Renderer\n\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n    this.renderer.setSize(this.width, this.height); // Post processing\n    // this.composer.setSize( this.width, this.height);\n    // const fxaaPass = new ShaderPass( FXAAShader );\n    // fxaaPass.material.uniforms[ 'resolution' ].value.x = 1 / ( this.width * window.devicePixelRatio);\n    // fxaaPass.material.uniforms[ 'resolution' ].value.y = 1 / ( this.height * window.devicePixelRatio);\n    // this.composer.addPass(fxaaPass);\n    // this.composer.addPass(new RenderPass(this.scene, this.camera));\n    // var bloomPass = new Unr2.2mealBloomPass(1, 25, 5, 256);\n    // this.composer.addPass(bloomPass);\n    // The camera aspect goes off since it could be exported at a different\n    // ratio.  Force update the aspect ratio.\n\n    this.camera.aspect = this.width / this.height;\n    this.camera.updateProjectionMatrix();\n  }\n\n  refresh() {\n    this.renderer.setClearColor(this.rendererConfig.clearColor, this.rendererConfig.backgroundAlpha);\n    this.resize();\n    this.draw();\n  }\n\n  getAnimationByName(name) {\n    return this.animations.filter(animationClip => {\n      return animationClip.name == name;\n    })[0];\n  }\n\n  getObjectByName(name) {\n    return this.activeScene.children.filter(object3d => {\n      return object3d.name == name;\n    })[0];\n  }\n\n  onProgressUpdate(progress) {\n    //Animation Mixer\n    if (this.mixer) {\n      // We need to find out how long the animation is.\n      // The mixer appears to have no knowledge oft this so we need to\n      // look up a specific animation and get the duration to\n      // get the total duration of the animation.\n      const cameraAnimation = this.getAnimationByName('CameraAction.004');\n      const duration = cameraAnimation.duration; // When duration hits it's max, animationMixer seems to hit the first\n      // frame so next allow it to reach the max value.\n\n      this.mixer.setTime(Math.min(duration * progress, duration - 0.001));\n    }\n\n    this.draw(); // this.renderer.render(this.scene, this.camera);\n    // this.composer.render();\n  }\n\n  draw() {\n    this.renderer.autoClear = true;\n    this.camera.layers.set(0);\n    this.renderer.render(this.scene, this.camera);\n    this.renderer.autoClear = false; // Don't clear\n\n    this.camera.layers.set(1);\n    this.renderer.render(this.scene, this.camera);\n  }\n\n}\n\nexports.default = ThreeObjectViewer9;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1vYmplY3Qtdmlld2VyOS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3RocmVlLW9iamVjdC12aWV3ZXI5LmpzPzg0MDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZGF0Z3VpZiA9IHJlcXVpcmUoXCIuLi9saWIvZGF0Z3VpZi9kYXRndWlmXCIpO1xuXG52YXIgX3RocmVlID0gcmVxdWlyZShcInRocmVlXCIpO1xuXG52YXIgVEhSRUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdGhyZWUpO1xuXG52YXIgX0dMVEZMb2FkZXIgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL2xvYWRlcnMvR0xURkxvYWRlclwiKTtcblxudmFyIF9FZmZlY3RDb21wb3NlciA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvRWZmZWN0Q29tcG9zZXJcIik7XG5cbnZhciBfUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvUmVuZGVyUGFzcy5qc1wiKTtcblxudmFyIF9VbnJlYWxCbG9vbVBhc3MgPSByZXF1aXJlKFwidGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL1VucmVhbEJsb29tUGFzcy5qc1wiKTtcblxudmFyIF9GWEFBU2hhZGVyID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9zaGFkZXJzL0ZYQUFTaGFkZXIuanNcIik7XG5cbnZhciBfU2hhZGVyUGFzcyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvU2hhZGVyUGFzcy5qc1wiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWYtcHJvZ3Jlc3NcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tXCIpO1xuXG52YXIgX2Vhc2UgPSByZXF1aXJlKFwiLi4vbGliL2Vhc2UvZWFzZVwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vLyBodHRwczovL3RocmVlanMub3JnL2RvY3MvI21hbnVhbC9lbi9pbnRyb2R1Y3Rpb24vTG9hZGluZy0zRC1tb2RlbHNcbi8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZXhhbXBsZXMvI3dlYmdsX2xvYWRlcl9nbHRmXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9iZWxsYmluZC9jNGY4YzUwMmZjYWNiZTI5NDIyZTVhYzMxNTI3Mzg1OFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bndpdGh0cmlhbmdsZXMvYmxlbmRlci10by10aHJlZWpzLWV4cG9ydC1ndWlkZS9ibG9iL21hc3Rlci9yZWFkbWUubWRcbi8vIGh0dHBzOi8vdGhyZWVqc2Z1bmRhbWVudGFscy5vcmcvdGhyZWVqcy9sZXNzb25zL3RocmVlanMtbG9hZC1nbHRmLmh0bWxcbi8vIGh0dHBzOi8vZGlzY292ZXJ0aHJlZWpzLmNvbS9ib29rL2ZpcnN0LXN0ZXBzL2xvYWQtbW9kZWxzL1xuLy8gaHR0cHM6Ly93d3cucGVudGFjcmVhdGlvbi5jb20vYmxvZy8yMDE5LzA5LzE5MDkxNi5odG1sXG4vLyBodHRwczovL3d3dy5wZW50YWNyZWF0aW9uLmNvbS9ibG9nLzIwMTkvMTAvMTkxMDE2Lmh0bWxcbi8vIGh0dHBzOi8vZG9jcy5ibGVuZGVyLm9yZy9tYW51YWwvamEvbGF0ZXN0L2FkZG9ucy9pb19zY2VuZV9nbHRmMi5odG1sXG4vLyBodHRwczovL2dsdGYtdmlld2VyLmRvbm1jY3VyZHkuY29tL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rvbm1jY3VyZHkvdGhyZWUtZ2x0Zi12aWV3ZXJcbi8vIGltcG9ydCB7IFJhZiB9IGZyb20gJy4uL2xpYi9yYWYvcmFmJztcbmNsYXNzIFRocmVlT2JqZWN0Vmlld2VyOSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdUaHJlZUpTIE9iamVjdCBWaWV3ZXIgRGVtbycpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJlbnQnKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMtY29udGFpbmVyJyk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcygpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3Mud2F0Y2godGhpcy5vblByb2dyZXNzVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc2Nyb2xsTGVycCA9IDAuMzg7XG4gICAgdGhpcy5zY3JvbGxFYXNlID0gJ2Vhc2VJblF1YWQnO1xuICAgIHRoaXMucmVuZGVyZXJDb25maWcgPSB7XG4gICAgICBjbGVhckNvbG9yOiAnI0M3QzVCOCcsXG4gICAgICBiYWNrZ3JvdW5kQWxwaGE6IDEuMFxuICAgIH07XG4gICAgdGhpcy5ndWkgPSBuZXcgX2RhdGd1aWYuRGF0Z3VpZih7XG4gICAgICBsb2FkOiBKU09OXG4gICAgfSk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdTZXR0aW5ncycpLm9wZW4oKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ1JlbmRlcmVyJywgJ1NldHRpbmdzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdDYW1lcmEnLCAnU2V0dGluZ3MnKTtcbiAgICB0aGlzLmd1aS5hZGRGb2xkZXIoJ1Njcm9sbCcsICdTZXR0aW5ncycpO1xuICAgIHRoaXMuZ3VpLmFkZEZvbGRlcignTGlnaHRzJyk7XG4gICAgdGhpcy5ndWkuYWRkRm9sZGVyKCdPYmplY3RzJyk7XG4gICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoJ1Njcm9sbCcsIHRoaXMsIFt7XG4gICAgICBrZXlOYW1lOiAnc2Nyb2xsTGVycCcsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEsXG4gICAgICBzdGVwOiAwLjAxXG4gICAgfSwge1xuICAgICAga2V5TmFtZTogJ3Njcm9sbEVhc2UnLFxuICAgICAgb3B0aW9uczogWydsaW5lYXInLCAnZWFzZU91dFF1YWQnLCAnZWFzZUluUXVhZCddXG4gICAgfV0pO1xuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdzY3JvbGwnLFxuICAgICAgY2FsbGJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50LCB3aW5kb3cuaW5uZXJIZWlnaHQpOyAvLyAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDAuMjYsIEVBU0UuZWFzZUluT3V0RXhwbyk7XG4gICAgICAgIC8vICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMC4wOCwgRUFTRS5saW5lYXIpO1xuXG4gICAgICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIHRoaXMuc2Nyb2xsTGVycCwgX2Vhc2UuRUFTRVt0aGlzLnNjcm9sbEVhc2VdKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICB0aGlzLmd1aS5vblVwZGF0ZShwcm9wID0+IHtcbiAgICAgIHRoaXMuZHJhdygpO1xuICAgIH0pO1xuICAgIHZhciBsb2FkZXIgPSBuZXcgX0dMVEZMb2FkZXIuR0xURkxvYWRlcigpO1xuICAgIGNvbnN0IHBhdGggPSAnLi9wdWJsaWMvaG9tZS9kZW1vMTAuZ2x0Zic7XG4gICAgbG9hZGVyLmxvYWQocGF0aCwgZ2x0ZiA9PiB7XG4gICAgICBjb25zdCBnbHRmRGF0YSA9IGdsdGYucGFyc2VyLmpzb247XG5cbiAgICAgIGNvbnN0IGdldE5vZGVCeU5hbWUgPSBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIGdsdGZEYXRhLm5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgICAgICByZXR1cm4gbm9kZS5uYW1lID0gbmFtZTtcbiAgICAgICAgfSlbMF07XG4gICAgICB9O1xuXG4gICAgICBjb25zb2xlLmxvZygnZ2x0ZiBkYXRhJywgZ2x0ZkRhdGEpO1xuICAgICAgdGhpcy5jbG9jayA9IG5ldyBUSFJFRS5DbG9jaygpO1xuICAgICAgY29uc3Qgc2NlbmUgPSBnbHRmLnNjZW5lc1swXTtcbiAgICAgIHRoaXMuYWN0aXZlU2NlbmUgPSBzY2VuZTtcbiAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGdsdGYuYW5pbWF0aW9uczsgLy8gQW5pbWF0aW9uIE1peGVy44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQXG5cbiAgICAgIHRoaXMubWl4ZXIgPSBuZXcgVEhSRUUuQW5pbWF0aW9uTWl4ZXIoc2NlbmUpOyAvL+WFqOOBpuOBrkFuaW1hdGlvbiBDbGlw44Gr5a++44GX44GmXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNbaV07IC8vQW5pbWF0aW9uIEFjdGlvbuOCkueUn+aIkFxuXG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLm1peGVyLmNsaXBBY3Rpb24oYW5pbWF0aW9uKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2FkZGVkJywgYW5pbWF0aW9uKTtcbiAgICAgICAgYWN0aW9uLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY2VuZS5hZGQoc2NlbmUpO1xuICAgICAgY29uc29sZS5sb2coJ3NjZW5lJywgc2NlbmUpO1xuICAgICAgY29uc29sZS5sb2coJ21peGVyJywgdGhpcy5taXhlcik7IC8vIGh0dHA6Ly9sZWFybmluZ3RocmVlanMuY29tL2Jsb2cvMjAxMi8wMS8yMC9jYXN0aW5nLXNoYWRvd3MvXG5cbiAgICAgIHRoaXMuc2NlbmUudHJhdmVyc2UoY2hpbGQgPT4ge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCkge1xuICAgICAgICAgIC8vIGNoaWxkLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdsaWdodCcsIGNoaWxkKTtcbiAgICAgICAgICAvLyBEZWJ1Z2dpbmcgbGlnaHQgcG9zaXRpb25zLlxuICAgICAgICAgIC8vIGNoaWxkLnNoYWRvd0NhbWVyYVZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAvLyBpZihjaGlsZC5zaGFkb3cpIHtcbiAgICAgICAgICAvLyAgICAgLy8gQWRqdXN0IHNoYWRvdyBiaWFzLlxuICAgICAgICAgIC8vICAgICAvLyBjaGlsZC5zaGFkb3cuYmlhcyA9IC0wLjAwMjtcbiAgICAgICAgICAvLyAgICAgLy8gUmVtb3ZlIHRoZSByaWdnZWQgbG9va2luZyBzaGFkb3dzLlxuICAgICAgICAgIC8vICAgICAvLyBjaGlsZC5zaGFkb3cubWFwU2l6ZS53aWR0aCA9IDEwMjQ7XG4gICAgICAgICAgLy8gICAgIC8vIGNoaWxkLnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IDEwMjQ7XG4gICAgICAgICAgLy8gICAgIC8vIGNoaWxkLnNoYWRvd0RhcmtuZXNzID0gMC41O1xuICAgICAgICAgIC8vICAgICAvLyBjaGlsZC5zaGFkb3cuY2FtZXJhLm5lYXIgPSAwO1xuICAgICAgICAgIC8vICAgICAvLyBjaGlsZC5zaGFkb3cuY2FtZXJhLmZhciA9IDEwMDA7XG4gICAgICAgICAgLy8gICAgIC8vIHZhciBoZWxwZXIgPSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBjaGlsZC5zaGFkb3cuY2FtZXJhICk7XG4gICAgICAgICAgLy8gICAgIC8vIHNjZW5lLmFkZCggaGVscGVyICk7XG4gICAgICAgICAgLy8gfVxuICAgICAgICAgIGNoaWxkLmxheWVycy5zZXQoMSk7IC8vIC8vIFBvaW50IGxpZ2h0cyBhcmUgZGVmaW5lZCBpbiB3YXR0cyB3aGljaCBnb2VzIHdhYXkgb2ZmIGluIHRocmVlLmpzXG5cbiAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0KSB7XG4gICAgICAgICAgICBjaGlsZC5pbnRlbnNpdHkgPSBjaGlsZC5pbnRlbnNpdHkgKiAwLjAwMDU7XG4gICAgICAgICAgfSAvLyBJZiBpdCdzIGEgc3BvdCBsaWdodCwgaXQgbmVlZHMgdG8gZ28gZG93biBldmVuIG1vcmUuXG5cblxuICAgICAgICAgIGlmIChjaGlsZC50eXBlID09IFwiU3BvdExpZ2h0XCIpIHtcbiAgICAgICAgICAgIGNoaWxkLmludGVuc2l0eSA9IGNoaWxkLmludGVuc2l0eSAqIDAuMDAxO1xuICAgICAgICAgIH0gLy8gY2hpbGQuaW50ZW5zaXR5ID0gMDtcblxuXG4gICAgICAgICAgaWYgKGNoaWxkLm5hbWUgPT0gJ1BvaW50X09yaWVudGF0aW9uJykge1xuICAgICAgICAgICAgLy8gY2hpbGQuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICAgICAgICBjaGlsZC5pbnRlbnNpdHkgPSA0LjY7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKGNoaWxkLm5hbWUsICdMaWdodHMnKTtcbiAgICAgICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcihjaGlsZC5uYW1lLCBjaGlsZCwgW3tcbiAgICAgICAgICAgIGtleU5hbWU6ICdjYXN0U2hhZG93J1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleU5hbWU6ICdpbnRlbnNpdHknLFxuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAzMDAwXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5TmFtZTogJ2NvbG9yJ1xuICAgICAgICAgIH1dKTtcblxuICAgICAgICAgIGlmIChjaGlsZC5zaGFkb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRvd0ZvbGRlcklkID0gY2hpbGQubmFtZSArICcgc2hhZG93JzsgLy8gY29uc29sZS5sb2coY2hpbGQuc2hhZG93KTtcblxuICAgICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKHNoYWRvd0ZvbGRlcklkLCBjaGlsZC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKHNoYWRvd0ZvbGRlcklkLCBjaGlsZC5zaGFkb3csIFt7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdiaWFzJyxcbiAgICAgICAgICAgICAgbWluOiAtMSxcbiAgICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgICAgICBzdGVwOiAwLjAwMDAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGtleU5hbWU6ICdyYWRpdXMnLFxuICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgIG1heDogMTAwLFxuICAgICAgICAgICAgICBzdGVwOiAwLjAxXG4gICAgICAgICAgICB9XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuTWVzaCkge1xuICAgICAgICAgIC8vIGNoaWxkLmNhc3RTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIC8vIGNoaWxkLnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgICAgICAgIC8vIGNoaWxkLmdlb21ldHJ5LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKHRydWUpO1xuICAgICAgICAgIGNvbnN0IGxpZ2h0RW5hYmxlZCA9IFsncDQtc3VwZXItc20nLCAncDQtc3VwZXItc20wMDEnLCAncDQtc3VwZXItc20wMDInXTtcblxuICAgICAgICAgIGlmICh+bGlnaHRFbmFibGVkLmluZGV4T2YoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgICAgIGNoaWxkLmxheWVycy5zZXQoMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ndWkuYWRkRm9sZGVyKGNoaWxkLm5hbWUsICdPYmplY3RzJyk7XG4gICAgICAgICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoY2hpbGQubmFtZSwgY2hpbGQsIFt7XG4gICAgICAgICAgICBrZXlOYW1lOiAnY2FzdFNoYWRvdydcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXlOYW1lOiAncmVjZWl2ZVNoYWRvdydcbiAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICBpZiAoY2hpbGQubWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsSWQgPSBjaGlsZC5uYW1lICsgJyBtYXRlcmlhbCc7XG4gICAgICAgICAgICB0aGlzLmd1aS5hZGRGb2xkZXIobWF0ZXJpYWxJZCwgY2hpbGQubmFtZSk7XG4gICAgICAgICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcihtYXRlcmlhbElkLCBjaGlsZC5tYXRlcmlhbCwgW3tcbiAgICAgICAgICAgICAga2V5TmFtZTogJ2VtaXNzaXZlSW50ZW5zaXR5JyxcbiAgICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgICBtYXg6IDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5TmFtZTogJ2ZsYXRTaGFkaW5nJyxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZC5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAga2V5TmFtZTogJ3dpcmVmcmFtZScsXG4gICAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGQubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSk7IC8vIEVuYWJsZSBzbW9vdGggc2hhZGluZy5cbiAgICAgICAgICAgIC8vIGNoaWxkLm1hdGVyaWFsLmZsYXRTaGFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBjaGlsZC5tYXRlcmlhbC53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGNoaWxkLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGNoaWxkLmdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgICAgICAgICAgLy8gY2hpbGQuZ2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHModHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoaWxkLm5hbWUgPT0gJ1BsYW5lMDAxJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ21lc2gnLCBjaGlsZCk7XG4gICAgICAgICAgfSAvLyBHZXQgdGhlIGltYWdlIG1hcHBpbmdzLlxuICAgICAgICAgIC8vIGlmKGNoaWxkLm1hdGVyaWFsICYmIGNoaWxkLm1hdGVyaWFsLm1hcCkge1xuICAgICAgICAgIC8vICAgY2hpbGQubWF0ZXJpYWwubWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgfSBlbHNlIHsvLyBjb25zb2xlLmxvZygnb3RoZXInLCBjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgfSk7IC8vIFNldCB0aGUgY2FtZXJhIGV4cG9ydGVkIGluIGdsdGYuXG4gICAgICAvLyBSZXF1aXJlcyBjYW1lcmEgdG8gYmUgZXhwb3J0ZWQgZm9yIGdsdGYuXG5cbiAgICAgIHRoaXMuY2FtZXJhID0gZ2x0Zi5jYW1lcmFzWzBdO1xuICAgICAgY29uc29sZS5sb2coJ2NhbWVyYScsIHRoaXMuY2FtZXJhKTtcbiAgICAgIHRoaXMucmVzaXplKCk7IC8vIFVzZSBmb2cgdG8gY292ZXIgZmFyIGRpc3RhbmNlcy5cbiAgICAgIC8vIGNvbnN0IGNvbG9yID0gMHgwMDAwMDtcbiAgICAgIC8vIHRoaXMuc2NlbmUuZm9nID0gbmV3IFRIUkVFLkZvZyhjb2xvciwgNSwgOCk7XG4gICAgICAvLyBFbmFibGUgc2hhZG93cy5cbiAgICAgIC8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL2NvbnN0YW50cy9SZW5kZXJlclxuXG4gICAgICB0aGlzLnJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkID0gdHJ1ZTsgLy8gVG8gYW50aWFsaWFzIHRoZSBzaGFkb3dcblxuICAgICAgdGhpcy5yZW5kZXJlci5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdhbW1hT3V0cHV0ID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2FtbWFGYWN0b3IgPSAyLjI7IC8vIEltcG9ydGFudCB0byBnZXQgdGhlIGNvcnJlY3QgY29sb3JzLlxuICAgICAgLy8gdGhpcy5yZW5kZXJlci5waHlzaWNhbGx5Q29ycmVjdExpZ3RzID0gdHJ1ZTtcbiAgICAgIC8vIEJhY2tncm91bmQgYXMgYmxhY2suXG4gICAgICAvLyB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHg0Mjg3ZjUpO1xuXG4gICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5yZW5kZXJlckNvbmZpZy5jbGVhckNvbG9yLCB0aGlzLnJlbmRlcmVyQ29uZmlnLmJhY2tncm91bmRBbHBoYSk7IC8vIEFmZmVjdHMgaG93IHN0cm9uZ2x5IGxpZ2h0cyBjb21lIGV4cG9zZWQuXG4gICAgICAvLyBodHRwczovL3RocmVlanMub3JnL2V4YW1wbGVzLyN3ZWJnbF90b25lbWFwcGluZ1xuXG4gICAgICB0aGlzLnJlbmRlcmVyLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAxOyAvLyB0aGlzLnJlbmRlcmVyLnRvbmVNYXBwaW5nRXhwb3N1cmUgPSAwLjY7XG5cbiAgICAgIHRoaXMucmVuZGVyZXIudG9uZU1hcHBpbmcgPSBUSFJFRS5BQ0VTRmlsbWljVG9uZU1hcHBpbmc7XG4gICAgICB0aGlzLmd1aS5hZGRPYmplY3RUb0ZvbGRlcignUmVuZGVyZXInLCB0aGlzLnJlbmRlcmVyLCBbe1xuICAgICAgICBrZXlOYW1lOiAndG9uZU1hcHBpbmdFeHBvc3VyZScsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiA1LFxuICAgICAgICBzdGVwOiAwLjAxXG4gICAgICB9LCB7XG4gICAgICAgIGtleU5hbWU6ICdnYW1tYUZhY3RvcicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAxMCxcbiAgICAgICAgc3RlcDogMC4wMVxuICAgICAgfV0pO1xuICAgICAgdGhpcy5ndWkuYWRkT2JqZWN0VG9Gb2xkZXIoJ1JlbmRlcmVyJywgdGhpcy5yZW5kZXJlckNvbmZpZywgW3tcbiAgICAgICAga2V5TmFtZTogJ2NsZWFyQ29sb3InLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcih0aGlzLnJlbmRlcmVyQ29uZmlnLmNsZWFyQ29sb3IsIHRoaXMucmVuZGVyZXJDb25maWcuYmFja2dyb3VuZEFscGhhKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXlOYW1lOiAnYmFja2dyb3VuZEFscGhhJyxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5yZW5kZXJlckNvbmZpZy5jbGVhckNvbG9yLCB0aGlzLnJlbmRlcmVyQ29uZmlnLmJhY2tncm91bmRBbHBoYSk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdDYW1lcmEnLCB0aGlzLmNhbWVyYSwgW3tcbiAgICAgICAga2V5TmFtZTogJ2ZvdicsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiA1MCxcbiAgICAgICAgc3RlcDogMC4wMSxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5TmFtZTogJ3pvb20nLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMTAsXG4gICAgICAgIHN0ZXA6IDAuMDAwMSxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcbiAgICAgIHRoaXMuZ3VpLmFkZEZvbGRlcignR2VuZXJhbCBMaWdodHMnKTtcbiAgICAgIHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnID0ge1xuICAgICAgICBhbWJpZW50TGlnaHRDb2xvcjogJyM3Mzk1YjMnLFxuICAgICAgICBhbWJpZW50TGlnaHRBbHBoYTogMFxuICAgICAgfTsgLy8gQWRkaXRpb25hbCBsaWdodGluZyBvdXRzaWRlIHRoZSBibGVuZGVyLlxuICAgICAgLy8gdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCggMHhmZmZmYmIsIDB4ZmZmZmZmLCAxICk7XG4gICAgICAvLyB0aGlzLnNjZW5lLmFkZCggbGlnaHQgKTtcblxuICAgICAgdGhpcy5hbWJpZW50TGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodENvbG9yKTtcbiAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmludGVuc2l0eSA9IHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodEFscGhhO1xuICAgICAgc2NlbmUuYWRkKHRoaXMuYW1iaWVudExpZ2h0KTtcbiAgICAgIHRoaXMuZ3VpLmFkZE9iamVjdFRvRm9sZGVyKCdHZW5lcmFsIExpZ2h0cycsIHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLCBbe1xuICAgICAgICBrZXlOYW1lOiAnYW1iaWVudExpZ2h0Q29sb3InLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodENvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXlOYW1lOiAnYW1iaWVudExpZ2h0QWxwaGEnLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYW1iaWVudExpZ2h0LmludGVuc2l0eSA9IHRoaXMuZ2VuZXJhbExpZ2h0Q29uZmlnLmFtYmllbnRMaWdodEFscGhhO1xuICAgICAgICB9XG4gICAgICB9XSk7IC8vIHZhciB3aWR0aCA9IDUwO1xuICAgICAgLy8gdmFyIGhlaWdodCA9IDUwO1xuICAgICAgLy8gdmFyIGludGVuc2l0eSA9IDA7XG4gICAgICAvLyB2YXIgcmVjdExpZ2h0ID0gbmV3IFRIUkVFLlJlY3RBcmVhTGlnaHQoJyNGRkZGRkYnLCBpbnRlbnNpdHksICB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgICAvLyByZWN0TGlnaHQucG9zaXRpb24uc2V0KCAwLCAwLCAyNSApO1xuICAgICAgLy8gLy8gcmVjdExpZ2h0Lmxvb2tBdCggMCwgMCwgMCApO1xuICAgICAgLy8gdGhpcy5zY2VuZS5hZGQoIHJlY3RMaWdodCApO1xuICAgICAgLy8gcmVjdExpZ2h0SGVscGVyID0gbmV3IFRIUkVFLlJlY3RBcmVhTGlnaHRIZWxwZXIoIHJlY3RMaWdodCApO1xuICAgICAgLy8gcmVjdExpZ2h0LmFkZCggcmVjdExpZ2h0SGVscGVyICk7XG5cbiAgICAgIHRoaXMuZ3VpLmFkZEJ1dHRvbignUmVmcmVzaCcsIHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpKTtcbiAgICB9LCB1bmRlZmluZWQsIGVycm9yID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgICAvLyBwcmVjaXNpb246ICdoaWdocCdcbiAgICAgIGF1dG9TaXplOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb21wb3NlciA9IG5ldyBfRWZmZWN0Q29tcG9zZXIuRWZmZWN0Q29tcG9zZXIodGhpcy5yZW5kZXJlcik7XG4gICAgdGhpcy5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemUuYmluZCh0aGlzKSwgZmFsc2UpO1xuICB9XG5cbiAgcmVzaXplKCkge1xuICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAxLCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuY2FudmFzQ29udGFpbmVyLnBhcmVudEVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbnZhc0NvbnRhaW5lci5wYXJlbnRFbGVtZW50Lm9mZnNldEhlaWdodDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rvbm1jY3VyZHkvdGhyZWUtZ2x0Zi12aWV3ZXIvYmxvYi9tYXN0ZXIvc3JjL3ZpZXdlci5qc1xuICAgIC8vIGh0dHBzOi8vdGhyZWVqcy5vcmcvZG9jcy8jYXBpL2VuL2NvbnN0YW50cy9SZW5kZXJlclxuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpOyAvLyBQb3N0IHByb2Nlc3NpbmdcbiAgICAvLyB0aGlzLmNvbXBvc2VyLnNldFNpemUoIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAvLyBjb25zdCBmeGFhUGFzcyA9IG5ldyBTaGFkZXJQYXNzKCBGWEFBU2hhZGVyICk7XG4gICAgLy8gZnhhYVBhc3MubWF0ZXJpYWwudW5pZm9ybXNbICdyZXNvbHV0aW9uJyBdLnZhbHVlLnggPSAxIC8gKCB0aGlzLndpZHRoICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgIC8vIGZ4YWFQYXNzLm1hdGVyaWFsLnVuaWZvcm1zWyAncmVzb2x1dGlvbicgXS52YWx1ZS55ID0gMSAvICggdGhpcy5oZWlnaHQgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5hZGRQYXNzKGZ4YWFQYXNzKTtcbiAgICAvLyB0aGlzLmNvbXBvc2VyLmFkZFBhc3MobmV3IFJlbmRlclBhc3ModGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpKTtcbiAgICAvLyB2YXIgYmxvb21QYXNzID0gbmV3IFVucjIuMm1lYWxCbG9vbVBhc3MoMSwgMjUsIDUsIDI1Nik7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5hZGRQYXNzKGJsb29tUGFzcyk7XG4gICAgLy8gVGhlIGNhbWVyYSBhc3BlY3QgZ29lcyBvZmYgc2luY2UgaXQgY291bGQgYmUgZXhwb3J0ZWQgYXQgYSBkaWZmZXJlbnRcbiAgICAvLyByYXRpby4gIEZvcmNlIHVwZGF0ZSB0aGUgYXNwZWN0IHJhdGlvLlxuXG4gICAgdGhpcy5jYW1lcmEuYXNwZWN0ID0gdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0O1xuICAgIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKHRoaXMucmVuZGVyZXJDb25maWcuY2xlYXJDb2xvciwgdGhpcy5yZW5kZXJlckNvbmZpZy5iYWNrZ3JvdW5kQWxwaGEpO1xuICAgIHRoaXMucmVzaXplKCk7XG4gICAgdGhpcy5kcmF3KCk7XG4gIH1cblxuICBnZXRBbmltYXRpb25CeU5hbWUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbnMuZmlsdGVyKGFuaW1hdGlvbkNsaXAgPT4ge1xuICAgICAgcmV0dXJuIGFuaW1hdGlvbkNsaXAubmFtZSA9PSBuYW1lO1xuICAgIH0pWzBdO1xuICB9XG5cbiAgZ2V0T2JqZWN0QnlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVTY2VuZS5jaGlsZHJlbi5maWx0ZXIob2JqZWN0M2QgPT4ge1xuICAgICAgcmV0dXJuIG9iamVjdDNkLm5hbWUgPT0gbmFtZTtcbiAgICB9KVswXTtcbiAgfVxuXG4gIG9uUHJvZ3Jlc3NVcGRhdGUocHJvZ3Jlc3MpIHtcbiAgICAvL0FuaW1hdGlvbiBNaXhlcuOCkuWun+ihjFxuICAgIGlmICh0aGlzLm1peGVyKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGZpbmQgb3V0IGhvdyBsb25nIHRoZSBhbmltYXRpb24gaXMuXG4gICAgICAvLyBUaGUgbWl4ZXIgYXBwZWFycyB0byBoYXZlIG5vIGtub3dsZWRnZSBvZnQgdGhpcyBzbyB3ZSBuZWVkIHRvXG4gICAgICAvLyBsb29rIHVwIGEgc3BlY2lmaWMgYW5pbWF0aW9uIGFuZCBnZXQgdGhlIGR1cmF0aW9uIHRvXG4gICAgICAvLyBnZXQgdGhlIHRvdGFsIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICBjb25zdCBjYW1lcmFBbmltYXRpb24gPSB0aGlzLmdldEFuaW1hdGlvbkJ5TmFtZSgnQ2FtZXJhQWN0aW9uLjAwNCcpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBjYW1lcmFBbmltYXRpb24uZHVyYXRpb247IC8vIFdoZW4gZHVyYXRpb24gaGl0cyBpdCdzIG1heCwgYW5pbWF0aW9uTWl4ZXIgc2VlbXMgdG8gaGl0IHRoZSBmaXJzdFxuICAgICAgLy8gZnJhbWUgc28gbmV4dCBhbGxvdyBpdCB0byByZWFjaCB0aGUgbWF4IHZhbHVlLlxuXG4gICAgICB0aGlzLm1peGVyLnNldFRpbWUoTWF0aC5taW4oZHVyYXRpb24gKiBwcm9ncmVzcywgZHVyYXRpb24gLSAwLjAwMSkpO1xuICAgIH1cblxuICAgIHRoaXMuZHJhdygpOyAvLyB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgLy8gdGhpcy5jb21wb3Nlci5yZW5kZXIoKTtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5hdXRvQ2xlYXIgPSB0cnVlO1xuICAgIHRoaXMuY2FtZXJhLmxheWVycy5zZXQoMCk7XG4gICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICAgIHRoaXMucmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2U7IC8vIERvbid0IGNsZWFyXG5cbiAgICB0aGlzLmNhbWVyYS5sYXllcnMuc2V0KDEpO1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRocmVlT2JqZWN0Vmlld2VyOTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/three-object-viewer9.js\n");

/***/ }),

/***/ "./examples/three-scene-renderer.js":
/*!******************************************!*\
  !*** ./examples/three-scene-renderer.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _OrbitControls = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n\nvar _sceneRenderer = __webpack_require__(/*! ../lib/threef/scene-renderer */ \"./lib/threef/scene-renderer.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _threef = __webpack_require__(/*! ../lib/threef/threef */ \"./lib/threef/threef.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nclass ThreeSceneRenderer {\n  constructor() {\n    console.log('scene renderer test.');\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.sceneRenderer = new _sceneRenderer.SceneRenderer({});\n    this.boxElements = [document.getElementById('box-1'), document.getElementById('box-2'), document.getElementById('box-3'), document.getElementById('box-4'), document.getElementById('box-5'), document.getElementById('box-6'), document.getElementById('box-7'), document.getElementById('box-8'), document.getElementById('box-8'), document.getElementById('box-9'), document.getElementById('box-10'), document.getElementById('box-11'), document.getElementById('box-12')];\n    this.generateScenes();\n    this.sceneRenderer.resize();\n    this.raf.start();\n  }\n\n  generateScenes() {\n    var geometries = [new THREE.BoxBufferGeometry(1, 1, 1), new THREE.SphereBufferGeometry(0.5, 12, 8), new THREE.DodecahedronBufferGeometry(0.5), new THREE.CylinderBufferGeometry(0.5, 0.5, 1, 12)];\n    this.boxElements.forEach(element => {\n      // Create a new scene.\n      const scene = new THREE.Scene(); // Add a new cam.\n\n      var camera = new THREE.PerspectiveCamera(50, 1, 1, 10);\n      camera.position.z = 2; // Add some stuff to the sample scene.\n\n      var geometry = geometries[geometries.length * Math.random() | 0];\n      var material = new THREE.MeshStandardMaterial({\n        color: new THREE.Color().setHSL(Math.random(), 1, 0.75),\n        roughness: 0.5,\n        metalness: 0,\n        flatShading: true\n      });\n      scene.add(new THREE.Mesh(geometry, material));\n      scene.add(new THREE.HemisphereLight(0xaaaaaa, 0x444444));\n      var light = new THREE.DirectionalLight(0xffffff, 0.5);\n      light.position.set(1, 1, 1);\n      scene.add(light); // var controls = new OrbitControls( camera, element);\n      // controls.minDistance = 2;\n      // controls.maxDistance = 5;\n      // controls.enablePan = false;\n      // controls.enableZoom = false;\n      // Register this to the sceneRenderer.\n\n      const textElement = element.querySelector('.text');\n      this.sceneRenderer.addScene({\n        // resizingAlgo: 'resizeWithFov',\n        // resizingScalar: 1.0,\n        resizingAlgo: 'contain',\n        resizingOptions: {\n          scalarX: 1.0,\n          scalarY: 1.0\n        },\n        scene: scene,\n        camera: camera,\n        domElement: element,\n        // On each render update, update the controls.\n        onBeforeRender: () => {\n          // controls.update();\n          scene.children[0].rotation.y = Date.now() * 0.001; // Example of moving DOM text with the scene.\n          // The element (not the scene renderer) size needs to be\n          // used to calculate positions.\n          // Because we are using FOV based resizing, we need to\n          // consider the resizingScalar and pass that over as a\n          // textScalar.\n\n          const textScalar = scene.userData.resizingScalar * 0.00003;\n\n          const domCoordinates = _threef.threef.toDomCoordinates(scene.children[0], camera, element.offsetWidth, element.offsetHeight, textScalar);\n\n          const domRotation = _threef.threef.toDomRotation(scene.children[0], camera, element.offsetWidth, element.offsetHeight);\n\n          _threef.threef.applyVectorToDom(textElement, domCoordinates, domRotation);\n        },\n        onBeforeResize: () => {\n          // scene.userData.resizingScalar = element.offsetHeight * 0.5;\n          scene.userData.resizingScalar = Math.min(element.offsetHeight, element.offsetWidth);\n        },\n\n        onResize() {\n          console.log('updating'); // camera.aspect = this.width / this.height;\n          // camera.updateProjectionMatrix();\n        }\n\n      });\n    });\n  }\n\n  onRaf() {\n    this.sceneRenderer.render();\n  }\n\n  resize() {}\n\n}\n\nexports.default = ThreeSceneRenderer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1zY2VuZS1yZW5kZXJlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3RocmVlLXNjZW5lLXJlbmRlcmVyLmpzPzQ5YTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfT3JiaXRDb250cm9scyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9sc1wiKTtcblxudmFyIF9zY2VuZVJlbmRlcmVyID0gcmVxdWlyZShcIi4uL2xpYi90aHJlZWYvc2NlbmUtcmVuZGVyZXJcIik7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX3RocmVlZiA9IHJlcXVpcmUoXCIuLi9saWIvdGhyZWVmL3RocmVlZlwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5jbGFzcyBUaHJlZVNjZW5lUmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygnc2NlbmUgcmVuZGVyZXIgdGVzdC4nKTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc2NlbmVSZW5kZXJlciA9IG5ldyBfc2NlbmVSZW5kZXJlci5TY2VuZVJlbmRlcmVyKHt9KTtcbiAgICB0aGlzLmJveEVsZW1lbnRzID0gW2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib3gtMScpLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm94LTInKSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JveC0zJyksIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib3gtNCcpLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm94LTUnKSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JveC02JyksIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib3gtNycpLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm94LTgnKSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JveC04JyksIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib3gtOScpLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm94LTEwJyksIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib3gtMTEnKSwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JveC0xMicpXTtcbiAgICB0aGlzLmdlbmVyYXRlU2NlbmVzKCk7XG4gICAgdGhpcy5zY2VuZVJlbmRlcmVyLnJlc2l6ZSgpO1xuICAgIHRoaXMucmFmLnN0YXJ0KCk7XG4gIH1cblxuICBnZW5lcmF0ZVNjZW5lcygpIHtcbiAgICB2YXIgZ2VvbWV0cmllcyA9IFtuZXcgVEhSRUUuQm94QnVmZmVyR2VvbWV0cnkoMSwgMSwgMSksIG5ldyBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeSgwLjUsIDEyLCA4KSwgbmV3IFRIUkVFLkRvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5KDAuNSksIG5ldyBUSFJFRS5DeWxpbmRlckJ1ZmZlckdlb21ldHJ5KDAuNSwgMC41LCAxLCAxMildO1xuICAgIHRoaXMuYm94RWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBzY2VuZS5cbiAgICAgIGNvbnN0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7IC8vIEFkZCBhIG5ldyBjYW0uXG5cbiAgICAgIHZhciBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNTAsIDEsIDEsIDEwKTtcbiAgICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gMjsgLy8gQWRkIHNvbWUgc3R1ZmYgdG8gdGhlIHNhbXBsZSBzY2VuZS5cblxuICAgICAgdmFyIGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tnZW9tZXRyaWVzLmxlbmd0aCAqIE1hdGgucmFuZG9tKCkgfCAwXTtcbiAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICAgIGNvbG9yOiBuZXcgVEhSRUUuQ29sb3IoKS5zZXRIU0woTWF0aC5yYW5kb20oKSwgMSwgMC43NSksXG4gICAgICAgIHJvdWdobmVzczogMC41LFxuICAgICAgICBtZXRhbG5lc3M6IDAsXG4gICAgICAgIGZsYXRTaGFkaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHNjZW5lLmFkZChuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpKTtcbiAgICAgIHNjZW5lLmFkZChuZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0KDB4YWFhYWFhLCAweDQ0NDQ0NCkpO1xuICAgICAgdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoMHhmZmZmZmYsIDAuNSk7XG4gICAgICBsaWdodC5wb3NpdGlvbi5zZXQoMSwgMSwgMSk7XG4gICAgICBzY2VuZS5hZGQobGlnaHQpOyAvLyB2YXIgY29udHJvbHMgPSBuZXcgT3JiaXRDb250cm9scyggY2FtZXJhLCBlbGVtZW50KTtcbiAgICAgIC8vIGNvbnRyb2xzLm1pbkRpc3RhbmNlID0gMjtcbiAgICAgIC8vIGNvbnRyb2xzLm1heERpc3RhbmNlID0gNTtcbiAgICAgIC8vIGNvbnRyb2xzLmVuYWJsZVBhbiA9IGZhbHNlO1xuICAgICAgLy8gY29udHJvbHMuZW5hYmxlWm9vbSA9IGZhbHNlO1xuICAgICAgLy8gUmVnaXN0ZXIgdGhpcyB0byB0aGUgc2NlbmVSZW5kZXJlci5cblxuICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy50ZXh0Jyk7XG4gICAgICB0aGlzLnNjZW5lUmVuZGVyZXIuYWRkU2NlbmUoe1xuICAgICAgICAvLyByZXNpemluZ0FsZ286ICdyZXNpemVXaXRoRm92JyxcbiAgICAgICAgLy8gcmVzaXppbmdTY2FsYXI6IDEuMCxcbiAgICAgICAgcmVzaXppbmdBbGdvOiAnY29udGFpbicsXG4gICAgICAgIHJlc2l6aW5nT3B0aW9uczoge1xuICAgICAgICAgIHNjYWxhclg6IDEuMCxcbiAgICAgICAgICBzY2FsYXJZOiAxLjBcbiAgICAgICAgfSxcbiAgICAgICAgc2NlbmU6IHNjZW5lLFxuICAgICAgICBjYW1lcmE6IGNhbWVyYSxcbiAgICAgICAgZG9tRWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgLy8gT24gZWFjaCByZW5kZXIgdXBkYXRlLCB1cGRhdGUgdGhlIGNvbnRyb2xzLlxuICAgICAgICBvbkJlZm9yZVJlbmRlcjogKCkgPT4ge1xuICAgICAgICAgIC8vIGNvbnRyb2xzLnVwZGF0ZSgpO1xuICAgICAgICAgIHNjZW5lLmNoaWxkcmVuWzBdLnJvdGF0aW9uLnkgPSBEYXRlLm5vdygpICogMC4wMDE7IC8vIEV4YW1wbGUgb2YgbW92aW5nIERPTSB0ZXh0IHdpdGggdGhlIHNjZW5lLlxuICAgICAgICAgIC8vIFRoZSBlbGVtZW50IChub3QgdGhlIHNjZW5lIHJlbmRlcmVyKSBzaXplIG5lZWRzIHRvIGJlXG4gICAgICAgICAgLy8gdXNlZCB0byBjYWxjdWxhdGUgcG9zaXRpb25zLlxuICAgICAgICAgIC8vIEJlY2F1c2Ugd2UgYXJlIHVzaW5nIEZPViBiYXNlZCByZXNpemluZywgd2UgbmVlZCB0b1xuICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSByZXNpemluZ1NjYWxhciBhbmQgcGFzcyB0aGF0IG92ZXIgYXMgYVxuICAgICAgICAgIC8vIHRleHRTY2FsYXIuXG5cbiAgICAgICAgICBjb25zdCB0ZXh0U2NhbGFyID0gc2NlbmUudXNlckRhdGEucmVzaXppbmdTY2FsYXIgKiAwLjAwMDAzO1xuXG4gICAgICAgICAgY29uc3QgZG9tQ29vcmRpbmF0ZXMgPSBfdGhyZWVmLnRocmVlZi50b0RvbUNvb3JkaW5hdGVzKHNjZW5lLmNoaWxkcmVuWzBdLCBjYW1lcmEsIGVsZW1lbnQub2Zmc2V0V2lkdGgsIGVsZW1lbnQub2Zmc2V0SGVpZ2h0LCB0ZXh0U2NhbGFyKTtcblxuICAgICAgICAgIGNvbnN0IGRvbVJvdGF0aW9uID0gX3RocmVlZi50aHJlZWYudG9Eb21Sb3RhdGlvbihzY2VuZS5jaGlsZHJlblswXSwgY2FtZXJhLCBlbGVtZW50Lm9mZnNldFdpZHRoLCBlbGVtZW50Lm9mZnNldEhlaWdodCk7XG5cbiAgICAgICAgICBfdGhyZWVmLnRocmVlZi5hcHBseVZlY3RvclRvRG9tKHRleHRFbGVtZW50LCBkb21Db29yZGluYXRlcywgZG9tUm90YXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBvbkJlZm9yZVJlc2l6ZTogKCkgPT4ge1xuICAgICAgICAgIC8vIHNjZW5lLnVzZXJEYXRhLnJlc2l6aW5nU2NhbGFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgKiAwLjU7XG4gICAgICAgICAgc2NlbmUudXNlckRhdGEucmVzaXppbmdTY2FsYXIgPSBNYXRoLm1pbihlbGVtZW50Lm9mZnNldEhlaWdodCwgZWxlbWVudC5vZmZzZXRXaWR0aCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25SZXNpemUoKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ3VwZGF0aW5nJyk7IC8vIGNhbWVyYS5hc3BlY3QgPSB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgLy8gY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIG9uUmFmKCkge1xuICAgIHRoaXMuc2NlbmVSZW5kZXJlci5yZW5kZXIoKTtcbiAgfVxuXG4gIHJlc2l6ZSgpIHt9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gVGhyZWVTY2VuZVJlbmRlcmVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/three-scene-renderer.js\n");

/***/ }),

/***/ "./examples/three-scene-renderer2.js":
/*!*******************************************!*\
  !*** ./examples/three-scene-renderer2.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _GLTFLoader = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\nvar _three = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _OrbitControls = __webpack_require__(/*! three/examples/jsm/controls/OrbitControls */ \"./node_modules/three/examples/jsm/controls/OrbitControls.js\");\n\nvar _sceneRenderer = __webpack_require__(/*! ../lib/threef/scene-renderer */ \"./lib/threef/scene-renderer.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _threef = __webpack_require__(/*! ../lib/threef/threef */ \"./lib/threef/threef.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nclass ThreeSceneRenderer2 {\n  constructor() {\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.sceneRenderer = new _sceneRenderer.SceneRenderer({});\n    this.boxElements = {\n      box1: document.getElementById('box-1'),\n      box2: document.getElementById('box-2'),\n      box3: document.getElementById('box-3'),\n      box4: document.getElementById('box-4'),\n      box5: document.getElementById('box-5'),\n      box6: document.getElementById('box-6')\n    }; // Create first scene1.\n\n    this.createGltfScene(this.boxElements.box1, 'public/scene-size-test2.gltf', {\n      resizingAlgo: 'contain',\n      resizingOptions: {\n        scalarX: 2.6,\n        scalarY: 3.8,\n        useFov: false\n      }\n    }); // Create second scene.\n\n    this.createGltfScene(this.boxElements.box2, 'public/scene-size-test2.gltf', {\n      resizingAlgo: 'contain',\n      resizingOptions: {\n        scalarX: 2.6,\n        scalarY: 3.8,\n        top: 0,\n        useFov: false\n      }\n    }); // Create third scene.\n\n    this.createGltfScene(this.boxElements.box3, 'public/scene-size-test2.gltf', {\n      resizingAlgo: 'contain',\n      resizingOptions: {\n        scalarX: 2.6,\n        scalarY: 3.8,\n        bottom: 0,\n        left: 0,\n        useFov: false\n      }\n    });\n    this.createGltfScene(this.boxElements.box4, 'public/scene-size-test2.gltf', {\n      resizingAlgo: 'cover',\n      resizingOptions: {\n        scalarX: 2.6,\n        scalarY: 3.8,\n        useFov: false\n      }\n    });\n    this.createGltfScene(this.boxElements.box5, 'public/scene-size-test2.gltf', {\n      resizingAlgo: 'cover',\n      resizingOptions: {\n        scalarX: 2.6,\n        scalarY: 3.8,\n        top: 0,\n        useFov: false\n      }\n    });\n    this.createGltfScene(this.boxElements.box6, 'public/scene-size-test2.gltf', {\n      resizingAlgo: 'cover',\n      resizingOptions: {\n        scalarX: 2.6,\n        scalarY: 3.8,\n        bottom: 0,\n        left: 0,\n        // right: 1\n        useFov: false\n      }\n    });\n    this.sceneRenderer.resize();\n    this.raf.start();\n  }\n\n  createGltfScene(domElement, gltfPath, options) {\n    const gltfLoader = new _GLTFLoader.GLTFLoader();\n\n    _threef.threef.loadGltf({\n      gltfPath: gltfPath,\n      gltfLoader: gltfLoader\n    }).then(gltf => {\n      // Add some lights.\n      const ambientLight = new THREE.AmbientLight('#FFFFFF');\n      ambientLight.intensity = options.ambientLightIntensity || 1.0; // Add the light to the scene.\n\n      gltf.scene.add(ambientLight);\n      this.sceneRenderer.addScene({\n        resizingAlgo: options.resizingAlgo,\n        resizingOptions: options.resizingOptions,\n        domElement: domElement,\n        scene: gltf.scene,\n        camera: gltf.cameras[0],\n        onBeforeRender: renderer => {\n          // Since this loads a gltf, we need to correct out the colors.\n          renderer.physicallyCorrectLights = true;\n          renderer.gammaOutput = true;\n        }\n      }, true);\n    });\n  }\n\n  onRaf() {\n    this.sceneRenderer.render();\n  }\n\n}\n\nexports.default = ThreeSceneRenderer2;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy90aHJlZS1zY2VuZS1yZW5kZXJlcjIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy90aHJlZS1zY2VuZS1yZW5kZXJlcjIuanM/ZmI1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9HTFRGTG9hZGVyID0gcmVxdWlyZShcInRocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0dMVEZMb2FkZXJcIik7XG5cbnZhciBfdGhyZWUgPSByZXF1aXJlKFwidGhyZWVcIik7XG5cbnZhciBUSFJFRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF90aHJlZSk7XG5cbnZhciBfT3JiaXRDb250cm9scyA9IHJlcXVpcmUoXCJ0aHJlZS9leGFtcGxlcy9qc20vY29udHJvbHMvT3JiaXRDb250cm9sc1wiKTtcblxudmFyIF9zY2VuZVJlbmRlcmVyID0gcmVxdWlyZShcIi4uL2xpYi90aHJlZWYvc2NlbmUtcmVuZGVyZXJcIik7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX3RocmVlZiA9IHJlcXVpcmUoXCIuLi9saWIvdGhyZWVmL3RocmVlZlwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiB7fTsgaWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5jbGFzcyBUaHJlZVNjZW5lUmVuZGVyZXIyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yYWYgPSBuZXcgX3JhZi5SYWYodGhpcy5vblJhZi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNjZW5lUmVuZGVyZXIgPSBuZXcgX3NjZW5lUmVuZGVyZXIuU2NlbmVSZW5kZXJlcih7fSk7XG4gICAgdGhpcy5ib3hFbGVtZW50cyA9IHtcbiAgICAgIGJveDE6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib3gtMScpLFxuICAgICAgYm94MjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JveC0yJyksXG4gICAgICBib3gzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm94LTMnKSxcbiAgICAgIGJveDQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib3gtNCcpLFxuICAgICAgYm94NTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JveC01JyksXG4gICAgICBib3g2OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm94LTYnKVxuICAgIH07IC8vIENyZWF0ZSBmaXJzdCBzY2VuZTEuXG5cbiAgICB0aGlzLmNyZWF0ZUdsdGZTY2VuZSh0aGlzLmJveEVsZW1lbnRzLmJveDEsICdwdWJsaWMvc2NlbmUtc2l6ZS10ZXN0Mi5nbHRmJywge1xuICAgICAgcmVzaXppbmdBbGdvOiAnY29udGFpbicsXG4gICAgICByZXNpemluZ09wdGlvbnM6IHtcbiAgICAgICAgc2NhbGFyWDogMi42LFxuICAgICAgICBzY2FsYXJZOiAzLjgsXG4gICAgICAgIHVzZUZvdjogZmFsc2VcbiAgICAgIH1cbiAgICB9KTsgLy8gQ3JlYXRlIHNlY29uZCBzY2VuZS5cblxuICAgIHRoaXMuY3JlYXRlR2x0ZlNjZW5lKHRoaXMuYm94RWxlbWVudHMuYm94MiwgJ3B1YmxpYy9zY2VuZS1zaXplLXRlc3QyLmdsdGYnLCB7XG4gICAgICByZXNpemluZ0FsZ286ICdjb250YWluJyxcbiAgICAgIHJlc2l6aW5nT3B0aW9uczoge1xuICAgICAgICBzY2FsYXJYOiAyLjYsXG4gICAgICAgIHNjYWxhclk6IDMuOCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICB1c2VGb3Y6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7IC8vIENyZWF0ZSB0aGlyZCBzY2VuZS5cblxuICAgIHRoaXMuY3JlYXRlR2x0ZlNjZW5lKHRoaXMuYm94RWxlbWVudHMuYm94MywgJ3B1YmxpYy9zY2VuZS1zaXplLXRlc3QyLmdsdGYnLCB7XG4gICAgICByZXNpemluZ0FsZ286ICdjb250YWluJyxcbiAgICAgIHJlc2l6aW5nT3B0aW9uczoge1xuICAgICAgICBzY2FsYXJYOiAyLjYsXG4gICAgICAgIHNjYWxhclk6IDMuOCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB1c2VGb3Y6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jcmVhdGVHbHRmU2NlbmUodGhpcy5ib3hFbGVtZW50cy5ib3g0LCAncHVibGljL3NjZW5lLXNpemUtdGVzdDIuZ2x0ZicsIHtcbiAgICAgIHJlc2l6aW5nQWxnbzogJ2NvdmVyJyxcbiAgICAgIHJlc2l6aW5nT3B0aW9uczoge1xuICAgICAgICBzY2FsYXJYOiAyLjYsXG4gICAgICAgIHNjYWxhclk6IDMuOCxcbiAgICAgICAgdXNlRm92OiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuY3JlYXRlR2x0ZlNjZW5lKHRoaXMuYm94RWxlbWVudHMuYm94NSwgJ3B1YmxpYy9zY2VuZS1zaXplLXRlc3QyLmdsdGYnLCB7XG4gICAgICByZXNpemluZ0FsZ286ICdjb3ZlcicsXG4gICAgICByZXNpemluZ09wdGlvbnM6IHtcbiAgICAgICAgc2NhbGFyWDogMi42LFxuICAgICAgICBzY2FsYXJZOiAzLjgsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgdXNlRm92OiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuY3JlYXRlR2x0ZlNjZW5lKHRoaXMuYm94RWxlbWVudHMuYm94NiwgJ3B1YmxpYy9zY2VuZS1zaXplLXRlc3QyLmdsdGYnLCB7XG4gICAgICByZXNpemluZ0FsZ286ICdjb3ZlcicsXG4gICAgICByZXNpemluZ09wdGlvbnM6IHtcbiAgICAgICAgc2NhbGFyWDogMi42LFxuICAgICAgICBzY2FsYXJZOiAzLjgsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgLy8gcmlnaHQ6IDFcbiAgICAgICAgdXNlRm92OiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2NlbmVSZW5kZXJlci5yZXNpemUoKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICB9XG5cbiAgY3JlYXRlR2x0ZlNjZW5lKGRvbUVsZW1lbnQsIGdsdGZQYXRoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZ2x0ZkxvYWRlciA9IG5ldyBfR0xURkxvYWRlci5HTFRGTG9hZGVyKCk7XG5cbiAgICBfdGhyZWVmLnRocmVlZi5sb2FkR2x0Zih7XG4gICAgICBnbHRmUGF0aDogZ2x0ZlBhdGgsXG4gICAgICBnbHRmTG9hZGVyOiBnbHRmTG9hZGVyXG4gICAgfSkudGhlbihnbHRmID0+IHtcbiAgICAgIC8vIEFkZCBzb21lIGxpZ2h0cy5cbiAgICAgIGNvbnN0IGFtYmllbnRMaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoJyNGRkZGRkYnKTtcbiAgICAgIGFtYmllbnRMaWdodC5pbnRlbnNpdHkgPSBvcHRpb25zLmFtYmllbnRMaWdodEludGVuc2l0eSB8fCAxLjA7IC8vIEFkZCB0aGUgbGlnaHQgdG8gdGhlIHNjZW5lLlxuXG4gICAgICBnbHRmLnNjZW5lLmFkZChhbWJpZW50TGlnaHQpO1xuICAgICAgdGhpcy5zY2VuZVJlbmRlcmVyLmFkZFNjZW5lKHtcbiAgICAgICAgcmVzaXppbmdBbGdvOiBvcHRpb25zLnJlc2l6aW5nQWxnbyxcbiAgICAgICAgcmVzaXppbmdPcHRpb25zOiBvcHRpb25zLnJlc2l6aW5nT3B0aW9ucyxcbiAgICAgICAgZG9tRWxlbWVudDogZG9tRWxlbWVudCxcbiAgICAgICAgc2NlbmU6IGdsdGYuc2NlbmUsXG4gICAgICAgIGNhbWVyYTogZ2x0Zi5jYW1lcmFzWzBdLFxuICAgICAgICBvbkJlZm9yZVJlbmRlcjogcmVuZGVyZXIgPT4ge1xuICAgICAgICAgIC8vIFNpbmNlIHRoaXMgbG9hZHMgYSBnbHRmLCB3ZSBuZWVkIHRvIGNvcnJlY3Qgb3V0IHRoZSBjb2xvcnMuXG4gICAgICAgICAgcmVuZGVyZXIucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgPSB0cnVlO1xuICAgICAgICAgIHJlbmRlcmVyLmdhbW1hT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgfSk7XG4gIH1cblxuICBvblJhZigpIHtcbiAgICB0aGlzLnNjZW5lUmVuZGVyZXIucmVuZGVyKCk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBUaHJlZVNjZW5lUmVuZGVyZXIyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/three-scene-renderer2.js\n");

/***/ }),

/***/ "./examples/vector-dom.js":
/*!********************************!*\
  !*** ./examples/vector-dom.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _dat = __webpack_require__(/*! dat.gui */ \"./node_modules/dat.gui/build/dat.gui.module.js\");\n\nvar dat = _interopRequireWildcard(_dat);\n\nvar _vectorDom = __webpack_require__(/*! ../lib/dom/vector-dom */ \"./lib/dom/vector-dom.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nclass VectorDomSample {\n  constructor() {\n    this.gui = new dat.GUI();\n    this.vectorBall = new _vectorDom.VectorDom(document.getElementById('ball'));\n    this.vectorBall.setPosition(new _vector.Vector(0, 0, 0)); // We are going to offset the entire element position to the center\n    // of the container.\n\n    this.vectorBall.setOffset(new _vector.Vector(800 / 2, 800 / 2, 0));\n    this.eularRotationAsRotationMatrix = false;\n    this.vectorBall.init();\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.raf.start();\n    let anchor = this.gui.addFolder('Anchor');\n    anchor.add(this.vectorBall, 'anchorX', 0, 1);\n    anchor.add(this.vectorBall, 'anchorY', 0, 1);\n    let projection = this.gui.addFolder('Position');\n    projection.add(this.vectorBall.position, 'x', -180, 180);\n    projection.add(this.vectorBall.position, 'y', -180, 180);\n    projection.add(this.vectorBall.position, 'z', -2, 10);\n    let rotation = this.gui.addFolder('Rotation');\n    rotation.add(this.vectorBall, 'rx', -360, 360);\n    rotation.add(this.vectorBall, 'ry', -360, 360);\n    rotation.add(this.vectorBall, 'rz', -360, 360);\n    rotation.add(this.vectorBall, 'eularRotationAsRotationMatrix');\n  }\n\n  onRaf() {\n    // this.vectorBall.rotation.addEuler(\n    //     20, 90, 30);\n    // this.progress += 0.04;\n    // this.vectorBall.rz = this.progress;\n    // console.log('s', this.vectorBall.rotation);\n    this.vectorBall.render(true);\n  }\n\n}\n\nexports.default = VectorDomSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy92ZWN0b3ItZG9tLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMvdmVjdG9yLWRvbS5qcz85OGNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2RhdCA9IHJlcXVpcmUoXCJkYXQuZ3VpXCIpO1xuXG52YXIgZGF0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2RhdCk7XG5cbnZhciBfdmVjdG9yRG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vdmVjdG9yLWRvbVwiKTtcblxudmFyIF9yYWYgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWZcIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi92ZWN0b3JcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY2xhc3MgVmVjdG9yRG9tU2FtcGxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ndWkgPSBuZXcgZGF0LkdVSSgpO1xuICAgIHRoaXMudmVjdG9yQmFsbCA9IG5ldyBfdmVjdG9yRG9tLlZlY3RvckRvbShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmFsbCcpKTtcbiAgICB0aGlzLnZlY3RvckJhbGwuc2V0UG9zaXRpb24obmV3IF92ZWN0b3IuVmVjdG9yKDAsIDAsIDApKTsgLy8gV2UgYXJlIGdvaW5nIHRvIG9mZnNldCB0aGUgZW50aXJlIGVsZW1lbnQgcG9zaXRpb24gdG8gdGhlIGNlbnRlclxuICAgIC8vIG9mIHRoZSBjb250YWluZXIuXG5cbiAgICB0aGlzLnZlY3RvckJhbGwuc2V0T2Zmc2V0KG5ldyBfdmVjdG9yLlZlY3Rvcig4MDAgLyAyLCA4MDAgLyAyLCAwKSk7XG4gICAgdGhpcy5ldWxhclJvdGF0aW9uQXNSb3RhdGlvbk1hdHJpeCA9IGZhbHNlO1xuICAgIHRoaXMudmVjdG9yQmFsbC5pbml0KCk7XG4gICAgdGhpcy5yYWYgPSBuZXcgX3JhZi5SYWYodGhpcy5vblJhZi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnJhZi5zdGFydCgpO1xuICAgIGxldCBhbmNob3IgPSB0aGlzLmd1aS5hZGRGb2xkZXIoJ0FuY2hvcicpO1xuICAgIGFuY2hvci5hZGQodGhpcy52ZWN0b3JCYWxsLCAnYW5jaG9yWCcsIDAsIDEpO1xuICAgIGFuY2hvci5hZGQodGhpcy52ZWN0b3JCYWxsLCAnYW5jaG9yWScsIDAsIDEpO1xuICAgIGxldCBwcm9qZWN0aW9uID0gdGhpcy5ndWkuYWRkRm9sZGVyKCdQb3NpdGlvbicpO1xuICAgIHByb2plY3Rpb24uYWRkKHRoaXMudmVjdG9yQmFsbC5wb3NpdGlvbiwgJ3gnLCAtMTgwLCAxODApO1xuICAgIHByb2plY3Rpb24uYWRkKHRoaXMudmVjdG9yQmFsbC5wb3NpdGlvbiwgJ3knLCAtMTgwLCAxODApO1xuICAgIHByb2plY3Rpb24uYWRkKHRoaXMudmVjdG9yQmFsbC5wb3NpdGlvbiwgJ3onLCAtMiwgMTApO1xuICAgIGxldCByb3RhdGlvbiA9IHRoaXMuZ3VpLmFkZEZvbGRlcignUm90YXRpb24nKTtcbiAgICByb3RhdGlvbi5hZGQodGhpcy52ZWN0b3JCYWxsLCAncngnLCAtMzYwLCAzNjApO1xuICAgIHJvdGF0aW9uLmFkZCh0aGlzLnZlY3RvckJhbGwsICdyeScsIC0zNjAsIDM2MCk7XG4gICAgcm90YXRpb24uYWRkKHRoaXMudmVjdG9yQmFsbCwgJ3J6JywgLTM2MCwgMzYwKTtcbiAgICByb3RhdGlvbi5hZGQodGhpcy52ZWN0b3JCYWxsLCAnZXVsYXJSb3RhdGlvbkFzUm90YXRpb25NYXRyaXgnKTtcbiAgfVxuXG4gIG9uUmFmKCkge1xuICAgIC8vIHRoaXMudmVjdG9yQmFsbC5yb3RhdGlvbi5hZGRFdWxlcihcbiAgICAvLyAgICAgMjAsIDkwLCAzMCk7XG4gICAgLy8gdGhpcy5wcm9ncmVzcyArPSAwLjA0O1xuICAgIC8vIHRoaXMudmVjdG9yQmFsbC5yeiA9IHRoaXMucHJvZ3Jlc3M7XG4gICAgLy8gY29uc29sZS5sb2coJ3MnLCB0aGlzLnZlY3RvckJhbGwucm90YXRpb24pO1xuICAgIHRoaXMudmVjdG9yQmFsbC5yZW5kZXIodHJ1ZSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBWZWN0b3JEb21TYW1wbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/vector-dom.js\n");

/***/ }),

/***/ "./examples/vector-dom2.js":
/*!*********************************!*\
  !*** ./examples/vector-dom2.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _dat = __webpack_require__(/*! dat.gui */ \"./node_modules/dat.gui/build/dat.gui.module.js\");\n\nvar dat = _interopRequireWildcard(_dat);\n\nvar _vectorDom = __webpack_require__(/*! ../lib/dom/vector-dom */ \"./lib/dom/vector-dom.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nclass VectorDomSample2 {\n  constructor() {\n    this.gui = new dat.GUI();\n    this.balls = Array.from(document.querySelectorAll('.ball'));\n    this.ballVectors = [];\n\n    const createBall = (id, x, y, z, sway) => {\n      let ballVector = new _vectorDom.VectorDom(document.getElementById(id)); // By default, VectorDom will stop running when element goes\n      // out of view so we turn this feature off.\n\n      ballVector.renderOnlyWhenInview = false; // Rougly and manually set it to the center of the screen.\n\n      ballVector.setOffset(new _vector.Vector(800 / 2 - 100, 800 / 2, 0));\n      ballVector.moveX = _mathf.mathf.getRandomFloat(-15, 15);\n      ballVector.moveY = _mathf.mathf.getRandomFloat(-5, 5);\n      ballVector.moveZ = _mathf.mathf.getRandomFloat(-0.01, 0.01);\n      ballVector.rotateX = _mathf.mathf.getRandomFloat(-180, 180);\n      ballVector.rotateY = _mathf.mathf.getRandomFloat(-180, 180);\n      ballVector.rotateZ = _mathf.mathf.getRandomFloat(-180, 180);\n      ballVector.sway = sway; // This demonstrates continously adding degrees to keep rotating\n      // an element.\n\n      ballVector.randomRotation = _mathf.mathf.getRandomFloat(-90, 90.5);\n      ballVector.setPosition(new _vector.Vector(x, y, z));\n      ballVector.init();\n      this.ballVectors.push(ballVector);\n    };\n\n    createBall('ball1', -100, 100, 2, true);\n    createBall('ball2', 100, 100, -0.5);\n    createBall('ball3', -100, -100, -0.2, true);\n    createBall('ball4', -100, -100, 1, true);\n    createBall('ball5', -100, 100, 0.5);\n    createBall('ball6', 100, 100, 0.2, true);\n    createBall('ball7', 100, -100, 0.5);\n    createBall('ball8', 100, -100, 1);\n    this.timer = 0;\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.raf.start();\n  }\n\n  onRaf(delta) {\n    this.timer += 0.04;\n    const sin = Math.sin(this.timer);\n    this.ballVectors.forEach(ballVector => {\n      let position = new _vector.Vector(ballVector.moveX * sin, ballVector.moveY * sin, ballVector.moveZ * sin);\n      ballVector.position.add(position); // Slerp the rotatation. Goes back and worth.\n\n      if (ballVector.sway) {\n        ballVector.rotation.slerpEuler(ballVector.rotateX * sin, ballVector.rotateY * sin, ballVector.rotateZ * sin, 0.25);\n      } else {\n        // Constant rotation rotation.\n        ballVector.rotation.addEuler(ballVector.randomRotation, ballVector.randomRotation, ballVector.randomRotation);\n      }\n\n      ballVector.render();\n    });\n  }\n\n}\n\nexports.default = VectorDomSample2;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy92ZWN0b3ItZG9tMi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3ZlY3Rvci1kb20yLmpzPzVlMDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZGF0ID0gcmVxdWlyZShcImRhdC5ndWlcIik7XG5cbnZhciBkYXQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfZGF0KTtcblxudmFyIF92ZWN0b3JEb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbS92ZWN0b3ItZG9tXCIpO1xuXG52YXIgX3JhZiA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZlwiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL3ZlY3RvclwiKTtcblxudmFyIF9tYXRoZiA9IHJlcXVpcmUoXCIuLi9saWIvbWF0aGYvbWF0aGZcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY2xhc3MgVmVjdG9yRG9tU2FtcGxlMiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZ3VpID0gbmV3IGRhdC5HVUkoKTtcbiAgICB0aGlzLmJhbGxzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYmFsbCcpKTtcbiAgICB0aGlzLmJhbGxWZWN0b3JzID0gW107XG5cbiAgICBjb25zdCBjcmVhdGVCYWxsID0gKGlkLCB4LCB5LCB6LCBzd2F5KSA9PiB7XG4gICAgICBsZXQgYmFsbFZlY3RvciA9IG5ldyBfdmVjdG9yRG9tLlZlY3RvckRvbShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpOyAvLyBCeSBkZWZhdWx0LCBWZWN0b3JEb20gd2lsbCBzdG9wIHJ1bm5pbmcgd2hlbiBlbGVtZW50IGdvZXNcbiAgICAgIC8vIG91dCBvZiB2aWV3IHNvIHdlIHR1cm4gdGhpcyBmZWF0dXJlIG9mZi5cblxuICAgICAgYmFsbFZlY3Rvci5yZW5kZXJPbmx5V2hlbkludmlldyA9IGZhbHNlOyAvLyBSb3VnbHkgYW5kIG1hbnVhbGx5IHNldCBpdCB0byB0aGUgY2VudGVyIG9mIHRoZSBzY3JlZW4uXG5cbiAgICAgIGJhbGxWZWN0b3Iuc2V0T2Zmc2V0KG5ldyBfdmVjdG9yLlZlY3Rvcig4MDAgLyAyIC0gMTAwLCA4MDAgLyAyLCAwKSk7XG4gICAgICBiYWxsVmVjdG9yLm1vdmVYID0gX21hdGhmLm1hdGhmLmdldFJhbmRvbUZsb2F0KC0xNSwgMTUpO1xuICAgICAgYmFsbFZlY3Rvci5tb3ZlWSA9IF9tYXRoZi5tYXRoZi5nZXRSYW5kb21GbG9hdCgtNSwgNSk7XG4gICAgICBiYWxsVmVjdG9yLm1vdmVaID0gX21hdGhmLm1hdGhmLmdldFJhbmRvbUZsb2F0KC0wLjAxLCAwLjAxKTtcbiAgICAgIGJhbGxWZWN0b3Iucm90YXRlWCA9IF9tYXRoZi5tYXRoZi5nZXRSYW5kb21GbG9hdCgtMTgwLCAxODApO1xuICAgICAgYmFsbFZlY3Rvci5yb3RhdGVZID0gX21hdGhmLm1hdGhmLmdldFJhbmRvbUZsb2F0KC0xODAsIDE4MCk7XG4gICAgICBiYWxsVmVjdG9yLnJvdGF0ZVogPSBfbWF0aGYubWF0aGYuZ2V0UmFuZG9tRmxvYXQoLTE4MCwgMTgwKTtcbiAgICAgIGJhbGxWZWN0b3Iuc3dheSA9IHN3YXk7IC8vIFRoaXMgZGVtb25zdHJhdGVzIGNvbnRpbm91c2x5IGFkZGluZyBkZWdyZWVzIHRvIGtlZXAgcm90YXRpbmdcbiAgICAgIC8vIGFuIGVsZW1lbnQuXG5cbiAgICAgIGJhbGxWZWN0b3IucmFuZG9tUm90YXRpb24gPSBfbWF0aGYubWF0aGYuZ2V0UmFuZG9tRmxvYXQoLTkwLCA5MC41KTtcbiAgICAgIGJhbGxWZWN0b3Iuc2V0UG9zaXRpb24obmV3IF92ZWN0b3IuVmVjdG9yKHgsIHksIHopKTtcbiAgICAgIGJhbGxWZWN0b3IuaW5pdCgpO1xuICAgICAgdGhpcy5iYWxsVmVjdG9ycy5wdXNoKGJhbGxWZWN0b3IpO1xuICAgIH07XG5cbiAgICBjcmVhdGVCYWxsKCdiYWxsMScsIC0xMDAsIDEwMCwgMiwgdHJ1ZSk7XG4gICAgY3JlYXRlQmFsbCgnYmFsbDInLCAxMDAsIDEwMCwgLTAuNSk7XG4gICAgY3JlYXRlQmFsbCgnYmFsbDMnLCAtMTAwLCAtMTAwLCAtMC4yLCB0cnVlKTtcbiAgICBjcmVhdGVCYWxsKCdiYWxsNCcsIC0xMDAsIC0xMDAsIDEsIHRydWUpO1xuICAgIGNyZWF0ZUJhbGwoJ2JhbGw1JywgLTEwMCwgMTAwLCAwLjUpO1xuICAgIGNyZWF0ZUJhbGwoJ2JhbGw2JywgMTAwLCAxMDAsIDAuMiwgdHJ1ZSk7XG4gICAgY3JlYXRlQmFsbCgnYmFsbDcnLCAxMDAsIC0xMDAsIDAuNSk7XG4gICAgY3JlYXRlQmFsbCgnYmFsbDgnLCAxMDAsIC0xMDAsIDEpO1xuICAgIHRoaXMudGltZXIgPSAwO1xuICAgIHRoaXMucmFmID0gbmV3IF9yYWYuUmFmKHRoaXMub25SYWYuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgfVxuXG4gIG9uUmFmKGRlbHRhKSB7XG4gICAgdGhpcy50aW1lciArPSAwLjA0O1xuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKHRoaXMudGltZXIpO1xuICAgIHRoaXMuYmFsbFZlY3RvcnMuZm9yRWFjaChiYWxsVmVjdG9yID0+IHtcbiAgICAgIGxldCBwb3NpdGlvbiA9IG5ldyBfdmVjdG9yLlZlY3RvcihiYWxsVmVjdG9yLm1vdmVYICogc2luLCBiYWxsVmVjdG9yLm1vdmVZICogc2luLCBiYWxsVmVjdG9yLm1vdmVaICogc2luKTtcbiAgICAgIGJhbGxWZWN0b3IucG9zaXRpb24uYWRkKHBvc2l0aW9uKTsgLy8gU2xlcnAgdGhlIHJvdGF0YXRpb24uIEdvZXMgYmFjayBhbmQgd29ydGguXG5cbiAgICAgIGlmIChiYWxsVmVjdG9yLnN3YXkpIHtcbiAgICAgICAgYmFsbFZlY3Rvci5yb3RhdGlvbi5zbGVycEV1bGVyKGJhbGxWZWN0b3Iucm90YXRlWCAqIHNpbiwgYmFsbFZlY3Rvci5yb3RhdGVZICogc2luLCBiYWxsVmVjdG9yLnJvdGF0ZVogKiBzaW4sIDAuMjUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29uc3RhbnQgcm90YXRpb24gcm90YXRpb24uXG4gICAgICAgIGJhbGxWZWN0b3Iucm90YXRpb24uYWRkRXVsZXIoYmFsbFZlY3Rvci5yYW5kb21Sb3RhdGlvbiwgYmFsbFZlY3Rvci5yYW5kb21Sb3RhdGlvbiwgYmFsbFZlY3Rvci5yYW5kb21Sb3RhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGJhbGxWZWN0b3IucmVuZGVyKCk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBWZWN0b3JEb21TYW1wbGUyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/vector-dom2.js\n");

/***/ }),

/***/ "./examples/vector-dom3.js":
/*!*********************************!*\
  !*** ./examples/vector-dom3.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _dat = __webpack_require__(/*! dat.gui */ \"./node_modules/dat.gui/build/dat.gui.module.js\");\n\nvar dat = _interopRequireWildcard(_dat);\n\nvar _vectorDom = __webpack_require__(/*! ../lib/dom/vector-dom */ \"./lib/dom/vector-dom.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _mouseTracker = __webpack_require__(/*! ../lib/dom/mouse-tracker */ \"./lib/dom/mouse-tracker.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nclass VectorDomSample3 {\n  constructor() {\n    this.gui = new dat.GUI();\n    console.log('vectorDOM3');\n    this.vectorBall = new _vectorDom.VectorDom(document.getElementById('ball'));\n    this.vectorBall.anchorX = 0;\n    this.vectorBall.anchorY = 0;\n    this.vectorBall.setPosition(new _vector.Vector(0, 0, 0.8 - 1));\n    this.vectorBall.init();\n    this.vectorBall2 = new _vectorDom.VectorDom(document.getElementById('ball2'));\n    this.vectorBall2.anchorX = 0.5;\n    this.vectorBall2.anchorY = 0.5;\n    this.vectorBall2.setPosition(new _vector.Vector(0, 0, 1.3 - 1));\n    this.vectorBall2.setOffset(new _vector.Vector(100, -200, 0));\n    this.vectorBall2.init();\n    this.text = new _vectorDom.VectorDom(document.getElementById('text'));\n    this.text.anchorX = 0;\n    this.text.anchorY = 0;\n    this.text.setPosition(new _vector.Vector(100, 200, 1.2 - 1));\n    this.text.init();\n    this.raf = new _raf.Raf(this.onRaf.bind(this));\n    this.raf.start();\n  }\n\n  onRaf() {\n    // this.text._.force.mouseRotationForce(\n    //     -0.002, -0.02, 0, 0.16\n    // );\n    this.vectorBall2._.force.mouseRotationForce(0.02, 0.02, 0, 0.02);\n\n    this.vectorBall._.force.scrollYRotationForce(-0.004, 0); // this.vectorBall2.rx += 0.003;\n    // this.vectorBall2._.force.addScrollYRotationForce(\n    //     0,\n    //     -0.004\n    // );\n\n\n    this.vectorBall.render();\n    this.vectorBall2.render(); // this.text.render();\n  }\n\n}\n\nexports.default = VectorDomSample3;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy92ZWN0b3ItZG9tMy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3ZlY3Rvci1kb20zLmpzP2M2NjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZGF0ID0gcmVxdWlyZShcImRhdC5ndWlcIik7XG5cbnZhciBkYXQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfZGF0KTtcblxudmFyIF92ZWN0b3JEb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbS92ZWN0b3ItZG9tXCIpO1xuXG52YXIgX3JhZiA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZlwiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL3ZlY3RvclwiKTtcblxudmFyIF9tb3VzZVRyYWNrZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9tb3VzZS10cmFja2VyXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IHt9OyBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmNsYXNzIFZlY3RvckRvbVNhbXBsZTMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmd1aSA9IG5ldyBkYXQuR1VJKCk7XG4gICAgY29uc29sZS5sb2coJ3ZlY3RvckRPTTMnKTtcbiAgICB0aGlzLnZlY3RvckJhbGwgPSBuZXcgX3ZlY3RvckRvbS5WZWN0b3JEb20oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhbGwnKSk7XG4gICAgdGhpcy52ZWN0b3JCYWxsLmFuY2hvclggPSAwO1xuICAgIHRoaXMudmVjdG9yQmFsbC5hbmNob3JZID0gMDtcbiAgICB0aGlzLnZlY3RvckJhbGwuc2V0UG9zaXRpb24obmV3IF92ZWN0b3IuVmVjdG9yKDAsIDAsIDAuOCAtIDEpKTtcbiAgICB0aGlzLnZlY3RvckJhbGwuaW5pdCgpO1xuICAgIHRoaXMudmVjdG9yQmFsbDIgPSBuZXcgX3ZlY3RvckRvbS5WZWN0b3JEb20oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhbGwyJykpO1xuICAgIHRoaXMudmVjdG9yQmFsbDIuYW5jaG9yWCA9IDAuNTtcbiAgICB0aGlzLnZlY3RvckJhbGwyLmFuY2hvclkgPSAwLjU7XG4gICAgdGhpcy52ZWN0b3JCYWxsMi5zZXRQb3NpdGlvbihuZXcgX3ZlY3Rvci5WZWN0b3IoMCwgMCwgMS4zIC0gMSkpO1xuICAgIHRoaXMudmVjdG9yQmFsbDIuc2V0T2Zmc2V0KG5ldyBfdmVjdG9yLlZlY3RvcigxMDAsIC0yMDAsIDApKTtcbiAgICB0aGlzLnZlY3RvckJhbGwyLmluaXQoKTtcbiAgICB0aGlzLnRleHQgPSBuZXcgX3ZlY3RvckRvbS5WZWN0b3JEb20oZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RleHQnKSk7XG4gICAgdGhpcy50ZXh0LmFuY2hvclggPSAwO1xuICAgIHRoaXMudGV4dC5hbmNob3JZID0gMDtcbiAgICB0aGlzLnRleHQuc2V0UG9zaXRpb24obmV3IF92ZWN0b3IuVmVjdG9yKDEwMCwgMjAwLCAxLjIgLSAxKSk7XG4gICAgdGhpcy50ZXh0LmluaXQoKTtcbiAgICB0aGlzLnJhZiA9IG5ldyBfcmFmLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgIHRoaXMucmFmLnN0YXJ0KCk7XG4gIH1cblxuICBvblJhZigpIHtcbiAgICAvLyB0aGlzLnRleHQuXy5mb3JjZS5tb3VzZVJvdGF0aW9uRm9yY2UoXG4gICAgLy8gICAgIC0wLjAwMiwgLTAuMDIsIDAsIDAuMTZcbiAgICAvLyApO1xuICAgIHRoaXMudmVjdG9yQmFsbDIuXy5mb3JjZS5tb3VzZVJvdGF0aW9uRm9yY2UoMC4wMiwgMC4wMiwgMCwgMC4wMik7XG5cbiAgICB0aGlzLnZlY3RvckJhbGwuXy5mb3JjZS5zY3JvbGxZUm90YXRpb25Gb3JjZSgtMC4wMDQsIDApOyAvLyB0aGlzLnZlY3RvckJhbGwyLnJ4ICs9IDAuMDAzO1xuICAgIC8vIHRoaXMudmVjdG9yQmFsbDIuXy5mb3JjZS5hZGRTY3JvbGxZUm90YXRpb25Gb3JjZShcbiAgICAvLyAgICAgMCxcbiAgICAvLyAgICAgLTAuMDA0XG4gICAgLy8gKTtcblxuXG4gICAgdGhpcy52ZWN0b3JCYWxsLnJlbmRlcigpO1xuICAgIHRoaXMudmVjdG9yQmFsbDIucmVuZGVyKCk7IC8vIHRoaXMudGV4dC5yZW5kZXIoKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFZlY3RvckRvbVNhbXBsZTM7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/vector-dom3.js\n");

/***/ }),

/***/ "./examples/video-player.js":
/*!**********************************!*\
  !*** ./examples/video-player.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nvar _videoPlayer = __webpack_require__(/*! ../lib/dom/video-player */ \"./lib/dom/video-player.js\");\n\nclass VideoPlayerSample {\n  constructor() {\n    let video = document.getElementById('video');\n    let time = document.getElementById('time');\n    let videoPlayer = new _videoPlayer.VideoPlayer(video, {\n      rafCallback: () => {\n        time.textContent = videoPlayer.getTime();\n      }\n    });\n    console.log(videoPlayer);\n    const watcher = new _domWatcher.DomWatcher();\n    videoPlayer.load(); // Button 1\n\n    watcher.add({\n      element: document.getElementById('button1'),\n      on: 'click',\n      callback: event => {\n        videoPlayer.play();\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    watcher.add({\n      element: document.getElementById('button2'),\n      on: 'click',\n      callback: event => {\n        videoPlayer.pause();\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    watcher.add({\n      element: document.getElementById('button3'),\n      on: 'click',\n      callback: event => {\n        videoPlayer.reset();\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n    watcher.add({\n      element: document.getElementById('button4'),\n      on: 'click',\n      callback: event => {\n        videoPlayer.playFromTo(5, 6);\n      },\n      eventOptions: {\n        passive: true\n      }\n    });\n  }\n\n}\n\nexports.default = VideoPlayerSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy92aWRlby1wbGF5ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy92aWRlby1wbGF5ZXIuanM/OWFlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbnZhciBfdmlkZW9QbGF5ZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS92aWRlby1wbGF5ZXJcIik7XG5cbmNsYXNzIFZpZGVvUGxheWVyU2FtcGxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IHZpZGVvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ZpZGVvJyk7XG4gICAgbGV0IHRpbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGltZScpO1xuICAgIGxldCB2aWRlb1BsYXllciA9IG5ldyBfdmlkZW9QbGF5ZXIuVmlkZW9QbGF5ZXIodmlkZW8sIHtcbiAgICAgIHJhZkNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIHRpbWUudGV4dENvbnRlbnQgPSB2aWRlb1BsYXllci5nZXRUaW1lKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc29sZS5sb2codmlkZW9QbGF5ZXIpO1xuICAgIGNvbnN0IHdhdGNoZXIgPSBuZXcgX2RvbVdhdGNoZXIuRG9tV2F0Y2hlcigpO1xuICAgIHZpZGVvUGxheWVyLmxvYWQoKTsgLy8gQnV0dG9uIDFcblxuICAgIHdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidXR0b24xJyksXG4gICAgICBvbjogJ2NsaWNrJyxcbiAgICAgIGNhbGxiYWNrOiBldmVudCA9PiB7XG4gICAgICAgIHZpZGVvUGxheWVyLnBsYXkoKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdidXR0b24yJyksXG4gICAgICBvbjogJ2NsaWNrJyxcbiAgICAgIGNhbGxiYWNrOiBldmVudCA9PiB7XG4gICAgICAgIHZpZGVvUGxheWVyLnBhdXNlKCk7XG4gICAgICB9LFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB3YXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnV0dG9uMycpLFxuICAgICAgb246ICdjbGljaycsXG4gICAgICBjYWxsYmFjazogZXZlbnQgPT4ge1xuICAgICAgICB2aWRlb1BsYXllci5yZXNldCgpO1xuICAgICAgfSxcbiAgICAgIGV2ZW50T3B0aW9uczoge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgd2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J1dHRvbjQnKSxcbiAgICAgIG9uOiAnY2xpY2snLFxuICAgICAgY2FsbGJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgdmlkZW9QbGF5ZXIucGxheUZyb21Ubyg1LCA2KTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gVmlkZW9QbGF5ZXJTYW1wbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/video-player.js\n");

/***/ }),

/***/ "./examples/video-progress.js":
/*!************************************!*\
  !*** ./examples/video-progress.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _videoProgress = __webpack_require__(/*! ../lib/dom/video-progress */ \"./lib/dom/video-progress.js\");\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _scrollRenderFix = __webpack_require__(/*! ../lib/dom/scroll-render-fix */ \"./lib/dom/scroll-render-fix.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\n/**\n * Experimental class that ties updates an html5 video with progress.\n * The problem with this approach is that the video is updated via,\n * currentTime which fires very slowly depending on video size\n * and browser.\n *\n * Currently, this seems to only work on Safari and Chrome if the video\n * file is compressed and small enough.\n *\n * Not recommended this for production use.\n *\n * ffmpeg -i video-test.mp4 -r 30 -g 1 -an -loglevel panic -vcodec copy -acodec copy video-test2.mp4\n * -r sets frame rate\n * -g sets a keyframe every frame.\n *\n * @experimental\n */\nclass VideoProgressSample {\n  constructor() {\n    let wrapper = document.getElementById('wrapper');\n    let video = document.getElementById('video');\n    const rafProgress = new _rafProgress.RafProgress();\n    this.videoProgress = new _videoProgress.VideoProgress(video); // Update rafProgress when the window scrolls.\n\n    window.addEventListener('scroll', () => {\n      // Set the progress of the video.\n      let progress = _dom.dom.getElementScrolledPercent(wrapper);\n\n      rafProgress.easeTo(progress, 0.25, _ease.EASE.easeInOutQuad);\n    }); // When the rafProgress updates, update the videoProgress\n    // with the latest.\n\n    rafProgress.watch((easedProgress, direction) => {\n      this.videoProgress.setProgress(easedProgress);\n    }); // When the video loads.\n\n    this.videoProgress.load().then(() => {\n      console.log('video loaded'); // Update the current progress.\n\n      let progress = _dom.dom.getElementScrolledPercent(wrapper);\n\n      rafProgress.setCurrentProgress(progress);\n    });\n  }\n\n}\n\nexports.default = VideoProgressSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy92aWRlby1wcm9ncmVzcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3ZpZGVvLXByb2dyZXNzLmpzP2FhNjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdmlkZW9Qcm9ncmVzcyA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL3ZpZGVvLXByb2dyZXNzXCIpO1xuXG52YXIgX3JhZlByb2dyZXNzID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmLXByb2dyZXNzXCIpO1xuXG52YXIgX2RvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbVwiKTtcblxudmFyIF9zY3JvbGxSZW5kZXJGaXggPSByZXF1aXJlKFwiLi4vbGliL2RvbS9zY3JvbGwtcmVuZGVyLWZpeFwiKTtcblxudmFyIF9lYXNlID0gcmVxdWlyZShcIi4uL2xpYi9lYXNlL2Vhc2VcIik7XG5cbi8qKlxuICogRXhwZXJpbWVudGFsIGNsYXNzIHRoYXQgdGllcyB1cGRhdGVzIGFuIGh0bWw1IHZpZGVvIHdpdGggcHJvZ3Jlc3MuXG4gKiBUaGUgcHJvYmxlbSB3aXRoIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB0aGUgdmlkZW8gaXMgdXBkYXRlZCB2aWEsXG4gKiBjdXJyZW50VGltZSB3aGljaCBmaXJlcyB2ZXJ5IHNsb3dseSBkZXBlbmRpbmcgb24gdmlkZW8gc2l6ZVxuICogYW5kIGJyb3dzZXIuXG4gKlxuICogQ3VycmVudGx5LCB0aGlzIHNlZW1zIHRvIG9ubHkgd29yayBvbiBTYWZhcmkgYW5kIENocm9tZSBpZiB0aGUgdmlkZW9cbiAqIGZpbGUgaXMgY29tcHJlc3NlZCBhbmQgc21hbGwgZW5vdWdoLlxuICpcbiAqIE5vdCByZWNvbW1lbmRlZCB0aGlzIGZvciBwcm9kdWN0aW9uIHVzZS5cbiAqXG4gKiBmZm1wZWcgLWkgdmlkZW8tdGVzdC5tcDQgLXIgMzAgLWcgMSAtYW4gLWxvZ2xldmVsIHBhbmljIC12Y29kZWMgY29weSAtYWNvZGVjIGNvcHkgdmlkZW8tdGVzdDIubXA0XG4gKiAtciBzZXRzIGZyYW1lIHJhdGVcbiAqIC1nIHNldHMgYSBrZXlmcmFtZSBldmVyeSBmcmFtZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmNsYXNzIFZpZGVvUHJvZ3Jlc3NTYW1wbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgd3JhcHBlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cmFwcGVyJyk7XG4gICAgbGV0IHZpZGVvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ZpZGVvJyk7XG4gICAgY29uc3QgcmFmUHJvZ3Jlc3MgPSBuZXcgX3JhZlByb2dyZXNzLlJhZlByb2dyZXNzKCk7XG4gICAgdGhpcy52aWRlb1Byb2dyZXNzID0gbmV3IF92aWRlb1Byb2dyZXNzLlZpZGVvUHJvZ3Jlc3ModmlkZW8pOyAvLyBVcGRhdGUgcmFmUHJvZ3Jlc3Mgd2hlbiB0aGUgd2luZG93IHNjcm9sbHMuXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4ge1xuICAgICAgLy8gU2V0IHRoZSBwcm9ncmVzcyBvZiB0aGUgdmlkZW8uXG4gICAgICBsZXQgcHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHdyYXBwZXIpO1xuXG4gICAgICByYWZQcm9ncmVzcy5lYXNlVG8ocHJvZ3Jlc3MsIDAuMjUsIF9lYXNlLkVBU0UuZWFzZUluT3V0UXVhZCk7XG4gICAgfSk7IC8vIFdoZW4gdGhlIHJhZlByb2dyZXNzIHVwZGF0ZXMsIHVwZGF0ZSB0aGUgdmlkZW9Qcm9ncmVzc1xuICAgIC8vIHdpdGggdGhlIGxhdGVzdC5cblxuICAgIHJhZlByb2dyZXNzLndhdGNoKChlYXNlZFByb2dyZXNzLCBkaXJlY3Rpb24pID0+IHtcbiAgICAgIHRoaXMudmlkZW9Qcm9ncmVzcy5zZXRQcm9ncmVzcyhlYXNlZFByb2dyZXNzKTtcbiAgICB9KTsgLy8gV2hlbiB0aGUgdmlkZW8gbG9hZHMuXG5cbiAgICB0aGlzLnZpZGVvUHJvZ3Jlc3MubG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ3ZpZGVvIGxvYWRlZCcpOyAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MuXG5cbiAgICAgIGxldCBwcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQod3JhcHBlcik7XG5cbiAgICAgIHJhZlByb2dyZXNzLnNldEN1cnJlbnRQcm9ncmVzcyhwcm9ncmVzcyk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBWaWRlb1Byb2dyZXNzU2FtcGxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/video-progress.js\n");

/***/ }),

/***/ "./examples/webgl-image-sequence.js":
/*!******************************************!*\
  !*** ./examples/webgl-image-sequence.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _webglImageSequence = __webpack_require__(/*! ../lib/dom/webgl-image-sequence */ \"./lib/dom/webgl-image-sequence.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\nclass WebGlImageSequenceSample {\n  constructor() {\n    console.log('webgl image sequence');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Instance of rafProgress.\n\n    this.rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        this.rafProgress.easeTo(this.progress, 0.25, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.rafProgress.watch(this.onProgressUpdate.bind(this)); // Generate image sources.\n\n    this.imageSources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.imageSources.push('./public/frames/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.webglImageSequence = new _webglImageSequence.WebGlImageSequence(this.canvasContainerElement, [{\n      images: this.imageSources\n    }], {\n      ariaLabel: 'Aria Label Test'\n    }); // Load the iamges.\n\n    this.webglImageSequence.load().then(() => {\n      // When ready render whatever the current easedProgress value is.\n      this.webglImageSequence.renderByProgress(this.rafProgress.currentProgress);\n    });\n  }\n\n  onProgressUpdate(easedProgress, direction) {\n    this.webglImageSequence.renderByProgress(easedProgress);\n  }\n\n}\n\nexports.default = WebGlImageSequenceSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy93ZWJnbC1pbWFnZS1zZXF1ZW5jZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3dlYmdsLWltYWdlLXNlcXVlbmNlLmpzPzFhMjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmFmUHJvZ3Jlc3MgPSByZXF1aXJlKFwiLi4vbGliL3JhZi9yYWYtcHJvZ3Jlc3NcIik7XG5cbnZhciBfd2ViZ2xJbWFnZVNlcXVlbmNlID0gcmVxdWlyZShcIi4uL2xpYi9kb20vd2ViZ2wtaW1hZ2Utc2VxdWVuY2VcIik7XG5cbnZhciBfZWFzZSA9IHJlcXVpcmUoXCIuLi9saWIvZWFzZS9lYXNlXCIpO1xuXG52YXIgX2RvbSA9IHJlcXVpcmUoXCIuLi9saWIvZG9tL2RvbVwiKTtcblxudmFyIF9kb21XYXRjaGVyID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tLXdhdGNoZXJcIik7XG5cbmNsYXNzIFdlYkdsSW1hZ2VTZXF1ZW5jZVNhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCd3ZWJnbCBpbWFnZSBzZXF1ZW5jZScpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5jYW52YXNDb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbnZhcy1jb250YWluZXInKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyZW50Jyk7IC8vIEluc3RhbmNlIG9mIHJhZlByb2dyZXNzLlxuXG4gICAgdGhpcy5yYWZQcm9ncmVzcyA9IG5ldyBfcmFmUHJvZ3Jlc3MuUmFmUHJvZ3Jlc3MoKTsgLy8gVXBkYXRlIHRoZSBwcm9ncmVzcyB2YWx1ZSBwZXIgc2Nyb2xsLlxuXG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Njcm9sbCcsXG4gICAgICBjYWxsYmFjazogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAwLjI1LCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gICAgICB9LFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTsgLy8gVXBkYXRlIHByb2dyZXNzIGltbWVkaWF0ZWx5IG9uIGxvYWQuXG5cbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDEsIF9lYXNlLkVBU0UuTGluZWFyKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzLndhdGNoKHRoaXMub25Qcm9ncmVzc1VwZGF0ZS5iaW5kKHRoaXMpKTsgLy8gR2VuZXJhdGUgaW1hZ2Ugc291cmNlcy5cblxuICAgIHRoaXMuaW1hZ2VTb3VyY2VzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSAxNTM7IGkrKykge1xuICAgICAgbGV0IHZhbHVlID0gaSArICcnO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5wYWRTdGFydCg0LCAnMCcpO1xuICAgICAgdGhpcy5pbWFnZVNvdXJjZXMucHVzaCgnLi9wdWJsaWMvZnJhbWVzL3RodW1iJyArIHZhbHVlICsgJy5qcGcnKTtcbiAgICB9IC8vIENyZWF0ZSBDYW52YXMgSW1hZ2UgU2VxdWVuZWNlXG5cblxuICAgIHRoaXMud2ViZ2xJbWFnZVNlcXVlbmNlID0gbmV3IF93ZWJnbEltYWdlU2VxdWVuY2UuV2ViR2xJbWFnZVNlcXVlbmNlKHRoaXMuY2FudmFzQ29udGFpbmVyRWxlbWVudCwgW3tcbiAgICAgIGltYWdlczogdGhpcy5pbWFnZVNvdXJjZXNcbiAgICB9XSwge1xuICAgICAgYXJpYUxhYmVsOiAnQXJpYSBMYWJlbCBUZXN0J1xuICAgIH0pOyAvLyBMb2FkIHRoZSBpYW1nZXMuXG5cbiAgICB0aGlzLndlYmdsSW1hZ2VTZXF1ZW5jZS5sb2FkKCkudGhlbigoKSA9PiB7XG4gICAgICAvLyBXaGVuIHJlYWR5IHJlbmRlciB3aGF0ZXZlciB0aGUgY3VycmVudCBlYXNlZFByb2dyZXNzIHZhbHVlIGlzLlxuICAgICAgdGhpcy53ZWJnbEltYWdlU2VxdWVuY2UucmVuZGVyQnlQcm9ncmVzcyh0aGlzLnJhZlByb2dyZXNzLmN1cnJlbnRQcm9ncmVzcyk7XG4gICAgfSk7XG4gIH1cblxuICBvblByb2dyZXNzVXBkYXRlKGVhc2VkUHJvZ3Jlc3MsIGRpcmVjdGlvbikge1xuICAgIHRoaXMud2ViZ2xJbWFnZVNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3MoZWFzZWRQcm9ncmVzcyk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBXZWJHbEltYWdlU2VxdWVuY2VTYW1wbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/webgl-image-sequence.js\n");

/***/ }),

/***/ "./examples/webgl-image-sequence2.js":
/*!*******************************************!*\
  !*** ./examples/webgl-image-sequence2.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _webglImageSequence = __webpack_require__(/*! ../lib/dom/webgl-image-sequence */ \"./lib/dom/webgl-image-sequence.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\n/**\n * This sample expands on canvas image sequence sample 1 and demonstrates\n * usage of multiinterpolate.\n */\nclass WebGlImageSequenceSample2 {\n  constructor() {\n    console.log('webgl image sequence2');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Instance of rafProgress.\n\n    this.rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        this.rafProgress.easeTo(this.progress, 0.25, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.rafProgress.watch(this.onProgressUpdate.bind(this)); // Generate image sources.\n\n    this.sources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.sources.push('./public/frames/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.webglImageSequence = new _webglImageSequence.WebGlImageSequence(this.canvasContainerElement, [{\n      images: this.sources\n    }]);\n    let progressPoints = [{\n      from: 0,\n      to: 0.5,\n      start: 0,\n      end: 1\n    }, {\n      from: 0.5,\n      to: 1,\n      start: 1,\n      end: 0\n    }];\n    this.webglImageSequence.setMultiInterpolation(progressPoints); // Load the iamges.\n\n    this.webglImageSequence.load().then(() => {\n      // When ready render whatever the current easedProgress value is.\n      this.webglImageSequence.renderByProgress(this.rafProgress.currentProgress);\n    });\n  }\n\n  onProgressUpdate(easedProgress, direction) {\n    this.webglImageSequence.renderByProgress(easedProgress);\n  }\n\n}\n\nexports.default = WebGlImageSequenceSample2;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy93ZWJnbC1pbWFnZS1zZXF1ZW5jZTIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy93ZWJnbC1pbWFnZS1zZXF1ZW5jZTIuanM/MDc5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yYWZQcm9ncmVzcyA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZi1wcm9ncmVzc1wiKTtcblxudmFyIF93ZWJnbEltYWdlU2VxdWVuY2UgPSByZXF1aXJlKFwiLi4vbGliL2RvbS93ZWJnbC1pbWFnZS1zZXF1ZW5jZVwiKTtcblxudmFyIF9lYXNlID0gcmVxdWlyZShcIi4uL2xpYi9lYXNlL2Vhc2VcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxuLyoqXG4gKiBUaGlzIHNhbXBsZSBleHBhbmRzIG9uIGNhbnZhcyBpbWFnZSBzZXF1ZW5jZSBzYW1wbGUgMSBhbmQgZGVtb25zdHJhdGVzXG4gKiB1c2FnZSBvZiBtdWx0aWludGVycG9sYXRlLlxuICovXG5jbGFzcyBXZWJHbEltYWdlU2VxdWVuY2VTYW1wbGUyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc29sZS5sb2coJ3dlYmdsIGltYWdlIHNlcXVlbmNlMicpO1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5jYW52YXNDb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbnZhcy1jb250YWluZXInKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyZW50Jyk7IC8vIEluc3RhbmNlIG9mIHJhZlByb2dyZXNzLlxuXG4gICAgdGhpcy5yYWZQcm9ncmVzcyA9IG5ldyBfcmFmUHJvZ3Jlc3MuUmFmUHJvZ3Jlc3MoKTsgLy8gVXBkYXRlIHRoZSBwcm9ncmVzcyB2YWx1ZSBwZXIgc2Nyb2xsLlxuXG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Njcm9sbCcsXG4gICAgICBjYWxsYmFjazogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAwLjI1LCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gICAgICB9LFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTsgLy8gVXBkYXRlIHByb2dyZXNzIGltbWVkaWF0ZWx5IG9uIGxvYWQuXG5cbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDEsIF9lYXNlLkVBU0UuTGluZWFyKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzLndhdGNoKHRoaXMub25Qcm9ncmVzc1VwZGF0ZS5iaW5kKHRoaXMpKTsgLy8gR2VuZXJhdGUgaW1hZ2Ugc291cmNlcy5cblxuICAgIHRoaXMuc291cmNlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMTUzOyBpKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9IGkgKyAnJztcbiAgICAgIHZhbHVlID0gdmFsdWUucGFkU3RhcnQoNCwgJzAnKTtcbiAgICAgIHRoaXMuc291cmNlcy5wdXNoKCcuL3B1YmxpYy9mcmFtZXMvdGh1bWInICsgdmFsdWUgKyAnLmpwZycpO1xuICAgIH0gLy8gQ3JlYXRlIENhbnZhcyBJbWFnZSBTZXF1ZW5lY2VcblxuXG4gICAgdGhpcy53ZWJnbEltYWdlU2VxdWVuY2UgPSBuZXcgX3dlYmdsSW1hZ2VTZXF1ZW5jZS5XZWJHbEltYWdlU2VxdWVuY2UodGhpcy5jYW52YXNDb250YWluZXJFbGVtZW50LCBbe1xuICAgICAgaW1hZ2VzOiB0aGlzLnNvdXJjZXNcbiAgICB9XSk7XG4gICAgbGV0IHByb2dyZXNzUG9pbnRzID0gW3tcbiAgICAgIGZyb206IDAsXG4gICAgICB0bzogMC41LFxuICAgICAgc3RhcnQ6IDAsXG4gICAgICBlbmQ6IDFcbiAgICB9LCB7XG4gICAgICBmcm9tOiAwLjUsXG4gICAgICB0bzogMSxcbiAgICAgIHN0YXJ0OiAxLFxuICAgICAgZW5kOiAwXG4gICAgfV07XG4gICAgdGhpcy53ZWJnbEltYWdlU2VxdWVuY2Uuc2V0TXVsdGlJbnRlcnBvbGF0aW9uKHByb2dyZXNzUG9pbnRzKTsgLy8gTG9hZCB0aGUgaWFtZ2VzLlxuXG4gICAgdGhpcy53ZWJnbEltYWdlU2VxdWVuY2UubG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gV2hlbiByZWFkeSByZW5kZXIgd2hhdGV2ZXIgdGhlIGN1cnJlbnQgZWFzZWRQcm9ncmVzcyB2YWx1ZSBpcy5cbiAgICAgIHRoaXMud2ViZ2xJbWFnZVNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3ModGhpcy5yYWZQcm9ncmVzcy5jdXJyZW50UHJvZ3Jlc3MpO1xuICAgIH0pO1xuICB9XG5cbiAgb25Qcm9ncmVzc1VwZGF0ZShlYXNlZFByb2dyZXNzLCBkaXJlY3Rpb24pIHtcbiAgICB0aGlzLndlYmdsSW1hZ2VTZXF1ZW5jZS5yZW5kZXJCeVByb2dyZXNzKGVhc2VkUHJvZ3Jlc3MpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gV2ViR2xJbWFnZVNlcXVlbmNlU2FtcGxlMjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/webgl-image-sequence2.js\n");

/***/ }),

/***/ "./examples/webgl-image-sequence3.js":
/*!*******************************************!*\
  !*** ./examples/webgl-image-sequence3.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _webglImageSequence = __webpack_require__(/*! ../lib/dom/webgl-image-sequence */ \"./lib/dom/webgl-image-sequence.js\");\n\n/**\n * CanvasImageSequence play feature.\n */\nclass CanvasImageSequenceSample3 {\n  constructor() {\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Generate image sources.\n\n    this.sources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.sources.push('./public/frames/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.sequence = new _webglImageSequence.WebGlImageSequence(this.canvasContainerElement, [{\n      images: this.sources\n    }]);\n    let progressPoints = [{\n      from: 0,\n      to: 0.5,\n      start: 0,\n      end: 1\n    }, {\n      from: 0.5,\n      to: 1,\n      start: 1,\n      end: 0\n    }];\n    this.sequence.setMultiInterpolation(progressPoints); // Load the iamges.\n\n    this.sequence.load().then(() => {\n      // On load, play the sequence from 0 - 1.\n      this.sequence.play(0, 1, 3000).then(() => {\n        console.log('play complete');\n      });\n    });\n  }\n\n}\n\nexports.default = CanvasImageSequenceSample3;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy93ZWJnbC1pbWFnZS1zZXF1ZW5jZTMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy93ZWJnbC1pbWFnZS1zZXF1ZW5jZTMuanM/YzIzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF93ZWJnbEltYWdlU2VxdWVuY2UgPSByZXF1aXJlKFwiLi4vbGliL2RvbS93ZWJnbC1pbWFnZS1zZXF1ZW5jZVwiKTtcblxuLyoqXG4gKiBDYW52YXNJbWFnZVNlcXVlbmNlIHBsYXkgZmVhdHVyZS5cbiAqL1xuY2xhc3MgQ2FudmFzSW1hZ2VTZXF1ZW5jZVNhbXBsZTMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLWNvbnRhaW5lcicpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJlbnQnKTsgLy8gR2VuZXJhdGUgaW1hZ2Ugc291cmNlcy5cblxuICAgIHRoaXMuc291cmNlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMTUzOyBpKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9IGkgKyAnJztcbiAgICAgIHZhbHVlID0gdmFsdWUucGFkU3RhcnQoNCwgJzAnKTtcbiAgICAgIHRoaXMuc291cmNlcy5wdXNoKCcuL3B1YmxpYy9mcmFtZXMvdGh1bWInICsgdmFsdWUgKyAnLmpwZycpO1xuICAgIH0gLy8gQ3JlYXRlIENhbnZhcyBJbWFnZSBTZXF1ZW5lY2VcblxuXG4gICAgdGhpcy5zZXF1ZW5jZSA9IG5ldyBfd2ViZ2xJbWFnZVNlcXVlbmNlLldlYkdsSW1hZ2VTZXF1ZW5jZSh0aGlzLmNhbnZhc0NvbnRhaW5lckVsZW1lbnQsIFt7XG4gICAgICBpbWFnZXM6IHRoaXMuc291cmNlc1xuICAgIH1dKTtcbiAgICBsZXQgcHJvZ3Jlc3NQb2ludHMgPSBbe1xuICAgICAgZnJvbTogMCxcbiAgICAgIHRvOiAwLjUsXG4gICAgICBzdGFydDogMCxcbiAgICAgIGVuZDogMVxuICAgIH0sIHtcbiAgICAgIGZyb206IDAuNSxcbiAgICAgIHRvOiAxLFxuICAgICAgc3RhcnQ6IDEsXG4gICAgICBlbmQ6IDBcbiAgICB9XTtcbiAgICB0aGlzLnNlcXVlbmNlLnNldE11bHRpSW50ZXJwb2xhdGlvbihwcm9ncmVzc1BvaW50cyk7IC8vIExvYWQgdGhlIGlhbWdlcy5cblxuICAgIHRoaXMuc2VxdWVuY2UubG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gT24gbG9hZCwgcGxheSB0aGUgc2VxdWVuY2UgZnJvbSAwIC0gMS5cbiAgICAgIHRoaXMuc2VxdWVuY2UucGxheSgwLCAxLCAzMDAwKS50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ3BsYXkgY29tcGxldGUnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2FudmFzSW1hZ2VTZXF1ZW5jZVNhbXBsZTM7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/webgl-image-sequence3.js\n");

/***/ }),

/***/ "./examples/webgl-image-sequence4.js":
/*!*******************************************!*\
  !*** ./examples/webgl-image-sequence4.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _webglImageSequence = __webpack_require__(/*! ../lib/dom/webgl-image-sequence */ \"./lib/dom/webgl-image-sequence.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\n/**\n * This sample expands on canvas image sequence sample 1 and demonstrates\n * usage of multiinterpolate.\n */\nclass CanvasImageSequenceSample3 {\n  constructor() {\n    console.log('canvas image sequence4');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Instance of rafProgress.\n\n    this.rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        this.rafProgress.easeTo(this.progress, 0.25, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.rafProgress.watch(this.onProgressUpdate.bind(this)); // Generate image sources.\n\n    this.sources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.sources.push('./public/frames/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.sequence = new _webglImageSequence.WebGlImageSequence(this.canvasContainerElement, [{\n      images: this.sources\n    }]); // We set the lerp value.\n\n    this.sequence.lerpAmount = 0.01; // Load the iamges.\n\n    this.sequence.load().then(() => {\n      // On load, play the sequence from 0 - 1.\n      this.sequence.play(0, 1, 1000).then(() => {\n        console.log('done', this.rafProgress.currentProgress); // Update the progress to the current scroll when done.\n        //\n        // At this time, the playing ends at 1 but the scroll progress\n        // could be something else so it will lerp \"towards\" the\n        // scroll position since we have lerp set.\n\n        this.sequence.renderByProgress(this.rafProgress.currentProgress);\n      });\n    });\n  }\n\n  onProgressUpdate(easedProgress, direction) {\n    this.sequence.renderByProgress(easedProgress);\n  }\n\n}\n\nexports.default = CanvasImageSequenceSample3;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy93ZWJnbC1pbWFnZS1zZXF1ZW5jZTQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy93ZWJnbC1pbWFnZS1zZXF1ZW5jZTQuanM/OWZjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yYWZQcm9ncmVzcyA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZi1wcm9ncmVzc1wiKTtcblxudmFyIF93ZWJnbEltYWdlU2VxdWVuY2UgPSByZXF1aXJlKFwiLi4vbGliL2RvbS93ZWJnbC1pbWFnZS1zZXF1ZW5jZVwiKTtcblxudmFyIF9lYXNlID0gcmVxdWlyZShcIi4uL2xpYi9lYXNlL2Vhc2VcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxuLyoqXG4gKiBUaGlzIHNhbXBsZSBleHBhbmRzIG9uIGNhbnZhcyBpbWFnZSBzZXF1ZW5jZSBzYW1wbGUgMSBhbmQgZGVtb25zdHJhdGVzXG4gKiB1c2FnZSBvZiBtdWx0aWludGVycG9sYXRlLlxuICovXG5jbGFzcyBDYW52YXNJbWFnZVNlcXVlbmNlU2FtcGxlMyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdjYW52YXMgaW1hZ2Ugc2VxdWVuY2U0Jyk7XG4gICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IF9kb21XYXRjaGVyLkRvbVdhdGNoZXIoKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLWNvbnRhaW5lcicpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJlbnQnKTsgLy8gSW5zdGFuY2Ugb2YgcmFmUHJvZ3Jlc3MuXG5cbiAgICB0aGlzLnJhZlByb2dyZXNzID0gbmV3IF9yYWZQcm9ncmVzcy5SYWZQcm9ncmVzcygpOyAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIHZhbHVlIHBlciBzY3JvbGwuXG5cbiAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgIG9uOiAnc2Nyb2xsJyxcbiAgICAgIGNhbGxiYWNrOiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDAuMjUsIF9lYXNlLkVBU0UuTGluZWFyKTtcbiAgICAgIH0sXG4gICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pOyAvLyBVcGRhdGUgcHJvZ3Jlc3MgaW1tZWRpYXRlbHkgb24gbG9hZC5cblxuICAgIHRoaXMucHJvZ3Jlc3MgPSBfZG9tLmRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMSwgX2Vhc2UuRUFTRS5MaW5lYXIpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3Mud2F0Y2godGhpcy5vblByb2dyZXNzVXBkYXRlLmJpbmQodGhpcykpOyAvLyBHZW5lcmF0ZSBpbWFnZSBzb3VyY2VzLlxuXG4gICAgdGhpcy5zb3VyY2VzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSAxNTM7IGkrKykge1xuICAgICAgbGV0IHZhbHVlID0gaSArICcnO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5wYWRTdGFydCg0LCAnMCcpO1xuICAgICAgdGhpcy5zb3VyY2VzLnB1c2goJy4vcHVibGljL2ZyYW1lcy90aHVtYicgKyB2YWx1ZSArICcuanBnJyk7XG4gICAgfSAvLyBDcmVhdGUgQ2FudmFzIEltYWdlIFNlcXVlbmVjZVxuXG5cbiAgICB0aGlzLnNlcXVlbmNlID0gbmV3IF93ZWJnbEltYWdlU2VxdWVuY2UuV2ViR2xJbWFnZVNlcXVlbmNlKHRoaXMuY2FudmFzQ29udGFpbmVyRWxlbWVudCwgW3tcbiAgICAgIGltYWdlczogdGhpcy5zb3VyY2VzXG4gICAgfV0pOyAvLyBXZSBzZXQgdGhlIGxlcnAgdmFsdWUuXG5cbiAgICB0aGlzLnNlcXVlbmNlLmxlcnBBbW91bnQgPSAwLjAxOyAvLyBMb2FkIHRoZSBpYW1nZXMuXG5cbiAgICB0aGlzLnNlcXVlbmNlLmxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIE9uIGxvYWQsIHBsYXkgdGhlIHNlcXVlbmNlIGZyb20gMCAtIDEuXG4gICAgICB0aGlzLnNlcXVlbmNlLnBsYXkoMCwgMSwgMTAwMCkudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdkb25lJywgdGhpcy5yYWZQcm9ncmVzcy5jdXJyZW50UHJvZ3Jlc3MpOyAvLyBVcGRhdGUgdGhlIHByb2dyZXNzIHRvIHRoZSBjdXJyZW50IHNjcm9sbCB3aGVuIGRvbmUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEF0IHRoaXMgdGltZSwgdGhlIHBsYXlpbmcgZW5kcyBhdCAxIGJ1dCB0aGUgc2Nyb2xsIHByb2dyZXNzXG4gICAgICAgIC8vIGNvdWxkIGJlIHNvbWV0aGluZyBlbHNlIHNvIGl0IHdpbGwgbGVycCBcInRvd2FyZHNcIiB0aGVcbiAgICAgICAgLy8gc2Nyb2xsIHBvc2l0aW9uIHNpbmNlIHdlIGhhdmUgbGVycCBzZXQuXG5cbiAgICAgICAgdGhpcy5zZXF1ZW5jZS5yZW5kZXJCeVByb2dyZXNzKHRoaXMucmFmUHJvZ3Jlc3MuY3VycmVudFByb2dyZXNzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgb25Qcm9ncmVzc1VwZGF0ZShlYXNlZFByb2dyZXNzLCBkaXJlY3Rpb24pIHtcbiAgICB0aGlzLnNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3MoZWFzZWRQcm9ncmVzcyk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBDYW52YXNJbWFnZVNlcXVlbmNlU2FtcGxlMzsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/webgl-image-sequence4.js\n");

/***/ }),

/***/ "./examples/webgl-image-sequence5.js":
/*!*******************************************!*\
  !*** ./examples/webgl-image-sequence5.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _webglImageSequence = __webpack_require__(/*! ../lib/dom/webgl-image-sequence */ \"./lib/dom/webgl-image-sequence.js\");\n\n/**\n * CanvasImageSequence play feature.\n */\nclass CanvasImageSequenceSample5 {\n  constructor() {\n    console.log('canvasImageSequence5');\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Generate image sources.\n\n    this.canvasImageSources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.canvasImageSources.push('./public/frames/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.sequence = new _webglImageSequence.WebGlImageSequence(this.canvasContainerElement, [{\n      images: this.canvasImageSources\n    }]);\n    this.sequence.lerpAmount = 0.01;\n    this.sequence.load().then(() => {\n      this.sequence.renderByProgress(0); // Immediately set to 1.  Because we previously set it to 0 and\n      // no 1 and we have lerp set, canvasImageSequence will lerp\n      // towards that value.\n\n      this.sequence.renderByProgress(1);\n    });\n  }\n\n}\n\nexports.default = CanvasImageSequenceSample5;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy93ZWJnbC1pbWFnZS1zZXF1ZW5jZTUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy93ZWJnbC1pbWFnZS1zZXF1ZW5jZTUuanM/OWM1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF93ZWJnbEltYWdlU2VxdWVuY2UgPSByZXF1aXJlKFwiLi4vbGliL2RvbS93ZWJnbC1pbWFnZS1zZXF1ZW5jZVwiKTtcblxuLyoqXG4gKiBDYW52YXNJbWFnZVNlcXVlbmNlIHBsYXkgZmVhdHVyZS5cbiAqL1xuY2xhc3MgQ2FudmFzSW1hZ2VTZXF1ZW5jZVNhbXBsZTUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygnY2FudmFzSW1hZ2VTZXF1ZW5jZTUnKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLWNvbnRhaW5lcicpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJlbnQnKTsgLy8gR2VuZXJhdGUgaW1hZ2Ugc291cmNlcy5cblxuICAgIHRoaXMuY2FudmFzSW1hZ2VTb3VyY2VzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSAxNTM7IGkrKykge1xuICAgICAgbGV0IHZhbHVlID0gaSArICcnO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5wYWRTdGFydCg0LCAnMCcpO1xuICAgICAgdGhpcy5jYW52YXNJbWFnZVNvdXJjZXMucHVzaCgnLi9wdWJsaWMvZnJhbWVzL3RodW1iJyArIHZhbHVlICsgJy5qcGcnKTtcbiAgICB9IC8vIENyZWF0ZSBDYW52YXMgSW1hZ2UgU2VxdWVuZWNlXG5cblxuICAgIHRoaXMuc2VxdWVuY2UgPSBuZXcgX3dlYmdsSW1hZ2VTZXF1ZW5jZS5XZWJHbEltYWdlU2VxdWVuY2UodGhpcy5jYW52YXNDb250YWluZXJFbGVtZW50LCBbe1xuICAgICAgaW1hZ2VzOiB0aGlzLmNhbnZhc0ltYWdlU291cmNlc1xuICAgIH1dKTtcbiAgICB0aGlzLnNlcXVlbmNlLmxlcnBBbW91bnQgPSAwLjAxO1xuICAgIHRoaXMuc2VxdWVuY2UubG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5zZXF1ZW5jZS5yZW5kZXJCeVByb2dyZXNzKDApOyAvLyBJbW1lZGlhdGVseSBzZXQgdG8gMS4gIEJlY2F1c2Ugd2UgcHJldmlvdXNseSBzZXQgaXQgdG8gMCBhbmRcbiAgICAgIC8vIG5vIDEgYW5kIHdlIGhhdmUgbGVycCBzZXQsIGNhbnZhc0ltYWdlU2VxdWVuY2Ugd2lsbCBsZXJwXG4gICAgICAvLyB0b3dhcmRzIHRoYXQgdmFsdWUuXG5cbiAgICAgIHRoaXMuc2VxdWVuY2UucmVuZGVyQnlQcm9ncmVzcygxKTtcbiAgICB9KTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc0ltYWdlU2VxdWVuY2VTYW1wbGU1OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/webgl-image-sequence5.js\n");

/***/ }),

/***/ "./examples/webgl-image-sequence7.js":
/*!*******************************************!*\
  !*** ./examples/webgl-image-sequence7.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _webglImageSequence = __webpack_require__(/*! ../lib/dom/webgl-image-sequence */ \"./lib/dom/webgl-image-sequence.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\n/**\n * This sample demonstrates CanvasImageSequence sizing with cover\n */\nclass CanvasImageSequenceSample7 {\n  constructor() {\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Instance of rafProgress.\n\n    this.rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        this.rafProgress.easeTo(this.progress, 0.25, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.rafProgress.watch(this.onProgressUpdate.bind(this)); // Generate image sources.\n\n    this.sources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.sources.push('./public/frames/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.sequence = new _webglImageSequence.WebGlImageSequence(this.canvasContainerElement, [{\n      images: this.sources\n    }], {\n      cover: true // bottom: 0,\n      // left: 0\n\n    }); // Load the images\n\n    this.sequence.load().then(() => {\n      // When ready render whatever the current easedProgress value is.\n      this.sequence.renderByProgress(this.rafProgress.currentProgress);\n    });\n  }\n\n  onProgressUpdate(easedProgress, direction) {\n    this.sequence.renderByProgress(easedProgress);\n  }\n\n}\n\nexports.default = CanvasImageSequenceSample7;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy93ZWJnbC1pbWFnZS1zZXF1ZW5jZTcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy93ZWJnbC1pbWFnZS1zZXF1ZW5jZTcuanM/Mjg5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yYWZQcm9ncmVzcyA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZi1wcm9ncmVzc1wiKTtcblxudmFyIF93ZWJnbEltYWdlU2VxdWVuY2UgPSByZXF1aXJlKFwiLi4vbGliL2RvbS93ZWJnbC1pbWFnZS1zZXF1ZW5jZVwiKTtcblxudmFyIF9lYXNlID0gcmVxdWlyZShcIi4uL2xpYi9lYXNlL2Vhc2VcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxuLyoqXG4gKiBUaGlzIHNhbXBsZSBkZW1vbnN0cmF0ZXMgQ2FudmFzSW1hZ2VTZXF1ZW5jZSBzaXppbmcgd2l0aCBjb3ZlclxuICovXG5jbGFzcyBDYW52YXNJbWFnZVNlcXVlbmNlU2FtcGxlNyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZG9tV2F0Y2hlciA9IG5ldyBfZG9tV2F0Y2hlci5Eb21XYXRjaGVyKCk7XG4gICAgdGhpcy5jYW52YXNDb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbnZhcy1jb250YWluZXInKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFyZW50Jyk7IC8vIEluc3RhbmNlIG9mIHJhZlByb2dyZXNzLlxuXG4gICAgdGhpcy5yYWZQcm9ncmVzcyA9IG5ldyBfcmFmUHJvZ3Jlc3MuUmFmUHJvZ3Jlc3MoKTsgLy8gVXBkYXRlIHRoZSBwcm9ncmVzcyB2YWx1ZSBwZXIgc2Nyb2xsLlxuXG4gICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbjogJ3Njcm9sbCcsXG4gICAgICBjYWxsYmFjazogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAwLjI1LCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gICAgICB9LFxuICAgICAgZXZlbnRPcHRpb25zOiB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH1cbiAgICB9KTsgLy8gVXBkYXRlIHByb2dyZXNzIGltbWVkaWF0ZWx5IG9uIGxvYWQuXG5cbiAgICB0aGlzLnByb2dyZXNzID0gX2RvbS5kb20uZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLnBhcmVudEVsZW1lbnQpO1xuICAgIHRoaXMucmFmUHJvZ3Jlc3MuZWFzZVRvKHRoaXMucHJvZ3Jlc3MsIDEsIF9lYXNlLkVBU0UuTGluZWFyKTtcbiAgICB0aGlzLnJhZlByb2dyZXNzLndhdGNoKHRoaXMub25Qcm9ncmVzc1VwZGF0ZS5iaW5kKHRoaXMpKTsgLy8gR2VuZXJhdGUgaW1hZ2Ugc291cmNlcy5cblxuICAgIHRoaXMuc291cmNlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMTUzOyBpKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9IGkgKyAnJztcbiAgICAgIHZhbHVlID0gdmFsdWUucGFkU3RhcnQoNCwgJzAnKTtcbiAgICAgIHRoaXMuc291cmNlcy5wdXNoKCcuL3B1YmxpYy9mcmFtZXMvdGh1bWInICsgdmFsdWUgKyAnLmpwZycpO1xuICAgIH0gLy8gQ3JlYXRlIENhbnZhcyBJbWFnZSBTZXF1ZW5lY2VcblxuXG4gICAgdGhpcy5zZXF1ZW5jZSA9IG5ldyBfd2ViZ2xJbWFnZVNlcXVlbmNlLldlYkdsSW1hZ2VTZXF1ZW5jZSh0aGlzLmNhbnZhc0NvbnRhaW5lckVsZW1lbnQsIFt7XG4gICAgICBpbWFnZXM6IHRoaXMuc291cmNlc1xuICAgIH1dLCB7XG4gICAgICBjb3ZlcjogdHJ1ZSAvLyBib3R0b206IDAsXG4gICAgICAvLyBsZWZ0OiAwXG5cbiAgICB9KTsgLy8gTG9hZCB0aGUgaW1hZ2VzXG5cbiAgICB0aGlzLnNlcXVlbmNlLmxvYWQoKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIFdoZW4gcmVhZHkgcmVuZGVyIHdoYXRldmVyIHRoZSBjdXJyZW50IGVhc2VkUHJvZ3Jlc3MgdmFsdWUgaXMuXG4gICAgICB0aGlzLnNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3ModGhpcy5yYWZQcm9ncmVzcy5jdXJyZW50UHJvZ3Jlc3MpO1xuICAgIH0pO1xuICB9XG5cbiAgb25Qcm9ncmVzc1VwZGF0ZShlYXNlZFByb2dyZXNzLCBkaXJlY3Rpb24pIHtcbiAgICB0aGlzLnNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3MoZWFzZWRQcm9ncmVzcyk7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBDYW52YXNJbWFnZVNlcXVlbmNlU2FtcGxlNzsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/webgl-image-sequence7.js\n");

/***/ }),

/***/ "./examples/webgl-image-sequence9.js":
/*!*******************************************!*\
  !*** ./examples/webgl-image-sequence9.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _rafProgress = __webpack_require__(/*! ../lib/raf/raf-progress */ \"./lib/raf/raf-progress.js\");\n\nvar _webglImageSequence = __webpack_require__(/*! ../lib/dom/webgl-image-sequence */ \"./lib/dom/webgl-image-sequence.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\nvar _dom = __webpack_require__(/*! ../lib/dom/dom */ \"./lib/dom/dom.js\");\n\nvar _domWatcher = __webpack_require__(/*! ../lib/dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n\n/**\n * This sample show loading multiple image sets\n */\nclass CanvasImageSequenceSample9 {\n  constructor() {\n    console.log('canvas image sequence');\n    this.domWatcher = new _domWatcher.DomWatcher();\n    this.canvasContainerElement = document.querySelector('.canvas-container');\n    this.parentElement = document.getElementById('parent'); // Instance of rafProgress.\n\n    this.rafProgress = new _rafProgress.RafProgress(); // Update the progress value per scroll.\n\n    this.domWatcher.add({\n      element: window,\n      on: 'scroll',\n      callback: event => {\n        this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n        this.rafProgress.easeTo(this.progress, 0.25, _ease.EASE.Linear);\n      },\n      eventOptions: {\n        passive: true\n      }\n    }); // Update progress immediately on load.\n\n    this.progress = _dom.dom.getElementScrolledPercent(this.parentElement);\n    this.rafProgress.easeTo(this.progress, 1, _ease.EASE.Linear);\n    this.rafProgress.watch(this.onProgressUpdate.bind(this)); // Generate image sources.\n\n    this.sources = [];\n\n    for (let i = 1; i <= 153; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.sources.push('./public/frames/thumb' + value + '.jpg');\n    } // Generate a second \"mobile\" image sources.\n\n\n    this.mobileImageSources = [];\n\n    for (let i = 1; i <= 120; i++) {\n      let value = i + '';\n      value = value.padStart(4, '0');\n      this.mobileImageSources.push('./public/frames2/thumb' + value + '.jpg');\n    } // Create Canvas Image Sequenece\n\n\n    this.sequence = new _webglImageSequence.WebGlImageSequence(this.canvasContainerElement, [{\n      images: this.sources,\n      when: () => {\n        return window.innerWidth >= 768;\n      }\n    }, {\n      images: this.mobileImageSources,\n      when: () => {\n        return window.innerWidth < 768;\n      }\n    }]); // this.canvasImageSequence.lerpAmount = 0.02;\n    // Load the iamges.\n\n    this.sequence.load().then(() => {\n      // When ready render whatever the current easedProgress value is.\n      this.sequence.renderByProgress(this.rafProgress.currentProgress);\n    });\n  }\n\n  onProgressUpdate(easedProgress, direction) {\n    this.sequence.renderByProgress(easedProgress);\n  }\n\n}\n\nexports.default = CanvasImageSequenceSample9;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy93ZWJnbC1pbWFnZS1zZXF1ZW5jZTkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy93ZWJnbC1pbWFnZS1zZXF1ZW5jZTkuanM/ZDZkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9yYWZQcm9ncmVzcyA9IHJlcXVpcmUoXCIuLi9saWIvcmFmL3JhZi1wcm9ncmVzc1wiKTtcblxudmFyIF93ZWJnbEltYWdlU2VxdWVuY2UgPSByZXF1aXJlKFwiLi4vbGliL2RvbS93ZWJnbC1pbWFnZS1zZXF1ZW5jZVwiKTtcblxudmFyIF9lYXNlID0gcmVxdWlyZShcIi4uL2xpYi9lYXNlL2Vhc2VcIik7XG5cbnZhciBfZG9tID0gcmVxdWlyZShcIi4uL2xpYi9kb20vZG9tXCIpO1xuXG52YXIgX2RvbVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vbGliL2RvbS9kb20td2F0Y2hlclwiKTtcblxuLyoqXG4gKiBUaGlzIHNhbXBsZSBzaG93IGxvYWRpbmcgbXVsdGlwbGUgaW1hZ2Ugc2V0c1xuICovXG5jbGFzcyBDYW52YXNJbWFnZVNlcXVlbmNlU2FtcGxlOSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdjYW52YXMgaW1hZ2Ugc2VxdWVuY2UnKTtcbiAgICB0aGlzLmRvbVdhdGNoZXIgPSBuZXcgX2RvbVdhdGNoZXIuRG9tV2F0Y2hlcigpO1xuICAgIHRoaXMuY2FudmFzQ29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXMtY29udGFpbmVyJyk7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcmVudCcpOyAvLyBJbnN0YW5jZSBvZiByYWZQcm9ncmVzcy5cblxuICAgIHRoaXMucmFmUHJvZ3Jlc3MgPSBuZXcgX3JhZlByb2dyZXNzLlJhZlByb2dyZXNzKCk7IC8vIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MgdmFsdWUgcGVyIHNjcm9sbC5cblxuICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgb246ICdzY3JvbGwnLFxuICAgICAgY2FsbGJhY2s6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgdGhpcy5yYWZQcm9ncmVzcy5lYXNlVG8odGhpcy5wcm9ncmVzcywgMC4yNSwgX2Vhc2UuRUFTRS5MaW5lYXIpO1xuICAgICAgfSxcbiAgICAgIGV2ZW50T3B0aW9uczoge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7IC8vIFVwZGF0ZSBwcm9ncmVzcyBpbW1lZGlhdGVseSBvbiBsb2FkLlxuXG4gICAgdGhpcy5wcm9ncmVzcyA9IF9kb20uZG9tLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5wYXJlbnRFbGVtZW50KTtcbiAgICB0aGlzLnJhZlByb2dyZXNzLmVhc2VUbyh0aGlzLnByb2dyZXNzLCAxLCBfZWFzZS5FQVNFLkxpbmVhcik7XG4gICAgdGhpcy5yYWZQcm9ncmVzcy53YXRjaCh0aGlzLm9uUHJvZ3Jlc3NVcGRhdGUuYmluZCh0aGlzKSk7IC8vIEdlbmVyYXRlIGltYWdlIHNvdXJjZXMuXG5cbiAgICB0aGlzLnNvdXJjZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IDE1MzsgaSsrKSB7XG4gICAgICBsZXQgdmFsdWUgPSBpICsgJyc7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnBhZFN0YXJ0KDQsICcwJyk7XG4gICAgICB0aGlzLnNvdXJjZXMucHVzaCgnLi9wdWJsaWMvZnJhbWVzL3RodW1iJyArIHZhbHVlICsgJy5qcGcnKTtcbiAgICB9IC8vIEdlbmVyYXRlIGEgc2Vjb25kIFwibW9iaWxlXCIgaW1hZ2Ugc291cmNlcy5cblxuXG4gICAgdGhpcy5tb2JpbGVJbWFnZVNvdXJjZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IDEyMDsgaSsrKSB7XG4gICAgICBsZXQgdmFsdWUgPSBpICsgJyc7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnBhZFN0YXJ0KDQsICcwJyk7XG4gICAgICB0aGlzLm1vYmlsZUltYWdlU291cmNlcy5wdXNoKCcuL3B1YmxpYy9mcmFtZXMyL3RodW1iJyArIHZhbHVlICsgJy5qcGcnKTtcbiAgICB9IC8vIENyZWF0ZSBDYW52YXMgSW1hZ2UgU2VxdWVuZWNlXG5cblxuICAgIHRoaXMuc2VxdWVuY2UgPSBuZXcgX3dlYmdsSW1hZ2VTZXF1ZW5jZS5XZWJHbEltYWdlU2VxdWVuY2UodGhpcy5jYW52YXNDb250YWluZXJFbGVtZW50LCBbe1xuICAgICAgaW1hZ2VzOiB0aGlzLnNvdXJjZXMsXG4gICAgICB3aGVuOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aCA+PSA3Njg7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgaW1hZ2VzOiB0aGlzLm1vYmlsZUltYWdlU291cmNlcyxcbiAgICAgIHdoZW46ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4O1xuICAgICAgfVxuICAgIH1dKTsgLy8gdGhpcy5jYW52YXNJbWFnZVNlcXVlbmNlLmxlcnBBbW91bnQgPSAwLjAyO1xuICAgIC8vIExvYWQgdGhlIGlhbWdlcy5cblxuICAgIHRoaXMuc2VxdWVuY2UubG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gV2hlbiByZWFkeSByZW5kZXIgd2hhdGV2ZXIgdGhlIGN1cnJlbnQgZWFzZWRQcm9ncmVzcyB2YWx1ZSBpcy5cbiAgICAgIHRoaXMuc2VxdWVuY2UucmVuZGVyQnlQcm9ncmVzcyh0aGlzLnJhZlByb2dyZXNzLmN1cnJlbnRQcm9ncmVzcyk7XG4gICAgfSk7XG4gIH1cblxuICBvblByb2dyZXNzVXBkYXRlKGVhc2VkUHJvZ3Jlc3MsIGRpcmVjdGlvbikge1xuICAgIHRoaXMuc2VxdWVuY2UucmVuZGVyQnlQcm9ncmVzcyhlYXNlZFByb2dyZXNzKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENhbnZhc0ltYWdlU2VxdWVuY2VTYW1wbGU5OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./examples/webgl-image-sequence9.js\n");

/***/ }),

/***/ "./examples/webgl.js":
/*!***************************!*\
  !*** ./examples/webgl.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _imageLoader = __webpack_require__(/*! ../lib/loader/image-loader */ \"./lib/loader/image-loader.js\");\n\nvar _raf = __webpack_require__(/*! ../lib/raf/raf */ \"./lib/raf/raf.js\");\n\nvar _dat = __webpack_require__(/*! dat.gui */ \"./node_modules/dat.gui/build/dat.gui.module.js\");\n\nvar dat = _interopRequireWildcard(_dat);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nconst vertexSrc = `\nprecision mediump float;\n\nattribute vec4 position;\n\nvarying vec2 vUv;\n\nvoid main() {\n\tgl_Position = position;\n    vUv = vec2( (position.x + 1.)/2., (-position.y + 1.)/2.);\n\n}\n`;\nconst fragmentSrc = `\nprecision mediump float;\n\nuniform float uTrans;\nuniform sampler2D uTexture0;\nuniform sampler2D uTexture1;\nuniform sampler2D uDisp;\n\nvarying vec2 vUv;\n\nfloat quarticInOut(float t) {\n  return t < 0.5\n    ? +8.0 * pow(t, 4.0)\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\n\nvoid main() {\n    vec4 disp = texture2D(uDisp, vUv);\n    float trans = clamp((uTrans * uTrans * 5.0) - disp.r * 2.0, 0.0, 1.0);\n    vec4 color0 = texture2D(uTexture0, vUv);\n    float shift = 1.0 - quarticInOut(uTrans);\n    shift = shift * disp.x;\n    vec4 color1 = texture2D(uTexture1, vUv + vec2(0.1 * disp.x * shift, 0.1 * disp.y * shift));\n\tgl_FragColor = mix(color0, color1 , trans);\n}\n`;\nconst assets = ['./public/guy2.jpg', './public/guy1.jpg', './public/displacement1.png'];\n\nclass WebGlSample {\n  constructor() {\n    console.log('webGL image distortion sample');\n    this.canvas = document.getElementById('canvas');\n    this.canvas.width = this.canvas.offsetWidth;\n    this.canvas.height = this.canvas.offsetHeight;\n    this.gl = canvas.getContext('webgl');\n    this.controls = {\n      trans: 0\n    }; // Setup\n\n    this.program = this.createProgram(vertexSrc, fragmentSrc);\n    this.createBuffer(this.program);\n    this.setUniform(this.program); // Setup raf loop.\n\n    this.raf = new _raf.Raf(this.loop.bind(this));\n    this.imageLoader = new _imageLoader.ImageLoader(assets);\n    this.imageLoader.load().then(this.onImageLoad.bind(this));\n    this.gui = new dat.GUI();\n    let gui = this.gui.addFolder('Controls');\n    gui.add(this.controls, 'trans', 0.000, 1.00).step(0.001);\n  }\n  /**\n     * Creates a program with vertex and frag shaders.\n     */\n\n\n  createProgram(vs, fr) {\n    // Create program\n    let program = this.gl.createProgram(); // Compile vertex shader\n\n    let vShader = this.gl.createShader(this.gl.VERTEX_SHADER);\n    this.gl.shaderSource(vShader, vs);\n    this.gl.compileShader(vShader); // Compile frag shader\n\n    let fShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);\n    this.gl.shaderSource(fShader, fr);\n    this.gl.compileShader(fShader);\n    this.gl.attachShader(program, vShader);\n    this.gl.deleteShader(vShader);\n    this.gl.attachShader(program, fShader);\n    this.gl.deleteShader(fShader);\n    this.gl.linkProgram(program);\n    return program;\n  }\n\n  createBuffer(program) {\n    let vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, 1]);\n    this.vertexBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);\n    this.vertexLocation = this.gl.getAttribLocation(program, 'position');\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n  }\n\n  setUniform(program) {\n    // uniform\n    this.uTransLoc = this.gl.getUniformLocation(program, 'uTrans');\n    this.uniforms = [];\n    this.uniforms.push(this.gl.getUniformLocation(program, 'uTexture0'));\n    this.uniforms.push(this.gl.getUniformLocation(program, 'uTexture1'));\n    this.uniforms.push(this.gl.getUniformLocation(program, 'uDisp'));\n  }\n  /**\n     * When all images have loaded.\n     */\n\n\n  onImageLoad(images) {\n    let gl = this.gl;\n    this.textures = [];\n    Object.values(images).forEach((image, i) => {\n      let imageName = assets[i];\n      let textureImage = images[imageName];\n      let texture = gl.createTexture(); // Add the image to the texture.\n\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, textureImage);\n      gl.generateMipmap(gl.TEXTURE_2D);\n      this.textures.push(texture);\n    }); // Now start raf.\n\n    this.raf.start();\n  }\n  /**\n     * Runs on raf loop once images are loaded.\n     */\n\n\n  loop() {\n    let gl = this.gl;\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.useProgram(this.program);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.vertexAttribPointer(this.vertexLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(this.vertexLocation);\n    this.textures.forEach((texture, index) => {\n      gl.activeTexture(gl.TEXTURE0 + index);\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.uniform1i(this.uniforms[index], index);\n    });\n    gl.uniform1f(this.uTransLoc, this.controls.trans);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  }\n\n}\n\nexports.default = WebGlSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy93ZWJnbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3dlYmdsLmpzP2U3NTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfaW1hZ2VMb2FkZXIgPSByZXF1aXJlKFwiLi4vbGliL2xvYWRlci9pbWFnZS1sb2FkZXJcIik7XG5cbnZhciBfcmFmID0gcmVxdWlyZShcIi4uL2xpYi9yYWYvcmFmXCIpO1xuXG52YXIgX2RhdCA9IHJlcXVpcmUoXCJkYXQuZ3VpXCIpO1xuXG52YXIgZGF0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2RhdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307IGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuY29uc3QgdmVydGV4U3JjID0gYFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbmF0dHJpYnV0ZSB2ZWM0IHBvc2l0aW9uO1xuXG52YXJ5aW5nIHZlYzIgdlV2O1xuXG52b2lkIG1haW4oKSB7XG5cdGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdlV2ID0gdmVjMiggKHBvc2l0aW9uLnggKyAxLikvMi4sICgtcG9zaXRpb24ueSArIDEuKS8yLik7XG5cbn1cbmA7XG5jb25zdCBmcmFnbWVudFNyYyA9IGBcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG51bmlmb3JtIGZsb2F0IHVUcmFucztcbnVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlMDtcbnVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlMTtcbnVuaWZvcm0gc2FtcGxlcjJEIHVEaXNwO1xuXG52YXJ5aW5nIHZlYzIgdlV2O1xuXG5mbG9hdCBxdWFydGljSW5PdXQoZmxvYXQgdCkge1xuICByZXR1cm4gdCA8IDAuNVxuICAgID8gKzguMCAqIHBvdyh0LCA0LjApXG4gICAgOiAtOC4wICogcG93KHQgLSAxLjAsIDQuMCkgKyAxLjA7XG59XG5cbnZvaWQgbWFpbigpIHtcbiAgICB2ZWM0IGRpc3AgPSB0ZXh0dXJlMkQodURpc3AsIHZVdik7XG4gICAgZmxvYXQgdHJhbnMgPSBjbGFtcCgodVRyYW5zICogdVRyYW5zICogNS4wKSAtIGRpc3AuciAqIDIuMCwgMC4wLCAxLjApO1xuICAgIHZlYzQgY29sb3IwID0gdGV4dHVyZTJEKHVUZXh0dXJlMCwgdlV2KTtcbiAgICBmbG9hdCBzaGlmdCA9IDEuMCAtIHF1YXJ0aWNJbk91dCh1VHJhbnMpO1xuICAgIHNoaWZ0ID0gc2hpZnQgKiBkaXNwLng7XG4gICAgdmVjNCBjb2xvcjEgPSB0ZXh0dXJlMkQodVRleHR1cmUxLCB2VXYgKyB2ZWMyKDAuMSAqIGRpc3AueCAqIHNoaWZ0LCAwLjEgKiBkaXNwLnkgKiBzaGlmdCkpO1xuXHRnbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IwLCBjb2xvcjEgLCB0cmFucyk7XG59XG5gO1xuY29uc3QgYXNzZXRzID0gWycuL3B1YmxpYy9ndXkyLmpwZycsICcuL3B1YmxpYy9ndXkxLmpwZycsICcuL3B1YmxpYy9kaXNwbGFjZW1lbnQxLnBuZyddO1xuXG5jbGFzcyBXZWJHbFNhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCd3ZWJHTCBpbWFnZSBkaXN0b3J0aW9uIHNhbXBsZScpO1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpO1xuICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMub2Zmc2V0SGVpZ2h0O1xuICAgIHRoaXMuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKTtcbiAgICB0aGlzLmNvbnRyb2xzID0ge1xuICAgICAgdHJhbnM6IDBcbiAgICB9OyAvLyBTZXR1cFxuXG4gICAgdGhpcy5wcm9ncmFtID0gdGhpcy5jcmVhdGVQcm9ncmFtKHZlcnRleFNyYywgZnJhZ21lbnRTcmMpO1xuICAgIHRoaXMuY3JlYXRlQnVmZmVyKHRoaXMucHJvZ3JhbSk7XG4gICAgdGhpcy5zZXRVbmlmb3JtKHRoaXMucHJvZ3JhbSk7IC8vIFNldHVwIHJhZiBsb29wLlxuXG4gICAgdGhpcy5yYWYgPSBuZXcgX3JhZi5SYWYodGhpcy5sb29wLmJpbmQodGhpcykpO1xuICAgIHRoaXMuaW1hZ2VMb2FkZXIgPSBuZXcgX2ltYWdlTG9hZGVyLkltYWdlTG9hZGVyKGFzc2V0cyk7XG4gICAgdGhpcy5pbWFnZUxvYWRlci5sb2FkKCkudGhlbih0aGlzLm9uSW1hZ2VMb2FkLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZ3VpID0gbmV3IGRhdC5HVUkoKTtcbiAgICBsZXQgZ3VpID0gdGhpcy5ndWkuYWRkRm9sZGVyKCdDb250cm9scycpO1xuICAgIGd1aS5hZGQodGhpcy5jb250cm9scywgJ3RyYW5zJywgMC4wMDAsIDEuMDApLnN0ZXAoMC4wMDEpO1xuICB9XG4gIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwcm9ncmFtIHdpdGggdmVydGV4IGFuZCBmcmFnIHNoYWRlcnMuXG4gICAgICovXG5cblxuICBjcmVhdGVQcm9ncmFtKHZzLCBmcikge1xuICAgIC8vIENyZWF0ZSBwcm9ncmFtXG4gICAgbGV0IHByb2dyYW0gPSB0aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTsgLy8gQ29tcGlsZSB2ZXJ0ZXggc2hhZGVyXG5cbiAgICBsZXQgdlNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHRoaXMuZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgdGhpcy5nbC5zaGFkZXJTb3VyY2UodlNoYWRlciwgdnMpO1xuICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcih2U2hhZGVyKTsgLy8gQ29tcGlsZSBmcmFnIHNoYWRlclxuXG4gICAgbGV0IGZTaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0aGlzLmdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgdGhpcy5nbC5zaGFkZXJTb3VyY2UoZlNoYWRlciwgZnIpO1xuICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihmU2hhZGVyKTtcbiAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2U2hhZGVyKTtcbiAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcih2U2hhZGVyKTtcbiAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmU2hhZGVyKTtcbiAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcihmU2hhZGVyKTtcbiAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG5cbiAgY3JlYXRlQnVmZmVyKHByb2dyYW0pIHtcbiAgICBsZXQgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFstMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgLTEsIC0xLCAxLCAxLCAxXSk7XG4gICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy52ZXJ0ZXhCdWZmZXIpO1xuICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIHRoaXMuZ2wuU1RBVElDX0RSQVcpO1xuICAgIHRoaXMudmVydGV4TG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdwb3NpdGlvbicpO1xuICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gIH1cblxuICBzZXRVbmlmb3JtKHByb2dyYW0pIHtcbiAgICAvLyB1bmlmb3Jt44Gu44Ot44Kx44O844K344On44Oz44KS5Y+W5b6X44GX44Gm44GK44GPXG4gICAgdGhpcy51VHJhbnNMb2MgPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVRyYW5zJyk7XG4gICAgdGhpcy51bmlmb3JtcyA9IFtdO1xuICAgIHRoaXMudW5pZm9ybXMucHVzaCh0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVRleHR1cmUwJykpO1xuICAgIHRoaXMudW5pZm9ybXMucHVzaCh0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVRleHR1cmUxJykpO1xuICAgIHRoaXMudW5pZm9ybXMucHVzaCh0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndURpc3AnKSk7XG4gIH1cbiAgLyoqXG4gICAgICogV2hlbiBhbGwgaW1hZ2VzIGhhdmUgbG9hZGVkLlxuICAgICAqL1xuXG5cbiAgb25JbWFnZUxvYWQoaW1hZ2VzKSB7XG4gICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICB0aGlzLnRleHR1cmVzID0gW107XG4gICAgT2JqZWN0LnZhbHVlcyhpbWFnZXMpLmZvckVhY2goKGltYWdlLCBpKSA9PiB7XG4gICAgICBsZXQgaW1hZ2VOYW1lID0gYXNzZXRzW2ldO1xuICAgICAgbGV0IHRleHR1cmVJbWFnZSA9IGltYWdlc1tpbWFnZU5hbWVdO1xuICAgICAgbGV0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7IC8vIEFkZCB0aGUgaW1hZ2UgdG8gdGhlIHRleHR1cmUuXG5cbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIGdsLlJHQiwgZ2wuVU5TSUdORURfQllURSwgdGV4dHVyZUltYWdlKTtcbiAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xuICAgICAgdGhpcy50ZXh0dXJlcy5wdXNoKHRleHR1cmUpO1xuICAgIH0pOyAvLyBOb3cgc3RhcnQgcmFmLlxuXG4gICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgfVxuICAvKipcbiAgICAgKiBSdW5zIG9uIHJhZiBsb29wIG9uY2UgaW1hZ2VzIGFyZSBsb2FkZWQuXG4gICAgICovXG5cblxuICBsb29wKCkge1xuICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcbiAgICBnbC5jbGVhckNvbG9yKDAuMCwgMC4wLCAwLjAsIDEuMCk7XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnZlcnRleEJ1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnZlcnRleExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMudmVydGV4TG9jYXRpb24pO1xuICAgIHRoaXMudGV4dHVyZXMuZm9yRWFjaCgodGV4dHVyZSwgaW5kZXgpID0+IHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBpbmRleCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIGdsLnVuaWZvcm0xaSh0aGlzLnVuaWZvcm1zW2luZGV4XSwgaW5kZXgpO1xuICAgIH0pO1xuICAgIGdsLnVuaWZvcm0xZih0aGlzLnVUcmFuc0xvYywgdGhpcy5jb250cm9scy50cmFucyk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDYpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gV2ViR2xTYW1wbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/webgl.js\n");

/***/ }),

/***/ "./examples/x.js":
/*!***********************!*\
  !*** ./examples/x.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _x = __webpack_require__(/*! ../lib/x/x */ \"./lib/x/x.js\");\n\nvar _xGameObject = __webpack_require__(/*! ../lib/x/x-game-object */ \"./lib/x/x-game-object.js\");\n\nvar _xLine = __webpack_require__(/*! ../lib/x/x-line */ \"./lib/x/x-line.js\");\n\nvar _xRectangle = __webpack_require__(/*! ../lib/x/x-rectangle */ \"./lib/x/x-rectangle.js\");\n\nvar _xStage = __webpack_require__(/*! ../lib/x/x-stage */ \"./lib/x/x-stage.js\");\n\nvar _xTexture = __webpack_require__(/*! ../lib/x/x-texture */ \"./lib/x/x-texture.js\");\n\nvar _xText = __webpack_require__(/*! ../lib/x/x-text */ \"./lib/x/x-text.js\");\n\nvar _imageLoader = __webpack_require__(/*! ../lib/loader/image-loader */ \"./lib/loader/image-loader.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\nvar _mathf = __webpack_require__(/*! ../lib/mathf/mathf */ \"./lib/mathf/mathf.js\");\n\nvar _ease = __webpack_require__(/*! ../lib/ease/ease */ \"./lib/ease/ease.js\");\n\n/**\n *\n * This is the an example of accelerating an XGameObject towards the\n * mouse position.\n *\n * Each XGameObject, has the following:\n * positon - vector\n * velocity - vector\n * acceleration - vector\n *\n *\n *\n *\n */\nclass XSample {\n  /**\n     * Loads teh required images and saves them to a cache with Xtexture.\n     * This starts the app.\n     */\n  constructor() {\n    this.imageTextures = {};\n    let images = new _imageLoader.ImageLoader(['./public/flower.jpg']).load().then(results => {\n      // Make textures out of the images.\n      Object.keys(results).forEach(key => {\n        this.imageTextures[key] = new _xTexture.XTexture(results[key]);\n      });\n      this.startApp();\n    });\n  }\n\n  startApp() {\n    const canvasElement = document.getElementById('mainCanvas');\n    this.X = new _x.X({\n      canvasElement: canvasElement,\n      debugMode: true\n    });\n    this.flower = new _xGameObject.XGameObject({\n      id: 'flower',\n      x: 250,\n      y: 250,\n      anchorX: 0.5,\n      anchorY: 0.5,\n      scaleX: 1,\n      scaleY: 1,\n      rotation: 1.5,\n      interactable: true,\n      texture: this.imageTextures['./public/flower.jpg']\n    });\n    this.X.stage.addChild(this.flower);\n    this.X.onTick(() => {\n      // On every frame, we want to update the acceleration of the\n      // test object so that it accelerates towards the mouse position.\n      //  We look at the distance between the mouse and\n      // the test object position.  To do this, we subtract the test position\n      // and  mouse position vector and apply that distance as the\n      // acceleration of the game object.\n      const distanceVector = _vector.Vector.subtract( // mouse\n      this.X.pointer.position, new _vector.Vector(this.flower.gcx, this.flower.gcy)); // We could just set the acceleration to the distance but then\n      // the flower image would just exactly be the position of the\n      // mouse.  To add some delay and smoothing, we ease the\n      // vales.\n\n\n      this.flower.acceleration = _vector.Vector.ease(this.flower.acceleration, distanceVector, 0.08); // Damping. We still get a of sprining so we damp out the springing.\n\n      this.flower.acceleration.lerp(_vector.Vector.ZERO, 0.8); // Based on the distance to the mouse, let's increase or decrease\n      // the rotation.\n\n      const minRotation = 0;\n      const maxRotation = 0.5;\n      const minMagnitude = 0;\n      const maxMagnitude = 500; // Now we get a value between 0-0.5 based on when the distance\n      // is between 0 and 500.\n\n      const rotation = _mathf.mathf.interpolateRange(distanceVector.length(), // The magnitude of the distance vector\n      minMagnitude, maxMagnitude, minRotation, maxRotation); // Let's make it more interesting and ease out the rotation per frame.\n\n\n      this.flower.rotaton = _mathf.mathf.ease(this.flower.rotation, rotation, 0.08, _ease.EASE.linear);\n      this.flower.rotation += rotation;\n      console.log(this.flower.velocity.magnitude(), this.flower.acceleration.magnitude());\n    });\n    this.X.start();\n  }\n\n}\n\nexports.default = XSample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy94LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZXhhbXBsZXMveC5qcz9jMjFiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3ggPSByZXF1aXJlKFwiLi4vbGliL3gveFwiKTtcblxudmFyIF94R2FtZU9iamVjdCA9IHJlcXVpcmUoXCIuLi9saWIveC94LWdhbWUtb2JqZWN0XCIpO1xuXG52YXIgX3hMaW5lID0gcmVxdWlyZShcIi4uL2xpYi94L3gtbGluZVwiKTtcblxudmFyIF94UmVjdGFuZ2xlID0gcmVxdWlyZShcIi4uL2xpYi94L3gtcmVjdGFuZ2xlXCIpO1xuXG52YXIgX3hTdGFnZSA9IHJlcXVpcmUoXCIuLi9saWIveC94LXN0YWdlXCIpO1xuXG52YXIgX3hUZXh0dXJlID0gcmVxdWlyZShcIi4uL2xpYi94L3gtdGV4dHVyZVwiKTtcblxudmFyIF94VGV4dCA9IHJlcXVpcmUoXCIuLi9saWIveC94LXRleHRcIik7XG5cbnZhciBfaW1hZ2VMb2FkZXIgPSByZXF1aXJlKFwiLi4vbGliL2xvYWRlci9pbWFnZS1sb2FkZXJcIik7XG5cbnZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uL2xpYi9tYXRoZi92ZWN0b3JcIik7XG5cbnZhciBfbWF0aGYgPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL21hdGhmXCIpO1xuXG52YXIgX2Vhc2UgPSByZXF1aXJlKFwiLi4vbGliL2Vhc2UvZWFzZVwiKTtcblxuLyoqXG4gKlxuICogVGhpcyBpcyB0aGUgYW4gZXhhbXBsZSBvZiBhY2NlbGVyYXRpbmcgYW4gWEdhbWVPYmplY3QgdG93YXJkcyB0aGVcbiAqIG1vdXNlIHBvc2l0aW9uLlxuICpcbiAqIEVhY2ggWEdhbWVPYmplY3QsIGhhcyB0aGUgZm9sbG93aW5nOlxuICogcG9zaXRvbiAtIHZlY3RvclxuICogdmVsb2NpdHkgLSB2ZWN0b3JcbiAqIGFjY2VsZXJhdGlvbiAtIHZlY3RvclxuICpcbiAqXG4gKlxuICpcbiAqL1xuY2xhc3MgWFNhbXBsZSB7XG4gIC8qKlxuICAgICAqIExvYWRzIHRlaCByZXF1aXJlZCBpbWFnZXMgYW5kIHNhdmVzIHRoZW0gdG8gYSBjYWNoZSB3aXRoIFh0ZXh0dXJlLlxuICAgICAqIFRoaXMgc3RhcnRzIHRoZSBhcHAuXG4gICAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW1hZ2VUZXh0dXJlcyA9IHt9O1xuICAgIGxldCBpbWFnZXMgPSBuZXcgX2ltYWdlTG9hZGVyLkltYWdlTG9hZGVyKFsnLi9wdWJsaWMvZmxvd2VyLmpwZyddKS5sb2FkKCkudGhlbihyZXN1bHRzID0+IHtcbiAgICAgIC8vIE1ha2UgdGV4dHVyZXMgb3V0IG9mIHRoZSBpbWFnZXMuXG4gICAgICBPYmplY3Qua2V5cyhyZXN1bHRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHRoaXMuaW1hZ2VUZXh0dXJlc1trZXldID0gbmV3IF94VGV4dHVyZS5YVGV4dHVyZShyZXN1bHRzW2tleV0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0YXJ0QXBwKCk7XG4gICAgfSk7XG4gIH1cblxuICBzdGFydEFwcCgpIHtcbiAgICBjb25zdCBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW5DYW52YXMnKTtcbiAgICB0aGlzLlggPSBuZXcgX3guWCh7XG4gICAgICBjYW52YXNFbGVtZW50OiBjYW52YXNFbGVtZW50LFxuICAgICAgZGVidWdNb2RlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5mbG93ZXIgPSBuZXcgX3hHYW1lT2JqZWN0LlhHYW1lT2JqZWN0KHtcbiAgICAgIGlkOiAnZmxvd2VyJyxcbiAgICAgIHg6IDI1MCxcbiAgICAgIHk6IDI1MCxcbiAgICAgIGFuY2hvclg6IDAuNSxcbiAgICAgIGFuY2hvclk6IDAuNSxcbiAgICAgIHNjYWxlWDogMSxcbiAgICAgIHNjYWxlWTogMSxcbiAgICAgIHJvdGF0aW9uOiAxLjUsXG4gICAgICBpbnRlcmFjdGFibGU6IHRydWUsXG4gICAgICB0ZXh0dXJlOiB0aGlzLmltYWdlVGV4dHVyZXNbJy4vcHVibGljL2Zsb3dlci5qcGcnXVxuICAgIH0pO1xuICAgIHRoaXMuWC5zdGFnZS5hZGRDaGlsZCh0aGlzLmZsb3dlcik7XG4gICAgdGhpcy5YLm9uVGljaygoKSA9PiB7XG4gICAgICAvLyBPbiBldmVyeSBmcmFtZSwgd2Ugd2FudCB0byB1cGRhdGUgdGhlIGFjY2VsZXJhdGlvbiBvZiB0aGVcbiAgICAgIC8vIHRlc3Qgb2JqZWN0IHNvIHRoYXQgaXQgYWNjZWxlcmF0ZXMgdG93YXJkcyB0aGUgbW91c2UgcG9zaXRpb24uXG4gICAgICAvLyAgV2UgbG9vayBhdCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbW91c2UgYW5kXG4gICAgICAvLyB0aGUgdGVzdCBvYmplY3QgcG9zaXRpb24uICBUbyBkbyB0aGlzLCB3ZSBzdWJ0cmFjdCB0aGUgdGVzdCBwb3NpdGlvblxuICAgICAgLy8gYW5kICBtb3VzZSBwb3NpdGlvbiB2ZWN0b3IgYW5kIGFwcGx5IHRoYXQgZGlzdGFuY2UgYXMgdGhlXG4gICAgICAvLyBhY2NlbGVyYXRpb24gb2YgdGhlIGdhbWUgb2JqZWN0LlxuICAgICAgY29uc3QgZGlzdGFuY2VWZWN0b3IgPSBfdmVjdG9yLlZlY3Rvci5zdWJ0cmFjdCggLy8gbW91c2VcbiAgICAgIHRoaXMuWC5wb2ludGVyLnBvc2l0aW9uLCBuZXcgX3ZlY3Rvci5WZWN0b3IodGhpcy5mbG93ZXIuZ2N4LCB0aGlzLmZsb3dlci5nY3kpKTsgLy8gV2UgY291bGQganVzdCBzZXQgdGhlIGFjY2VsZXJhdGlvbiB0byB0aGUgZGlzdGFuY2UgYnV0IHRoZW5cbiAgICAgIC8vIHRoZSBmbG93ZXIgaW1hZ2Ugd291bGQganVzdCBleGFjdGx5IGJlIHRoZSBwb3NpdGlvbiBvZiB0aGVcbiAgICAgIC8vIG1vdXNlLiAgVG8gYWRkIHNvbWUgZGVsYXkgYW5kIHNtb290aGluZywgd2UgZWFzZSB0aGVcbiAgICAgIC8vIHZhbGVzLlxuXG5cbiAgICAgIHRoaXMuZmxvd2VyLmFjY2VsZXJhdGlvbiA9IF92ZWN0b3IuVmVjdG9yLmVhc2UodGhpcy5mbG93ZXIuYWNjZWxlcmF0aW9uLCBkaXN0YW5jZVZlY3RvciwgMC4wOCk7IC8vIERhbXBpbmcuIFdlIHN0aWxsIGdldCBhIG9mIHNwcmluaW5nIHNvIHdlIGRhbXAgb3V0IHRoZSBzcHJpbmdpbmcuXG5cbiAgICAgIHRoaXMuZmxvd2VyLmFjY2VsZXJhdGlvbi5sZXJwKF92ZWN0b3IuVmVjdG9yLlpFUk8sIDAuOCk7IC8vIEJhc2VkIG9uIHRoZSBkaXN0YW5jZSB0byB0aGUgbW91c2UsIGxldCdzIGluY3JlYXNlIG9yIGRlY3JlYXNlXG4gICAgICAvLyB0aGUgcm90YXRpb24uXG5cbiAgICAgIGNvbnN0IG1pblJvdGF0aW9uID0gMDtcbiAgICAgIGNvbnN0IG1heFJvdGF0aW9uID0gMC41O1xuICAgICAgY29uc3QgbWluTWFnbml0dWRlID0gMDtcbiAgICAgIGNvbnN0IG1heE1hZ25pdHVkZSA9IDUwMDsgLy8gTm93IHdlIGdldCBhIHZhbHVlIGJldHdlZW4gMC0wLjUgYmFzZWQgb24gd2hlbiB0aGUgZGlzdGFuY2VcbiAgICAgIC8vIGlzIGJldHdlZW4gMCBhbmQgNTAwLlxuXG4gICAgICBjb25zdCByb3RhdGlvbiA9IF9tYXRoZi5tYXRoZi5pbnRlcnBvbGF0ZVJhbmdlKGRpc3RhbmNlVmVjdG9yLmxlbmd0aCgpLCAvLyBUaGUgbWFnbml0dWRlIG9mIHRoZSBkaXN0YW5jZSB2ZWN0b3JcbiAgICAgIG1pbk1hZ25pdHVkZSwgbWF4TWFnbml0dWRlLCBtaW5Sb3RhdGlvbiwgbWF4Um90YXRpb24pOyAvLyBMZXQncyBtYWtlIGl0IG1vcmUgaW50ZXJlc3RpbmcgYW5kIGVhc2Ugb3V0IHRoZSByb3RhdGlvbiBwZXIgZnJhbWUuXG5cblxuICAgICAgdGhpcy5mbG93ZXIucm90YXRvbiA9IF9tYXRoZi5tYXRoZi5lYXNlKHRoaXMuZmxvd2VyLnJvdGF0aW9uLCByb3RhdGlvbiwgMC4wOCwgX2Vhc2UuRUFTRS5saW5lYXIpO1xuICAgICAgdGhpcy5mbG93ZXIucm90YXRpb24gKz0gcm90YXRpb247XG4gICAgICBjb25zb2xlLmxvZyh0aGlzLmZsb3dlci52ZWxvY2l0eS5tYWduaXR1ZGUoKSwgdGhpcy5mbG93ZXIuYWNjZWxlcmF0aW9uLm1hZ25pdHVkZSgpKTtcbiAgICB9KTtcbiAgICB0aGlzLlguc3RhcnQoKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFhTYW1wbGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./examples/x.js\n");

/***/ }),

/***/ "./examples/x2.js":
/*!************************!*\
  !*** ./examples/x2.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _x = __webpack_require__(/*! ../lib/x/x */ \"./lib/x/x.js\");\n\nvar _xGameObject = __webpack_require__(/*! ../lib/x/x-game-object */ \"./lib/x/x-game-object.js\");\n\nvar _xLine = __webpack_require__(/*! ../lib/x/x-line */ \"./lib/x/x-line.js\");\n\nvar _xRectangle = __webpack_require__(/*! ../lib/x/x-rectangle */ \"./lib/x/x-rectangle.js\");\n\nvar _xStage = __webpack_require__(/*! ../lib/x/x-stage */ \"./lib/x/x-stage.js\");\n\nvar _xTexture = __webpack_require__(/*! ../lib/x/x-texture */ \"./lib/x/x-texture.js\");\n\nvar _xText = __webpack_require__(/*! ../lib/x/x-text */ \"./lib/x/x-text.js\");\n\nvar _imageLoader = __webpack_require__(/*! ../lib/loader/image-loader */ \"./lib/loader/image-loader.js\");\n\nvar _vector = __webpack_require__(/*! ../lib/mathf/vector */ \"./lib/mathf/vector.js\");\n\n/**\n *\n * This is the an example of accelerating an XGameObject towards the\n * mouse position.\n *\n * Each XGameObject, has the following:\n * positon - vector\n * velocity - vector\n * acceleration - vector\n *\n *\n *\n *\n */\nclass X2Sample {\n  constructor() {\n    console.log('x2');\n    this.imageTextures = {};\n    let images = new _imageLoader.ImageLoader(['./public/boy.png', './public/boy2.png', './public/boy3.png', './public/flower.jpg']).load().then(results => {\n      // Make textures out of the images.\n      Object.keys(results).forEach(key => {\n        this.imageTextures[key] = new _xTexture.XTexture(results[key]);\n      });\n      this.startApp();\n    });\n  }\n\n  startApp() {\n    const canvasElement = document.getElementById('mainCanvas');\n    this.X = new _x.X({\n      canvasElement: canvasElement,\n      debugMode: true\n    });\n    this.txt = new _xText.XText({\n      x: 100,\n      y: 100,\n      text: 'Hello yoyoyo;yoyoyoyoyo'\n    });\n    this.X.stage.addChild(this.txt);\n    console.log(this.txt);\n    const rect = new _xRectangle.XRectangle({\n      x: 900,\n      y: 500,\n      width: 100,\n      height: 150,\n      fillStyle: 'red'\n    });\n    this.X.stage.addChild(rect); // this.line = new XLine({\n    //     lineWidth: 10,\n    //     startX: 100,\n    //     startY: 100,\n    //     endX: 250,\n    //     endY: 250\n    // });\n\n    this.flower = new _xGameObject.XGameObject({\n      id: 'flower',\n      x: 250,\n      y: 250,\n      anchorX: 0.5,\n      anchorY: 0.5,\n      scaleX: 1,\n      scaleY: 1,\n      rotation: 1.5,\n      interactable: true,\n      onMouseDown: gameObject => {\n        console.log(gameObject); // gameObject.acceleration.add(Vector.ONE);\n        // console.table(gameObject.globalComputedBox);\n        // console.log('wh', gameObject.width, gameObject.height);\n        // console.log('gx', gameObject.gx, gameObject.gy);\n        // console.log('gcx', gameObject.gcx, gameObject.gcy);\n        // console.table({\n        //     anchor: gameObject.anchorX + ' ' + gameObject.anchorY,\n        //     width: gameObject.width,\n        //     height: gameObject.height,\n        //     x: gameObject.x,\n        //     y: gameObject.y,\n        //     box: gameObject.globalComputedBox,\n        //     parentX: gameObject.parent.x,\n        //     parentY: gameObject.parent.y,\n        //     gx: gameObject.gx,\n        //     gy: gameObject.gy,\n        // });\n      },\n      texture: this.imageTextures['./public/flower.jpg']\n    }); // this.test.debug = true;\n\n    this.X.stage.addChild(this.flower);\n    this.X.onTick(() => {});\n    this.X.start();\n  }\n\n}\n\nexports.default = X2Sample;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9leGFtcGxlcy94Mi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2V4YW1wbGVzL3gyLmpzPzMyMmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfeCA9IHJlcXVpcmUoXCIuLi9saWIveC94XCIpO1xuXG52YXIgX3hHYW1lT2JqZWN0ID0gcmVxdWlyZShcIi4uL2xpYi94L3gtZ2FtZS1vYmplY3RcIik7XG5cbnZhciBfeExpbmUgPSByZXF1aXJlKFwiLi4vbGliL3gveC1saW5lXCIpO1xuXG52YXIgX3hSZWN0YW5nbGUgPSByZXF1aXJlKFwiLi4vbGliL3gveC1yZWN0YW5nbGVcIik7XG5cbnZhciBfeFN0YWdlID0gcmVxdWlyZShcIi4uL2xpYi94L3gtc3RhZ2VcIik7XG5cbnZhciBfeFRleHR1cmUgPSByZXF1aXJlKFwiLi4vbGliL3gveC10ZXh0dXJlXCIpO1xuXG52YXIgX3hUZXh0ID0gcmVxdWlyZShcIi4uL2xpYi94L3gtdGV4dFwiKTtcblxudmFyIF9pbWFnZUxvYWRlciA9IHJlcXVpcmUoXCIuLi9saWIvbG9hZGVyL2ltYWdlLWxvYWRlclwiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vbGliL21hdGhmL3ZlY3RvclwiKTtcblxuLyoqXG4gKlxuICogVGhpcyBpcyB0aGUgYW4gZXhhbXBsZSBvZiBhY2NlbGVyYXRpbmcgYW4gWEdhbWVPYmplY3QgdG93YXJkcyB0aGVcbiAqIG1vdXNlIHBvc2l0aW9uLlxuICpcbiAqIEVhY2ggWEdhbWVPYmplY3QsIGhhcyB0aGUgZm9sbG93aW5nOlxuICogcG9zaXRvbiAtIHZlY3RvclxuICogdmVsb2NpdHkgLSB2ZWN0b3JcbiAqIGFjY2VsZXJhdGlvbiAtIHZlY3RvclxuICpcbiAqXG4gKlxuICpcbiAqL1xuY2xhc3MgWDJTYW1wbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zb2xlLmxvZygneDInKTtcbiAgICB0aGlzLmltYWdlVGV4dHVyZXMgPSB7fTtcbiAgICBsZXQgaW1hZ2VzID0gbmV3IF9pbWFnZUxvYWRlci5JbWFnZUxvYWRlcihbJy4vcHVibGljL2JveS5wbmcnLCAnLi9wdWJsaWMvYm95Mi5wbmcnLCAnLi9wdWJsaWMvYm95My5wbmcnLCAnLi9wdWJsaWMvZmxvd2VyLmpwZyddKS5sb2FkKCkudGhlbihyZXN1bHRzID0+IHtcbiAgICAgIC8vIE1ha2UgdGV4dHVyZXMgb3V0IG9mIHRoZSBpbWFnZXMuXG4gICAgICBPYmplY3Qua2V5cyhyZXN1bHRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIHRoaXMuaW1hZ2VUZXh0dXJlc1trZXldID0gbmV3IF94VGV4dHVyZS5YVGV4dHVyZShyZXN1bHRzW2tleV0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0YXJ0QXBwKCk7XG4gICAgfSk7XG4gIH1cblxuICBzdGFydEFwcCgpIHtcbiAgICBjb25zdCBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW5DYW52YXMnKTtcbiAgICB0aGlzLlggPSBuZXcgX3guWCh7XG4gICAgICBjYW52YXNFbGVtZW50OiBjYW52YXNFbGVtZW50LFxuICAgICAgZGVidWdNb2RlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy50eHQgPSBuZXcgX3hUZXh0LlhUZXh0KHtcbiAgICAgIHg6IDEwMCxcbiAgICAgIHk6IDEwMCxcbiAgICAgIHRleHQ6ICdIZWxsbyB5b3lveW87eW95b3lveW95bydcbiAgICB9KTtcbiAgICB0aGlzLlguc3RhZ2UuYWRkQ2hpbGQodGhpcy50eHQpO1xuICAgIGNvbnNvbGUubG9nKHRoaXMudHh0KTtcbiAgICBjb25zdCByZWN0ID0gbmV3IF94UmVjdGFuZ2xlLlhSZWN0YW5nbGUoe1xuICAgICAgeDogOTAwLFxuICAgICAgeTogNTAwLFxuICAgICAgd2lkdGg6IDEwMCxcbiAgICAgIGhlaWdodDogMTUwLFxuICAgICAgZmlsbFN0eWxlOiAncmVkJ1xuICAgIH0pO1xuICAgIHRoaXMuWC5zdGFnZS5hZGRDaGlsZChyZWN0KTsgLy8gdGhpcy5saW5lID0gbmV3IFhMaW5lKHtcbiAgICAvLyAgICAgbGluZVdpZHRoOiAxMCxcbiAgICAvLyAgICAgc3RhcnRYOiAxMDAsXG4gICAgLy8gICAgIHN0YXJ0WTogMTAwLFxuICAgIC8vICAgICBlbmRYOiAyNTAsXG4gICAgLy8gICAgIGVuZFk6IDI1MFxuICAgIC8vIH0pO1xuXG4gICAgdGhpcy5mbG93ZXIgPSBuZXcgX3hHYW1lT2JqZWN0LlhHYW1lT2JqZWN0KHtcbiAgICAgIGlkOiAnZmxvd2VyJyxcbiAgICAgIHg6IDI1MCxcbiAgICAgIHk6IDI1MCxcbiAgICAgIGFuY2hvclg6IDAuNSxcbiAgICAgIGFuY2hvclk6IDAuNSxcbiAgICAgIHNjYWxlWDogMSxcbiAgICAgIHNjYWxlWTogMSxcbiAgICAgIHJvdGF0aW9uOiAxLjUsXG4gICAgICBpbnRlcmFjdGFibGU6IHRydWUsXG4gICAgICBvbk1vdXNlRG93bjogZ2FtZU9iamVjdCA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGdhbWVPYmplY3QpOyAvLyBnYW1lT2JqZWN0LmFjY2VsZXJhdGlvbi5hZGQoVmVjdG9yLk9ORSk7XG4gICAgICAgIC8vIGNvbnNvbGUudGFibGUoZ2FtZU9iamVjdC5nbG9iYWxDb21wdXRlZEJveCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd3aCcsIGdhbWVPYmplY3Qud2lkdGgsIGdhbWVPYmplY3QuaGVpZ2h0KTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2d4JywgZ2FtZU9iamVjdC5neCwgZ2FtZU9iamVjdC5neSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdnY3gnLCBnYW1lT2JqZWN0LmdjeCwgZ2FtZU9iamVjdC5nY3kpO1xuICAgICAgICAvLyBjb25zb2xlLnRhYmxlKHtcbiAgICAgICAgLy8gICAgIGFuY2hvcjogZ2FtZU9iamVjdC5hbmNob3JYICsgJyAnICsgZ2FtZU9iamVjdC5hbmNob3JZLFxuICAgICAgICAvLyAgICAgd2lkdGg6IGdhbWVPYmplY3Qud2lkdGgsXG4gICAgICAgIC8vICAgICBoZWlnaHQ6IGdhbWVPYmplY3QuaGVpZ2h0LFxuICAgICAgICAvLyAgICAgeDogZ2FtZU9iamVjdC54LFxuICAgICAgICAvLyAgICAgeTogZ2FtZU9iamVjdC55LFxuICAgICAgICAvLyAgICAgYm94OiBnYW1lT2JqZWN0Lmdsb2JhbENvbXB1dGVkQm94LFxuICAgICAgICAvLyAgICAgcGFyZW50WDogZ2FtZU9iamVjdC5wYXJlbnQueCxcbiAgICAgICAgLy8gICAgIHBhcmVudFk6IGdhbWVPYmplY3QucGFyZW50LnksXG4gICAgICAgIC8vICAgICBneDogZ2FtZU9iamVjdC5neCxcbiAgICAgICAgLy8gICAgIGd5OiBnYW1lT2JqZWN0Lmd5LFxuICAgICAgICAvLyB9KTtcbiAgICAgIH0sXG4gICAgICB0ZXh0dXJlOiB0aGlzLmltYWdlVGV4dHVyZXNbJy4vcHVibGljL2Zsb3dlci5qcGcnXVxuICAgIH0pOyAvLyB0aGlzLnRlc3QuZGVidWcgPSB0cnVlO1xuXG4gICAgdGhpcy5YLnN0YWdlLmFkZENoaWxkKHRoaXMuZmxvd2VyKTtcbiAgICB0aGlzLlgub25UaWNrKCgpID0+IHt9KTtcbiAgICB0aGlzLlguc3RhcnQoKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFgyU2FtcGxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./examples/x2.js\n");

/***/ }),

/***/ "./lib/arrayf/arrayf.js":
/*!******************************!*\
  !*** ./lib/arrayf/arrayf.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.arrayf = void 0;\n/**\n * A static class that helps with arrays.\n */\nconst __1 = __webpack_require__(/*! .. */ \"./lib/index.js\");\nclass arrayf {\n    /**\n     * A deep copy that works with objects or arrays.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static deepCopy(input) {\n        let value, key;\n        if (typeof input !== 'object' || input === null) {\n            return input;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = Array.isArray(input) ? [] : {};\n        for (key in input) {\n            value = input[key];\n            output[key] =\n                typeof value === 'object' && value !== null\n                    ? arrayf.deepCopy(value)\n                    : value;\n        }\n        return output;\n    }\n    /**\n     * Return value from array that generates the highest return value when\n     * passed as a parameter to the score function.\n     *\n     * Multiple score functions can be passed with later functions used only to\n     * break ties for values returned from the previous score function.\n     *\n     * Example:\n     * ```\n     * const values = [{'a': 2, 'b': 3}, {'a': 1, 'b': 4}];\n     * arrayf.max(values, (x) => x.a); // Returns {'a': 2, 'b': 3}\n     * arrayf.max(values, (x) => x.b); // Returns {'a': 1, 'b': 4}\n     * ```\n     */\n    static max(values, ...scoreFns) {\n        let maxValue = null;\n        let maxScore = Number.NEGATIVE_INFINITY;\n        const scoreFn = scoreFns[0];\n        values.forEach(value => {\n            const score = scoreFn(value);\n            if (maxScore < score) {\n                maxValue = value;\n                maxScore = score;\n            }\n            else if (maxScore === score && scoreFns.length > 1) {\n                let i = 1;\n                let tieBreaker = scoreFns[i];\n                while (i < scoreFns.length &&\n                    tieBreaker(maxValue) === tieBreaker(value)) {\n                    tieBreaker = scoreFns[i++];\n                }\n                if (tieBreaker(maxValue) < tieBreaker(value)) {\n                    maxValue = value;\n                }\n            }\n        });\n        return maxValue;\n    }\n    /**\n     * Return value from array that generates the lowest return value when\n     * passed as a parameter to the score function.\n     *\n     * Multiple score functions can be passed with later functions used only to\n     * break ties for values returned from the previous score function.\n     *\n     * Example:\n     * ```\n     * const values = [{'a': 2, 'b': 3}, {'a': 1, 'b': 4}];\n     * arrayf.min(values, (x) => x.a); // Returns {'a': 1, 'b': 4}\n     * arrayf.min(values, (x) => x.b); // Returns {'a': 2, 'b': 3}\n     * ```\n     */\n    static min(values, ...scoreFns) {\n        return arrayf.max(values, ...scoreFns.map(scoreFn => {\n            return (v) => -1 * scoreFn(v);\n        }));\n    }\n    /**\n     * Operates as per the built in slice with the option to wrap around from\n     * the end of the array to the start and vice versa. Can also slice in the\n     * reverse direction if given a negative value for `direction`.\n     * @param values\n     * @param startIndex\n     * @param rawEndIndex\n     * @param direction\n     */\n    static loopSlice(values, startIndex, rawEndIndex, direction = 1) {\n        const result = [];\n        const length = values.length;\n        const increment = Math.sign(direction);\n        const endIndex = __1.mathf.wrap(rawEndIndex, 0, length);\n        let index = __1.mathf.wrap(startIndex, 0, length);\n        while (index !== endIndex) {\n            result.push(values[index]);\n            index = __1.mathf.wrap(index + increment, 0, length);\n        }\n        return result;\n    }\n    /**\n     * Determines if the given values contain the given value.\n     * @param values\n     * @param value\n     */\n    static contains(values, value) {\n        return values.indexOf(value) !== -1;\n    }\n}\nexports.arrayf = arrayf;\n//# sourceMappingURL=arrayf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvYXJyYXlmL2FycmF5Zi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9hcnJheWYvYXJyYXlmLmpzP2IyNjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFycmF5ZiA9IHZvaWQgMDtcbi8qKlxuICogQSBzdGF0aWMgY2xhc3MgdGhhdCBoZWxwcyB3aXRoIGFycmF5cy5cbiAqL1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uXCIpO1xuY2xhc3MgYXJyYXlmIHtcbiAgICAvKipcbiAgICAgKiBBIGRlZXAgY29weSB0aGF0IHdvcmtzIHdpdGggb2JqZWN0cyBvciBhcnJheXMuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgZGVlcENvcHkoaW5wdXQpIHtcbiAgICAgICAgbGV0IHZhbHVlLCBrZXk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnIHx8IGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBbXSA6IHt9O1xuICAgICAgICBmb3IgKGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgdmFsdWUgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyBhcnJheWYuZGVlcENvcHkodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHZhbHVlIGZyb20gYXJyYXkgdGhhdCBnZW5lcmF0ZXMgdGhlIGhpZ2hlc3QgcmV0dXJuIHZhbHVlIHdoZW5cbiAgICAgKiBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgdG8gdGhlIHNjb3JlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogTXVsdGlwbGUgc2NvcmUgZnVuY3Rpb25zIGNhbiBiZSBwYXNzZWQgd2l0aCBsYXRlciBmdW5jdGlvbnMgdXNlZCBvbmx5IHRvXG4gICAgICogYnJlYWsgdGllcyBmb3IgdmFsdWVzIHJldHVybmVkIGZyb20gdGhlIHByZXZpb3VzIHNjb3JlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCB2YWx1ZXMgPSBbeydhJzogMiwgJ2InOiAzfSwgeydhJzogMSwgJ2InOiA0fV07XG4gICAgICogYXJyYXlmLm1heCh2YWx1ZXMsICh4KSA9PiB4LmEpOyAvLyBSZXR1cm5zIHsnYSc6IDIsICdiJzogM31cbiAgICAgKiBhcnJheWYubWF4KHZhbHVlcywgKHgpID0+IHguYik7IC8vIFJldHVybnMgeydhJzogMSwgJ2InOiA0fVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBtYXgodmFsdWVzLCAuLi5zY29yZUZucykge1xuICAgICAgICBsZXQgbWF4VmFsdWUgPSBudWxsO1xuICAgICAgICBsZXQgbWF4U2NvcmUgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIGNvbnN0IHNjb3JlRm4gPSBzY29yZUZuc1swXTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NvcmUgPSBzY29yZUZuKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChtYXhTY29yZSA8IHNjb3JlKSB7XG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBtYXhTY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF4U2NvcmUgPT09IHNjb3JlICYmIHNjb3JlRm5zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgICAgICAgICAgbGV0IHRpZUJyZWFrZXIgPSBzY29yZUZuc1tpXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IHNjb3JlRm5zLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICB0aWVCcmVha2VyKG1heFZhbHVlKSA9PT0gdGllQnJlYWtlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGllQnJlYWtlciA9IHNjb3JlRm5zW2krK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aWVCcmVha2VyKG1heFZhbHVlKSA8IHRpZUJyZWFrZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdmFsdWUgZnJvbSBhcnJheSB0aGF0IGdlbmVyYXRlcyB0aGUgbG93ZXN0IHJldHVybiB2YWx1ZSB3aGVuXG4gICAgICogcGFzc2VkIGFzIGEgcGFyYW1ldGVyIHRvIHRoZSBzY29yZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIE11bHRpcGxlIHNjb3JlIGZ1bmN0aW9ucyBjYW4gYmUgcGFzc2VkIHdpdGggbGF0ZXIgZnVuY3Rpb25zIHVzZWQgb25seSB0b1xuICAgICAqIGJyZWFrIHRpZXMgZm9yIHZhbHVlcyByZXR1cm5lZCBmcm9tIHRoZSBwcmV2aW91cyBzY29yZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogYGBgXG4gICAgICogY29uc3QgdmFsdWVzID0gW3snYSc6IDIsICdiJzogM30sIHsnYSc6IDEsICdiJzogNH1dO1xuICAgICAqIGFycmF5Zi5taW4odmFsdWVzLCAoeCkgPT4geC5hKTsgLy8gUmV0dXJucyB7J2EnOiAxLCAnYic6IDR9XG4gICAgICogYXJyYXlmLm1pbih2YWx1ZXMsICh4KSA9PiB4LmIpOyAvLyBSZXR1cm5zIHsnYSc6IDIsICdiJzogM31cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgbWluKHZhbHVlcywgLi4uc2NvcmVGbnMpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Zi5tYXgodmFsdWVzLCAuLi5zY29yZUZucy5tYXAoc2NvcmVGbiA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHYpID0+IC0xICogc2NvcmVGbih2KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVyYXRlcyBhcyBwZXIgdGhlIGJ1aWx0IGluIHNsaWNlIHdpdGggdGhlIG9wdGlvbiB0byB3cmFwIGFyb3VuZCBmcm9tXG4gICAgICogdGhlIGVuZCBvZiB0aGUgYXJyYXkgdG8gdGhlIHN0YXJ0IGFuZCB2aWNlIHZlcnNhLiBDYW4gYWxzbyBzbGljZSBpbiB0aGVcbiAgICAgKiByZXZlcnNlIGRpcmVjdGlvbiBpZiBnaXZlbiBhIG5lZ2F0aXZlIHZhbHVlIGZvciBgZGlyZWN0aW9uYC5cbiAgICAgKiBAcGFyYW0gdmFsdWVzXG4gICAgICogQHBhcmFtIHN0YXJ0SW5kZXhcbiAgICAgKiBAcGFyYW0gcmF3RW5kSW5kZXhcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGxvb3BTbGljZSh2YWx1ZXMsIHN0YXJ0SW5kZXgsIHJhd0VuZEluZGV4LCBkaXJlY3Rpb24gPSAxKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBpbmNyZW1lbnQgPSBNYXRoLnNpZ24oZGlyZWN0aW9uKTtcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSBfXzEubWF0aGYud3JhcChyYXdFbmRJbmRleCwgMCwgbGVuZ3RoKTtcbiAgICAgICAgbGV0IGluZGV4ID0gX18xLm1hdGhmLndyYXAoc3RhcnRJbmRleCwgMCwgbGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGluZGV4ICE9PSBlbmRJbmRleCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWVzW2luZGV4XSk7XG4gICAgICAgICAgICBpbmRleCA9IF9fMS5tYXRoZi53cmFwKGluZGV4ICsgaW5jcmVtZW50LCAwLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHZhbHVlcyBjb250YWluIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gdmFsdWVzXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIGNvbnRhaW5zKHZhbHVlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgfVxufVxuZXhwb3J0cy5hcnJheWYgPSBhcnJheWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheWYuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/arrayf/arrayf.js\n");

/***/ }),

/***/ "./lib/datguif/datguif.js":
/*!********************************!*\
  !*** ./lib/datguif/datguif.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Datguif = void 0;\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst dat = __webpack_require__(/*! dat.gui */ \"./node_modules/dat.gui/build/dat.gui.module.js\");\nconst is_1 = __webpack_require__(/*! ../is/is */ \"./lib/is/is.js\");\nconst color_1 = __webpack_require__(/*! ../mathf/color */ \"./lib/mathf/color.js\");\n/**\n * Wrapper around https://github.com/dataarts/dat.gui/blob/master/API.md\n * to make an object output easier.\n *\n * ```ts\n *\n * const gui = new Datguif();\n *\n * // Register an update callback.\n * gui.onUpdate(()=> {\n *   console.log('gui controls updated');\n * })\n *\n *\n * gui.addFolder('Lights').open();\n * gui.addFolder('Other Config');\n *\n *\n * // Add a subfolder to lights\n * gui.addFolder('Directional Lights', 'Lights');\n * gui.addFolder('Atmosphere Lights', 'Lights');\n *\n *\n * const otherConfig = {\n *   'scale': 0.5,\n *   'optimize': false\n * }\n *\n * const directionalLight = {\n *   'intensity': 0.5,\n *   'show': false,\n *   'castShadow': true,\n * }\n *\n *\n * // Add the directional light to the Directional Lights folder.\n * // Only show intensity and castShadow properties.\n * gui.addObjectToFolder('Directional Lights',\n *   directionalLights,\n *  [\n *   { keyName: 'castShadow'},\n *   { keyName: 'intensity', min: 0, max: 100, callback: ()=> {\n *        console.log('intensity just changed');\n *   }},\n *   { keyName: 'ease', ['linear', 'easeInOutQuad']}\n * ]);\n *\n *\n * // Add the scale option to the Other config folder.\n * gui.addObjectPropertyToFolder(\n *   'Other Config',\n *   otherConfig,\n *  {\n *    keyname: 'scale'\n *  }\n * )\n *\n *\n * // Add functions.\n * guid.addToFolder(\n *  ()=> {\n *    // refresh code.\n *    console.log('hohoho');\n *  },\n *  'Refresh'\n * )\n *\n *\n * ```\n */\nclass Datguif {\n    constructor(\n    //@see https://github.com/dataarts/dat.gui/blob/master/API.md#new_GUI_new\n    guiParams) {\n        const options = guiParams;\n        if (!options) {\n            options.load = JSON;\n        }\n        this.gui = new dat.GUI(options);\n        this.folders = [];\n        this.updateCallbacks = [];\n    }\n    getGui() {\n        return this.gui;\n    }\n    /**\n     * Adds an update callback.\n     */\n    onUpdate(callback) {\n        this.updateCallbacks.push(callback);\n    }\n    runUpdate() {\n        this.updateCallbacks.forEach(callback => {\n            callback();\n        });\n    }\n    // Adds a to level button\n    addButton(label, callback) {\n        const id = label.replace(' ', '_');\n        const obj = {};\n        obj[id] = callback;\n        this.gui.add(obj, label.replace(' ', '_'));\n    }\n    /**\n     *\n     * Add a folder to the datguif system.\n     *\n     * @param folderName\n     * @param parentFolder\n     */\n    addFolder(folderName, parentFolderName) {\n        let folder;\n        if (this.folderExists(folderName)) {\n            throw new Error('Folder names must be unique');\n        }\n        if (parentFolderName) {\n            const parentFolder = this.getFolder(parentFolderName).gui;\n            folder = parentFolder.addFolder(folderName);\n        }\n        else {\n            folder = this.gui.addFolder(folderName);\n        }\n        this.folders.push({\n            name: folderName,\n            gui: folder,\n        });\n        return folder;\n    }\n    /**\n     * Checks if a folder of a given name already exists.\n     */\n    folderExists(folderName) {\n        const folder = this.folders.filter(f => {\n            return f.name === folderName;\n        })[0];\n        return !!folder;\n    }\n    getFolder(folderName) {\n        const folder = this.folders.filter(f => {\n            return f.name === folderName;\n        })[0];\n        if (!folder) {\n            throw new Error('No folder named:' + folder + ' was found');\n        }\n        return folder;\n    }\n    addToFolder(folderName, obj, keyName) {\n        const folder = this.getFolder(folderName);\n        folder.gui.add(obj, keyName);\n    }\n    addObjectPropertyToFolder(folderName, obj, config) {\n        const folder = this.getFolder(folderName);\n        const value = obj[config.keyName];\n        if (!is_1.is.defined(value)) {\n            return;\n        }\n        // If this looks \"color\" like.  Convert it to color and then handle\n        // the update when it comes back. (Support for Three.Color)\n        if (value.r && value.g && value.b) {\n            const colorObj = {};\n            colorObj[config.keyName] = color_1.color.normalizedRgbToRgb(color_1.color.colorRgbToRgb(value));\n            folder.gui.addColor(colorObj, config.keyName).onChange(() => {\n                // // Convert it back.\n                const converted = {\n                    r: color_1.color.rgbToNormalizedRgb(colorObj[config.keyName])[0],\n                    g: color_1.color.rgbToNormalizedRgb(colorObj[config.keyName])[1],\n                    b: color_1.color.rgbToNormalizedRgb(colorObj[config.keyName])[2],\n                };\n                obj[config.keyName] = converted;\n                config.callback && config.callback();\n                this.runUpdate();\n            });\n            return;\n        }\n        // Support for #FFFFFF type colors.\n        if (is_1.is.cssHex(value)) {\n            folder.gui.addColor(obj, config.keyName).onChange(() => {\n                config.callback && config.callback();\n                this.runUpdate();\n            });\n            return;\n        }\n        if (is_1.is.defined(config.options)) {\n            folder.gui.add(obj, config.keyName, config.options).onChange(() => {\n                config.callback && config.callback();\n                this.runUpdate();\n            });\n            return;\n        }\n        if (is_1.is.defined(config.min) && is_1.is.defined(config.max)) {\n            folder.gui\n                .add(obj, config.keyName, +config.min, +config.max)\n                .step(config.step || 0.1)\n                .onChange(() => {\n                config.callback && config.callback();\n                this.runUpdate();\n            });\n            return;\n        }\n        folder.gui.add(obj, config.keyName).onChange(() => {\n            config.callback && config.callback();\n            this.runUpdate();\n        });\n    }\n    addObjectToFolder(folderName, obj, mapping) {\n        this.gui.remember(obj);\n        for (const key in obj) {\n            // Check if this key should be displayed.\n            const config = mapping.filter(c => {\n                return c.keyName === key;\n            })[0];\n            if (config) {\n                this.addObjectPropertyToFolder(folderName, obj, config);\n            }\n        }\n    }\n}\nexports.Datguif = Datguif;\n/* eslint-enable */\n//# sourceMappingURL=datguif.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZGF0Z3VpZi9kYXRndWlmLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2RhdGd1aWYvZGF0Z3VpZi5qcz84MzE5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EYXRndWlmID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3QgZGF0ID0gcmVxdWlyZShcImRhdC5ndWlcIik7XG5jb25zdCBpc18xID0gcmVxdWlyZShcIi4uL2lzL2lzXCIpO1xuY29uc3QgY29sb3JfMSA9IHJlcXVpcmUoXCIuLi9tYXRoZi9jb2xvclwiKTtcbi8qKlxuICogV3JhcHBlciBhcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL2RhdGFhcnRzL2RhdC5ndWkvYmxvYi9tYXN0ZXIvQVBJLm1kXG4gKiB0byBtYWtlIGFuIG9iamVjdCBvdXRwdXQgZWFzaWVyLlxuICpcbiAqIGBgYHRzXG4gKlxuICogY29uc3QgZ3VpID0gbmV3IERhdGd1aWYoKTtcbiAqXG4gKiAvLyBSZWdpc3RlciBhbiB1cGRhdGUgY2FsbGJhY2suXG4gKiBndWkub25VcGRhdGUoKCk9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdndWkgY29udHJvbHMgdXBkYXRlZCcpO1xuICogfSlcbiAqXG4gKlxuICogZ3VpLmFkZEZvbGRlcignTGlnaHRzJykub3BlbigpO1xuICogZ3VpLmFkZEZvbGRlcignT3RoZXIgQ29uZmlnJyk7XG4gKlxuICpcbiAqIC8vIEFkZCBhIHN1YmZvbGRlciB0byBsaWdodHNcbiAqIGd1aS5hZGRGb2xkZXIoJ0RpcmVjdGlvbmFsIExpZ2h0cycsICdMaWdodHMnKTtcbiAqIGd1aS5hZGRGb2xkZXIoJ0F0bW9zcGhlcmUgTGlnaHRzJywgJ0xpZ2h0cycpO1xuICpcbiAqXG4gKiBjb25zdCBvdGhlckNvbmZpZyA9IHtcbiAqICAgJ3NjYWxlJzogMC41LFxuICogICAnb3B0aW1pemUnOiBmYWxzZVxuICogfVxuICpcbiAqIGNvbnN0IGRpcmVjdGlvbmFsTGlnaHQgPSB7XG4gKiAgICdpbnRlbnNpdHknOiAwLjUsXG4gKiAgICdzaG93JzogZmFsc2UsXG4gKiAgICdjYXN0U2hhZG93JzogdHJ1ZSxcbiAqIH1cbiAqXG4gKlxuICogLy8gQWRkIHRoZSBkaXJlY3Rpb25hbCBsaWdodCB0byB0aGUgRGlyZWN0aW9uYWwgTGlnaHRzIGZvbGRlci5cbiAqIC8vIE9ubHkgc2hvdyBpbnRlbnNpdHkgYW5kIGNhc3RTaGFkb3cgcHJvcGVydGllcy5cbiAqIGd1aS5hZGRPYmplY3RUb0ZvbGRlcignRGlyZWN0aW9uYWwgTGlnaHRzJyxcbiAqICAgZGlyZWN0aW9uYWxMaWdodHMsXG4gKiAgW1xuICogICB7IGtleU5hbWU6ICdjYXN0U2hhZG93J30sXG4gKiAgIHsga2V5TmFtZTogJ2ludGVuc2l0eScsIG1pbjogMCwgbWF4OiAxMDAsIGNhbGxiYWNrOiAoKT0+IHtcbiAqICAgICAgICBjb25zb2xlLmxvZygnaW50ZW5zaXR5IGp1c3QgY2hhbmdlZCcpO1xuICogICB9fSxcbiAqICAgeyBrZXlOYW1lOiAnZWFzZScsIFsnbGluZWFyJywgJ2Vhc2VJbk91dFF1YWQnXX1cbiAqIF0pO1xuICpcbiAqXG4gKiAvLyBBZGQgdGhlIHNjYWxlIG9wdGlvbiB0byB0aGUgT3RoZXIgY29uZmlnIGZvbGRlci5cbiAqIGd1aS5hZGRPYmplY3RQcm9wZXJ0eVRvRm9sZGVyKFxuICogICAnT3RoZXIgQ29uZmlnJyxcbiAqICAgb3RoZXJDb25maWcsXG4gKiAge1xuICogICAga2V5bmFtZTogJ3NjYWxlJ1xuICogIH1cbiAqIClcbiAqXG4gKlxuICogLy8gQWRkIGZ1bmN0aW9ucy5cbiAqIGd1aWQuYWRkVG9Gb2xkZXIoXG4gKiAgKCk9PiB7XG4gKiAgICAvLyByZWZyZXNoIGNvZGUuXG4gKiAgICBjb25zb2xlLmxvZygnaG9ob2hvJyk7XG4gKiAgfSxcbiAqICAnUmVmcmVzaCdcbiAqIClcbiAqXG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIERhdGd1aWYge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZGF0YWFydHMvZGF0Lmd1aS9ibG9iL21hc3Rlci9BUEkubWQjbmV3X0dVSV9uZXdcbiAgICBndWlQYXJhbXMpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGd1aVBhcmFtcztcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zLmxvYWQgPSBKU09OO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3VpID0gbmV3IGRhdC5HVUkob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZm9sZGVycyA9IFtdO1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrcyA9IFtdO1xuICAgIH1cbiAgICBnZXRHdWkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmd1aTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiB1cGRhdGUgY2FsbGJhY2suXG4gICAgICovXG4gICAgb25VcGRhdGUoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIHJ1blVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWRkcyBhIHRvIGxldmVsIGJ1dHRvblxuICAgIGFkZEJ1dHRvbihsYWJlbCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaWQgPSBsYWJlbC5yZXBsYWNlKCcgJywgJ18nKTtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG9ialtpZF0gPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5ndWkuYWRkKG9iaiwgbGFiZWwucmVwbGFjZSgnICcsICdfJykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFkZCBhIGZvbGRlciB0byB0aGUgZGF0Z3VpZiBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9sZGVyTmFtZVxuICAgICAqIEBwYXJhbSBwYXJlbnRGb2xkZXJcbiAgICAgKi9cbiAgICBhZGRGb2xkZXIoZm9sZGVyTmFtZSwgcGFyZW50Rm9sZGVyTmFtZSkge1xuICAgICAgICBsZXQgZm9sZGVyO1xuICAgICAgICBpZiAodGhpcy5mb2xkZXJFeGlzdHMoZm9sZGVyTmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9sZGVyIG5hbWVzIG11c3QgYmUgdW5pcXVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudEZvbGRlck5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEZvbGRlciA9IHRoaXMuZ2V0Rm9sZGVyKHBhcmVudEZvbGRlck5hbWUpLmd1aTtcbiAgICAgICAgICAgIGZvbGRlciA9IHBhcmVudEZvbGRlci5hZGRGb2xkZXIoZm9sZGVyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb2xkZXIgPSB0aGlzLmd1aS5hZGRGb2xkZXIoZm9sZGVyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb2xkZXJzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogZm9sZGVyTmFtZSxcbiAgICAgICAgICAgIGd1aTogZm9sZGVyLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvbGRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgZm9sZGVyIG9mIGEgZ2l2ZW4gbmFtZSBhbHJlYWR5IGV4aXN0cy5cbiAgICAgKi9cbiAgICBmb2xkZXJFeGlzdHMoZm9sZGVyTmFtZSkge1xuICAgICAgICBjb25zdCBmb2xkZXIgPSB0aGlzLmZvbGRlcnMuZmlsdGVyKGYgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGYubmFtZSA9PT0gZm9sZGVyTmFtZTtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHJldHVybiAhIWZvbGRlcjtcbiAgICB9XG4gICAgZ2V0Rm9sZGVyKGZvbGRlck5hbWUpIHtcbiAgICAgICAgY29uc3QgZm9sZGVyID0gdGhpcy5mb2xkZXJzLmZpbHRlcihmID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmLm5hbWUgPT09IGZvbGRlck5hbWU7XG4gICAgICAgIH0pWzBdO1xuICAgICAgICBpZiAoIWZvbGRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBmb2xkZXIgbmFtZWQ6JyArIGZvbGRlciArICcgd2FzIGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbGRlcjtcbiAgICB9XG4gICAgYWRkVG9Gb2xkZXIoZm9sZGVyTmFtZSwgb2JqLCBrZXlOYW1lKSB7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuZ2V0Rm9sZGVyKGZvbGRlck5hbWUpO1xuICAgICAgICBmb2xkZXIuZ3VpLmFkZChvYmosIGtleU5hbWUpO1xuICAgIH1cbiAgICBhZGRPYmplY3RQcm9wZXJ0eVRvRm9sZGVyKGZvbGRlck5hbWUsIG9iaiwgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuZ2V0Rm9sZGVyKGZvbGRlck5hbWUpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtjb25maWcua2V5TmFtZV07XG4gICAgICAgIGlmICghaXNfMS5pcy5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgbG9va3MgXCJjb2xvclwiIGxpa2UuICBDb252ZXJ0IGl0IHRvIGNvbG9yIGFuZCB0aGVuIGhhbmRsZVxuICAgICAgICAvLyB0aGUgdXBkYXRlIHdoZW4gaXQgY29tZXMgYmFjay4gKFN1cHBvcnQgZm9yIFRocmVlLkNvbG9yKVxuICAgICAgICBpZiAodmFsdWUuciAmJiB2YWx1ZS5nICYmIHZhbHVlLmIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yT2JqID0ge307XG4gICAgICAgICAgICBjb2xvck9ialtjb25maWcua2V5TmFtZV0gPSBjb2xvcl8xLmNvbG9yLm5vcm1hbGl6ZWRSZ2JUb1JnYihjb2xvcl8xLmNvbG9yLmNvbG9yUmdiVG9SZ2IodmFsdWUpKTtcbiAgICAgICAgICAgIGZvbGRlci5ndWkuYWRkQ29sb3IoY29sb3JPYmosIGNvbmZpZy5rZXlOYW1lKS5vbkNoYW5nZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gLy8gQ29udmVydCBpdCBiYWNrLlxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcjogY29sb3JfMS5jb2xvci5yZ2JUb05vcm1hbGl6ZWRSZ2IoY29sb3JPYmpbY29uZmlnLmtleU5hbWVdKVswXSxcbiAgICAgICAgICAgICAgICAgICAgZzogY29sb3JfMS5jb2xvci5yZ2JUb05vcm1hbGl6ZWRSZ2IoY29sb3JPYmpbY29uZmlnLmtleU5hbWVdKVsxXSxcbiAgICAgICAgICAgICAgICAgICAgYjogY29sb3JfMS5jb2xvci5yZ2JUb05vcm1hbGl6ZWRSZ2IoY29sb3JPYmpbY29uZmlnLmtleU5hbWVdKVsyXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9ialtjb25maWcua2V5TmFtZV0gPSBjb252ZXJ0ZWQ7XG4gICAgICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrICYmIGNvbmZpZy5jYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdXBwb3J0IGZvciAjRkZGRkZGIHR5cGUgY29sb3JzLlxuICAgICAgICBpZiAoaXNfMS5pcy5jc3NIZXgodmFsdWUpKSB7XG4gICAgICAgICAgICBmb2xkZXIuZ3VpLmFkZENvbG9yKG9iaiwgY29uZmlnLmtleU5hbWUpLm9uQ2hhbmdlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25maWcuY2FsbGJhY2sgJiYgY29uZmlnLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5VcGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc18xLmlzLmRlZmluZWQoY29uZmlnLm9wdGlvbnMpKSB7XG4gICAgICAgICAgICBmb2xkZXIuZ3VpLmFkZChvYmosIGNvbmZpZy5rZXlOYW1lLCBjb25maWcub3B0aW9ucykub25DaGFuZ2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFjayAmJiBjb25maWcuY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzXzEuaXMuZGVmaW5lZChjb25maWcubWluKSAmJiBpc18xLmlzLmRlZmluZWQoY29uZmlnLm1heCkpIHtcbiAgICAgICAgICAgIGZvbGRlci5ndWlcbiAgICAgICAgICAgICAgICAuYWRkKG9iaiwgY29uZmlnLmtleU5hbWUsICtjb25maWcubWluLCArY29uZmlnLm1heClcbiAgICAgICAgICAgICAgICAuc3RlcChjb25maWcuc3RlcCB8fCAwLjEpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25maWcuY2FsbGJhY2sgJiYgY29uZmlnLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5VcGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvbGRlci5ndWkuYWRkKG9iaiwgY29uZmlnLmtleU5hbWUpLm9uQ2hhbmdlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFjayAmJiBjb25maWcuY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHRoaXMucnVuVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRPYmplY3RUb0ZvbGRlcihmb2xkZXJOYW1lLCBvYmosIG1hcHBpbmcpIHtcbiAgICAgICAgdGhpcy5ndWkucmVtZW1iZXIob2JqKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGtleSBzaG91bGQgYmUgZGlzcGxheWVkLlxuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gbWFwcGluZy5maWx0ZXIoYyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMua2V5TmFtZSA9PT0ga2V5O1xuICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRPYmplY3RQcm9wZXJ0eVRvRm9sZGVyKGZvbGRlck5hbWUsIG9iaiwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGF0Z3VpZiA9IERhdGd1aWY7XG4vKiBlc2xpbnQtZW5hYmxlICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRndWlmLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/datguif/datguif.js\n");

/***/ }),

/***/ "./lib/dom/bom.js":
/*!************************!*\
  !*** ./lib/dom/bom.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bom = void 0;\nconst is_1 = __webpack_require__(/*! ../is/is */ \"./lib/is/is.js\");\n/**\n * Degu BOM (browser object model) function\n */\nclass bom {\n    /**\n     * Acts just like a regular window resize but fixes resize thrashing that\n     * happens on mobile during scrolling.\n     *\n     * The issue is that on mobile, there is that browser URL bar.  As the user\n     * scrolls, the url bar scrolls way with it, increasing the viewport\n     * height.  The window fires the resize event (since it is a different size).\n     *\n     * This causes a situation where, as the user scrolls through a page on\n     * mobile, resize events are unnecessarily called if you only care\n     * about the \"width\" changing.\n     *\n     * The method creates a listener on the window resize except it retains\n     * memory of the last browser width.  If the browser width hasn't\n     * changed, it will cull/cut off that event.\n     *\n     * ```ts\n     * let done = bom.smartResize(()=> {\n     *   console.log('window resize but called when user scrolls on mobile')\n     * }, { passive: true});\n     *\n     *\n     * // Call later to remove listener.\n     * done();\n     *\n     * ```\n     *\n     *\n     * This isn't applied on non-mobile browsers.\n     * @param {Function} callback\n     * @param {Object} options The resize options such as passive: true\n     * @return {Function} A function that which when called, will automatically\n     *     remove that attached listener from the window.\n     */\n    static smartResize(callback, options) {\n        let width = 0;\n        const handler = e => {\n            const currentWidth = window.innerWidth;\n            const allowCallback = !is_1.is.mobile() || width !== currentWidth;\n            if (allowCallback) {\n                callback(e);\n                width = currentWidth;\n            }\n        };\n        window.addEventListener('resize', handler, options);\n        return () => {\n            window.removeEventListener('resize', handler);\n        };\n    }\n    /**\n     * Checks the current browser and appends a css class name to the element.\n     *\n     * ```\n     * // Now this element would receive a class name of the current browser such\n     * // as 'safari', 'ios'\n     * bom.appendBrowserNameToElement(element);\n     * ```\n     * @param element\n     */\n    static appendBrowserNameToElement(element) {\n        const checks = {\n            ieOrEdge: is_1.is.ieOrEdge,\n            edge: is_1.is.edge,\n            ie: is_1.is.ie,\n            mobile: is_1.is.mobile,\n            safari: is_1.is.safari,\n            chrome: is_1.is.chrome,\n            chromeOs: is_1.is.chrome,\n            firefox: is_1.is.firefox,\n            ios: is_1.is.ios,\n            ipad: is_1.is.ipad,\n            android: is_1.is.android,\n        };\n        for (const key in checks) {\n            if (checks[key]()) {\n                element.classList.add(key);\n            }\n        }\n    }\n}\nexports.bom = bom;\n//# sourceMappingURL=bom.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL2JvbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9kb20vYm9tLmpzPzAyZDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJvbSA9IHZvaWQgMDtcbmNvbnN0IGlzXzEgPSByZXF1aXJlKFwiLi4vaXMvaXNcIik7XG4vKipcbiAqIERlZ3UgQk9NIChicm93c2VyIG9iamVjdCBtb2RlbCkgZnVuY3Rpb25cbiAqL1xuY2xhc3MgYm9tIHtcbiAgICAvKipcbiAgICAgKiBBY3RzIGp1c3QgbGlrZSBhIHJlZ3VsYXIgd2luZG93IHJlc2l6ZSBidXQgZml4ZXMgcmVzaXplIHRocmFzaGluZyB0aGF0XG4gICAgICogaGFwcGVucyBvbiBtb2JpbGUgZHVyaW5nIHNjcm9sbGluZy5cbiAgICAgKlxuICAgICAqIFRoZSBpc3N1ZSBpcyB0aGF0IG9uIG1vYmlsZSwgdGhlcmUgaXMgdGhhdCBicm93c2VyIFVSTCBiYXIuICBBcyB0aGUgdXNlclxuICAgICAqIHNjcm9sbHMsIHRoZSB1cmwgYmFyIHNjcm9sbHMgd2F5IHdpdGggaXQsIGluY3JlYXNpbmcgdGhlIHZpZXdwb3J0XG4gICAgICogaGVpZ2h0LiAgVGhlIHdpbmRvdyBmaXJlcyB0aGUgcmVzaXplIGV2ZW50IChzaW5jZSBpdCBpcyBhIGRpZmZlcmVudCBzaXplKS5cbiAgICAgKlxuICAgICAqIFRoaXMgY2F1c2VzIGEgc2l0dWF0aW9uIHdoZXJlLCBhcyB0aGUgdXNlciBzY3JvbGxzIHRocm91Z2ggYSBwYWdlIG9uXG4gICAgICogbW9iaWxlLCByZXNpemUgZXZlbnRzIGFyZSB1bm5lY2Vzc2FyaWx5IGNhbGxlZCBpZiB5b3Ugb25seSBjYXJlXG4gICAgICogYWJvdXQgdGhlIFwid2lkdGhcIiBjaGFuZ2luZy5cbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2QgY3JlYXRlcyBhIGxpc3RlbmVyIG9uIHRoZSB3aW5kb3cgcmVzaXplIGV4Y2VwdCBpdCByZXRhaW5zXG4gICAgICogbWVtb3J5IG9mIHRoZSBsYXN0IGJyb3dzZXIgd2lkdGguICBJZiB0aGUgYnJvd3NlciB3aWR0aCBoYXNuJ3RcbiAgICAgKiBjaGFuZ2VkLCBpdCB3aWxsIGN1bGwvY3V0IG9mZiB0aGF0IGV2ZW50LlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBsZXQgZG9uZSA9IGJvbS5zbWFydFJlc2l6ZSgoKT0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCd3aW5kb3cgcmVzaXplIGJ1dCBjYWxsZWQgd2hlbiB1c2VyIHNjcm9sbHMgb24gbW9iaWxlJylcbiAgICAgKiB9LCB7IHBhc3NpdmU6IHRydWV9KTtcbiAgICAgKlxuICAgICAqXG4gICAgICogLy8gQ2FsbCBsYXRlciB0byByZW1vdmUgbGlzdGVuZXIuXG4gICAgICogZG9uZSgpO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKlxuICAgICAqIFRoaXMgaXNuJ3QgYXBwbGllZCBvbiBub24tbW9iaWxlIGJyb3dzZXJzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIHJlc2l6ZSBvcHRpb25zIHN1Y2ggYXMgcGFzc2l2ZTogdHJ1ZVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgd2hpY2ggd2hlbiBjYWxsZWQsIHdpbGwgYXV0b21hdGljYWxseVxuICAgICAqICAgICByZW1vdmUgdGhhdCBhdHRhY2hlZCBsaXN0ZW5lciBmcm9tIHRoZSB3aW5kb3cuXG4gICAgICovXG4gICAgc3RhdGljIHNtYXJ0UmVzaXplKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgY29uc3QgYWxsb3dDYWxsYmFjayA9ICFpc18xLmlzLm1vYmlsZSgpIHx8IHdpZHRoICE9PSBjdXJyZW50V2lkdGg7XG4gICAgICAgICAgICBpZiAoYWxsb3dDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gY3VycmVudFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgY3VycmVudCBicm93c2VyIGFuZCBhcHBlbmRzIGEgY3NzIGNsYXNzIG5hbWUgdG8gdGhlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAvLyBOb3cgdGhpcyBlbGVtZW50IHdvdWxkIHJlY2VpdmUgYSBjbGFzcyBuYW1lIG9mIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VjaFxuICAgICAqIC8vIGFzICdzYWZhcmknLCAnaW9zJ1xuICAgICAqIGJvbS5hcHBlbmRCcm93c2VyTmFtZVRvRWxlbWVudChlbGVtZW50KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBlbmRCcm93c2VyTmFtZVRvRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGNoZWNrcyA9IHtcbiAgICAgICAgICAgIGllT3JFZGdlOiBpc18xLmlzLmllT3JFZGdlLFxuICAgICAgICAgICAgZWRnZTogaXNfMS5pcy5lZGdlLFxuICAgICAgICAgICAgaWU6IGlzXzEuaXMuaWUsXG4gICAgICAgICAgICBtb2JpbGU6IGlzXzEuaXMubW9iaWxlLFxuICAgICAgICAgICAgc2FmYXJpOiBpc18xLmlzLnNhZmFyaSxcbiAgICAgICAgICAgIGNocm9tZTogaXNfMS5pcy5jaHJvbWUsXG4gICAgICAgICAgICBjaHJvbWVPczogaXNfMS5pcy5jaHJvbWUsXG4gICAgICAgICAgICBmaXJlZm94OiBpc18xLmlzLmZpcmVmb3gsXG4gICAgICAgICAgICBpb3M6IGlzXzEuaXMuaW9zLFxuICAgICAgICAgICAgaXBhZDogaXNfMS5pcy5pcGFkLFxuICAgICAgICAgICAgYW5kcm9pZDogaXNfMS5pcy5hbmRyb2lkLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVja3Nba2V5XSgpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmJvbSA9IGJvbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvbS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/dom/bom.js\n");

/***/ }),

/***/ "./lib/dom/cached-mouse-tracker.js":
/*!*****************************************!*\
  !*** ./lib/dom/cached-mouse-tracker.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CachedMouseTracker = void 0;\nconst __1 = __webpack_require__(/*! .. */ \"./lib/index.js\");\nconst vector_1 = __webpack_require__(/*! ../mathf/vector */ \"./lib/mathf/vector.js\");\nconst CURSOR_MOVE_EVENTS = ['mousemove', 'touchstart', 'touchmove'];\n/**\n * Tracks the client mouse position per frame.\n *\n * This improves performance and ensures that all frame-synced animations are\n * always using the same position value by delaying mouse position updates until\n * the preRead step of the RAF loop.\n *\n * If needed could be extended to:\n * - Track the page position and screen position.\n * - Track whether or not the mouse is pressed.\n * - Track velocity and gestures.\n *\n * If any of these needs arise this can serve as a reference:\n * https://github.com/angusm/toolbox-v2/blob/130326ee6b26e652d4bf7442c65ffbfeccc31649/src/toolbox/utils/cached-vectors/cursor.ts\n */\nclass CachedMouseTracker {\n    constructor() {\n        if (CachedMouseTracker.uses.size === 0) {\n            CachedMouseTracker.raf = new __1.Raf();\n            CachedMouseTracker.clientPosition = vector_1.Vector.ZERO;\n            CachedMouseTracker.domWatcher = new __1.DomWatcher();\n            CURSOR_MOVE_EVENTS.forEach(cursorMoveEvent => {\n                CachedMouseTracker.domWatcher.add({\n                    element: window,\n                    on: cursorMoveEvent,\n                    eventOptions: { passive: true },\n                    callback: (e) => CachedMouseTracker.updatePosition(e),\n                });\n            });\n        }\n        CachedMouseTracker.uses.add(this);\n    }\n    /**\n     * Updates the currently tracked position from either a touch event or a mouse\n     * event.\n     * @param event\n     */\n    static updatePosition(event) {\n        if (event instanceof MouseEvent) {\n            this.updatePositionFromEvent(event);\n        }\n        else if (event instanceof TouchEvent) {\n            this.updatePositionFromTouchEvent(event);\n        }\n    }\n    /**\n     * Update the tracked position from the touch event.\n     * @param touchEvent\n     */\n    static updatePositionFromTouchEvent(touchEvent) {\n        if (touchEvent.touches.length > 0) {\n            this.updatePositionFromEvent(touchEvent.touches[0]);\n        }\n    }\n    /**\n     * Update the tracked position using event information.\n     * @param data\n     */\n    static updatePositionFromEvent(data) {\n        this.raf.preRead(() => {\n            this.clientPosition = new vector_1.Vector(data.clientX, data.clientY);\n        });\n    }\n    /**\n     * Return the current cached mouse position as determined by clientX and\n     * clientY values.\n     */\n    getClientPosition() {\n        return CachedMouseTracker.clientPosition;\n    }\n    /**\n     * Dispose of the currently in use tracker.\n     */\n    dispose() {\n        CachedMouseTracker.uses.delete(this);\n        if (CachedMouseTracker.uses.size === 0) {\n            CachedMouseTracker.domWatcher.dispose();\n            CachedMouseTracker.raf.dispose();\n            CachedMouseTracker.clientPosition = null;\n        }\n    }\n}\nexports.CachedMouseTracker = CachedMouseTracker;\n// Use static variables so that independent instances can operate as a\n// singleton but be disposed separately without the user needing to worry\n// about the singleton pattern.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nCachedMouseTracker.uses = new Set();\n//# sourceMappingURL=cached-mouse-tracker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL2NhY2hlZC1tb3VzZS10cmFja2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2RvbS9jYWNoZWQtbW91c2UtdHJhY2tlci5qcz9kZWYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYWNoZWRNb3VzZVRyYWNrZXIgPSB2b2lkIDA7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi5cIik7XG5jb25zdCB2ZWN0b3JfMSA9IHJlcXVpcmUoXCIuLi9tYXRoZi92ZWN0b3JcIik7XG5jb25zdCBDVVJTT1JfTU9WRV9FVkVOVFMgPSBbJ21vdXNlbW92ZScsICd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZSddO1xuLyoqXG4gKiBUcmFja3MgdGhlIGNsaWVudCBtb3VzZSBwb3NpdGlvbiBwZXIgZnJhbWUuXG4gKlxuICogVGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBhbmQgZW5zdXJlcyB0aGF0IGFsbCBmcmFtZS1zeW5jZWQgYW5pbWF0aW9ucyBhcmVcbiAqIGFsd2F5cyB1c2luZyB0aGUgc2FtZSBwb3NpdGlvbiB2YWx1ZSBieSBkZWxheWluZyBtb3VzZSBwb3NpdGlvbiB1cGRhdGVzIHVudGlsXG4gKiB0aGUgcHJlUmVhZCBzdGVwIG9mIHRoZSBSQUYgbG9vcC5cbiAqXG4gKiBJZiBuZWVkZWQgY291bGQgYmUgZXh0ZW5kZWQgdG86XG4gKiAtIFRyYWNrIHRoZSBwYWdlIHBvc2l0aW9uIGFuZCBzY3JlZW4gcG9zaXRpb24uXG4gKiAtIFRyYWNrIHdoZXRoZXIgb3Igbm90IHRoZSBtb3VzZSBpcyBwcmVzc2VkLlxuICogLSBUcmFjayB2ZWxvY2l0eSBhbmQgZ2VzdHVyZXMuXG4gKlxuICogSWYgYW55IG9mIHRoZXNlIG5lZWRzIGFyaXNlIHRoaXMgY2FuIHNlcnZlIGFzIGEgcmVmZXJlbmNlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VzbS90b29sYm94LXYyL2Jsb2IvMTMwMzI2ZWU2YjI2ZTY1MmQ0YmY3NDQyYzY1ZmZiZmVjY2MzMTY0OS9zcmMvdG9vbGJveC91dGlscy9jYWNoZWQtdmVjdG9ycy9jdXJzb3IudHNcbiAqL1xuY2xhc3MgQ2FjaGVkTW91c2VUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKENhY2hlZE1vdXNlVHJhY2tlci51c2VzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIENhY2hlZE1vdXNlVHJhY2tlci5yYWYgPSBuZXcgX18xLlJhZigpO1xuICAgICAgICAgICAgQ2FjaGVkTW91c2VUcmFja2VyLmNsaWVudFBvc2l0aW9uID0gdmVjdG9yXzEuVmVjdG9yLlpFUk87XG4gICAgICAgICAgICBDYWNoZWRNb3VzZVRyYWNrZXIuZG9tV2F0Y2hlciA9IG5ldyBfXzEuRG9tV2F0Y2hlcigpO1xuICAgICAgICAgICAgQ1VSU09SX01PVkVfRVZFTlRTLmZvckVhY2goY3Vyc29yTW92ZUV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBDYWNoZWRNb3VzZVRyYWNrZXIuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICAgICAgICAgICAgICAgIG9uOiBjdXJzb3JNb3ZlRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50T3B0aW9uczogeyBwYXNzaXZlOiB0cnVlIH0sXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAoZSkgPT4gQ2FjaGVkTW91c2VUcmFja2VyLnVwZGF0ZVBvc2l0aW9uKGUpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgQ2FjaGVkTW91c2VUcmFja2VyLnVzZXMuYWRkKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50bHkgdHJhY2tlZCBwb3NpdGlvbiBmcm9tIGVpdGhlciBhIHRvdWNoIGV2ZW50IG9yIGEgbW91c2VcbiAgICAgKiBldmVudC5cbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgdXBkYXRlUG9zaXRpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbkZyb21FdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uRnJvbVRvdWNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdHJhY2tlZCBwb3NpdGlvbiBmcm9tIHRoZSB0b3VjaCBldmVudC5cbiAgICAgKiBAcGFyYW0gdG91Y2hFdmVudFxuICAgICAqL1xuICAgIHN0YXRpYyB1cGRhdGVQb3NpdGlvbkZyb21Ub3VjaEV2ZW50KHRvdWNoRXZlbnQpIHtcbiAgICAgICAgaWYgKHRvdWNoRXZlbnQudG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uRnJvbUV2ZW50KHRvdWNoRXZlbnQudG91Y2hlc1swXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSB0cmFja2VkIHBvc2l0aW9uIHVzaW5nIGV2ZW50IGluZm9ybWF0aW9uLlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgc3RhdGljIHVwZGF0ZVBvc2l0aW9uRnJvbUV2ZW50KGRhdGEpIHtcbiAgICAgICAgdGhpcy5yYWYucHJlUmVhZCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudFBvc2l0aW9uID0gbmV3IHZlY3Rvcl8xLlZlY3RvcihkYXRhLmNsaWVudFgsIGRhdGEuY2xpZW50WSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgY2FjaGVkIG1vdXNlIHBvc2l0aW9uIGFzIGRldGVybWluZWQgYnkgY2xpZW50WCBhbmRcbiAgICAgKiBjbGllbnRZIHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXRDbGllbnRQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIENhY2hlZE1vdXNlVHJhY2tlci5jbGllbnRQb3NpdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgY3VycmVudGx5IGluIHVzZSB0cmFja2VyLlxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIENhY2hlZE1vdXNlVHJhY2tlci51c2VzLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgaWYgKENhY2hlZE1vdXNlVHJhY2tlci51c2VzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIENhY2hlZE1vdXNlVHJhY2tlci5kb21XYXRjaGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIENhY2hlZE1vdXNlVHJhY2tlci5yYWYuZGlzcG9zZSgpO1xuICAgICAgICAgICAgQ2FjaGVkTW91c2VUcmFja2VyLmNsaWVudFBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2FjaGVkTW91c2VUcmFja2VyID0gQ2FjaGVkTW91c2VUcmFja2VyO1xuLy8gVXNlIHN0YXRpYyB2YXJpYWJsZXMgc28gdGhhdCBpbmRlcGVuZGVudCBpbnN0YW5jZXMgY2FuIG9wZXJhdGUgYXMgYVxuLy8gc2luZ2xldG9uIGJ1dCBiZSBkaXNwb3NlZCBzZXBhcmF0ZWx5IHdpdGhvdXQgdGhlIHVzZXIgbmVlZGluZyB0byB3b3JyeVxuLy8gYWJvdXQgdGhlIHNpbmdsZXRvbiBwYXR0ZXJuLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbkNhY2hlZE1vdXNlVHJhY2tlci51c2VzID0gbmV3IFNldCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FjaGVkLW1vdXNlLXRyYWNrZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/dom/cached-mouse-tracker.js\n");

/***/ }),

/***/ "./lib/dom/canvas-image-sequence.js":
/*!******************************************!*\
  !*** ./lib/dom/canvas-image-sequence.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CanvasImageSequence = exports.canvasImageSequenceErrors = void 0;\nconst dom_1 = __webpack_require__(/*! ../dom/dom */ \"./lib/dom/dom.js\");\nconst is_1 = __webpack_require__(/*! ../is/is */ \"./lib/is/is.js\");\nconst func_1 = __webpack_require__(/*! ../func/func */ \"./lib/func/func.js\");\nconst defer_1 = __webpack_require__(/*! ../func/defer */ \"./lib/func/defer.js\");\nconst blob_loader_1 = __webpack_require__(/*! ../loader/blob-loader */ \"./lib/loader/blob-loader.js\");\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst dom_watcher_1 = __webpack_require__(/*! ../dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\nconst multi_interpolate_1 = __webpack_require__(/*! ../interpolate/multi-interpolate */ \"./lib/interpolate/multi-interpolate.js\");\nconst raf_timer_1 = __webpack_require__(/*! ../raf/raf-timer */ \"./lib/raf/raf-timer.js\");\nconst fps_1 = __webpack_require__(/*! ../time/fps */ \"./lib/time/fps.js\");\nconst dom_canvas_1 = __webpack_require__(/*! ../dom/dom-canvas */ \"./lib/dom/dom-canvas.js\");\nexports.canvasImageSequenceErrors = {\n    NO_ELEMENT: 'An element is required for canvas image sequence',\n    NO_IMAGE_SETS: 'Image sets are required for canvas image sequence',\n    NO_IMAGES: 'There are no images defined in your canvas image sequence image set',\n};\n/**\n * A class that allows you to play through an image sequence (sprite) based on\n * progress.\n *\n *\n * Usage:\n *\n * HTML / SASS\n * ```\n * <div class=\"my-element\"></div>\n *\n *\n * .my-element\n *   width: 100vw\n *   height: 100vh\n * ```\n *\n * Then in your JS:\n *\n * ```ts\n *\n * // All images are assumed to be the same dimensions.\n * let myImages = [\n *   'image-1.jpg',\n *   'image-2.jpg',\n *   'image-3.jpg',\n *   'image-4.jpg',\n *    ...\n *   'image-100.jpg',\n * ]\n *\n * let canvasImageSequence = new CanvasImageSequence(\n *   document.querySelector('.my-element'),\n *   // Pass in your imageSet.  You can specific multiple (see below).\n *   [{images: myImages}],\n *    // Optional sizing.\n *   {\n *      cover: false, // Use cover mode.  Defaults to false.\n *      bottom: 0 // Align to the bottom.\n *      left: 0.2 // Align to the left\n *      leftNoClip: true // When aligning to left, use the no clip algo.\n *   },\n *   is.ipad() : 1 : undefined // Force dpr 1 on ipad that has less memory.\n * );\n *\n * // Loads the images.\n * canvasImageSequence.load();\n *\n * // At a later time.  If images aren't loaded yet, render will get ignored.\n *  canvasImageSequence.renderByProgress(0);  // Renders frame at progress 0.\n *  canvasImageSequence.renderByProgress(0.5);  // Renders frame at progress 0.5\n *  canvasImageSequence.renderByProgress(1);  // Renders frame at progress 1\n *\n * // When done.\n * canvasImageSequence.dispose();\n *\n * ```\n * The above would add a canvas to myElement.  The image that gets rendered\n * in the canvas, will be fitted would an algo similar to background:contain\n * so that the image is fully visible.  If the image different aspect ratio\n * than the contain, the image will be both vertically and horizontally centered\n * with contain (maximizing the scale without bleeding out).\n *\n *\n * You can also listen load completion.  Typically, loading frames takes a\n * while so you may want to add a loading indicator and on load completion,\n * render teh canvasImageSequence to the current frame.\n * ```ts\n *\n * // Use image load promise to ensure images are ready.\n * canvasImageSequence.load().then(()=> {\n *    // On load complete render the frame that maps to the current progress.\n *    canvasImageSequence.renderByProgress(myCurrentProgress);\n * })\n *\n *\n * ```\n *\n *\n *\n * ### Sizing options.\n * CanvasImageSequence has two render modes, contain (default) and cover.\n * Contain will by default vertically center your image but you can offset this\n * by providing a bottom value.\n *\n *\n * ```ts\n * let canvasImageSequence = new CanvasImageSequence(\n *   document.querySelector('.my-element'),\n *   [{images: myImages}],\n *   {\n *     cover: true\n *   }\n * );\n *\n * ```\n *\n *\n * ## MultiInterpolate capabilities.\n * Canvas Image Sequence has multiinterpolation built in to make it easier to\n * manage more complex sequences.\n * Normally, you may want to map an image sequence to just play from start to\n * end.  But what if you wanted more flexiblity?  You can do things like:\n *\n *\n * ```ts\n *\n * let progressPoints = [\n *       {\n *         from: 0, to: 0.5, start: 0, end: 1,\n *       },\n *       {\n *         from: 0.5, to: 1, start: 1, end: 0,\n *       },\n * ];\n * canvasImageSequence.setMultiInterpolation(progressPoints);\n * canvasImageSequence.load();\n *\n * ```\n * In the above, now the image sequence will play from start to end and back to\n * the start.  You can define your own progress points to have full control over\n * how you want your image sequence sprite to play out.\n *\n *\n * ## Playback capability\n * You can also play your canvas image sequence with a timer.\n * The playback also provides a completion promise.\n *\n * ```ts\n * // Create a complicated playback.\n * let progressPoints = [\n *       {\n *         from: 0, to: 0.5, start: 0, end: 1,\n *       },\n *       {\n *         from: 0.5, to: 1, start: 1, end: 0,\n *       },\n * ];\n * canvasImageSequence.setMultiInterpolation(progressPoints);\n * // Now load the images.\n * canvasImageSequence.load().then(()=> {\n *    // Now play the image sequence from progress 0 - 1 over a span of 3000 ms.\n *    canvasImageSequence.play(0, 1, 3000).then(()=> {\n *       console.log('done');\n *    })\n * })\n *\n *\n * // Use stop if you need to stop the aniamtion.\n * canvasImageSequence.stop();\n *\n * ```\n *\n * ### Lerp Towards Capability\n * By setting a lerp value, canvasImageSequence will automatically \"lerp\" towards\n * frames if the delta between the currently rendered frame and the requested\n * progress is large.\n * * This is useful to \"smooth\" out movement between frames.\n *\n *\n * To use this feature, simply set the lerp value.\n *\n * As an exmaple we initially set the progress to 0 but immediately, change it to 1.\n * You will see that the progress value will lerp.   Internally, this happens\n * by running raf until the frame value delta is less than 1 and stable.\n *\n * ```ts\n *  canvasImageSequence.lerpAmount = 0.12;\n *  canvasImageSequence.renderByProgress(0);\n *  canvasImageSequence.renderByProgress(1);\n * ```\n *\n *\n * Another usecase for setting lerp is to handle resolving state after playing\n * a sequence. See canvas-image-sequence4 for more on this.\n *\n *\n *\n * ### Clipping Feature\n * Similar to css clip-path, you can pass clip-path-ish shapes to canvasImageSequence\n * which will then be applied when the canvas paints / renders.\n *\n * The clipping currently supports, inset type only.\n *\n * ```ts\n *\n * canvasImageSequence.setClipInterpolations({\n *   type: 'inset',\n *   interpolations: [\n *     {\n *       progress: [{ from: 0, to: 1, start: 0, end: 0.5}],\n *       id: 'top'\n *     },\n *     {\n *       progress: [{ from: 0, to: 1, start: 0, end: 0.5}],\n *       id: 'right'\n *     },\n *     {\n *       progress: [{ from: 0, to: 1, start: 0, end: 0.5}],\n *       id: 'bottom'\n *     },\n *     {\n *       progress: [{ from: 0, to: 1, start: 0, end: 0.5}],\n *       id: 'left'\n *     },\n *     {\n *       progress: [{ from: 0, to: 1, start: 0, end: 0.5}],\n *       id: 'border-radius'\n *     }\n *   ]\n * })\n *\n *\n * canvasImageSequence.renderByProgress(0.5); // The clipping at 0.5 progress is rendered.\n *\n * ```\n *\n *\n * ## Selectively loading different sets of images.\n *\n * You can pass different sets of images to use.   Use the when condition\n * to modify your set.   Note that the when condition is only evaluated\n * upon resize.  If a new image set is matched, loading of that image\n * set will automatically happen in the background and render when complete.\n *\n * ```ts\n *\n * let myImages = [\n *   'image-1.jpg',\n *    ...\n *   'image-100.jpg',\n * ];\n *\n * let myMobileImages = [\n *   'image-mobile-1.jpg',\n *   'image-mobile-100.jpg',\n * ];\n *  let canvasImageSequence = new CanvasImageSequence(\n *   document.querySelector('.my-element'),\n *   [{\n *     when: ()=> { return window.innerWidth >= 768},\n *     images: myImages\n *   },\n *   {\n *     when: ()=> { return window.innerWidth < 768},\n *     images: myMobileImages\n *   }]\n * );\n *\n * ```\n *\n * Can I have imageSets for only desktop or mobile?  Yes you can!\n *\n * ```ts\n *  let canvasImageSequence = new CanvasImageSequence(\n *   document.querySelector('.my-element'),\n *   [\n *   {\n *     when: ()=> { return window.innerWidth < 768},\n *     images: myMobileImages\n *   }]\n * );\n *\n * ```\n * Here we specify canvasImageSequence with an imageSet for only mobile.  This\n * means the images will only load on mobile and canvasImageSequence won't\n * do anything on desktop (nothing will show since there are no images).\n *\n *\n *\n * ############# Dev Notes ####################\n *\n * # Memory management (dev notes)\n * When working on this class, you have to be very careful about memory management\n * since we are dealing with a lot of images.\n *\n * There is native memory and image cache that need to be particularly looked at.\n * You can go to Chrome -> Task manager and monitor the usage.\n * Make sure to enable the memory footprint and image cache columns.\n *\n * For Safari, the best place is to open Activity Monitor. Open safari and\n * open the site.  Within Activity Monitor, look for your process (it will be the\n * name of the page).  Double click on it to get real memory usage.  You can\n * also use the Safari WebTools memory and CPU profile.\n *\n *\n * 1) image.decode() and ImageBitmaps\n * If you run image.decode() or load ImageBitmaps, this data appears to get stored\n * over in native memory.  canvas.drawImage stores in image cache which is\n * separate.\n *\n * The issue is the when you run image.decode() or use ImageBitmaps, the native\n * memory space they occupy, won't get flushed.  It seems to get flushed only\n * when the canvas or document is unloaded.\n *\n * For example:\n *\n * ```\n * const image = new Image();\n * image.src = 'hohoho.jpg';\n * image.decode(()=> { // This pushes it to native memory.\n *   image = null; // This won't get removed even with GC.\n * })\n * ```\n *\n * This removes the reference to the image but even with GC won't flush the native\n * memory.\n *\n * It's best to avoid this and instead just load images normally OR\n * use ObjectUrl to make a local blob.\n *\n *\n * 2) Problem 2\n * canvas.drawImage(image) memory issues and also Safari DataURI (base64)\n *\n * canvas.drawImage, essentially copies the decoded image data over to the image cache.\n * Therefore, even doing:\n *\n * ```\n * canvas.drawImage(image);  // decoded copy stored to image cache.\n * canvas.drawImage(image);  // decoded copy stored to image cache\n * canvas.drawImage(image);  // decoded copy stored to image cache.\n * ```\n * Quickly results in the imageCache growing.  While this is usually fine since\n * the image cache gets cleared pretty quickly, with a class like this, if you have\n * 100 images, that cache with that data decoded ends up being very large.\n *\n * To avoid this, you need to delete the image from reference.\n *\n * ```\n * canvas.drawImage(image);  // decoded copy stored to image cache.\n * image.src = null; // reference removed.  image cache gets cleared.\n * image = null;\n * ```\n *\n * This essentially means, that if we don't want the image cache to grow, we\n * need to delete the image that was just drawn after the draw call.\n *\n *\n * 3) Problem 3\n * Safari Canvas Issues:\n * Note that Safari also has some issues with memory management.\n * In general, Safari doesn't do a great job offloading base64 images from cache.\n *\n * The best way to manage is:\n * 1) don't use base64Images and draw to canvas (since Safari doesn't release memory)\n * 2) delete image data to offload memory after drawImage calls.\n *\n *\n * Overall best practice:\n * The solution take to avoid these problems are:\n * - don't use image.decode()\n * - don't use ImageBitmaps\n * - don't use base64uri image Safari can't offload them.\n * - always remove the image after using drawImage().  Best way to do this is\n *   to use a temporary image and assign it a local objectURI.\n * - when you resize a canvas it clears it out.  You need to resize with smartResize\n *   to avoid flashes on ios mobile where the document height changes as you resize\n *   firing resize events.\n *\n *\n * Approach to solving the above:\n * 1) Make XHR calls to all image urls and save the blobs in memory (blobCache).\n * 2) Create a single cacheImage (Image) that will temporarily hold data while it gets\n *    drawn to canvas (cacheImage)\n * 3) On each draw call, use ObjectURIs to locally generate a temporary blob image.\n *    Set that to the cacheImage then canvas.drawImage(cacheImage) and following that\n *    then revoke the ObjectURI (to release it from memory).\n *\n * This can be roughly illustrated as:\n * ```ts\n *\n * this.blobCache = xxx.getBlobsDataFromServer();\n *\n * // Create an image that will temporarily hold data.\n * this.cacheImage = new Image();\n *\n * draw(source) {\n *\n *   img.onload = () => {\n *     this.drawImage(this.cacheImage);\n *     // Remove it from memory.\n *     URL.revokeObjectURL(image.src);\n *   }\n *\n *    // Create a local objectURI and apply it as the image source.\n *    this.cacheImage.src = URL.createObjectURL(this.blobCache[source]);\n * }\n *\n * dispose() {\n *   // Delete all blobs help in memory.\n *   this.blobCache = null;\n * }\n *\n * ```\n *\n * With the solution above, generally, the encoded size of all images are stored\n * in native memory + one decoded image in memory cache at any given time.  If you\n * are working with pngs, this can still mean a huge memory hoge so watch out.\n *\n *\n * 4) FPS - ipad CPU\n * Since we need to decode per drawFrame, this has a higher CPU cost.\n *\n * To lower the CPU usage, internally we manage an fps rate limiter.\n * This is set to 30, which is the maximum we really need to get a smooth\n * perceived animation.\n *\n * 5) Even with the optimizations above, VRAM (GPU memory) can can be relatively\n *    high. If you just need basic features, consider webgl-image-canvas\n *    as an alternative which is more performant.\n *\n *\n *\n *\n *\n * @see https://github.com/blinkkcode/degu/blob/master/examples/canvas-image-sequence.js\n * @see https://github.com/blinkkcode/degu/blob/master/examples/canvas-image-sequence2.js\n * @see https://github.com/blinkkcode/degu/blob/master/examples/canvas-image-sequence3.js\n * @see https://github.com/blinkkcode/degu/blob/master/examples/canvas-image-sequence4.js\n * @see https://github.com/blinkkcode/degu/blob/master/examples/canvas-image-sequence5.js\n * @unstable\n */\nclass CanvasImageSequence {\n    constructor(element, imageSets, options, dpr) {\n        /**\n         * The lerp amount when there is a delta between target and current frame\n         * greater than 1.  This defaults to 1 (meaning no lerp).  Change this value\n         * if you want canvasImageSequennce to smoothly interpolate between large\n         * deltas between the target and current frames.\n         */\n        this.lerpAmount = 1;\n        this.element = element;\n        if (!element) {\n            throw new Error(exports.canvasImageSequenceErrors.NO_ELEMENT);\n        }\n        if (!imageSets) {\n            throw new Error(exports.canvasImageSequenceErrors.NO_IMAGE_SETS);\n        }\n        this.imageSets = imageSets;\n        this.activeImageSet = null;\n        this.blobCache = {};\n        this.options = options;\n        this.isPlaying = false;\n        // this.useBitmapImageIfPossible = false;\n        // Create canvas.\n        this.canvasElement = document.createElement('canvas');\n        // Add aria label if available.\n        if (this.options && this.options.ariaLabel) {\n            this.canvasElement.setAttribute('aria-label', this.options.ariaLabel);\n            this.canvasElement.setAttribute('role', 'img');\n        }\n        else {\n            this.canvasElement.setAttribute('aria-hidden', 'true');\n        }\n        this.context = this.canvasElement.getContext('2d');\n        this.dpr = func_1.func.setDefault(dpr, window.devicePixelRatio || 1);\n        this.canvasWidth = 0;\n        this.canvasHeight = 0;\n        this.imageNaturalHeight = 0;\n        this.imageNaturalWidth = 0;\n        this.currentFrame = 0;\n        this.lastDrawSource = null;\n        this.targetFrame = 0;\n        this.containScale = null;\n        this.disposed = false;\n        // Set FPS to 30 for Safari to limit computation.  Safari takes a lot\n        // more time to decode images so this prevents high CPU usage crashes\n        // in Safari.\n        this.fps = new fps_1.Fps(is_1.is.safari() ? 30 : 60);\n        this.cacheImage = new Image();\n        this.rafTimer = null;\n        this.multiInterpolate = null;\n        this.clipMultiInterpolate = null;\n        this.clipPathType = null;\n        this.blobLoader = null;\n        this.progress = null;\n        this.playDefer = null;\n        this.domWatcher = new dom_watcher_1.DomWatcher();\n        this.domWatcher.add({\n            element: window,\n            // Ensure we use smart resize here because resizing canvas will make\n            // it flash (due to clearing the canvas).\n            on: 'smartResize',\n            callback: () => {\n                this.resize();\n                this.flush(); // Make a empty call to clear the memoize cache.\n                // Rerender the last known image.\n                this.lastDrawSource = null;\n                this.fps.lock(false);\n                this.lastRenderSource && this.draw(this.lastRenderSource);\n                this.fps.lock(true);\n            },\n            id: 'resize',\n            eventOptions: { passive: true },\n        });\n        this.resize();\n        this.domWatcher.run('resize');\n        // Another resize watcher dedicated to checking to checking if a new\n        // image set should be loaded.\n        this.domWatcher.add({\n            element: window,\n            on: 'smartResize',\n            callback: () => {\n                // Evaluate if we need to load a different image set.\n                const newSet = this.getSourceThatShouldLoad(this.imageSets);\n                if (newSet !== this.activeImageSet) {\n                    this.loadNewSet(this.imageSets);\n                    // Autoload the content.\n                    this.load().then(() => {\n                        // Set last frame to null to allow redrawing.\n                        this.lastDrawSource = null;\n                        this.fps.lock(false);\n                        this.renderByProgress(this.progress || 0);\n                        this.fps.lock(true);\n                    });\n                }\n            },\n            id: 'image-set-resize',\n            eventOptions: { passive: true },\n        });\n        this.element.appendChild(this.canvasElement);\n        this.readyPromise = new defer_1.Defer();\n        this.loadNewSet(imageSets);\n        // The previously rendered image source.\n        this.lastRenderSource = null;\n        this.lastDrawSource = null;\n        // Cull unncessary update\n        this.draw = func_1.func.runOnceOnChange(this.draw.bind(this));\n    }\n    /**\n     * Sets an optional multiinterpolations.  This allows you to define\n     * more complex play sequences on your image sequence.\n     *\n     * Here is an example of playing the image sequence from start to end\n     * and back to end.\n     *\n     * ```ts\n     * let progressPoints = [\n     *       {\n     *         from: 0, to: 0.5, start: 0, end: 1,\n     *       },\n     *       {\n     *         from: 0.5, to: 1, start: 1, end: 0,\n     *       },\n     * ];\n     * canvasImageSequence.setMultiInterpolation(progressPoints);\n     *\n     * ```\n     */\n    setMultiInterpolation(interpolations) {\n        this.multiInterpolate = new multi_interpolate_1.MultiInterpolate({\n            interpolations: [\n                {\n                    id: 'sequence',\n                    progress: interpolations,\n                },\n            ],\n        });\n    }\n    resize() {\n        this.canvasWidth = this.element.offsetWidth;\n        this.canvasHeight = this.element.offsetHeight;\n        // Set canvas to high dpr, the actual width to the size.\n        // @see https://gist.github.com/callumlocke/cc258a193839691f60dd\n        // for inspiration.\n        this.canvasElement.width = this.element.offsetWidth * this.dpr;\n        this.canvasElement.height = this.element.offsetHeight * this.dpr;\n        this.canvasElement.style.width = this.canvasWidth + 'px';\n        this.canvasElement.style.height = this.canvasHeight + 'px';\n        // Scale up the canvas to compensate DPR.\n        this.context.scale(this.dpr, this.dpr);\n    }\n    /**\n     * Starts loading the images.\n     */\n    load() {\n        // If there is no matching imageSet there is nothing to load.\n        if (!this.blobLoader || !this.activeImageSet) {\n            // Defer resolution.\n            window.setTimeout(() => {\n                this.readyPromise.resolve();\n            });\n            return this.readyPromise.getPromise();\n        }\n        const loadAllBlobs = () => {\n            this.blobLoader.load().then(results => {\n                this.blobCache = results;\n                this.setImageDimensions().then(() => {\n                    this.blobLoader.dispose();\n                    this.readyPromise.resolve(results);\n                });\n            });\n        };\n        loadAllBlobs();\n        return this.readyPromise.getPromise();\n    }\n    /**\n     * Allows you to set new imageSets.\n     *\n     * @param imageSource\n     */\n    loadNewSet(imageSets) {\n        // Release memory of current set.\n        this.blobLoader && this.blobLoader.dispose();\n        // Save the image sources.\n        this.imageSets = imageSets;\n        this.activeImageSet = this.getSourceThatShouldLoad(this.imageSets);\n        if (this.activeImageSet && !is_1.is.array(this.activeImageSet.images)) {\n            throw new Error(exports.canvasImageSequenceErrors.NO_IMAGES);\n        }\n        // Set the active image set if one is available.\n        if (this.activeImageSet) {\n            this.blobLoader = new blob_loader_1.BlobLoader(this.activeImageSet.images);\n        }\n        else {\n            this.blobLoader = null;\n        }\n        this.blobCache = {};\n        this.flush();\n        this.lastRenderSource = null;\n        // Reset the readyPromise.\n        this.readyPromise = new defer_1.Defer();\n    }\n    /**\n     * Given a list of CanvasImageSequenceImageSets evaluates which set should\n     * be used to load into the canvas.  The criteria is that any\n     * imageSet without when is used or if when condition is specified the\n     * when condition is evaluated and if true, it is used.  If multiple imageSets\n     * are found, the the first one is used.\n     */\n    getSourceThatShouldLoad(sources) {\n        const matchingSouces = [];\n        sources.forEach(source => {\n            if (!source.when) {\n                matchingSouces.push(source);\n            }\n            else {\n                source.when() && matchingSouces.push(source);\n            }\n        });\n        return matchingSouces[0];\n    }\n    /**\n     * Makes a deletable image clone.\n     */\n    makeImage(source) {\n        return new Promise(resolve => {\n            if (!source || !this.blobCache[source]) {\n                resolve(null);\n                return;\n            }\n            // Remove the objectURL Blob from locale cache.\n            URL.revokeObjectURL(this.cacheImage.src);\n            this.cacheImage.onload = () => {\n                resolve(this.cacheImage);\n            };\n            // Create a new temporary ObjectURl to store.\n            this.cacheImage.src = URL.createObjectURL(this.blobCache[source]);\n        });\n    }\n    /**\n     * Sets the images dimensions used internally based on the first image.\n     * Assumes all images are uniform size.\n     */\n    setImageDimensions() {\n        return new Promise(resolve => {\n            const source = this.activeImageSet.images[0];\n            const blob = this.blobCache[source];\n            // Generate an image from teh first blob.\n            dom_1.dom.makeImageFromBlob(blob).then((image) => {\n                const bitMapsLoaded = !image.naturalWidth;\n                this.imageNaturalHeight = bitMapsLoaded\n                    ? image.height\n                    : image.naturalHeight;\n                this.imageNaturalWidth = bitMapsLoaded\n                    ? image.width\n                    : image.naturalWidth;\n                // Release it from memory.\n                dom_1.dom.deleteImage(image);\n                image = null;\n                resolve();\n            });\n        });\n    }\n    /**\n     * Gets internally used current image seet.\n     */\n    getActiveImages() {\n        return this.activeImageSet.images;\n    }\n    /**\n     * Sets an clip path type interpolation on the canvas drawing.\n     * Currently only supports inset type.\n     *\n     * ```ts\n     *\n     * canvasImageSequence.setClipInterpolations({\n     *   type: 'inset',\n     *   interpolations: [\n     *     {\n     *       progress: [{ from: 0, to: 1, start: 0, end: 0.5}],\n     *       id: 'top'\n     *     },\n     *     {\n     *       progress: [{ from: 0, to: 1, start: 0, end: 0.5}],\n     *       id: 'right'\n     *     },\n     *     {\n     *       progress: [{ from: 0, to: 1, start: 0, end: 0.5}],\n     *       id: 'bottom'\n     *     },\n     *     {\n     *       progress: [{ from: 0, to: 1, start: 0, end: 0.5}],\n     *       id: 'left'\n     *     },\n     *     {\n     *       progress: [{ from: 0, to: 1, start: 0, end: 0.5}],\n     *       id: 'border-radius'\n     *     }\n     *   ]\n     * })\n     *\n     *\n     * canvasImageSequence.renderByProgress(0.5); // The clipping at 0.5 progress is rendered.\n     *\n     * ```\n     *\n     */\n    setClipInterpolations(config) {\n        this.clipPathType = config.type;\n        this.clipMultiInterpolate = new multi_interpolate_1.MultiInterpolate({\n            interpolations: config.interpolations,\n        });\n    }\n    /**\n     * Renders by progress.  0 would mean the very first frame and the 1 would\n     * mean the last.\n     * @param {number} n A progress value between 0 and 1.\n     * @param {noMultiInterpolate} An option to force evaluation without\n     *   multiInterpolation.  This is useful in cases where you have\n     *   multiInterpolation enabled but you want to manually update the\n     *   position of the frame without it using multiInterpolation.  Simply,\n     *   being able to say, I want to render the image sequnce at 0.9 for example.\n     */\n    renderByProgress(n, noMultiInterpolate = false) {\n        this.progress = mathf_1.mathf.clamp01(n);\n        !this.isPlaying && this.renderProgress(n, noMultiInterpolate);\n    }\n    /**\n     * Internal render by progress value.\n     * @param {number} n A progress value between 0 and 1.\n     * @param {noMultiInterpolate} An option to force evaluation without\n     *   multiInterpolation.  This is useful in cases where you have\n     *   multiInterpolation enabled but you want to manually update the\n     *   position of the frame without it using multiInterpolation.  Simply,\n     *   being able to say, I want to render the image sequnce at 0.9 for example.\n     */\n    renderProgress(n, noMultiInterpolate = false) {\n        let progress = mathf_1.mathf.clamp01(n);\n        // If the optional multiinterpolate is set, then use multiInterpolate\n        // to figure out what the correct frame should be.\n        if (this.multiInterpolate && !noMultiInterpolate) {\n            const interpolateMap = this.multiInterpolate.calculate(progress);\n            progress = mathf_1.mathf.clamp01(interpolateMap['sequence']);\n        }\n        // Update clip path multli interpolate.\n        if (this.clipMultiInterpolate) {\n            this.clipMultiInterpolate.calculate(progress);\n        }\n        // Flush cache if progress is 0 or 1 to ensure final frame is always\n        // played.\n        if (progress >= 0.95 || progress <= 0.05) {\n            this.flush();\n        }\n        // Figure out the correct frame to render based on the number of\n        // frames in the sequence.\n        if (this.activeImageSet) {\n            const total = this.activeImageSet.images.length - 1;\n            const targetFrame = Math.ceil(mathf_1.mathf.lerp(0, total, progress));\n            this.renderFrame(targetFrame);\n        }\n    }\n    /**\n     * Renders a given frame on to the html element.\n     * @param i\n     */\n    renderFrame(i) {\n        // If images aren't loaded yet, skip drawing.\n        if (!this.readyPromise.complete) {\n            return;\n        }\n        this.targetFrame = i;\n        // If the delta between target and current frame is greater than\n        // 1 and there is a lerp value set, lerp towards the target frame.\n        // Otherwise, just set the currentFrame\n        // to the target for immediate updates.\n        // Note that by default, the lerp amount is set to 1 (meaning no lerp),\n        let diff = Math.abs(this.targetFrame - this.currentFrame);\n        if (diff > 1 && !this.isPlaying && this.lerpAmount < 1) {\n            this.currentFrame = mathf_1.mathf.lerp(this.currentFrame, this.targetFrame, this.lerpAmount);\n            // If there is a delta, keep updating with RAF until it gets resolved.\n            diff = Math.abs(this.targetFrame - this.currentFrame);\n            const precision = 0.001;\n            if (diff >= precision) {\n                window.requestAnimationFrame(() => {\n                    this.renderFrame(this.targetFrame);\n                });\n            }\n        }\n        else {\n            this.currentFrame = this.targetFrame;\n        }\n        const imageSource = this.activeImageSet.images[Math.round(this.currentFrame)];\n        this.draw(imageSource);\n    }\n    /**\n     * Flush the draw cache.\n     */\n    flush() {\n        this.draw(''); // Make a empty call to clear the memoize cache.\n        this.draw(null);\n    }\n    /**\n     * Draws a rectangle on the canvas.\n     */\n    drawRectangle(config) {\n        // let radiusPercent = config.radius;\n        // let height = config.top - config.bottom;\n        // let width = config.left - config.right;\n        // Calculate border radius as a percentage.\n        const radius = {\n            tl: config.radius,\n            tr: config.radius,\n            br: config.radius,\n            bl: config.radius,\n        };\n        this.context.beginPath();\n        this.context.moveTo(config.left + radius.tl, config.top);\n        this.context.lineTo(config.right - radius.tr, config.top);\n        this.context.quadraticCurveTo(config.right, config.top, config.right, config.top + radius.tr);\n        this.context.lineTo(config.right, config.bottom - radius.br);\n        this.context.quadraticCurveTo(config.right, config.bottom, config.right - radius.br, config.bottom);\n        this.context.lineTo(config.left + radius.bl, config.bottom);\n        this.context.quadraticCurveTo(config.left, config.bottom, config.left, config.bottom - radius.bl);\n        this.context.lineTo(config.left, config.top + radius.tl);\n        this.context.quadraticCurveTo(config.left, config.top, config.left + radius.tl, config.top);\n        this.context.closePath();\n        this.context.fill();\n    }\n    /**\n     * Applies clipping to the canvas prior to drawing.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Path2D\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clip\n     */\n    applyCanvasClipping() {\n        // Make a similar algo as inset done in css clip-path.\n        //\n        // clip-path: inset(var(--clip-top) var(--clip-right) var(--clip-bottom) var(--clip-left) round var(--clip-radius))\n        //\n        // Since it's an inset algo, 0% would mean it is fully show.\n        // - top: 50% would mean the top half is missing\n        // - bottom: 50% would mean the bottom half is missing\n        // - right: 50% would mean the right half is missing\n        // - left: 50% would mean the left half is missing\n        if (this.clipPathType === 'inset') {\n            const results = this.clipMultiInterpolate.getCalculations() || {};\n            const top = results['top'] || 0;\n            const bottom = results['bottom'] || 0;\n            const left = results['left'] || 0;\n            const right = results['right'] || 0;\n            const borderRadius = results['border-radius'] || 0;\n            this.drawRectangle({\n                top: this.canvasHeight - (1 - top) * this.canvasHeight,\n                left: this.canvasWidth - (1 - left) * this.canvasWidth,\n                right: (1 - right) * this.canvasWidth,\n                bottom: (1 - bottom) * this.canvasHeight,\n                radius: borderRadius,\n            });\n            this.context.clip();\n        }\n    }\n    clear() {\n        this.context.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n    }\n    async draw(imageSource) {\n        // Prevent invalid draws\n        if (!imageSource || this.disposed) {\n            return;\n        }\n        if (imageSource === this.lastDrawSource) {\n            return;\n        }\n        this.lastDrawSource = imageSource;\n        // If this was called at a rate exceeding the fps limit.\n        if (!this.fps.canRun()) {\n            this.fps.schedule(() => {\n                // Force a draw.  This ensures that even with FPS limiting,\n                // the very last draw call is always rendered.\n                this.lastDrawSource = null;\n                this.draw(imageSource);\n            });\n            return;\n        }\n        const image = await this.makeImage(imageSource);\n        // Decoding images in this way, we see a huge memory jump.  Avoid for now.\n        // await image.decode();\n        // If an image couldn't be generated for some reason.\n        if (!image) {\n            return;\n        }\n        const imageBox = {\n            width: this.imageNaturalWidth,\n            height: this.imageNaturalHeight,\n        };\n        const containerBox = {\n            width: this.canvasWidth,\n            height: this.canvasHeight,\n        };\n        this.clear();\n        if (!is_1.is.null(this.clipPathType)) {\n            this.context.save();\n            this.applyCanvasClipping();\n        }\n        // Background \"cover\" sizing.\n        // Defaults to center.\n        if (this.options && this.options.cover) {\n            const cover = mathf_1.mathf.calculateBackgroundCover(containerBox, imageBox);\n            if (this.options && is_1.is.number(this.options.left)) {\n                cover.xOffset =\n                    (containerBox.width - imageBox.width * cover.scalar) *\n                        -this.options.left;\n            }\n            if (this.options && is_1.is.number(this.options.right)) {\n                // Right align first.\n                cover.xOffset = -(containerBox.width - imageBox.width * cover.scalar);\n                cover.xOffset +=\n                    (containerBox.width - imageBox.width * cover.scalar) *\n                        this.options.right;\n            }\n            if (this.options && is_1.is.number(this.options.bottom)) {\n                // Set to bottom.\n                cover.yOffset = -(containerBox.height - imageBox.height * cover.scalar);\n                // Clipping Bottom algo.\n                // Add the percentage amount specified.\n                cover.yOffset +=\n                    (containerBox.height - imageBox.height * cover.scalar) *\n                        this.options.bottom;\n            }\n            if (this.options && is_1.is.number(this.options.top)) {\n                cover.yOffset =\n                    (containerBox.height - imageBox.height * cover.scalar) *\n                        -this.options.top;\n            }\n            this.context.drawImage(image, -cover.xOffset >> 0, -cover.yOffset >> 0, (imageBox.width * cover.scalar) >> 0, (imageBox.height * cover.scalar) >> 0);\n        }\n        else {\n            // Default to contain sizing algo.\n            this.containScale = mathf_1.mathf.calculateBackgroundContain(containerBox, imageBox);\n            // Default center algo.\n            let diffX = (containerBox.width - imageBox.width * this.containScale) / 2;\n            let diffY = (containerBox.height - imageBox.height * this.containScale) / 2;\n            // Sizing option logic.\n            if (this.options && is_1.is.number(this.options.bottom)) {\n                // Bottom align it.\n                diffY = containerBox.height - imageBox.height * this.containScale;\n                // Easy way to test this is to set bottom: 1 and\n                // bottomClipping: false which would top align the image.\n                if (this.options.bottomNoClip) {\n                    diffY -=\n                        (containerBox.height - imageBox.height * this.containScale) *\n                            this.options.bottom;\n                }\n                else {\n                    // Clipping Bottom algo.\n                    // Add the percentage amount specified.\n                    diffY -= containerBox.height * this.options.bottom;\n                }\n            }\n            if (this.options && is_1.is.number(this.options.right)) {\n                // Right align it.\n                diffX = containerBox.width - imageBox.width * this.containScale;\n                // Easy way to test this is to set right: 1 and\n                // rightClipping: false which would left align the image.\n                if (this.options.rightNoClip) {\n                    diffX -=\n                        (containerBox.width - imageBox.width * this.containScale) *\n                            this.options.right;\n                }\n                else {\n                    // Clipping right algo.\n                    // Add the percentage amount specified.\n                    diffX -= containerBox.width * this.options.right;\n                }\n            }\n            if (this.options && is_1.is.number(this.options.top)) {\n                // Top align it.\n                diffY = 0;\n                // Easy way to test this is to set top: 1 and\n                // topClipping: false which would bottom aligned the image.\n                if (this.options.topNoClip) {\n                    diffY =\n                        (containerBox.height - imageBox.height * this.containScale) *\n                            this.options.top;\n                }\n                else {\n                    // Clipping Top algo.\n                    // Add the percentage amount specified.\n                    diffY += this.options.top * containerBox.height;\n                }\n            }\n            if (this.options && is_1.is.number(this.options.left)) {\n                // Left align it.\n                diffX = 0;\n                // Easy way to test this is to set left: 1 and\n                // leftClipping: false which would right aligned the image.\n                if (this.options.leftNoClip) {\n                    diffX =\n                        (containerBox.width - imageBox.width * this.containScale) *\n                            this.options.left;\n                }\n                else {\n                    // Clipping left algo.\n                    // Add the percentage amount specified.\n                    diffX += this.options.left * containerBox.width;\n                }\n            }\n            this.context.drawImage(image, diffX >> 0, diffY >> 0, (imageBox.width * this.containScale) >> 0, (imageBox.height * this.containScale) >> 0);\n        }\n        if (!is_1.is.null(this.clipPathType)) {\n            this.context.restore();\n        }\n        this.lastRenderSource = imageSource;\n    }\n    /**\n     * Updates the internal sizing options.\n     * @param options\n     */\n    setSizingOptions(options) {\n        this.options = options;\n    }\n    /**\n     * Plays the canvas image sequence with a timer. Playing will \"hijack\" the\n     * progress events while playing.   For example:\n     *\n     * ```ts\n     *    canvasImageSequence.play(0, 1, 3000).then(() => {\n     *       console.log('play complete');\n     *   });\n     * ```\n     *\n     * Here we tell the canvasImageSequence to play from start to end over\n     * a 3000ms period.  During this 3000ms period, any calls other to\n     * calls \"renderByProgress\" will get ignored since they can conflict with\n     * the playback.\n     *\n     *\n     * @param from A number between 0 - 1\n     * @param to A number between 0 - 1\n     * @param duration The duration in ms.\n     * @return Promise A promise that completes when done.\n     */\n    play(from, to, duration) {\n        this.stop();\n        this.rafTimer = new raf_timer_1.RafTimer((progress) => {\n            const interpolatedProgress = mathf_1.mathf.interpolateRange(progress, 0, 1, from, to);\n            this.renderProgress(interpolatedProgress);\n        });\n        this.rafTimer.setDuration(duration);\n        this.playDefer = new defer_1.Defer();\n        this.rafTimer.onComplete(() => {\n            this.isPlaying = false;\n            this.playDefer.resolve();\n            this.rafTimer.dispose();\n        });\n        this.rafTimer.play();\n        this.isPlaying = true;\n        return this.playDefer.getPromise();\n    }\n    /**\n     * Gets the hex color at the given coordinates of the canvas as it is\n     * renders at the moment.\n     * @param coords\n     */\n    getHexColorAtPoint(coords) {\n        return dom_canvas_1.domCanvas.getColorAtPointAsHex(this.context, coords);\n    }\n    /**\n     * Immediately stops the canvas animation playing.\n     * (that happens with play method).\n     */\n    stop() {\n        this.rafTimer && this.rafTimer.pause();\n        this.rafTimer && this.rafTimer.dispose();\n        this.playDefer && this.playDefer.resolve();\n    }\n    /**\n     * Returns the image dimension that were fetched.  This is based\n     * on the \"first\" image in the sequence.\n     * The sizes will be null if called prior to loading images.\n     */\n    getImageSize() {\n        return {\n            width: this.imageNaturalWidth,\n            height: this.imageNaturalHeight,\n        };\n    }\n    dispose() {\n        this.disposed = true;\n        this.stop();\n        this.domWatcher.dispose();\n        this.rafTimer && this.rafTimer.dispose();\n        this.blobLoader && this.blobLoader.dispose();\n        this.element = null;\n        this.blobCache = null;\n        this.canvasElement = null;\n        dom_1.dom.deleteImage(this.cacheImage);\n        this.cacheImage = null;\n    }\n}\nexports.CanvasImageSequence = CanvasImageSequence;\n//# sourceMappingURL=canvas-image-sequence.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL2NhbnZhcy1pbWFnZS1zZXF1ZW5jZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9kb20vY2FudmFzLWltYWdlLXNlcXVlbmNlLmpzPzRlMDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhbnZhc0ltYWdlU2VxdWVuY2UgPSBleHBvcnRzLmNhbnZhc0ltYWdlU2VxdWVuY2VFcnJvcnMgPSB2b2lkIDA7XG5jb25zdCBkb21fMSA9IHJlcXVpcmUoXCIuLi9kb20vZG9tXCIpO1xuY29uc3QgaXNfMSA9IHJlcXVpcmUoXCIuLi9pcy9pc1wiKTtcbmNvbnN0IGZ1bmNfMSA9IHJlcXVpcmUoXCIuLi9mdW5jL2Z1bmNcIik7XG5jb25zdCBkZWZlcl8xID0gcmVxdWlyZShcIi4uL2Z1bmMvZGVmZXJcIik7XG5jb25zdCBibG9iX2xvYWRlcl8xID0gcmVxdWlyZShcIi4uL2xvYWRlci9ibG9iLWxvYWRlclwiKTtcbmNvbnN0IG1hdGhmXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvbWF0aGZcIik7XG5jb25zdCBkb21fd2F0Y2hlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb20td2F0Y2hlclwiKTtcbmNvbnN0IG11bHRpX2ludGVycG9sYXRlXzEgPSByZXF1aXJlKFwiLi4vaW50ZXJwb2xhdGUvbXVsdGktaW50ZXJwb2xhdGVcIik7XG5jb25zdCByYWZfdGltZXJfMSA9IHJlcXVpcmUoXCIuLi9yYWYvcmFmLXRpbWVyXCIpO1xuY29uc3QgZnBzXzEgPSByZXF1aXJlKFwiLi4vdGltZS9mcHNcIik7XG5jb25zdCBkb21fY2FudmFzXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbS1jYW52YXNcIik7XG5leHBvcnRzLmNhbnZhc0ltYWdlU2VxdWVuY2VFcnJvcnMgPSB7XG4gICAgTk9fRUxFTUVOVDogJ0FuIGVsZW1lbnQgaXMgcmVxdWlyZWQgZm9yIGNhbnZhcyBpbWFnZSBzZXF1ZW5jZScsXG4gICAgTk9fSU1BR0VfU0VUUzogJ0ltYWdlIHNldHMgYXJlIHJlcXVpcmVkIGZvciBjYW52YXMgaW1hZ2Ugc2VxdWVuY2UnLFxuICAgIE5PX0lNQUdFUzogJ1RoZXJlIGFyZSBubyBpbWFnZXMgZGVmaW5lZCBpbiB5b3VyIGNhbnZhcyBpbWFnZSBzZXF1ZW5jZSBpbWFnZSBzZXQnLFxufTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGFsbG93cyB5b3UgdG8gcGxheSB0aHJvdWdoIGFuIGltYWdlIHNlcXVlbmNlIChzcHJpdGUpIGJhc2VkIG9uXG4gKiBwcm9ncmVzcy5cbiAqXG4gKlxuICogVXNhZ2U6XG4gKlxuICogSFRNTCAvIFNBU1NcbiAqIGBgYFxuICogPGRpdiBjbGFzcz1cIm15LWVsZW1lbnRcIj48L2Rpdj5cbiAqXG4gKlxuICogLm15LWVsZW1lbnRcbiAqICAgd2lkdGg6IDEwMHZ3XG4gKiAgIGhlaWdodDogMTAwdmhcbiAqIGBgYFxuICpcbiAqIFRoZW4gaW4geW91ciBKUzpcbiAqXG4gKiBgYGB0c1xuICpcbiAqIC8vIEFsbCBpbWFnZXMgYXJlIGFzc3VtZWQgdG8gYmUgdGhlIHNhbWUgZGltZW5zaW9ucy5cbiAqIGxldCBteUltYWdlcyA9IFtcbiAqICAgJ2ltYWdlLTEuanBnJyxcbiAqICAgJ2ltYWdlLTIuanBnJyxcbiAqICAgJ2ltYWdlLTMuanBnJyxcbiAqICAgJ2ltYWdlLTQuanBnJyxcbiAqICAgIC4uLlxuICogICAnaW1hZ2UtMTAwLmpwZycsXG4gKiBdXG4gKlxuICogbGV0IGNhbnZhc0ltYWdlU2VxdWVuY2UgPSBuZXcgQ2FudmFzSW1hZ2VTZXF1ZW5jZShcbiAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm15LWVsZW1lbnQnKSxcbiAqICAgLy8gUGFzcyBpbiB5b3VyIGltYWdlU2V0LiAgWW91IGNhbiBzcGVjaWZpYyBtdWx0aXBsZSAoc2VlIGJlbG93KS5cbiAqICAgW3tpbWFnZXM6IG15SW1hZ2VzfV0sXG4gKiAgICAvLyBPcHRpb25hbCBzaXppbmcuXG4gKiAgIHtcbiAqICAgICAgY292ZXI6IGZhbHNlLCAvLyBVc2UgY292ZXIgbW9kZS4gIERlZmF1bHRzIHRvIGZhbHNlLlxuICogICAgICBib3R0b206IDAgLy8gQWxpZ24gdG8gdGhlIGJvdHRvbS5cbiAqICAgICAgbGVmdDogMC4yIC8vIEFsaWduIHRvIHRoZSBsZWZ0XG4gKiAgICAgIGxlZnROb0NsaXA6IHRydWUgLy8gV2hlbiBhbGlnbmluZyB0byBsZWZ0LCB1c2UgdGhlIG5vIGNsaXAgYWxnby5cbiAqICAgfSxcbiAqICAgaXMuaXBhZCgpIDogMSA6IHVuZGVmaW5lZCAvLyBGb3JjZSBkcHIgMSBvbiBpcGFkIHRoYXQgaGFzIGxlc3MgbWVtb3J5LlxuICogKTtcbiAqXG4gKiAvLyBMb2FkcyB0aGUgaW1hZ2VzLlxuICogY2FudmFzSW1hZ2VTZXF1ZW5jZS5sb2FkKCk7XG4gKlxuICogLy8gQXQgYSBsYXRlciB0aW1lLiAgSWYgaW1hZ2VzIGFyZW4ndCBsb2FkZWQgeWV0LCByZW5kZXIgd2lsbCBnZXQgaWdub3JlZC5cbiAqICBjYW52YXNJbWFnZVNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3MoMCk7ICAvLyBSZW5kZXJzIGZyYW1lIGF0IHByb2dyZXNzIDAuXG4gKiAgY2FudmFzSW1hZ2VTZXF1ZW5jZS5yZW5kZXJCeVByb2dyZXNzKDAuNSk7ICAvLyBSZW5kZXJzIGZyYW1lIGF0IHByb2dyZXNzIDAuNVxuICogIGNhbnZhc0ltYWdlU2VxdWVuY2UucmVuZGVyQnlQcm9ncmVzcygxKTsgIC8vIFJlbmRlcnMgZnJhbWUgYXQgcHJvZ3Jlc3MgMVxuICpcbiAqIC8vIFdoZW4gZG9uZS5cbiAqIGNhbnZhc0ltYWdlU2VxdWVuY2UuZGlzcG9zZSgpO1xuICpcbiAqIGBgYFxuICogVGhlIGFib3ZlIHdvdWxkIGFkZCBhIGNhbnZhcyB0byBteUVsZW1lbnQuICBUaGUgaW1hZ2UgdGhhdCBnZXRzIHJlbmRlcmVkXG4gKiBpbiB0aGUgY2FudmFzLCB3aWxsIGJlIGZpdHRlZCB3b3VsZCBhbiBhbGdvIHNpbWlsYXIgdG8gYmFja2dyb3VuZDpjb250YWluXG4gKiBzbyB0aGF0IHRoZSBpbWFnZSBpcyBmdWxseSB2aXNpYmxlLiAgSWYgdGhlIGltYWdlIGRpZmZlcmVudCBhc3BlY3QgcmF0aW9cbiAqIHRoYW4gdGhlIGNvbnRhaW4sIHRoZSBpbWFnZSB3aWxsIGJlIGJvdGggdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IGNlbnRlcmVkXG4gKiB3aXRoIGNvbnRhaW4gKG1heGltaXppbmcgdGhlIHNjYWxlIHdpdGhvdXQgYmxlZWRpbmcgb3V0KS5cbiAqXG4gKlxuICogWW91IGNhbiBhbHNvIGxpc3RlbiBsb2FkIGNvbXBsZXRpb24uICBUeXBpY2FsbHksIGxvYWRpbmcgZnJhbWVzIHRha2VzIGFcbiAqIHdoaWxlIHNvIHlvdSBtYXkgd2FudCB0byBhZGQgYSBsb2FkaW5nIGluZGljYXRvciBhbmQgb24gbG9hZCBjb21wbGV0aW9uLFxuICogcmVuZGVyIHRlaCBjYW52YXNJbWFnZVNlcXVlbmNlIHRvIHRoZSBjdXJyZW50IGZyYW1lLlxuICogYGBgdHNcbiAqXG4gKiAvLyBVc2UgaW1hZ2UgbG9hZCBwcm9taXNlIHRvIGVuc3VyZSBpbWFnZXMgYXJlIHJlYWR5LlxuICogY2FudmFzSW1hZ2VTZXF1ZW5jZS5sb2FkKCkudGhlbigoKT0+IHtcbiAqICAgIC8vIE9uIGxvYWQgY29tcGxldGUgcmVuZGVyIHRoZSBmcmFtZSB0aGF0IG1hcHMgdG8gdGhlIGN1cnJlbnQgcHJvZ3Jlc3MuXG4gKiAgICBjYW52YXNJbWFnZVNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3MobXlDdXJyZW50UHJvZ3Jlc3MpO1xuICogfSlcbiAqXG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKiAjIyMgU2l6aW5nIG9wdGlvbnMuXG4gKiBDYW52YXNJbWFnZVNlcXVlbmNlIGhhcyB0d28gcmVuZGVyIG1vZGVzLCBjb250YWluIChkZWZhdWx0KSBhbmQgY292ZXIuXG4gKiBDb250YWluIHdpbGwgYnkgZGVmYXVsdCB2ZXJ0aWNhbGx5IGNlbnRlciB5b3VyIGltYWdlIGJ1dCB5b3UgY2FuIG9mZnNldCB0aGlzXG4gKiBieSBwcm92aWRpbmcgYSBib3R0b20gdmFsdWUuXG4gKlxuICpcbiAqIGBgYHRzXG4gKiBsZXQgY2FudmFzSW1hZ2VTZXF1ZW5jZSA9IG5ldyBDYW52YXNJbWFnZVNlcXVlbmNlKFxuICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubXktZWxlbWVudCcpLFxuICogICBbe2ltYWdlczogbXlJbWFnZXN9XSxcbiAqICAge1xuICogICAgIGNvdmVyOiB0cnVlXG4gKiAgIH1cbiAqICk7XG4gKlxuICogYGBgXG4gKlxuICpcbiAqICMjIE11bHRpSW50ZXJwb2xhdGUgY2FwYWJpbGl0aWVzLlxuICogQ2FudmFzIEltYWdlIFNlcXVlbmNlIGhhcyBtdWx0aWludGVycG9sYXRpb24gYnVpbHQgaW4gdG8gbWFrZSBpdCBlYXNpZXIgdG9cbiAqIG1hbmFnZSBtb3JlIGNvbXBsZXggc2VxdWVuY2VzLlxuICogTm9ybWFsbHksIHlvdSBtYXkgd2FudCB0byBtYXAgYW4gaW1hZ2Ugc2VxdWVuY2UgdG8ganVzdCBwbGF5IGZyb20gc3RhcnQgdG9cbiAqIGVuZC4gIEJ1dCB3aGF0IGlmIHlvdSB3YW50ZWQgbW9yZSBmbGV4aWJsaXR5PyAgWW91IGNhbiBkbyB0aGluZ3MgbGlrZTpcbiAqXG4gKlxuICogYGBgdHNcbiAqXG4gKiBsZXQgcHJvZ3Jlc3NQb2ludHMgPSBbXG4gKiAgICAgICB7XG4gKiAgICAgICAgIGZyb206IDAsIHRvOiAwLjUsIHN0YXJ0OiAwLCBlbmQ6IDEsXG4gKiAgICAgICB9LFxuICogICAgICAge1xuICogICAgICAgICBmcm9tOiAwLjUsIHRvOiAxLCBzdGFydDogMSwgZW5kOiAwLFxuICogICAgICAgfSxcbiAqIF07XG4gKiBjYW52YXNJbWFnZVNlcXVlbmNlLnNldE11bHRpSW50ZXJwb2xhdGlvbihwcm9ncmVzc1BvaW50cyk7XG4gKiBjYW52YXNJbWFnZVNlcXVlbmNlLmxvYWQoKTtcbiAqXG4gKiBgYGBcbiAqIEluIHRoZSBhYm92ZSwgbm93IHRoZSBpbWFnZSBzZXF1ZW5jZSB3aWxsIHBsYXkgZnJvbSBzdGFydCB0byBlbmQgYW5kIGJhY2sgdG9cbiAqIHRoZSBzdGFydC4gIFlvdSBjYW4gZGVmaW5lIHlvdXIgb3duIHByb2dyZXNzIHBvaW50cyB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyXG4gKiBob3cgeW91IHdhbnQgeW91ciBpbWFnZSBzZXF1ZW5jZSBzcHJpdGUgdG8gcGxheSBvdXQuXG4gKlxuICpcbiAqICMjIFBsYXliYWNrIGNhcGFiaWxpdHlcbiAqIFlvdSBjYW4gYWxzbyBwbGF5IHlvdXIgY2FudmFzIGltYWdlIHNlcXVlbmNlIHdpdGggYSB0aW1lci5cbiAqIFRoZSBwbGF5YmFjayBhbHNvIHByb3ZpZGVzIGEgY29tcGxldGlvbiBwcm9taXNlLlxuICpcbiAqIGBgYHRzXG4gKiAvLyBDcmVhdGUgYSBjb21wbGljYXRlZCBwbGF5YmFjay5cbiAqIGxldCBwcm9ncmVzc1BvaW50cyA9IFtcbiAqICAgICAgIHtcbiAqICAgICAgICAgZnJvbTogMCwgdG86IDAuNSwgc3RhcnQ6IDAsIGVuZDogMSxcbiAqICAgICAgIH0sXG4gKiAgICAgICB7XG4gKiAgICAgICAgIGZyb206IDAuNSwgdG86IDEsIHN0YXJ0OiAxLCBlbmQ6IDAsXG4gKiAgICAgICB9LFxuICogXTtcbiAqIGNhbnZhc0ltYWdlU2VxdWVuY2Uuc2V0TXVsdGlJbnRlcnBvbGF0aW9uKHByb2dyZXNzUG9pbnRzKTtcbiAqIC8vIE5vdyBsb2FkIHRoZSBpbWFnZXMuXG4gKiBjYW52YXNJbWFnZVNlcXVlbmNlLmxvYWQoKS50aGVuKCgpPT4ge1xuICogICAgLy8gTm93IHBsYXkgdGhlIGltYWdlIHNlcXVlbmNlIGZyb20gcHJvZ3Jlc3MgMCAtIDEgb3ZlciBhIHNwYW4gb2YgMzAwMCBtcy5cbiAqICAgIGNhbnZhc0ltYWdlU2VxdWVuY2UucGxheSgwLCAxLCAzMDAwKS50aGVuKCgpPT4ge1xuICogICAgICAgY29uc29sZS5sb2coJ2RvbmUnKTtcbiAqICAgIH0pXG4gKiB9KVxuICpcbiAqXG4gKiAvLyBVc2Ugc3RvcCBpZiB5b3UgbmVlZCB0byBzdG9wIHRoZSBhbmlhbXRpb24uXG4gKiBjYW52YXNJbWFnZVNlcXVlbmNlLnN0b3AoKTtcbiAqXG4gKiBgYGBcbiAqXG4gKiAjIyMgTGVycCBUb3dhcmRzIENhcGFiaWxpdHlcbiAqIEJ5IHNldHRpbmcgYSBsZXJwIHZhbHVlLCBjYW52YXNJbWFnZVNlcXVlbmNlIHdpbGwgYXV0b21hdGljYWxseSBcImxlcnBcIiB0b3dhcmRzXG4gKiBmcmFtZXMgaWYgdGhlIGRlbHRhIGJldHdlZW4gdGhlIGN1cnJlbnRseSByZW5kZXJlZCBmcmFtZSBhbmQgdGhlIHJlcXVlc3RlZFxuICogcHJvZ3Jlc3MgaXMgbGFyZ2UuXG4gKiAqIFRoaXMgaXMgdXNlZnVsIHRvIFwic21vb3RoXCIgb3V0IG1vdmVtZW50IGJldHdlZW4gZnJhbWVzLlxuICpcbiAqXG4gKiBUbyB1c2UgdGhpcyBmZWF0dXJlLCBzaW1wbHkgc2V0IHRoZSBsZXJwIHZhbHVlLlxuICpcbiAqIEFzIGFuIGV4bWFwbGUgd2UgaW5pdGlhbGx5IHNldCB0aGUgcHJvZ3Jlc3MgdG8gMCBidXQgaW1tZWRpYXRlbHksIGNoYW5nZSBpdCB0byAxLlxuICogWW91IHdpbGwgc2VlIHRoYXQgdGhlIHByb2dyZXNzIHZhbHVlIHdpbGwgbGVycC4gICBJbnRlcm5hbGx5LCB0aGlzIGhhcHBlbnNcbiAqIGJ5IHJ1bm5pbmcgcmFmIHVudGlsIHRoZSBmcmFtZSB2YWx1ZSBkZWx0YSBpcyBsZXNzIHRoYW4gMSBhbmQgc3RhYmxlLlxuICpcbiAqIGBgYHRzXG4gKiAgY2FudmFzSW1hZ2VTZXF1ZW5jZS5sZXJwQW1vdW50ID0gMC4xMjtcbiAqICBjYW52YXNJbWFnZVNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3MoMCk7XG4gKiAgY2FudmFzSW1hZ2VTZXF1ZW5jZS5yZW5kZXJCeVByb2dyZXNzKDEpO1xuICogYGBgXG4gKlxuICpcbiAqIEFub3RoZXIgdXNlY2FzZSBmb3Igc2V0dGluZyBsZXJwIGlzIHRvIGhhbmRsZSByZXNvbHZpbmcgc3RhdGUgYWZ0ZXIgcGxheWluZ1xuICogYSBzZXF1ZW5jZS4gU2VlIGNhbnZhcy1pbWFnZS1zZXF1ZW5jZTQgZm9yIG1vcmUgb24gdGhpcy5cbiAqXG4gKlxuICpcbiAqICMjIyBDbGlwcGluZyBGZWF0dXJlXG4gKiBTaW1pbGFyIHRvIGNzcyBjbGlwLXBhdGgsIHlvdSBjYW4gcGFzcyBjbGlwLXBhdGgtaXNoIHNoYXBlcyB0byBjYW52YXNJbWFnZVNlcXVlbmNlXG4gKiB3aGljaCB3aWxsIHRoZW4gYmUgYXBwbGllZCB3aGVuIHRoZSBjYW52YXMgcGFpbnRzIC8gcmVuZGVycy5cbiAqXG4gKiBUaGUgY2xpcHBpbmcgY3VycmVudGx5IHN1cHBvcnRzLCBpbnNldCB0eXBlIG9ubHkuXG4gKlxuICogYGBgdHNcbiAqXG4gKiBjYW52YXNJbWFnZVNlcXVlbmNlLnNldENsaXBJbnRlcnBvbGF0aW9ucyh7XG4gKiAgIHR5cGU6ICdpbnNldCcsXG4gKiAgIGludGVycG9sYXRpb25zOiBbXG4gKiAgICAge1xuICogICAgICAgcHJvZ3Jlc3M6IFt7IGZyb206IDAsIHRvOiAxLCBzdGFydDogMCwgZW5kOiAwLjV9XSxcbiAqICAgICAgIGlkOiAndG9wJ1xuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgcHJvZ3Jlc3M6IFt7IGZyb206IDAsIHRvOiAxLCBzdGFydDogMCwgZW5kOiAwLjV9XSxcbiAqICAgICAgIGlkOiAncmlnaHQnXG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBwcm9ncmVzczogW3sgZnJvbTogMCwgdG86IDEsIHN0YXJ0OiAwLCBlbmQ6IDAuNX1dLFxuICogICAgICAgaWQ6ICdib3R0b20nXG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBwcm9ncmVzczogW3sgZnJvbTogMCwgdG86IDEsIHN0YXJ0OiAwLCBlbmQ6IDAuNX1dLFxuICogICAgICAgaWQ6ICdsZWZ0J1xuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgcHJvZ3Jlc3M6IFt7IGZyb206IDAsIHRvOiAxLCBzdGFydDogMCwgZW5kOiAwLjV9XSxcbiAqICAgICAgIGlkOiAnYm9yZGVyLXJhZGl1cydcbiAqICAgICB9XG4gKiAgIF1cbiAqIH0pXG4gKlxuICpcbiAqIGNhbnZhc0ltYWdlU2VxdWVuY2UucmVuZGVyQnlQcm9ncmVzcygwLjUpOyAvLyBUaGUgY2xpcHBpbmcgYXQgMC41IHByb2dyZXNzIGlzIHJlbmRlcmVkLlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKiAjIyBTZWxlY3RpdmVseSBsb2FkaW5nIGRpZmZlcmVudCBzZXRzIG9mIGltYWdlcy5cbiAqXG4gKiBZb3UgY2FuIHBhc3MgZGlmZmVyZW50IHNldHMgb2YgaW1hZ2VzIHRvIHVzZS4gICBVc2UgdGhlIHdoZW4gY29uZGl0aW9uXG4gKiB0byBtb2RpZnkgeW91ciBzZXQuICAgTm90ZSB0aGF0IHRoZSB3aGVuIGNvbmRpdGlvbiBpcyBvbmx5IGV2YWx1YXRlZFxuICogdXBvbiByZXNpemUuICBJZiBhIG5ldyBpbWFnZSBzZXQgaXMgbWF0Y2hlZCwgbG9hZGluZyBvZiB0aGF0IGltYWdlXG4gKiBzZXQgd2lsbCBhdXRvbWF0aWNhbGx5IGhhcHBlbiBpbiB0aGUgYmFja2dyb3VuZCBhbmQgcmVuZGVyIHdoZW4gY29tcGxldGUuXG4gKlxuICogYGBgdHNcbiAqXG4gKiBsZXQgbXlJbWFnZXMgPSBbXG4gKiAgICdpbWFnZS0xLmpwZycsXG4gKiAgICAuLi5cbiAqICAgJ2ltYWdlLTEwMC5qcGcnLFxuICogXTtcbiAqXG4gKiBsZXQgbXlNb2JpbGVJbWFnZXMgPSBbXG4gKiAgICdpbWFnZS1tb2JpbGUtMS5qcGcnLFxuICogICAnaW1hZ2UtbW9iaWxlLTEwMC5qcGcnLFxuICogXTtcbiAqICBsZXQgY2FudmFzSW1hZ2VTZXF1ZW5jZSA9IG5ldyBDYW52YXNJbWFnZVNlcXVlbmNlKFxuICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubXktZWxlbWVudCcpLFxuICogICBbe1xuICogICAgIHdoZW46ICgpPT4geyByZXR1cm4gd2luZG93LmlubmVyV2lkdGggPj0gNzY4fSxcbiAqICAgICBpbWFnZXM6IG15SW1hZ2VzXG4gKiAgIH0sXG4gKiAgIHtcbiAqICAgICB3aGVuOiAoKT0+IHsgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4fSxcbiAqICAgICBpbWFnZXM6IG15TW9iaWxlSW1hZ2VzXG4gKiAgIH1dXG4gKiApO1xuICpcbiAqIGBgYFxuICpcbiAqIENhbiBJIGhhdmUgaW1hZ2VTZXRzIGZvciBvbmx5IGRlc2t0b3Agb3IgbW9iaWxlPyAgWWVzIHlvdSBjYW4hXG4gKlxuICogYGBgdHNcbiAqICBsZXQgY2FudmFzSW1hZ2VTZXF1ZW5jZSA9IG5ldyBDYW52YXNJbWFnZVNlcXVlbmNlKFxuICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubXktZWxlbWVudCcpLFxuICogICBbXG4gKiAgIHtcbiAqICAgICB3aGVuOiAoKT0+IHsgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4fSxcbiAqICAgICBpbWFnZXM6IG15TW9iaWxlSW1hZ2VzXG4gKiAgIH1dXG4gKiApO1xuICpcbiAqIGBgYFxuICogSGVyZSB3ZSBzcGVjaWZ5IGNhbnZhc0ltYWdlU2VxdWVuY2Ugd2l0aCBhbiBpbWFnZVNldCBmb3Igb25seSBtb2JpbGUuICBUaGlzXG4gKiBtZWFucyB0aGUgaW1hZ2VzIHdpbGwgb25seSBsb2FkIG9uIG1vYmlsZSBhbmQgY2FudmFzSW1hZ2VTZXF1ZW5jZSB3b24ndFxuICogZG8gYW55dGhpbmcgb24gZGVza3RvcCAobm90aGluZyB3aWxsIHNob3cgc2luY2UgdGhlcmUgYXJlIG5vIGltYWdlcykuXG4gKlxuICpcbiAqXG4gKiAjIyMjIyMjIyMjIyMjIERldiBOb3RlcyAjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICpcbiAqICMgTWVtb3J5IG1hbmFnZW1lbnQgKGRldiBub3RlcylcbiAqIFdoZW4gd29ya2luZyBvbiB0aGlzIGNsYXNzLCB5b3UgaGF2ZSB0byBiZSB2ZXJ5IGNhcmVmdWwgYWJvdXQgbWVtb3J5IG1hbmFnZW1lbnRcbiAqIHNpbmNlIHdlIGFyZSBkZWFsaW5nIHdpdGggYSBsb3Qgb2YgaW1hZ2VzLlxuICpcbiAqIFRoZXJlIGlzIG5hdGl2ZSBtZW1vcnkgYW5kIGltYWdlIGNhY2hlIHRoYXQgbmVlZCB0byBiZSBwYXJ0aWN1bGFybHkgbG9va2VkIGF0LlxuICogWW91IGNhbiBnbyB0byBDaHJvbWUgLT4gVGFzayBtYW5hZ2VyIGFuZCBtb25pdG9yIHRoZSB1c2FnZS5cbiAqIE1ha2Ugc3VyZSB0byBlbmFibGUgdGhlIG1lbW9yeSBmb290cHJpbnQgYW5kIGltYWdlIGNhY2hlIGNvbHVtbnMuXG4gKlxuICogRm9yIFNhZmFyaSwgdGhlIGJlc3QgcGxhY2UgaXMgdG8gb3BlbiBBY3Rpdml0eSBNb25pdG9yLiBPcGVuIHNhZmFyaSBhbmRcbiAqIG9wZW4gdGhlIHNpdGUuICBXaXRoaW4gQWN0aXZpdHkgTW9uaXRvciwgbG9vayBmb3IgeW91ciBwcm9jZXNzIChpdCB3aWxsIGJlIHRoZVxuICogbmFtZSBvZiB0aGUgcGFnZSkuICBEb3VibGUgY2xpY2sgb24gaXQgdG8gZ2V0IHJlYWwgbWVtb3J5IHVzYWdlLiAgWW91IGNhblxuICogYWxzbyB1c2UgdGhlIFNhZmFyaSBXZWJUb29scyBtZW1vcnkgYW5kIENQVSBwcm9maWxlLlxuICpcbiAqXG4gKiAxKSBpbWFnZS5kZWNvZGUoKSBhbmQgSW1hZ2VCaXRtYXBzXG4gKiBJZiB5b3UgcnVuIGltYWdlLmRlY29kZSgpIG9yIGxvYWQgSW1hZ2VCaXRtYXBzLCB0aGlzIGRhdGEgYXBwZWFycyB0byBnZXQgc3RvcmVkXG4gKiBvdmVyIGluIG5hdGl2ZSBtZW1vcnkuICBjYW52YXMuZHJhd0ltYWdlIHN0b3JlcyBpbiBpbWFnZSBjYWNoZSB3aGljaCBpc1xuICogc2VwYXJhdGUuXG4gKlxuICogVGhlIGlzc3VlIGlzIHRoZSB3aGVuIHlvdSBydW4gaW1hZ2UuZGVjb2RlKCkgb3IgdXNlIEltYWdlQml0bWFwcywgdGhlIG5hdGl2ZVxuICogbWVtb3J5IHNwYWNlIHRoZXkgb2NjdXB5LCB3b24ndCBnZXQgZmx1c2hlZC4gIEl0IHNlZW1zIHRvIGdldCBmbHVzaGVkIG9ubHlcbiAqIHdoZW4gdGhlIGNhbnZhcyBvciBkb2N1bWVudCBpcyB1bmxvYWRlZC5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gKiBpbWFnZS5zcmMgPSAnaG9ob2hvLmpwZyc7XG4gKiBpbWFnZS5kZWNvZGUoKCk9PiB7IC8vIFRoaXMgcHVzaGVzIGl0IHRvIG5hdGl2ZSBtZW1vcnkuXG4gKiAgIGltYWdlID0gbnVsbDsgLy8gVGhpcyB3b24ndCBnZXQgcmVtb3ZlZCBldmVuIHdpdGggR0MuXG4gKiB9KVxuICogYGBgXG4gKlxuICogVGhpcyByZW1vdmVzIHRoZSByZWZlcmVuY2UgdG8gdGhlIGltYWdlIGJ1dCBldmVuIHdpdGggR0Mgd29uJ3QgZmx1c2ggdGhlIG5hdGl2ZVxuICogbWVtb3J5LlxuICpcbiAqIEl0J3MgYmVzdCB0byBhdm9pZCB0aGlzIGFuZCBpbnN0ZWFkIGp1c3QgbG9hZCBpbWFnZXMgbm9ybWFsbHkgT1JcbiAqIHVzZSBPYmplY3RVcmwgdG8gbWFrZSBhIGxvY2FsIGJsb2IuXG4gKlxuICpcbiAqIDIpIFByb2JsZW0gMlxuICogY2FudmFzLmRyYXdJbWFnZShpbWFnZSkgbWVtb3J5IGlzc3VlcyBhbmQgYWxzbyBTYWZhcmkgRGF0YVVSSSAoYmFzZTY0KVxuICpcbiAqIGNhbnZhcy5kcmF3SW1hZ2UsIGVzc2VudGlhbGx5IGNvcGllcyB0aGUgZGVjb2RlZCBpbWFnZSBkYXRhIG92ZXIgdG8gdGhlIGltYWdlIGNhY2hlLlxuICogVGhlcmVmb3JlLCBldmVuIGRvaW5nOlxuICpcbiAqIGBgYFxuICogY2FudmFzLmRyYXdJbWFnZShpbWFnZSk7ICAvLyBkZWNvZGVkIGNvcHkgc3RvcmVkIHRvIGltYWdlIGNhY2hlLlxuICogY2FudmFzLmRyYXdJbWFnZShpbWFnZSk7ICAvLyBkZWNvZGVkIGNvcHkgc3RvcmVkIHRvIGltYWdlIGNhY2hlXG4gKiBjYW52YXMuZHJhd0ltYWdlKGltYWdlKTsgIC8vIGRlY29kZWQgY29weSBzdG9yZWQgdG8gaW1hZ2UgY2FjaGUuXG4gKiBgYGBcbiAqIFF1aWNrbHkgcmVzdWx0cyBpbiB0aGUgaW1hZ2VDYWNoZSBncm93aW5nLiAgV2hpbGUgdGhpcyBpcyB1c3VhbGx5IGZpbmUgc2luY2VcbiAqIHRoZSBpbWFnZSBjYWNoZSBnZXRzIGNsZWFyZWQgcHJldHR5IHF1aWNrbHksIHdpdGggYSBjbGFzcyBsaWtlIHRoaXMsIGlmIHlvdSBoYXZlXG4gKiAxMDAgaW1hZ2VzLCB0aGF0IGNhY2hlIHdpdGggdGhhdCBkYXRhIGRlY29kZWQgZW5kcyB1cCBiZWluZyB2ZXJ5IGxhcmdlLlxuICpcbiAqIFRvIGF2b2lkIHRoaXMsIHlvdSBuZWVkIHRvIGRlbGV0ZSB0aGUgaW1hZ2UgZnJvbSByZWZlcmVuY2UuXG4gKlxuICogYGBgXG4gKiBjYW52YXMuZHJhd0ltYWdlKGltYWdlKTsgIC8vIGRlY29kZWQgY29weSBzdG9yZWQgdG8gaW1hZ2UgY2FjaGUuXG4gKiBpbWFnZS5zcmMgPSBudWxsOyAvLyByZWZlcmVuY2UgcmVtb3ZlZC4gIGltYWdlIGNhY2hlIGdldHMgY2xlYXJlZC5cbiAqIGltYWdlID0gbnVsbDtcbiAqIGBgYFxuICpcbiAqIFRoaXMgZXNzZW50aWFsbHkgbWVhbnMsIHRoYXQgaWYgd2UgZG9uJ3Qgd2FudCB0aGUgaW1hZ2UgY2FjaGUgdG8gZ3Jvdywgd2VcbiAqIG5lZWQgdG8gZGVsZXRlIHRoZSBpbWFnZSB0aGF0IHdhcyBqdXN0IGRyYXduIGFmdGVyIHRoZSBkcmF3IGNhbGwuXG4gKlxuICpcbiAqIDMpIFByb2JsZW0gM1xuICogU2FmYXJpIENhbnZhcyBJc3N1ZXM6XG4gKiBOb3RlIHRoYXQgU2FmYXJpIGFsc28gaGFzIHNvbWUgaXNzdWVzIHdpdGggbWVtb3J5IG1hbmFnZW1lbnQuXG4gKiBJbiBnZW5lcmFsLCBTYWZhcmkgZG9lc24ndCBkbyBhIGdyZWF0IGpvYiBvZmZsb2FkaW5nIGJhc2U2NCBpbWFnZXMgZnJvbSBjYWNoZS5cbiAqXG4gKiBUaGUgYmVzdCB3YXkgdG8gbWFuYWdlIGlzOlxuICogMSkgZG9uJ3QgdXNlIGJhc2U2NEltYWdlcyBhbmQgZHJhdyB0byBjYW52YXMgKHNpbmNlIFNhZmFyaSBkb2Vzbid0IHJlbGVhc2UgbWVtb3J5KVxuICogMikgZGVsZXRlIGltYWdlIGRhdGEgdG8gb2ZmbG9hZCBtZW1vcnkgYWZ0ZXIgZHJhd0ltYWdlIGNhbGxzLlxuICpcbiAqXG4gKiBPdmVyYWxsIGJlc3QgcHJhY3RpY2U6XG4gKiBUaGUgc29sdXRpb24gdGFrZSB0byBhdm9pZCB0aGVzZSBwcm9ibGVtcyBhcmU6XG4gKiAtIGRvbid0IHVzZSBpbWFnZS5kZWNvZGUoKVxuICogLSBkb24ndCB1c2UgSW1hZ2VCaXRtYXBzXG4gKiAtIGRvbid0IHVzZSBiYXNlNjR1cmkgaW1hZ2UgU2FmYXJpIGNhbid0IG9mZmxvYWQgdGhlbS5cbiAqIC0gYWx3YXlzIHJlbW92ZSB0aGUgaW1hZ2UgYWZ0ZXIgdXNpbmcgZHJhd0ltYWdlKCkuICBCZXN0IHdheSB0byBkbyB0aGlzIGlzXG4gKiAgIHRvIHVzZSBhIHRlbXBvcmFyeSBpbWFnZSBhbmQgYXNzaWduIGl0IGEgbG9jYWwgb2JqZWN0VVJJLlxuICogLSB3aGVuIHlvdSByZXNpemUgYSBjYW52YXMgaXQgY2xlYXJzIGl0IG91dC4gIFlvdSBuZWVkIHRvIHJlc2l6ZSB3aXRoIHNtYXJ0UmVzaXplXG4gKiAgIHRvIGF2b2lkIGZsYXNoZXMgb24gaW9zIG1vYmlsZSB3aGVyZSB0aGUgZG9jdW1lbnQgaGVpZ2h0IGNoYW5nZXMgYXMgeW91IHJlc2l6ZVxuICogICBmaXJpbmcgcmVzaXplIGV2ZW50cy5cbiAqXG4gKlxuICogQXBwcm9hY2ggdG8gc29sdmluZyB0aGUgYWJvdmU6XG4gKiAxKSBNYWtlIFhIUiBjYWxscyB0byBhbGwgaW1hZ2UgdXJscyBhbmQgc2F2ZSB0aGUgYmxvYnMgaW4gbWVtb3J5IChibG9iQ2FjaGUpLlxuICogMikgQ3JlYXRlIGEgc2luZ2xlIGNhY2hlSW1hZ2UgKEltYWdlKSB0aGF0IHdpbGwgdGVtcG9yYXJpbHkgaG9sZCBkYXRhIHdoaWxlIGl0IGdldHNcbiAqICAgIGRyYXduIHRvIGNhbnZhcyAoY2FjaGVJbWFnZSlcbiAqIDMpIE9uIGVhY2ggZHJhdyBjYWxsLCB1c2UgT2JqZWN0VVJJcyB0byBsb2NhbGx5IGdlbmVyYXRlIGEgdGVtcG9yYXJ5IGJsb2IgaW1hZ2UuXG4gKiAgICBTZXQgdGhhdCB0byB0aGUgY2FjaGVJbWFnZSB0aGVuIGNhbnZhcy5kcmF3SW1hZ2UoY2FjaGVJbWFnZSkgYW5kIGZvbGxvd2luZyB0aGF0XG4gKiAgICB0aGVuIHJldm9rZSB0aGUgT2JqZWN0VVJJICh0byByZWxlYXNlIGl0IGZyb20gbWVtb3J5KS5cbiAqXG4gKiBUaGlzIGNhbiBiZSByb3VnaGx5IGlsbHVzdHJhdGVkIGFzOlxuICogYGBgdHNcbiAqXG4gKiB0aGlzLmJsb2JDYWNoZSA9IHh4eC5nZXRCbG9ic0RhdGFGcm9tU2VydmVyKCk7XG4gKlxuICogLy8gQ3JlYXRlIGFuIGltYWdlIHRoYXQgd2lsbCB0ZW1wb3JhcmlseSBob2xkIGRhdGEuXG4gKiB0aGlzLmNhY2hlSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAqXG4gKiBkcmF3KHNvdXJjZSkge1xuICpcbiAqICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAqICAgICB0aGlzLmRyYXdJbWFnZSh0aGlzLmNhY2hlSW1hZ2UpO1xuICogICAgIC8vIFJlbW92ZSBpdCBmcm9tIG1lbW9yeS5cbiAqICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGltYWdlLnNyYyk7XG4gKiAgIH1cbiAqXG4gKiAgICAvLyBDcmVhdGUgYSBsb2NhbCBvYmplY3RVUkkgYW5kIGFwcGx5IGl0IGFzIHRoZSBpbWFnZSBzb3VyY2UuXG4gKiAgICB0aGlzLmNhY2hlSW1hZ2Uuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLmJsb2JDYWNoZVtzb3VyY2VdKTtcbiAqIH1cbiAqXG4gKiBkaXNwb3NlKCkge1xuICogICAvLyBEZWxldGUgYWxsIGJsb2JzIGhlbHAgaW4gbWVtb3J5LlxuICogICB0aGlzLmJsb2JDYWNoZSA9IG51bGw7XG4gKiB9XG4gKlxuICogYGBgXG4gKlxuICogV2l0aCB0aGUgc29sdXRpb24gYWJvdmUsIGdlbmVyYWxseSwgdGhlIGVuY29kZWQgc2l6ZSBvZiBhbGwgaW1hZ2VzIGFyZSBzdG9yZWRcbiAqIGluIG5hdGl2ZSBtZW1vcnkgKyBvbmUgZGVjb2RlZCBpbWFnZSBpbiBtZW1vcnkgY2FjaGUgYXQgYW55IGdpdmVuIHRpbWUuICBJZiB5b3VcbiAqIGFyZSB3b3JraW5nIHdpdGggcG5ncywgdGhpcyBjYW4gc3RpbGwgbWVhbiBhIGh1Z2UgbWVtb3J5IGhvZ2Ugc28gd2F0Y2ggb3V0LlxuICpcbiAqXG4gKiA0KSBGUFMgLSBpcGFkIENQVVxuICogU2luY2Ugd2UgbmVlZCB0byBkZWNvZGUgcGVyIGRyYXdGcmFtZSwgdGhpcyBoYXMgYSBoaWdoZXIgQ1BVIGNvc3QuXG4gKlxuICogVG8gbG93ZXIgdGhlIENQVSB1c2FnZSwgaW50ZXJuYWxseSB3ZSBtYW5hZ2UgYW4gZnBzIHJhdGUgbGltaXRlci5cbiAqIFRoaXMgaXMgc2V0IHRvIDMwLCB3aGljaCBpcyB0aGUgbWF4aW11bSB3ZSByZWFsbHkgbmVlZCB0byBnZXQgYSBzbW9vdGhcbiAqIHBlcmNlaXZlZCBhbmltYXRpb24uXG4gKlxuICogNSkgRXZlbiB3aXRoIHRoZSBvcHRpbWl6YXRpb25zIGFib3ZlLCBWUkFNIChHUFUgbWVtb3J5KSBjYW4gY2FuIGJlIHJlbGF0aXZlbHlcbiAqICAgIGhpZ2guIElmIHlvdSBqdXN0IG5lZWQgYmFzaWMgZmVhdHVyZXMsIGNvbnNpZGVyIHdlYmdsLWltYWdlLWNhbnZhc1xuICogICAgYXMgYW4gYWx0ZXJuYXRpdmUgd2hpY2ggaXMgbW9yZSBwZXJmb3JtYW50LlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ibGlua2tjb2RlL2RlZ3UvYmxvYi9tYXN0ZXIvZXhhbXBsZXMvY2FudmFzLWltYWdlLXNlcXVlbmNlLmpzXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ibGlua2tjb2RlL2RlZ3UvYmxvYi9tYXN0ZXIvZXhhbXBsZXMvY2FudmFzLWltYWdlLXNlcXVlbmNlMi5qc1xuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vYmxpbmtrY29kZS9kZWd1L2Jsb2IvbWFzdGVyL2V4YW1wbGVzL2NhbnZhcy1pbWFnZS1zZXF1ZW5jZTMuanNcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JsaW5ra2NvZGUvZGVndS9ibG9iL21hc3Rlci9leGFtcGxlcy9jYW52YXMtaW1hZ2Utc2VxdWVuY2U0LmpzXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ibGlua2tjb2RlL2RlZ3UvYmxvYi9tYXN0ZXIvZXhhbXBsZXMvY2FudmFzLWltYWdlLXNlcXVlbmNlNS5qc1xuICogQHVuc3RhYmxlXG4gKi9cbmNsYXNzIENhbnZhc0ltYWdlU2VxdWVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGltYWdlU2V0cywgb3B0aW9ucywgZHByKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGVycCBhbW91bnQgd2hlbiB0aGVyZSBpcyBhIGRlbHRhIGJldHdlZW4gdGFyZ2V0IGFuZCBjdXJyZW50IGZyYW1lXG4gICAgICAgICAqIGdyZWF0ZXIgdGhhbiAxLiAgVGhpcyBkZWZhdWx0cyB0byAxIChtZWFuaW5nIG5vIGxlcnApLiAgQ2hhbmdlIHRoaXMgdmFsdWVcbiAgICAgICAgICogaWYgeW91IHdhbnQgY2FudmFzSW1hZ2VTZXF1ZW5uY2UgdG8gc21vb3RobHkgaW50ZXJwb2xhdGUgYmV0d2VlbiBsYXJnZVxuICAgICAgICAgKiBkZWx0YXMgYmV0d2VlbiB0aGUgdGFyZ2V0IGFuZCBjdXJyZW50IGZyYW1lcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVycEFtb3VudCA9IDE7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGV4cG9ydHMuY2FudmFzSW1hZ2VTZXF1ZW5jZUVycm9ycy5OT19FTEVNRU5UKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWltYWdlU2V0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGV4cG9ydHMuY2FudmFzSW1hZ2VTZXF1ZW5jZUVycm9ycy5OT19JTUFHRV9TRVRTKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmltYWdlU2V0cyA9IGltYWdlU2V0cztcbiAgICAgICAgdGhpcy5hY3RpdmVJbWFnZVNldCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmxvYkNhY2hlID0ge307XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIC8vIHRoaXMudXNlQml0bWFwSW1hZ2VJZlBvc3NpYmxlID0gZmFsc2U7XG4gICAgICAgIC8vIENyZWF0ZSBjYW52YXMuXG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAvLyBBZGQgYXJpYSBsYWJlbCBpZiBhdmFpbGFibGUuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmFyaWFMYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRoaXMub3B0aW9ucy5hcmlhTGFiZWwpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdpbWcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGhpcy5kcHIgPSBmdW5jXzEuZnVuYy5zZXREZWZhdWx0KGRwciwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgIHRoaXMuY2FudmFzV2lkdGggPSAwO1xuICAgICAgICB0aGlzLmNhbnZhc0hlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuaW1hZ2VOYXR1cmFsSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5pbWFnZU5hdHVyYWxXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0RHJhd1NvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0RnJhbWUgPSAwO1xuICAgICAgICB0aGlzLmNvbnRhaW5TY2FsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gU2V0IEZQUyB0byAzMCBmb3IgU2FmYXJpIHRvIGxpbWl0IGNvbXB1dGF0aW9uLiAgU2FmYXJpIHRha2VzIGEgbG90XG4gICAgICAgIC8vIG1vcmUgdGltZSB0byBkZWNvZGUgaW1hZ2VzIHNvIHRoaXMgcHJldmVudHMgaGlnaCBDUFUgdXNhZ2UgY3Jhc2hlc1xuICAgICAgICAvLyBpbiBTYWZhcmkuXG4gICAgICAgIHRoaXMuZnBzID0gbmV3IGZwc18xLkZwcyhpc18xLmlzLnNhZmFyaSgpID8gMzAgOiA2MCk7XG4gICAgICAgIHRoaXMuY2FjaGVJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICB0aGlzLnJhZlRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5tdWx0aUludGVycG9sYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGlwTXVsdGlJbnRlcnBvbGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY2xpcFBhdGhUeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5ibG9iTG9hZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIHRoaXMucGxheURlZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IGRvbV93YXRjaGVyXzEuRG9tV2F0Y2hlcigpO1xuICAgICAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSB1c2Ugc21hcnQgcmVzaXplIGhlcmUgYmVjYXVzZSByZXNpemluZyBjYW52YXMgd2lsbCBtYWtlXG4gICAgICAgICAgICAvLyBpdCBmbGFzaCAoZHVlIHRvIGNsZWFyaW5nIHRoZSBjYW52YXMpLlxuICAgICAgICAgICAgb246ICdzbWFydFJlc2l6ZScsXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpOyAvLyBNYWtlIGEgZW1wdHkgY2FsbCB0byBjbGVhciB0aGUgbWVtb2l6ZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAvLyBSZXJlbmRlciB0aGUgbGFzdCBrbm93biBpbWFnZS5cbiAgICAgICAgICAgICAgICB0aGlzLmxhc3REcmF3U291cmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmZwcy5sb2NrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZW5kZXJTb3VyY2UgJiYgdGhpcy5kcmF3KHRoaXMubGFzdFJlbmRlclNvdXJjZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mcHMubG9jayh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogJ3Jlc2l6ZScsXG4gICAgICAgICAgICBldmVudE9wdGlvbnM6IHsgcGFzc2l2ZTogdHJ1ZSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgdGhpcy5kb21XYXRjaGVyLnJ1bigncmVzaXplJyk7XG4gICAgICAgIC8vIEFub3RoZXIgcmVzaXplIHdhdGNoZXIgZGVkaWNhdGVkIHRvIGNoZWNraW5nIHRvIGNoZWNraW5nIGlmIGEgbmV3XG4gICAgICAgIC8vIGltYWdlIHNldCBzaG91bGQgYmUgbG9hZGVkLlxuICAgICAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgICAgICAgIG9uOiAnc21hcnRSZXNpemUnLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSBpZiB3ZSBuZWVkIHRvIGxvYWQgYSBkaWZmZXJlbnQgaW1hZ2Ugc2V0LlxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NldCA9IHRoaXMuZ2V0U291cmNlVGhhdFNob3VsZExvYWQodGhpcy5pbWFnZVNldHMpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdTZXQgIT09IHRoaXMuYWN0aXZlSW1hZ2VTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkTmV3U2V0KHRoaXMuaW1hZ2VTZXRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXV0b2xvYWQgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGxhc3QgZnJhbWUgdG8gbnVsbCB0byBhbGxvdyByZWRyYXdpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3REcmF3U291cmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnBzLmxvY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJCeVByb2dyZXNzKHRoaXMucHJvZ3Jlc3MgfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZwcy5sb2NrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQ6ICdpbWFnZS1zZXQtcmVzaXplJyxcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uczogeyBwYXNzaXZlOiB0cnVlIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgdGhpcy5yZWFkeVByb21pc2UgPSBuZXcgZGVmZXJfMS5EZWZlcigpO1xuICAgICAgICB0aGlzLmxvYWROZXdTZXQoaW1hZ2VTZXRzKTtcbiAgICAgICAgLy8gVGhlIHByZXZpb3VzbHkgcmVuZGVyZWQgaW1hZ2Ugc291cmNlLlxuICAgICAgICB0aGlzLmxhc3RSZW5kZXJTb3VyY2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3REcmF3U291cmNlID0gbnVsbDtcbiAgICAgICAgLy8gQ3VsbCB1bm5jZXNzYXJ5IHVwZGF0ZVxuICAgICAgICB0aGlzLmRyYXcgPSBmdW5jXzEuZnVuYy5ydW5PbmNlT25DaGFuZ2UodGhpcy5kcmF3LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGFuIG9wdGlvbmFsIG11bHRpaW50ZXJwb2xhdGlvbnMuICBUaGlzIGFsbG93cyB5b3UgdG8gZGVmaW5lXG4gICAgICogbW9yZSBjb21wbGV4IHBsYXkgc2VxdWVuY2VzIG9uIHlvdXIgaW1hZ2Ugc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgb2YgcGxheWluZyB0aGUgaW1hZ2Ugc2VxdWVuY2UgZnJvbSBzdGFydCB0byBlbmRcbiAgICAgKiBhbmQgYmFjayB0byBlbmQuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGxldCBwcm9ncmVzc1BvaW50cyA9IFtcbiAgICAgKiAgICAgICB7XG4gICAgICogICAgICAgICBmcm9tOiAwLCB0bzogMC41LCBzdGFydDogMCwgZW5kOiAxLFxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgZnJvbTogMC41LCB0bzogMSwgc3RhcnQ6IDEsIGVuZDogMCxcbiAgICAgKiAgICAgICB9LFxuICAgICAqIF07XG4gICAgICogY2FudmFzSW1hZ2VTZXF1ZW5jZS5zZXRNdWx0aUludGVycG9sYXRpb24ocHJvZ3Jlc3NQb2ludHMpO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0TXVsdGlJbnRlcnBvbGF0aW9uKGludGVycG9sYXRpb25zKSB7XG4gICAgICAgIHRoaXMubXVsdGlJbnRlcnBvbGF0ZSA9IG5ldyBtdWx0aV9pbnRlcnBvbGF0ZV8xLk11bHRpSW50ZXJwb2xhdGUoe1xuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnc2VxdWVuY2UnLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogaW50ZXJwb2xhdGlvbnMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNpemUoKSB7XG4gICAgICAgIHRoaXMuY2FudmFzV2lkdGggPSB0aGlzLmVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzSGVpZ2h0ID0gdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgLy8gU2V0IGNhbnZhcyB0byBoaWdoIGRwciwgdGhlIGFjdHVhbCB3aWR0aCB0byB0aGUgc2l6ZS5cbiAgICAgICAgLy8gQHNlZSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9jYWxsdW1sb2NrZS9jYzI1OGExOTM4Mzk2OTFmNjBkZFxuICAgICAgICAvLyBmb3IgaW5zcGlyYXRpb24uXG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudC53aWR0aCA9IHRoaXMuZWxlbWVudC5vZmZzZXRXaWR0aCAqIHRoaXMuZHByO1xuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQuaGVpZ2h0ID0gdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodCAqIHRoaXMuZHByO1xuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQuc3R5bGUud2lkdGggPSB0aGlzLmNhbnZhc1dpZHRoICsgJ3B4JztcbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMuY2FudmFzSGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgLy8gU2NhbGUgdXAgdGhlIGNhbnZhcyB0byBjb21wZW5zYXRlIERQUi5cbiAgICAgICAgdGhpcy5jb250ZXh0LnNjYWxlKHRoaXMuZHByLCB0aGlzLmRwcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBsb2FkaW5nIHRoZSBpbWFnZXMuXG4gICAgICovXG4gICAgbG9hZCgpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbWF0Y2hpbmcgaW1hZ2VTZXQgdGhlcmUgaXMgbm90aGluZyB0byBsb2FkLlxuICAgICAgICBpZiAoIXRoaXMuYmxvYkxvYWRlciB8fCAhdGhpcy5hY3RpdmVJbWFnZVNldCkge1xuICAgICAgICAgICAgLy8gRGVmZXIgcmVzb2x1dGlvbi5cbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWR5UHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWR5UHJvbWlzZS5nZXRQcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9hZEFsbEJsb2JzID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ibG9iTG9hZGVyLmxvYWQoKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvYkNhY2hlID0gcmVzdWx0cztcbiAgICAgICAgICAgICAgICB0aGlzLnNldEltYWdlRGltZW5zaW9ucygpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJsb2JMb2FkZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWR5UHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGxvYWRBbGxCbG9icygpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkeVByb21pc2UuZ2V0UHJvbWlzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgeW91IHRvIHNldCBuZXcgaW1hZ2VTZXRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGltYWdlU291cmNlXG4gICAgICovXG4gICAgbG9hZE5ld1NldChpbWFnZVNldHMpIHtcbiAgICAgICAgLy8gUmVsZWFzZSBtZW1vcnkgb2YgY3VycmVudCBzZXQuXG4gICAgICAgIHRoaXMuYmxvYkxvYWRlciAmJiB0aGlzLmJsb2JMb2FkZXIuZGlzcG9zZSgpO1xuICAgICAgICAvLyBTYXZlIHRoZSBpbWFnZSBzb3VyY2VzLlxuICAgICAgICB0aGlzLmltYWdlU2V0cyA9IGltYWdlU2V0cztcbiAgICAgICAgdGhpcy5hY3RpdmVJbWFnZVNldCA9IHRoaXMuZ2V0U291cmNlVGhhdFNob3VsZExvYWQodGhpcy5pbWFnZVNldHMpO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVJbWFnZVNldCAmJiAhaXNfMS5pcy5hcnJheSh0aGlzLmFjdGl2ZUltYWdlU2V0LmltYWdlcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLmNhbnZhc0ltYWdlU2VxdWVuY2VFcnJvcnMuTk9fSU1BR0VTKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIGFjdGl2ZSBpbWFnZSBzZXQgaWYgb25lIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlSW1hZ2VTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuYmxvYkxvYWRlciA9IG5ldyBibG9iX2xvYWRlcl8xLkJsb2JMb2FkZXIodGhpcy5hY3RpdmVJbWFnZVNldC5pbWFnZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ibG9iTG9hZGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJsb2JDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHRoaXMubGFzdFJlbmRlclNvdXJjZSA9IG51bGw7XG4gICAgICAgIC8vIFJlc2V0IHRoZSByZWFkeVByb21pc2UuXG4gICAgICAgIHRoaXMucmVhZHlQcm9taXNlID0gbmV3IGRlZmVyXzEuRGVmZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBsaXN0IG9mIENhbnZhc0ltYWdlU2VxdWVuY2VJbWFnZVNldHMgZXZhbHVhdGVzIHdoaWNoIHNldCBzaG91bGRcbiAgICAgKiBiZSB1c2VkIHRvIGxvYWQgaW50byB0aGUgY2FudmFzLiAgVGhlIGNyaXRlcmlhIGlzIHRoYXQgYW55XG4gICAgICogaW1hZ2VTZXQgd2l0aG91dCB3aGVuIGlzIHVzZWQgb3IgaWYgd2hlbiBjb25kaXRpb24gaXMgc3BlY2lmaWVkIHRoZVxuICAgICAqIHdoZW4gY29uZGl0aW9uIGlzIGV2YWx1YXRlZCBhbmQgaWYgdHJ1ZSwgaXQgaXMgdXNlZC4gIElmIG11bHRpcGxlIGltYWdlU2V0c1xuICAgICAqIGFyZSBmb3VuZCwgdGhlIHRoZSBmaXJzdCBvbmUgaXMgdXNlZC5cbiAgICAgKi9cbiAgICBnZXRTb3VyY2VUaGF0U2hvdWxkTG9hZChzb3VyY2VzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nU291Y2VzID0gW107XG4gICAgICAgIHNvdXJjZXMuZm9yRWFjaChzb3VyY2UgPT4ge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2Uud2hlbikge1xuICAgICAgICAgICAgICAgIG1hdGNoaW5nU291Y2VzLnB1c2goc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZS53aGVuKCkgJiYgbWF0Y2hpbmdTb3VjZXMucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nU291Y2VzWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGRlbGV0YWJsZSBpbWFnZSBjbG9uZS5cbiAgICAgKi9cbiAgICBtYWtlSW1hZ2Uoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGlmICghc291cmNlIHx8ICF0aGlzLmJsb2JDYWNoZVtzb3VyY2VdKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdFVSTCBCbG9iIGZyb20gbG9jYWxlIGNhY2hlLlxuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLmNhY2hlSW1hZ2Uuc3JjKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmNhY2hlSW1hZ2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyB0ZW1wb3JhcnkgT2JqZWN0VVJsIHRvIHN0b3JlLlxuICAgICAgICAgICAgdGhpcy5jYWNoZUltYWdlLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy5ibG9iQ2FjaGVbc291cmNlXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbWFnZXMgZGltZW5zaW9ucyB1c2VkIGludGVybmFsbHkgYmFzZWQgb24gdGhlIGZpcnN0IGltYWdlLlxuICAgICAqIEFzc3VtZXMgYWxsIGltYWdlcyBhcmUgdW5pZm9ybSBzaXplLlxuICAgICAqL1xuICAgIHNldEltYWdlRGltZW5zaW9ucygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5hY3RpdmVJbWFnZVNldC5pbWFnZXNbMF07XG4gICAgICAgICAgICBjb25zdCBibG9iID0gdGhpcy5ibG9iQ2FjaGVbc291cmNlXTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGFuIGltYWdlIGZyb20gdGVoIGZpcnN0IGJsb2IuXG4gICAgICAgICAgICBkb21fMS5kb20ubWFrZUltYWdlRnJvbUJsb2IoYmxvYikudGhlbigoaW1hZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRNYXBzTG9hZGVkID0gIWltYWdlLm5hdHVyYWxXaWR0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlTmF0dXJhbEhlaWdodCA9IGJpdE1hcHNMb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgPyBpbWFnZS5oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgOiBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VOYXR1cmFsV2lkdGggPSBiaXRNYXBzTG9hZGVkXG4gICAgICAgICAgICAgICAgICAgID8gaW1hZ2Uud2lkdGhcbiAgICAgICAgICAgICAgICAgICAgOiBpbWFnZS5uYXR1cmFsV2lkdGg7XG4gICAgICAgICAgICAgICAgLy8gUmVsZWFzZSBpdCBmcm9tIG1lbW9yeS5cbiAgICAgICAgICAgICAgICBkb21fMS5kb20uZGVsZXRlSW1hZ2UoaW1hZ2UpO1xuICAgICAgICAgICAgICAgIGltYWdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgaW50ZXJuYWxseSB1c2VkIGN1cnJlbnQgaW1hZ2Ugc2VldC5cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVJbWFnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUltYWdlU2V0LmltYWdlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhbiBjbGlwIHBhdGggdHlwZSBpbnRlcnBvbGF0aW9uIG9uIHRoZSBjYW52YXMgZHJhd2luZy5cbiAgICAgKiBDdXJyZW50bHkgb25seSBzdXBwb3J0cyBpbnNldCB0eXBlLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIGNhbnZhc0ltYWdlU2VxdWVuY2Uuc2V0Q2xpcEludGVycG9sYXRpb25zKHtcbiAgICAgKiAgIHR5cGU6ICdpbnNldCcsXG4gICAgICogICBpbnRlcnBvbGF0aW9uczogW1xuICAgICAqICAgICB7XG4gICAgICogICAgICAgcHJvZ3Jlc3M6IFt7IGZyb206IDAsIHRvOiAxLCBzdGFydDogMCwgZW5kOiAwLjV9XSxcbiAgICAgKiAgICAgICBpZDogJ3RvcCdcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIHByb2dyZXNzOiBbeyBmcm9tOiAwLCB0bzogMSwgc3RhcnQ6IDAsIGVuZDogMC41fV0sXG4gICAgICogICAgICAgaWQ6ICdyaWdodCdcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIHByb2dyZXNzOiBbeyBmcm9tOiAwLCB0bzogMSwgc3RhcnQ6IDAsIGVuZDogMC41fV0sXG4gICAgICogICAgICAgaWQ6ICdib3R0b20nXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBwcm9ncmVzczogW3sgZnJvbTogMCwgdG86IDEsIHN0YXJ0OiAwLCBlbmQ6IDAuNX1dLFxuICAgICAqICAgICAgIGlkOiAnbGVmdCdcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIHByb2dyZXNzOiBbeyBmcm9tOiAwLCB0bzogMSwgc3RhcnQ6IDAsIGVuZDogMC41fV0sXG4gICAgICogICAgICAgaWQ6ICdib3JkZXItcmFkaXVzJ1xuICAgICAqICAgICB9XG4gICAgICogICBdXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqXG4gICAgICogY2FudmFzSW1hZ2VTZXF1ZW5jZS5yZW5kZXJCeVByb2dyZXNzKDAuNSk7IC8vIFRoZSBjbGlwcGluZyBhdCAwLjUgcHJvZ3Jlc3MgaXMgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqL1xuICAgIHNldENsaXBJbnRlcnBvbGF0aW9ucyhjb25maWcpIHtcbiAgICAgICAgdGhpcy5jbGlwUGF0aFR5cGUgPSBjb25maWcudHlwZTtcbiAgICAgICAgdGhpcy5jbGlwTXVsdGlJbnRlcnBvbGF0ZSA9IG5ldyBtdWx0aV9pbnRlcnBvbGF0ZV8xLk11bHRpSW50ZXJwb2xhdGUoe1xuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbnM6IGNvbmZpZy5pbnRlcnBvbGF0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYnkgcHJvZ3Jlc3MuICAwIHdvdWxkIG1lYW4gdGhlIHZlcnkgZmlyc3QgZnJhbWUgYW5kIHRoZSAxIHdvdWxkXG4gICAgICogbWVhbiB0aGUgbGFzdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBBIHByb2dyZXNzIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcGFyYW0ge25vTXVsdGlJbnRlcnBvbGF0ZX0gQW4gb3B0aW9uIHRvIGZvcmNlIGV2YWx1YXRpb24gd2l0aG91dFxuICAgICAqICAgbXVsdGlJbnRlcnBvbGF0aW9uLiAgVGhpcyBpcyB1c2VmdWwgaW4gY2FzZXMgd2hlcmUgeW91IGhhdmVcbiAgICAgKiAgIG11bHRpSW50ZXJwb2xhdGlvbiBlbmFibGVkIGJ1dCB5b3Ugd2FudCB0byBtYW51YWxseSB1cGRhdGUgdGhlXG4gICAgICogICBwb3NpdGlvbiBvZiB0aGUgZnJhbWUgd2l0aG91dCBpdCB1c2luZyBtdWx0aUludGVycG9sYXRpb24uICBTaW1wbHksXG4gICAgICogICBiZWluZyBhYmxlIHRvIHNheSwgSSB3YW50IHRvIHJlbmRlciB0aGUgaW1hZ2Ugc2VxdW5jZSBhdCAwLjkgZm9yIGV4YW1wbGUuXG4gICAgICovXG4gICAgcmVuZGVyQnlQcm9ncmVzcyhuLCBub011bHRpSW50ZXJwb2xhdGUgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gbWF0aGZfMS5tYXRoZi5jbGFtcDAxKG4pO1xuICAgICAgICAhdGhpcy5pc1BsYXlpbmcgJiYgdGhpcy5yZW5kZXJQcm9ncmVzcyhuLCBub011bHRpSW50ZXJwb2xhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCByZW5kZXIgYnkgcHJvZ3Jlc3MgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gQSBwcm9ncmVzcyB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHBhcmFtIHtub011bHRpSW50ZXJwb2xhdGV9IEFuIG9wdGlvbiB0byBmb3JjZSBldmFsdWF0aW9uIHdpdGhvdXRcbiAgICAgKiAgIG11bHRpSW50ZXJwb2xhdGlvbi4gIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VzIHdoZXJlIHlvdSBoYXZlXG4gICAgICogICBtdWx0aUludGVycG9sYXRpb24gZW5hYmxlZCBidXQgeW91IHdhbnQgdG8gbWFudWFsbHkgdXBkYXRlIHRoZVxuICAgICAqICAgcG9zaXRpb24gb2YgdGhlIGZyYW1lIHdpdGhvdXQgaXQgdXNpbmcgbXVsdGlJbnRlcnBvbGF0aW9uLiAgU2ltcGx5LFxuICAgICAqICAgYmVpbmcgYWJsZSB0byBzYXksIEkgd2FudCB0byByZW5kZXIgdGhlIGltYWdlIHNlcXVuY2UgYXQgMC45IGZvciBleGFtcGxlLlxuICAgICAqL1xuICAgIHJlbmRlclByb2dyZXNzKG4sIG5vTXVsdGlJbnRlcnBvbGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBwcm9ncmVzcyA9IG1hdGhmXzEubWF0aGYuY2xhbXAwMShuKTtcbiAgICAgICAgLy8gSWYgdGhlIG9wdGlvbmFsIG11bHRpaW50ZXJwb2xhdGUgaXMgc2V0LCB0aGVuIHVzZSBtdWx0aUludGVycG9sYXRlXG4gICAgICAgIC8vIHRvIGZpZ3VyZSBvdXQgd2hhdCB0aGUgY29ycmVjdCBmcmFtZSBzaG91bGQgYmUuXG4gICAgICAgIGlmICh0aGlzLm11bHRpSW50ZXJwb2xhdGUgJiYgIW5vTXVsdGlJbnRlcnBvbGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVNYXAgPSB0aGlzLm11bHRpSW50ZXJwb2xhdGUuY2FsY3VsYXRlKHByb2dyZXNzKTtcbiAgICAgICAgICAgIHByb2dyZXNzID0gbWF0aGZfMS5tYXRoZi5jbGFtcDAxKGludGVycG9sYXRlTWFwWydzZXF1ZW5jZSddKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgY2xpcCBwYXRoIG11bHRsaSBpbnRlcnBvbGF0ZS5cbiAgICAgICAgaWYgKHRoaXMuY2xpcE11bHRpSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpcE11bHRpSW50ZXJwb2xhdGUuY2FsY3VsYXRlKHByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGbHVzaCBjYWNoZSBpZiBwcm9ncmVzcyBpcyAwIG9yIDEgdG8gZW5zdXJlIGZpbmFsIGZyYW1lIGlzIGFsd2F5c1xuICAgICAgICAvLyBwbGF5ZWQuXG4gICAgICAgIGlmIChwcm9ncmVzcyA+PSAwLjk1IHx8IHByb2dyZXNzIDw9IDAuMDUpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGZyYW1lIHRvIHJlbmRlciBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mXG4gICAgICAgIC8vIGZyYW1lcyBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUltYWdlU2V0KSB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbCA9IHRoaXMuYWN0aXZlSW1hZ2VTZXQuaW1hZ2VzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRGcmFtZSA9IE1hdGguY2VpbChtYXRoZl8xLm1hdGhmLmxlcnAoMCwgdG90YWwsIHByb2dyZXNzKSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckZyYW1lKHRhcmdldEZyYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgZ2l2ZW4gZnJhbWUgb24gdG8gdGhlIGh0bWwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gaVxuICAgICAqL1xuICAgIHJlbmRlckZyYW1lKGkpIHtcbiAgICAgICAgLy8gSWYgaW1hZ2VzIGFyZW4ndCBsb2FkZWQgeWV0LCBza2lwIGRyYXdpbmcuXG4gICAgICAgIGlmICghdGhpcy5yZWFkeVByb21pc2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRhcmdldEZyYW1lID0gaTtcbiAgICAgICAgLy8gSWYgdGhlIGRlbHRhIGJldHdlZW4gdGFyZ2V0IGFuZCBjdXJyZW50IGZyYW1lIGlzIGdyZWF0ZXIgdGhhblxuICAgICAgICAvLyAxIGFuZCB0aGVyZSBpcyBhIGxlcnAgdmFsdWUgc2V0LCBsZXJwIHRvd2FyZHMgdGhlIHRhcmdldCBmcmFtZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHNldCB0aGUgY3VycmVudEZyYW1lXG4gICAgICAgIC8vIHRvIHRoZSB0YXJnZXQgZm9yIGltbWVkaWF0ZSB1cGRhdGVzLlxuICAgICAgICAvLyBOb3RlIHRoYXQgYnkgZGVmYXVsdCwgdGhlIGxlcnAgYW1vdW50IGlzIHNldCB0byAxIChtZWFuaW5nIG5vIGxlcnApLFxuICAgICAgICBsZXQgZGlmZiA9IE1hdGguYWJzKHRoaXMudGFyZ2V0RnJhbWUgLSB0aGlzLmN1cnJlbnRGcmFtZSk7XG4gICAgICAgIGlmIChkaWZmID4gMSAmJiAhdGhpcy5pc1BsYXlpbmcgJiYgdGhpcy5sZXJwQW1vdW50IDwgMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSBtYXRoZl8xLm1hdGhmLmxlcnAodGhpcy5jdXJyZW50RnJhbWUsIHRoaXMudGFyZ2V0RnJhbWUsIHRoaXMubGVycEFtb3VudCk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGRlbHRhLCBrZWVwIHVwZGF0aW5nIHdpdGggUkFGIHVudGlsIGl0IGdldHMgcmVzb2x2ZWQuXG4gICAgICAgICAgICBkaWZmID0gTWF0aC5hYnModGhpcy50YXJnZXRGcmFtZSAtIHRoaXMuY3VycmVudEZyYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IDAuMDAxO1xuICAgICAgICAgICAgaWYgKGRpZmYgPj0gcHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRnJhbWUodGhpcy50YXJnZXRGcmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IHRoaXMudGFyZ2V0RnJhbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1hZ2VTb3VyY2UgPSB0aGlzLmFjdGl2ZUltYWdlU2V0LmltYWdlc1tNYXRoLnJvdW5kKHRoaXMuY3VycmVudEZyYW1lKV07XG4gICAgICAgIHRoaXMuZHJhdyhpbWFnZVNvdXJjZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoIHRoZSBkcmF3IGNhY2hlLlxuICAgICAqL1xuICAgIGZsdXNoKCkge1xuICAgICAgICB0aGlzLmRyYXcoJycpOyAvLyBNYWtlIGEgZW1wdHkgY2FsbCB0byBjbGVhciB0aGUgbWVtb2l6ZSBjYWNoZS5cbiAgICAgICAgdGhpcy5kcmF3KG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIHJlY3RhbmdsZSBvbiB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIGRyYXdSZWN0YW5nbGUoY29uZmlnKSB7XG4gICAgICAgIC8vIGxldCByYWRpdXNQZXJjZW50ID0gY29uZmlnLnJhZGl1cztcbiAgICAgICAgLy8gbGV0IGhlaWdodCA9IGNvbmZpZy50b3AgLSBjb25maWcuYm90dG9tO1xuICAgICAgICAvLyBsZXQgd2lkdGggPSBjb25maWcubGVmdCAtIGNvbmZpZy5yaWdodDtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGJvcmRlciByYWRpdXMgYXMgYSBwZXJjZW50YWdlLlxuICAgICAgICBjb25zdCByYWRpdXMgPSB7XG4gICAgICAgICAgICB0bDogY29uZmlnLnJhZGl1cyxcbiAgICAgICAgICAgIHRyOiBjb25maWcucmFkaXVzLFxuICAgICAgICAgICAgYnI6IGNvbmZpZy5yYWRpdXMsXG4gICAgICAgICAgICBibDogY29uZmlnLnJhZGl1cyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmNvbnRleHQubW92ZVRvKGNvbmZpZy5sZWZ0ICsgcmFkaXVzLnRsLCBjb25maWcudG9wKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmxpbmVUbyhjb25maWcucmlnaHQgLSByYWRpdXMudHIsIGNvbmZpZy50b3ApO1xuICAgICAgICB0aGlzLmNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjb25maWcucmlnaHQsIGNvbmZpZy50b3AsIGNvbmZpZy5yaWdodCwgY29uZmlnLnRvcCArIHJhZGl1cy50cik7XG4gICAgICAgIHRoaXMuY29udGV4dC5saW5lVG8oY29uZmlnLnJpZ2h0LCBjb25maWcuYm90dG9tIC0gcmFkaXVzLmJyKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY29uZmlnLnJpZ2h0LCBjb25maWcuYm90dG9tLCBjb25maWcucmlnaHQgLSByYWRpdXMuYnIsIGNvbmZpZy5ib3R0b20pO1xuICAgICAgICB0aGlzLmNvbnRleHQubGluZVRvKGNvbmZpZy5sZWZ0ICsgcmFkaXVzLmJsLCBjb25maWcuYm90dG9tKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY29uZmlnLmxlZnQsIGNvbmZpZy5ib3R0b20sIGNvbmZpZy5sZWZ0LCBjb25maWcuYm90dG9tIC0gcmFkaXVzLmJsKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmxpbmVUbyhjb25maWcubGVmdCwgY29uZmlnLnRvcCArIHJhZGl1cy50bCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbmZpZy5sZWZ0LCBjb25maWcudG9wLCBjb25maWcubGVmdCArIHJhZGl1cy50bCwgY29uZmlnLnRvcCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBjbGlwcGluZyB0byB0aGUgY2FudmFzIHByaW9yIHRvIGRyYXdpbmcuXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUGF0aDJEXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2NsaXBcbiAgICAgKi9cbiAgICBhcHBseUNhbnZhc0NsaXBwaW5nKCkge1xuICAgICAgICAvLyBNYWtlIGEgc2ltaWxhciBhbGdvIGFzIGluc2V0IGRvbmUgaW4gY3NzIGNsaXAtcGF0aC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gY2xpcC1wYXRoOiBpbnNldCh2YXIoLS1jbGlwLXRvcCkgdmFyKC0tY2xpcC1yaWdodCkgdmFyKC0tY2xpcC1ib3R0b20pIHZhcigtLWNsaXAtbGVmdCkgcm91bmQgdmFyKC0tY2xpcC1yYWRpdXMpKVxuICAgICAgICAvL1xuICAgICAgICAvLyBTaW5jZSBpdCdzIGFuIGluc2V0IGFsZ28sIDAlIHdvdWxkIG1lYW4gaXQgaXMgZnVsbHkgc2hvdy5cbiAgICAgICAgLy8gLSB0b3A6IDUwJSB3b3VsZCBtZWFuIHRoZSB0b3AgaGFsZiBpcyBtaXNzaW5nXG4gICAgICAgIC8vIC0gYm90dG9tOiA1MCUgd291bGQgbWVhbiB0aGUgYm90dG9tIGhhbGYgaXMgbWlzc2luZ1xuICAgICAgICAvLyAtIHJpZ2h0OiA1MCUgd291bGQgbWVhbiB0aGUgcmlnaHQgaGFsZiBpcyBtaXNzaW5nXG4gICAgICAgIC8vIC0gbGVmdDogNTAlIHdvdWxkIG1lYW4gdGhlIGxlZnQgaGFsZiBpcyBtaXNzaW5nXG4gICAgICAgIGlmICh0aGlzLmNsaXBQYXRoVHlwZSA9PT0gJ2luc2V0Jykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuY2xpcE11bHRpSW50ZXJwb2xhdGUuZ2V0Q2FsY3VsYXRpb25zKCkgfHwge307XG4gICAgICAgICAgICBjb25zdCB0b3AgPSByZXN1bHRzWyd0b3AnXSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gcmVzdWx0c1snYm90dG9tJ10gfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSByZXN1bHRzWydsZWZ0J10gfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gcmVzdWx0c1sncmlnaHQnXSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gcmVzdWx0c1snYm9yZGVyLXJhZGl1cyddIHx8IDA7XG4gICAgICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoe1xuICAgICAgICAgICAgICAgIHRvcDogdGhpcy5jYW52YXNIZWlnaHQgLSAoMSAtIHRvcCkgKiB0aGlzLmNhbnZhc0hlaWdodCxcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmNhbnZhc1dpZHRoIC0gKDEgLSBsZWZ0KSAqIHRoaXMuY2FudmFzV2lkdGgsXG4gICAgICAgICAgICAgICAgcmlnaHQ6ICgxIC0gcmlnaHQpICogdGhpcy5jYW52YXNXaWR0aCxcbiAgICAgICAgICAgICAgICBib3R0b206ICgxIC0gYm90dG9tKSAqIHRoaXMuY2FudmFzSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY2xpcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzV2lkdGgsIHRoaXMuY2FudmFzSGVpZ2h0KTtcbiAgICB9XG4gICAgYXN5bmMgZHJhdyhpbWFnZVNvdXJjZSkge1xuICAgICAgICAvLyBQcmV2ZW50IGludmFsaWQgZHJhd3NcbiAgICAgICAgaWYgKCFpbWFnZVNvdXJjZSB8fCB0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltYWdlU291cmNlID09PSB0aGlzLmxhc3REcmF3U291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0RHJhd1NvdXJjZSA9IGltYWdlU291cmNlO1xuICAgICAgICAvLyBJZiB0aGlzIHdhcyBjYWxsZWQgYXQgYSByYXRlIGV4Y2VlZGluZyB0aGUgZnBzIGxpbWl0LlxuICAgICAgICBpZiAoIXRoaXMuZnBzLmNhblJ1bigpKSB7XG4gICAgICAgICAgICB0aGlzLmZwcy5zY2hlZHVsZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgYSBkcmF3LiAgVGhpcyBlbnN1cmVzIHRoYXQgZXZlbiB3aXRoIEZQUyBsaW1pdGluZyxcbiAgICAgICAgICAgICAgICAvLyB0aGUgdmVyeSBsYXN0IGRyYXcgY2FsbCBpcyBhbHdheXMgcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0RHJhd1NvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3KGltYWdlU291cmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGltYWdlID0gYXdhaXQgdGhpcy5tYWtlSW1hZ2UoaW1hZ2VTb3VyY2UpO1xuICAgICAgICAvLyBEZWNvZGluZyBpbWFnZXMgaW4gdGhpcyB3YXksIHdlIHNlZSBhIGh1Z2UgbWVtb3J5IGp1bXAuICBBdm9pZCBmb3Igbm93LlxuICAgICAgICAvLyBhd2FpdCBpbWFnZS5kZWNvZGUoKTtcbiAgICAgICAgLy8gSWYgYW4gaW1hZ2UgY291bGRuJ3QgYmUgZ2VuZXJhdGVkIGZvciBzb21lIHJlYXNvbi5cbiAgICAgICAgaWYgKCFpbWFnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGltYWdlQm94ID0ge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMuaW1hZ2VOYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaW1hZ2VOYXR1cmFsSGVpZ2h0LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb250YWluZXJCb3ggPSB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5jYW52YXNXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5jYW52YXNIZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgaWYgKCFpc18xLmlzLm51bGwodGhpcy5jbGlwUGF0aFR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgdGhpcy5hcHBseUNhbnZhc0NsaXBwaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFja2dyb3VuZCBcImNvdmVyXCIgc2l6aW5nLlxuICAgICAgICAvLyBEZWZhdWx0cyB0byBjZW50ZXIuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmNvdmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjb3ZlciA9IG1hdGhmXzEubWF0aGYuY2FsY3VsYXRlQmFja2dyb3VuZENvdmVyKGNvbnRhaW5lckJveCwgaW1hZ2VCb3gpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiBpc18xLmlzLm51bWJlcih0aGlzLm9wdGlvbnMubGVmdCkpIHtcbiAgICAgICAgICAgICAgICBjb3Zlci54T2Zmc2V0ID1cbiAgICAgICAgICAgICAgICAgICAgKGNvbnRhaW5lckJveC53aWR0aCAtIGltYWdlQm94LndpZHRoICogY292ZXIuc2NhbGFyKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAtdGhpcy5vcHRpb25zLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIGlzXzEuaXMubnVtYmVyKHRoaXMub3B0aW9ucy5yaWdodCkpIHtcbiAgICAgICAgICAgICAgICAvLyBSaWdodCBhbGlnbiBmaXJzdC5cbiAgICAgICAgICAgICAgICBjb3Zlci54T2Zmc2V0ID0gLShjb250YWluZXJCb3gud2lkdGggLSBpbWFnZUJveC53aWR0aCAqIGNvdmVyLnNjYWxhcik7XG4gICAgICAgICAgICAgICAgY292ZXIueE9mZnNldCArPVxuICAgICAgICAgICAgICAgICAgICAoY29udGFpbmVyQm94LndpZHRoIC0gaW1hZ2VCb3gud2lkdGggKiBjb3Zlci5zY2FsYXIpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgaXNfMS5pcy5udW1iZXIodGhpcy5vcHRpb25zLmJvdHRvbSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdG8gYm90dG9tLlxuICAgICAgICAgICAgICAgIGNvdmVyLnlPZmZzZXQgPSAtKGNvbnRhaW5lckJveC5oZWlnaHQgLSBpbWFnZUJveC5oZWlnaHQgKiBjb3Zlci5zY2FsYXIpO1xuICAgICAgICAgICAgICAgIC8vIENsaXBwaW5nIEJvdHRvbSBhbGdvLlxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcGVyY2VudGFnZSBhbW91bnQgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGNvdmVyLnlPZmZzZXQgKz1cbiAgICAgICAgICAgICAgICAgICAgKGNvbnRhaW5lckJveC5oZWlnaHQgLSBpbWFnZUJveC5oZWlnaHQgKiBjb3Zlci5zY2FsYXIpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5ib3R0b207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIGlzXzEuaXMubnVtYmVyKHRoaXMub3B0aW9ucy50b3ApKSB7XG4gICAgICAgICAgICAgICAgY292ZXIueU9mZnNldCA9XG4gICAgICAgICAgICAgICAgICAgIChjb250YWluZXJCb3guaGVpZ2h0IC0gaW1hZ2VCb3guaGVpZ2h0ICogY292ZXIuc2NhbGFyKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAtdGhpcy5vcHRpb25zLnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIC1jb3Zlci54T2Zmc2V0ID4+IDAsIC1jb3Zlci55T2Zmc2V0ID4+IDAsIChpbWFnZUJveC53aWR0aCAqIGNvdmVyLnNjYWxhcikgPj4gMCwgKGltYWdlQm94LmhlaWdodCAqIGNvdmVyLnNjYWxhcikgPj4gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGNvbnRhaW4gc2l6aW5nIGFsZ28uXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5TY2FsZSA9IG1hdGhmXzEubWF0aGYuY2FsY3VsYXRlQmFja2dyb3VuZENvbnRhaW4oY29udGFpbmVyQm94LCBpbWFnZUJveCk7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGNlbnRlciBhbGdvLlxuICAgICAgICAgICAgbGV0IGRpZmZYID0gKGNvbnRhaW5lckJveC53aWR0aCAtIGltYWdlQm94LndpZHRoICogdGhpcy5jb250YWluU2NhbGUpIC8gMjtcbiAgICAgICAgICAgIGxldCBkaWZmWSA9IChjb250YWluZXJCb3guaGVpZ2h0IC0gaW1hZ2VCb3guaGVpZ2h0ICogdGhpcy5jb250YWluU2NhbGUpIC8gMjtcbiAgICAgICAgICAgIC8vIFNpemluZyBvcHRpb24gbG9naWMuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIGlzXzEuaXMubnVtYmVyKHRoaXMub3B0aW9ucy5ib3R0b20pKSB7XG4gICAgICAgICAgICAgICAgLy8gQm90dG9tIGFsaWduIGl0LlxuICAgICAgICAgICAgICAgIGRpZmZZID0gY29udGFpbmVyQm94LmhlaWdodCAtIGltYWdlQm94LmhlaWdodCAqIHRoaXMuY29udGFpblNjYWxlO1xuICAgICAgICAgICAgICAgIC8vIEVhc3kgd2F5IHRvIHRlc3QgdGhpcyBpcyB0byBzZXQgYm90dG9tOiAxIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJvdHRvbUNsaXBwaW5nOiBmYWxzZSB3aGljaCB3b3VsZCB0b3AgYWxpZ24gdGhlIGltYWdlLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYm90dG9tTm9DbGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZZIC09XG4gICAgICAgICAgICAgICAgICAgICAgICAoY29udGFpbmVyQm94LmhlaWdodCAtIGltYWdlQm94LmhlaWdodCAqIHRoaXMuY29udGFpblNjYWxlKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsaXBwaW5nIEJvdHRvbSBhbGdvLlxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHBlcmNlbnRhZ2UgYW1vdW50IHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgZGlmZlkgLT0gY29udGFpbmVyQm94LmhlaWdodCAqIHRoaXMub3B0aW9ucy5ib3R0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiBpc18xLmlzLm51bWJlcih0aGlzLm9wdGlvbnMucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gUmlnaHQgYWxpZ24gaXQuXG4gICAgICAgICAgICAgICAgZGlmZlggPSBjb250YWluZXJCb3gud2lkdGggLSBpbWFnZUJveC53aWR0aCAqIHRoaXMuY29udGFpblNjYWxlO1xuICAgICAgICAgICAgICAgIC8vIEVhc3kgd2F5IHRvIHRlc3QgdGhpcyBpcyB0byBzZXQgcmlnaHQ6IDEgYW5kXG4gICAgICAgICAgICAgICAgLy8gcmlnaHRDbGlwcGluZzogZmFsc2Ugd2hpY2ggd291bGQgbGVmdCBhbGlnbiB0aGUgaW1hZ2UuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yaWdodE5vQ2xpcCkge1xuICAgICAgICAgICAgICAgICAgICBkaWZmWCAtPVxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnRhaW5lckJveC53aWR0aCAtIGltYWdlQm94LndpZHRoICogdGhpcy5jb250YWluU2NhbGUpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGlwcGluZyByaWdodCBhbGdvLlxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHBlcmNlbnRhZ2UgYW1vdW50IHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgZGlmZlggLT0gY29udGFpbmVyQm94LndpZHRoICogdGhpcy5vcHRpb25zLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgaXNfMS5pcy5udW1iZXIodGhpcy5vcHRpb25zLnRvcCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUb3AgYWxpZ24gaXQuXG4gICAgICAgICAgICAgICAgZGlmZlkgPSAwO1xuICAgICAgICAgICAgICAgIC8vIEVhc3kgd2F5IHRvIHRlc3QgdGhpcyBpcyB0byBzZXQgdG9wOiAxIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRvcENsaXBwaW5nOiBmYWxzZSB3aGljaCB3b3VsZCBib3R0b20gYWxpZ25lZCB0aGUgaW1hZ2UuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50b3BOb0NsaXApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZlkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnRhaW5lckJveC5oZWlnaHQgLSBpbWFnZUJveC5oZWlnaHQgKiB0aGlzLmNvbnRhaW5TY2FsZSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50b3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGlwcGluZyBUb3AgYWxnby5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBwZXJjZW50YWdlIGFtb3VudCBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGRpZmZZICs9IHRoaXMub3B0aW9ucy50b3AgKiBjb250YWluZXJCb3guaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgaXNfMS5pcy5udW1iZXIodGhpcy5vcHRpb25zLmxlZnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gTGVmdCBhbGlnbiBpdC5cbiAgICAgICAgICAgICAgICBkaWZmWCA9IDA7XG4gICAgICAgICAgICAgICAgLy8gRWFzeSB3YXkgdG8gdGVzdCB0aGlzIGlzIHRvIHNldCBsZWZ0OiAxIGFuZFxuICAgICAgICAgICAgICAgIC8vIGxlZnRDbGlwcGluZzogZmFsc2Ugd2hpY2ggd291bGQgcmlnaHQgYWxpZ25lZCB0aGUgaW1hZ2UuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sZWZ0Tm9DbGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZYID1cbiAgICAgICAgICAgICAgICAgICAgICAgIChjb250YWluZXJCb3gud2lkdGggLSBpbWFnZUJveC53aWR0aCAqIHRoaXMuY29udGFpblNjYWxlKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGlwcGluZyBsZWZ0IGFsZ28uXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcGVyY2VudGFnZSBhbW91bnQgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBkaWZmWCArPSB0aGlzLm9wdGlvbnMubGVmdCAqIGNvbnRhaW5lckJveC53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCBkaWZmWCA+PiAwLCBkaWZmWSA+PiAwLCAoaW1hZ2VCb3gud2lkdGggKiB0aGlzLmNvbnRhaW5TY2FsZSkgPj4gMCwgKGltYWdlQm94LmhlaWdodCAqIHRoaXMuY29udGFpblNjYWxlKSA+PiAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzXzEuaXMubnVsbCh0aGlzLmNsaXBQYXRoVHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0UmVuZGVyU291cmNlID0gaW1hZ2VTb3VyY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIHNpemluZyBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgc2V0U2l6aW5nT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBsYXlzIHRoZSBjYW52YXMgaW1hZ2Ugc2VxdWVuY2Ugd2l0aCBhIHRpbWVyLiBQbGF5aW5nIHdpbGwgXCJoaWphY2tcIiB0aGVcbiAgICAgKiBwcm9ncmVzcyBldmVudHMgd2hpbGUgcGxheWluZy4gICBGb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogICAgY2FudmFzSW1hZ2VTZXF1ZW5jZS5wbGF5KDAsIDEsIDMwMDApLnRoZW4oKCkgPT4ge1xuICAgICAqICAgICAgIGNvbnNvbGUubG9nKCdwbGF5IGNvbXBsZXRlJyk7XG4gICAgICogICB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEhlcmUgd2UgdGVsbCB0aGUgY2FudmFzSW1hZ2VTZXF1ZW5jZSB0byBwbGF5IGZyb20gc3RhcnQgdG8gZW5kIG92ZXJcbiAgICAgKiBhIDMwMDBtcyBwZXJpb2QuICBEdXJpbmcgdGhpcyAzMDAwbXMgcGVyaW9kLCBhbnkgY2FsbHMgb3RoZXIgdG9cbiAgICAgKiBjYWxscyBcInJlbmRlckJ5UHJvZ3Jlc3NcIiB3aWxsIGdldCBpZ25vcmVkIHNpbmNlIHRoZXkgY2FuIGNvbmZsaWN0IHdpdGhcbiAgICAgKiB0aGUgcGxheWJhY2suXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmcm9tIEEgbnVtYmVyIGJldHdlZW4gMCAtIDFcbiAgICAgKiBAcGFyYW0gdG8gQSBudW1iZXIgYmV0d2VlbiAwIC0gMVxuICAgICAqIEBwYXJhbSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gaW4gbXMuXG4gICAgICogQHJldHVybiBQcm9taXNlIEEgcHJvbWlzZSB0aGF0IGNvbXBsZXRlcyB3aGVuIGRvbmUuXG4gICAgICovXG4gICAgcGxheShmcm9tLCB0bywgZHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMucmFmVGltZXIgPSBuZXcgcmFmX3RpbWVyXzEuUmFmVGltZXIoKHByb2dyZXNzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRQcm9ncmVzcyA9IG1hdGhmXzEubWF0aGYuaW50ZXJwb2xhdGVSYW5nZShwcm9ncmVzcywgMCwgMSwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJQcm9ncmVzcyhpbnRlcnBvbGF0ZWRQcm9ncmVzcyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJhZlRpbWVyLnNldER1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5wbGF5RGVmZXIgPSBuZXcgZGVmZXJfMS5EZWZlcigpO1xuICAgICAgICB0aGlzLnJhZlRpbWVyLm9uQ29tcGxldGUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGxheURlZmVyLnJlc29sdmUoKTtcbiAgICAgICAgICAgIHRoaXMucmFmVGltZXIuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yYWZUaW1lci5wbGF5KCk7XG4gICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxheURlZmVyLmdldFByb21pc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGV4IGNvbG9yIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcyBvZiB0aGUgY2FudmFzIGFzIGl0IGlzXG4gICAgICogcmVuZGVycyBhdCB0aGUgbW9tZW50LlxuICAgICAqIEBwYXJhbSBjb29yZHNcbiAgICAgKi9cbiAgICBnZXRIZXhDb2xvckF0UG9pbnQoY29vcmRzKSB7XG4gICAgICAgIHJldHVybiBkb21fY2FudmFzXzEuZG9tQ2FudmFzLmdldENvbG9yQXRQb2ludEFzSGV4KHRoaXMuY29udGV4dCwgY29vcmRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1tZWRpYXRlbHkgc3RvcHMgdGhlIGNhbnZhcyBhbmltYXRpb24gcGxheWluZy5cbiAgICAgKiAodGhhdCBoYXBwZW5zIHdpdGggcGxheSBtZXRob2QpLlxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMucmFmVGltZXIgJiYgdGhpcy5yYWZUaW1lci5wYXVzZSgpO1xuICAgICAgICB0aGlzLnJhZlRpbWVyICYmIHRoaXMucmFmVGltZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnBsYXlEZWZlciAmJiB0aGlzLnBsYXlEZWZlci5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGltYWdlIGRpbWVuc2lvbiB0aGF0IHdlcmUgZmV0Y2hlZC4gIFRoaXMgaXMgYmFzZWRcbiAgICAgKiBvbiB0aGUgXCJmaXJzdFwiIGltYWdlIGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgKiBUaGUgc2l6ZXMgd2lsbCBiZSBudWxsIGlmIGNhbGxlZCBwcmlvciB0byBsb2FkaW5nIGltYWdlcy5cbiAgICAgKi9cbiAgICBnZXRJbWFnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5pbWFnZU5hdHVyYWxXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5pbWFnZU5hdHVyYWxIZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5kb21XYXRjaGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5yYWZUaW1lciAmJiB0aGlzLnJhZlRpbWVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5ibG9iTG9hZGVyICYmIHRoaXMuYmxvYkxvYWRlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuYmxvYkNhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgZG9tXzEuZG9tLmRlbGV0ZUltYWdlKHRoaXMuY2FjaGVJbWFnZSk7XG4gICAgICAgIHRoaXMuY2FjaGVJbWFnZSA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5DYW52YXNJbWFnZVNlcXVlbmNlID0gQ2FudmFzSW1hZ2VTZXF1ZW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbnZhcy1pbWFnZS1zZXF1ZW5jZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/dom/canvas-image-sequence.js\n");

/***/ }),

/***/ "./lib/dom/document-mouse-tracker.js":
/*!*******************************************!*\
  !*** ./lib/dom/document-mouse-tracker.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mouse_tracker_1 = __webpack_require__(/*! ./mouse-tracker */ \"./lib/dom/mouse-tracker.js\");\n/**\n * A global singleton instance of the mouse tracker attached to the document body.\n */\nconst documentMouseTracker = new mouse_tracker_1.MouseTracker(document.body, () => { }, false);\nexports.default = documentMouseTracker;\n//# sourceMappingURL=document-mouse-tracker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL2RvY3VtZW50LW1vdXNlLXRyYWNrZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL2RvY3VtZW50LW1vdXNlLXRyYWNrZXIuanM/MDQ0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG1vdXNlX3RyYWNrZXJfMSA9IHJlcXVpcmUoXCIuL21vdXNlLXRyYWNrZXJcIik7XG4vKipcbiAqIEEgZ2xvYmFsIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGUgbW91c2UgdHJhY2tlciBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQgYm9keS5cbiAqL1xuY29uc3QgZG9jdW1lbnRNb3VzZVRyYWNrZXIgPSBuZXcgbW91c2VfdHJhY2tlcl8xLk1vdXNlVHJhY2tlcihkb2N1bWVudC5ib2R5LCAoKSA9PiB7IH0sIGZhbHNlKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRvY3VtZW50TW91c2VUcmFja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9jdW1lbnQtbW91c2UtdHJhY2tlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/dom/document-mouse-tracker.js\n");

/***/ }),

/***/ "./lib/dom/dom-canvas.js":
/*!*******************************!*\
  !*** ./lib/dom/dom-canvas.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.domCanvas = void 0;\nconst color_1 = __webpack_require__(/*! ../mathf/color */ \"./lib/mathf/color.js\");\n/**\n * Very basic HTML5 canvas helper methods.\n * @unstable\n */\nclass domCanvas {\n    constructor() { }\n    static setFillColor(context, fillColor) {\n        context.fillStyle = fillColor;\n    }\n    static setStrokeColor(context, strokeColor) {\n        context.strokeStyle = strokeColor;\n    }\n    static line(context, x1, y1, x2, y2) {\n        context.beginPath();\n        context.moveTo(x1, y1);\n        context.lineTo(x2, y2);\n        context.stroke();\n    }\n    /**\n     * Display text at given coordinates.   Quick because this method is\n     * just if you want to output something quickly without concent to\n     * font-size style.\n     * @param context\n     * @param text\n     */\n    static quickText(context, text, x, y) {\n        context.font = '12px sans-serif';\n        context.strokeText(text, x, y);\n    }\n    static point(context, x, y, size = 5) {\n        context.fillRect(x, y, size, size);\n    }\n    static vectorLine(context, v1, v2) {\n        domCanvas.line(context, v1.x, v1.y, v2.x, v2.y);\n    }\n    static vectorPoint(context, v, size = 5) {\n        domCanvas.point(context, v.x, v.y, size);\n    }\n    static vectorQuadrilateral(context, v1, v2, v3, v4) {\n        context.beginPath();\n        context.moveTo(v1.x, v1.y);\n        context.lineTo(v2.x, v2.y);\n        context.lineTo(v3.x, v3.y);\n        context.lineTo(v4.x, v4.y);\n        context.closePath();\n        context.fill();\n    }\n    /**\n     * Given a list of Vectors, draws lines from start to end.\n     */\n    static drawVectors(context, vectors) {\n        context.beginPath();\n        context.moveTo(vectors[0].x, vectors[0].y);\n        vectors.forEach(v => {\n            context.lineTo(v.x, v.y);\n        });\n        context.closePath();\n        context.fill();\n    }\n    /**\n     * Acquires the pixel color of given coordinates on the canvas.\n     */\n    static getColorAtPointAsRgb(context, coords) {\n        const pixelData = context.getImageData(coords.x, coords.y, 1, 1).data;\n        const rgb = {\n            r: pixelData[0],\n            g: pixelData[1],\n            b: pixelData[2],\n        };\n        return rgb;\n    }\n    /**\n     * Acquires the pixel color of given coordinates on the canvas\n     * as returns it as a hex value.\n     */\n    static getColorAtPointAsHex(context, coords) {\n        const rgb = domCanvas.getColorAtPointAsRgb(context, coords);\n        return color_1.color.rgbToHex(rgb);\n    }\n}\nexports.domCanvas = domCanvas;\n//# sourceMappingURL=dom-canvas.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL2RvbS1jYW52YXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL2RvbS1jYW52YXMuanM/ODZkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZG9tQ2FudmFzID0gdm9pZCAwO1xuY29uc3QgY29sb3JfMSA9IHJlcXVpcmUoXCIuLi9tYXRoZi9jb2xvclwiKTtcbi8qKlxuICogVmVyeSBiYXNpYyBIVE1MNSBjYW52YXMgaGVscGVyIG1ldGhvZHMuXG4gKiBAdW5zdGFibGVcbiAqL1xuY2xhc3MgZG9tQ2FudmFzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIHN0YXRpYyBzZXRGaWxsQ29sb3IoY29udGV4dCwgZmlsbENvbG9yKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZmlsbENvbG9yO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0U3Ryb2tlQ29sb3IoY29udGV4dCwgc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yO1xuICAgIH1cbiAgICBzdGF0aWMgbGluZShjb250ZXh0LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4MSwgeTEpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IHRleHQgYXQgZ2l2ZW4gY29vcmRpbmF0ZXMuICAgUXVpY2sgYmVjYXVzZSB0aGlzIG1ldGhvZCBpc1xuICAgICAqIGp1c3QgaWYgeW91IHdhbnQgdG8gb3V0cHV0IHNvbWV0aGluZyBxdWlja2x5IHdpdGhvdXQgY29uY2VudCB0b1xuICAgICAqIGZvbnQtc2l6ZSBzdHlsZS5cbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEBwYXJhbSB0ZXh0XG4gICAgICovXG4gICAgc3RhdGljIHF1aWNrVGV4dChjb250ZXh0LCB0ZXh0LCB4LCB5KSB7XG4gICAgICAgIGNvbnRleHQuZm9udCA9ICcxMnB4IHNhbnMtc2VyaWYnO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQodGV4dCwgeCwgeSk7XG4gICAgfVxuICAgIHN0YXRpYyBwb2ludChjb250ZXh0LCB4LCB5LCBzaXplID0gNSkge1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHgsIHksIHNpemUsIHNpemUpO1xuICAgIH1cbiAgICBzdGF0aWMgdmVjdG9yTGluZShjb250ZXh0LCB2MSwgdjIpIHtcbiAgICAgICAgZG9tQ2FudmFzLmxpbmUoY29udGV4dCwgdjEueCwgdjEueSwgdjIueCwgdjIueSk7XG4gICAgfVxuICAgIHN0YXRpYyB2ZWN0b3JQb2ludChjb250ZXh0LCB2LCBzaXplID0gNSkge1xuICAgICAgICBkb21DYW52YXMucG9pbnQoY29udGV4dCwgdi54LCB2LnksIHNpemUpO1xuICAgIH1cbiAgICBzdGF0aWMgdmVjdG9yUXVhZHJpbGF0ZXJhbChjb250ZXh0LCB2MSwgdjIsIHYzLCB2NCkge1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyh2MS54LCB2MS55KTtcbiAgICAgICAgY29udGV4dC5saW5lVG8odjIueCwgdjIueSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHYzLngsIHYzLnkpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh2NC54LCB2NC55KTtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgbGlzdCBvZiBWZWN0b3JzLCBkcmF3cyBsaW5lcyBmcm9tIHN0YXJ0IHRvIGVuZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZHJhd1ZlY3RvcnMoY29udGV4dCwgdmVjdG9ycykge1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyh2ZWN0b3JzWzBdLngsIHZlY3RvcnNbMF0ueSk7XG4gICAgICAgIHZlY3RvcnMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHYueCwgdi55KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3F1aXJlcyB0aGUgcGl4ZWwgY29sb3Igb2YgZ2l2ZW4gY29vcmRpbmF0ZXMgb24gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29sb3JBdFBvaW50QXNSZ2IoY29udGV4dCwgY29vcmRzKSB7XG4gICAgICAgIGNvbnN0IHBpeGVsRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKGNvb3Jkcy54LCBjb29yZHMueSwgMSwgMSkuZGF0YTtcbiAgICAgICAgY29uc3QgcmdiID0ge1xuICAgICAgICAgICAgcjogcGl4ZWxEYXRhWzBdLFxuICAgICAgICAgICAgZzogcGl4ZWxEYXRhWzFdLFxuICAgICAgICAgICAgYjogcGl4ZWxEYXRhWzJdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3F1aXJlcyB0aGUgcGl4ZWwgY29sb3Igb2YgZ2l2ZW4gY29vcmRpbmF0ZXMgb24gdGhlIGNhbnZhc1xuICAgICAqIGFzIHJldHVybnMgaXQgYXMgYSBoZXggdmFsdWUuXG4gICAgICovXG4gICAgc3RhdGljIGdldENvbG9yQXRQb2ludEFzSGV4KGNvbnRleHQsIGNvb3Jkcykge1xuICAgICAgICBjb25zdCByZ2IgPSBkb21DYW52YXMuZ2V0Q29sb3JBdFBvaW50QXNSZ2IoY29udGV4dCwgY29vcmRzKTtcbiAgICAgICAgcmV0dXJuIGNvbG9yXzEuY29sb3IucmdiVG9IZXgocmdiKTtcbiAgICB9XG59XG5leHBvcnRzLmRvbUNhbnZhcyA9IGRvbUNhbnZhcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvbS1jYW52YXMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/dom/dom-canvas.js\n");

/***/ }),

/***/ "./lib/dom/dom-watcher.js":
/*!********************************!*\
  !*** ./lib/dom/dom-watcher.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DomWatcher = void 0;\nconst bom_1 = __webpack_require__(/*! ../dom/bom */ \"./lib/dom/bom.js\");\nconst is_1 = __webpack_require__(/*! ../is/is */ \"./lib/is/is.js\");\n/**\n * A class that helps with DOM events.  The main usecase for this class is\n * to be able to watch the dom and then later remove a group of events\n * all at once.\n *\n * Basic Usage\n * ```ts\n * let watcher = new DomWatcher();\n *\n * var scrollCallback = (event, done)=> {\n *   // on scroll events.\n * };\n * watcher.add({\n *   element: window,\n *   on: 'scroll',\n *   callback: scrollCallback,\n *   eventOptions: { passive: true }\n * })\n *\n * watcher.add({\n *   element: element,\n *   on: 'click',\n *   callback: ()=> {},\n * );\n *\n *\n * # Add multiple events\n * watcher.add({\n *   element: element,\n *   on: ['click', 'mousemove'],\n *   callback: ()=> {},\n * );\n *\n *\n * // Removes all watchers.\n * watcher.removeAll();\n * ```\n *\n *\n * Advanged Usage\n * ```ts\n * let new watcher = new DomWatcher();\n *\n * // Removes by Id\n * watcher.add({\n *   element: element,\n *   on: 'click',\n *   callback: ()=> {},\n *   id: 'abc'\n * );\n *\n *\n * // Runs the callback associated with abc.  NOTE this is just dry running it\n * // so it's not an actual browser event (hence no event data is provided).\n * watcher.run('abc');\n *\n * watcher.removeById('abc');\n *\n *\n * // Ids actually don't need to be unique.\n * watcher.add({ element: element, on: 'click', callback: ()=> {}, id: 'group1');\n * watcher.add({ element: anotherElement, on: 'mousemove', callback: ()=> {}, id: 'group1');\n * watcher.removeById('group1');\n *\n * // Conditional execution\n * watcher.add({\n *    element: window\n *    callback: ()=> {\n *      console.log('called only on mobile');\n *    }\n *    eventOptions: { passive: true }\n *    on: 'scroll',\n *    runWhen: window.innerWidth < 600\n * });\n *\n *\n * watcher.add({\n *    element: submitElement\n *    callback: ()=> {\n *      console.log('submitted');\n *    }\n *    on: 'click',\n *    runWhen: ()=> { return this.validate()}\n * });\n *\n * ```\n *\n *\n * #### Debouncing\n *\n * ```ts\n * // Add debouncing.\n *     watcher.add({\n *         element: document.body,\n *         on: 'mousemove',\n *         callback: func.debounce((event) => {\n *             console.log('movemove!!');\n *         }, 500),\n *     });\n *\n * ```\n *\n * #### SmartResize\n * How can I use this with bom.smartResize?\n * Just use the 'smartResize' event instead.\n *\n * ```ts\n *\n *     watcher.add({\n *         element: window,\n *         on: 'smartResize',\n *         callback: (event) => {\n *             console.log('smart resizing');\n *         },\n *     });\n *\n * ```\n *\n *\n * Culling events only when an element is inview.\n * See example/scroll-demo for actual example.\n *\n * ```ts\n *   let ev = elementVisibility.inview(element, {});\n *   let watcher = new DomWatcher();\n *   watcher.add({\n *      element: window,\n *      on: 'scroll',\n *      eventOptions: { passive: true },\n *      callback: ()=> {\n *         // Runs only when this element is inview.\n *      },\n *      // Tells to run scroll ONLY when the element is inview.\n *      runWhen: ()=> { return ev.state().inview; }\n *   });\n *\n *\n *   // Later\n *   ev.dispose();\n *   watcher.dispose();\n *\n * ```\n *\n *\n */\nclass DomWatcher {\n    constructor() {\n        this.watcherConfigs = [];\n    }\n    /**\n     * Adds a watcher and immediately begins watching.\n     * @param config\n     */\n    add(config) {\n        // Check whether config.on is a array with multiple events such\n        // as ['click', 'mousemove'] or is a single event.\n        if (is_1.is.array(config.on)) {\n            const events = config.on;\n            events.forEach((eventName) => {\n                const clone = Object.assign({}, config);\n                clone.on = eventName;\n                this.addSingleEvent(clone);\n            });\n        }\n        else {\n            this.addSingleEvent(config);\n        }\n    }\n    /**\n     * Adds a single event.\n     * @param config\n     */\n    addSingleEvent(config) {\n        const listener = (event) => {\n            if (config.runWhen) {\n                config.runWhen() && config.callback(event);\n            }\n            else {\n                config.callback(event);\n            }\n        };\n        config.listener = listener;\n        // If the on event is smartResize, wrap it with dom.smartResize.\n        if (config.on === 'smartResize') {\n            config.remover = bom_1.bom.smartResize(listener, config.eventOptions || {});\n        }\n        else {\n            // Add listening.\n            config.element.addEventListener(config.on, listener, config.eventOptions || {});\n            // Generate the remover.\n            config.remover = () => {\n                config.element.removeEventListener(config.on, listener, config.eventOptions || {});\n            };\n        }\n        this.watcherConfigs.push(config);\n    }\n    /**\n     * Removes a given watcher by id.\n     * @param id The id of the watcher to remove.\n     */\n    removeById(id) {\n        this.watcherConfigs = this.watcherConfigs.filter((config) => {\n            if (config.id && config.id === id) {\n                // Save as var to avoid typescript null error.\n                const remover = config.remover;\n                remover && remover();\n                return false;\n            }\n            return config;\n        });\n    }\n    /**\n     * Removes all dom watchers.\n     */\n    removeAll() {\n        this.watcherConfigs.forEach(config => {\n            const remover = config.remover;\n            remover && remover();\n        });\n        this.watcherConfigs = [];\n    }\n    /**\n     *\n     * Dry runs a callback by id.  This just calls the callback and isn't the\n     * actual browser event so no event data will be available when using\n     * this method.\n     *\n     * ```ts\n     * watcher.add({\n     *    element: element,\n     *    callback: ()=> {\n     *      console.log('yo');\n     *    }\n     *    on: 'click',\n     *    id: 'yo'\n     * });\n     *\n     * watcher.run('yo');\n     * ```\n     * @param id\n     */\n    run(id) {\n        const configsToRun = this.watcherConfigs.filter((config) => {\n            return config.id && config.id === id;\n        });\n        configsToRun.forEach(config => {\n            config.callback() && config.callback();\n        });\n    }\n    /**\n     * Disposes of domWatcher.\n     */\n    dispose() {\n        this.removeAll();\n    }\n}\nexports.DomWatcher = DomWatcher;\n//# sourceMappingURL=dom-watcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL2RvbS13YXRjaGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2RvbS9kb20td2F0Y2hlci5qcz9lOWI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Eb21XYXRjaGVyID0gdm9pZCAwO1xuY29uc3QgYm9tXzEgPSByZXF1aXJlKFwiLi4vZG9tL2JvbVwiKTtcbmNvbnN0IGlzXzEgPSByZXF1aXJlKFwiLi4vaXMvaXNcIik7XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBoZWxwcyB3aXRoIERPTSBldmVudHMuICBUaGUgbWFpbiB1c2VjYXNlIGZvciB0aGlzIGNsYXNzIGlzXG4gKiB0byBiZSBhYmxlIHRvIHdhdGNoIHRoZSBkb20gYW5kIHRoZW4gbGF0ZXIgcmVtb3ZlIGEgZ3JvdXAgb2YgZXZlbnRzXG4gKiBhbGwgYXQgb25jZS5cbiAqXG4gKiBCYXNpYyBVc2FnZVxuICogYGBgdHNcbiAqIGxldCB3YXRjaGVyID0gbmV3IERvbVdhdGNoZXIoKTtcbiAqXG4gKiB2YXIgc2Nyb2xsQ2FsbGJhY2sgPSAoZXZlbnQsIGRvbmUpPT4ge1xuICogICAvLyBvbiBzY3JvbGwgZXZlbnRzLlxuICogfTtcbiAqIHdhdGNoZXIuYWRkKHtcbiAqICAgZWxlbWVudDogd2luZG93LFxuICogICBvbjogJ3Njcm9sbCcsXG4gKiAgIGNhbGxiYWNrOiBzY3JvbGxDYWxsYmFjayxcbiAqICAgZXZlbnRPcHRpb25zOiB7IHBhc3NpdmU6IHRydWUgfVxuICogfSlcbiAqXG4gKiB3YXRjaGVyLmFkZCh7XG4gKiAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gKiAgIG9uOiAnY2xpY2snLFxuICogICBjYWxsYmFjazogKCk9PiB7fSxcbiAqICk7XG4gKlxuICpcbiAqICMgQWRkIG11bHRpcGxlIGV2ZW50c1xuICogd2F0Y2hlci5hZGQoe1xuICogICBlbGVtZW50OiBlbGVtZW50LFxuICogICBvbjogWydjbGljaycsICdtb3VzZW1vdmUnXSxcbiAqICAgY2FsbGJhY2s6ICgpPT4ge30sXG4gKiApO1xuICpcbiAqXG4gKiAvLyBSZW1vdmVzIGFsbCB3YXRjaGVycy5cbiAqIHdhdGNoZXIucmVtb3ZlQWxsKCk7XG4gKiBgYGBcbiAqXG4gKlxuICogQWR2YW5nZWQgVXNhZ2VcbiAqIGBgYHRzXG4gKiBsZXQgbmV3IHdhdGNoZXIgPSBuZXcgRG9tV2F0Y2hlcigpO1xuICpcbiAqIC8vIFJlbW92ZXMgYnkgSWRcbiAqIHdhdGNoZXIuYWRkKHtcbiAqICAgZWxlbWVudDogZWxlbWVudCxcbiAqICAgb246ICdjbGljaycsXG4gKiAgIGNhbGxiYWNrOiAoKT0+IHt9LFxuICogICBpZDogJ2FiYydcbiAqICk7XG4gKlxuICpcbiAqIC8vIFJ1bnMgdGhlIGNhbGxiYWNrIGFzc29jaWF0ZWQgd2l0aCBhYmMuICBOT1RFIHRoaXMgaXMganVzdCBkcnkgcnVubmluZyBpdFxuICogLy8gc28gaXQncyBub3QgYW4gYWN0dWFsIGJyb3dzZXIgZXZlbnQgKGhlbmNlIG5vIGV2ZW50IGRhdGEgaXMgcHJvdmlkZWQpLlxuICogd2F0Y2hlci5ydW4oJ2FiYycpO1xuICpcbiAqIHdhdGNoZXIucmVtb3ZlQnlJZCgnYWJjJyk7XG4gKlxuICpcbiAqIC8vIElkcyBhY3R1YWxseSBkb24ndCBuZWVkIHRvIGJlIHVuaXF1ZS5cbiAqIHdhdGNoZXIuYWRkKHsgZWxlbWVudDogZWxlbWVudCwgb246ICdjbGljaycsIGNhbGxiYWNrOiAoKT0+IHt9LCBpZDogJ2dyb3VwMScpO1xuICogd2F0Y2hlci5hZGQoeyBlbGVtZW50OiBhbm90aGVyRWxlbWVudCwgb246ICdtb3VzZW1vdmUnLCBjYWxsYmFjazogKCk9PiB7fSwgaWQ6ICdncm91cDEnKTtcbiAqIHdhdGNoZXIucmVtb3ZlQnlJZCgnZ3JvdXAxJyk7XG4gKlxuICogLy8gQ29uZGl0aW9uYWwgZXhlY3V0aW9uXG4gKiB3YXRjaGVyLmFkZCh7XG4gKiAgICBlbGVtZW50OiB3aW5kb3dcbiAqICAgIGNhbGxiYWNrOiAoKT0+IHtcbiAqICAgICAgY29uc29sZS5sb2coJ2NhbGxlZCBvbmx5IG9uIG1vYmlsZScpO1xuICogICAgfVxuICogICAgZXZlbnRPcHRpb25zOiB7IHBhc3NpdmU6IHRydWUgfVxuICogICAgb246ICdzY3JvbGwnLFxuICogICAgcnVuV2hlbjogd2luZG93LmlubmVyV2lkdGggPCA2MDBcbiAqIH0pO1xuICpcbiAqXG4gKiB3YXRjaGVyLmFkZCh7XG4gKiAgICBlbGVtZW50OiBzdWJtaXRFbGVtZW50XG4gKiAgICBjYWxsYmFjazogKCk9PiB7XG4gKiAgICAgIGNvbnNvbGUubG9nKCdzdWJtaXR0ZWQnKTtcbiAqICAgIH1cbiAqICAgIG9uOiAnY2xpY2snLFxuICogICAgcnVuV2hlbjogKCk9PiB7IHJldHVybiB0aGlzLnZhbGlkYXRlKCl9XG4gKiB9KTtcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICogIyMjIyBEZWJvdW5jaW5nXG4gKlxuICogYGBgdHNcbiAqIC8vIEFkZCBkZWJvdW5jaW5nLlxuICogICAgIHdhdGNoZXIuYWRkKHtcbiAqICAgICAgICAgZWxlbWVudDogZG9jdW1lbnQuYm9keSxcbiAqICAgICAgICAgb246ICdtb3VzZW1vdmUnLFxuICogICAgICAgICBjYWxsYmFjazogZnVuYy5kZWJvdW5jZSgoZXZlbnQpID0+IHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtb3ZlbW92ZSEhJyk7XG4gKiAgICAgICAgIH0sIDUwMCksXG4gKiAgICAgfSk7XG4gKlxuICogYGBgXG4gKlxuICogIyMjIyBTbWFydFJlc2l6ZVxuICogSG93IGNhbiBJIHVzZSB0aGlzIHdpdGggYm9tLnNtYXJ0UmVzaXplP1xuICogSnVzdCB1c2UgdGhlICdzbWFydFJlc2l6ZScgZXZlbnQgaW5zdGVhZC5cbiAqXG4gKiBgYGB0c1xuICpcbiAqICAgICB3YXRjaGVyLmFkZCh7XG4gKiAgICAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAqICAgICAgICAgb246ICdzbWFydFJlc2l6ZScsXG4gKiAgICAgICAgIGNhbGxiYWNrOiAoZXZlbnQpID0+IHtcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzbWFydCByZXNpemluZycpO1xuICogICAgICAgICB9LFxuICogICAgIH0pO1xuICpcbiAqIGBgYFxuICpcbiAqXG4gKiBDdWxsaW5nIGV2ZW50cyBvbmx5IHdoZW4gYW4gZWxlbWVudCBpcyBpbnZpZXcuXG4gKiBTZWUgZXhhbXBsZS9zY3JvbGwtZGVtbyBmb3IgYWN0dWFsIGV4YW1wbGUuXG4gKlxuICogYGBgdHNcbiAqICAgbGV0IGV2ID0gZWxlbWVudFZpc2liaWxpdHkuaW52aWV3KGVsZW1lbnQsIHt9KTtcbiAqICAgbGV0IHdhdGNoZXIgPSBuZXcgRG9tV2F0Y2hlcigpO1xuICogICB3YXRjaGVyLmFkZCh7XG4gKiAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAqICAgICAgb246ICdzY3JvbGwnLFxuICogICAgICBldmVudE9wdGlvbnM6IHsgcGFzc2l2ZTogdHJ1ZSB9LFxuICogICAgICBjYWxsYmFjazogKCk9PiB7XG4gKiAgICAgICAgIC8vIFJ1bnMgb25seSB3aGVuIHRoaXMgZWxlbWVudCBpcyBpbnZpZXcuXG4gKiAgICAgIH0sXG4gKiAgICAgIC8vIFRlbGxzIHRvIHJ1biBzY3JvbGwgT05MWSB3aGVuIHRoZSBlbGVtZW50IGlzIGludmlldy5cbiAqICAgICAgcnVuV2hlbjogKCk9PiB7IHJldHVybiBldi5zdGF0ZSgpLmludmlldzsgfVxuICogICB9KTtcbiAqXG4gKlxuICogICAvLyBMYXRlclxuICogICBldi5kaXNwb3NlKCk7XG4gKiAgIHdhdGNoZXIuZGlzcG9zZSgpO1xuICpcbiAqIGBgYFxuICpcbiAqXG4gKi9cbmNsYXNzIERvbVdhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLndhdGNoZXJDb25maWdzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB3YXRjaGVyIGFuZCBpbW1lZGlhdGVseSBiZWdpbnMgd2F0Y2hpbmcuXG4gICAgICogQHBhcmFtIGNvbmZpZ1xuICAgICAqL1xuICAgIGFkZChjb25maWcpIHtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBjb25maWcub24gaXMgYSBhcnJheSB3aXRoIG11bHRpcGxlIGV2ZW50cyBzdWNoXG4gICAgICAgIC8vIGFzIFsnY2xpY2snLCAnbW91c2Vtb3ZlJ10gb3IgaXMgYSBzaW5nbGUgZXZlbnQuXG4gICAgICAgIGlmIChpc18xLmlzLmFycmF5KGNvbmZpZy5vbikpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IGNvbmZpZy5vbjtcbiAgICAgICAgICAgIGV2ZW50cy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgY2xvbmUub24gPSBldmVudE5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTaW5nbGVFdmVudChjbG9uZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2luZ2xlRXZlbnQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc2luZ2xlIGV2ZW50LlxuICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgKi9cbiAgICBhZGRTaW5nbGVFdmVudChjb25maWcpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChjb25maWcucnVuV2hlbikge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5ydW5XaGVuKCkgJiYgY29uZmlnLmNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFjayhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbmZpZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICAvLyBJZiB0aGUgb24gZXZlbnQgaXMgc21hcnRSZXNpemUsIHdyYXAgaXQgd2l0aCBkb20uc21hcnRSZXNpemUuXG4gICAgICAgIGlmIChjb25maWcub24gPT09ICdzbWFydFJlc2l6ZScpIHtcbiAgICAgICAgICAgIGNvbmZpZy5yZW1vdmVyID0gYm9tXzEuYm9tLnNtYXJ0UmVzaXplKGxpc3RlbmVyLCBjb25maWcuZXZlbnRPcHRpb25zIHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCBsaXN0ZW5pbmcuXG4gICAgICAgICAgICBjb25maWcuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGNvbmZpZy5vbiwgbGlzdGVuZXIsIGNvbmZpZy5ldmVudE9wdGlvbnMgfHwge30pO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgdGhlIHJlbW92ZXIuXG4gICAgICAgICAgICBjb25maWcucmVtb3ZlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25maWcuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGNvbmZpZy5vbiwgbGlzdGVuZXIsIGNvbmZpZy5ldmVudE9wdGlvbnMgfHwge30pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhdGNoZXJDb25maWdzLnB1c2goY29uZmlnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGdpdmVuIHdhdGNoZXIgYnkgaWQuXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgd2F0Y2hlciB0byByZW1vdmUuXG4gICAgICovXG4gICAgcmVtb3ZlQnlJZChpZCkge1xuICAgICAgICB0aGlzLndhdGNoZXJDb25maWdzID0gdGhpcy53YXRjaGVyQ29uZmlncy5maWx0ZXIoKGNvbmZpZykgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5pZCAmJiBjb25maWcuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBhcyB2YXIgdG8gYXZvaWQgdHlwZXNjcmlwdCBudWxsIGVycm9yLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZXIgPSBjb25maWcucmVtb3ZlcjtcbiAgICAgICAgICAgICAgICByZW1vdmVyICYmIHJlbW92ZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZG9tIHdhdGNoZXJzLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbCgpIHtcbiAgICAgICAgdGhpcy53YXRjaGVyQ29uZmlncy5mb3JFYWNoKGNvbmZpZyA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVyID0gY29uZmlnLnJlbW92ZXI7XG4gICAgICAgICAgICByZW1vdmVyICYmIHJlbW92ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud2F0Y2hlckNvbmZpZ3MgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEcnkgcnVucyBhIGNhbGxiYWNrIGJ5IGlkLiAgVGhpcyBqdXN0IGNhbGxzIHRoZSBjYWxsYmFjayBhbmQgaXNuJ3QgdGhlXG4gICAgICogYWN0dWFsIGJyb3dzZXIgZXZlbnQgc28gbm8gZXZlbnQgZGF0YSB3aWxsIGJlIGF2YWlsYWJsZSB3aGVuIHVzaW5nXG4gICAgICogdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIHdhdGNoZXIuYWRkKHtcbiAgICAgKiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAqICAgIGNhbGxiYWNrOiAoKT0+IHtcbiAgICAgKiAgICAgIGNvbnNvbGUubG9nKCd5bycpO1xuICAgICAqICAgIH1cbiAgICAgKiAgICBvbjogJ2NsaWNrJyxcbiAgICAgKiAgICBpZDogJ3lvJ1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogd2F0Y2hlci5ydW4oJ3lvJyk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGlkXG4gICAgICovXG4gICAgcnVuKGlkKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3NUb1J1biA9IHRoaXMud2F0Y2hlckNvbmZpZ3MuZmlsdGVyKChjb25maWcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuaWQgJiYgY29uZmlnLmlkID09PSBpZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbmZpZ3NUb1J1bi5mb3JFYWNoKGNvbmZpZyA9PiB7XG4gICAgICAgICAgICBjb25maWcuY2FsbGJhY2soKSAmJiBjb25maWcuY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIG9mIGRvbVdhdGNoZXIuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGwoKTtcbiAgICB9XG59XG5leHBvcnRzLkRvbVdhdGNoZXIgPSBEb21XYXRjaGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tLXdhdGNoZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/dom/dom-watcher.js\n");

/***/ }),

/***/ "./lib/dom/dom.js":
/*!************************!*\
  !*** ./lib/dom/dom.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dom = void 0;\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst defer_1 = __webpack_require__(/*! ../func/defer */ \"./lib/func/defer.js\");\nconst func_1 = __webpack_require__(/*! ../func/func */ \"./lib/func/func.js\");\nconst is_1 = __webpack_require__(/*! ../is/is */ \"./lib/is/is.js\");\nconst dom_watcher_1 = __webpack_require__(/*! ../dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n/**\n * Degu DOM utility functions.\n */\nclass dom {\n    /**\n     * Given an element, returns the amount that the element has been scrolled\n     * through in the the window.\n     *\n     * Example:\n     * This method is particularly useful when you have a 100vh sticky element\n     * and want a relative distance travelled percentage.\n     *\n     * ```\n     * HTML\n     * <div class=\"parent\">\n     *    <div class=\"child\"><div class=\"content\"></div>\n     * </div>\n     *\n     * SASS\n     * .parent\n     *   position: relative\n     *   height: 300vh  // Should be more than 100vh\n     * .child\n     *   position: sticky\n     *   height: 100vh\n     *   width: 100%\n     *   top: 0\n     * .contents\n     *   position: relative\n     *   height: 100vh\n     *\n     * JS\n     *\n     *  window.addEventListener('scroll', () => {\n     *     let progress =\n     *             dom.getElementScrolledPercent(this.stickyParent_);\n     *     // 0 when the above the element,\n     *     // increases as you scroll thorugh\n     *     // 1 when the bottom of the element reaches the bottom of the screen.\n     *     console.log(progress);\n     *   });\n     *\n     *\n     * ```\n     *\n     * Top and bottom offset.\n     * You can offset the top and bottom so that the calculations are shifted.\n     *\n     * ```ts\n     *\n     *     let startOffset = 100;\n     *     // Now progress will start when the element is 100px inview.\n     *     // But still will complete normally at the bottom.\n     *     let progress =\n     *             mathf.getElementScrolledPercent(this.element, startOffset, 0);\n     *\n     *     let startOffset = window.innerHeight;\n     *     // Now progress when the top of the element hits the top of the screen.\n     *     // But still will complete normally at the bottom.\n     *     let progress =\n     *             mathf.getElementScrolledPercent(this.element, startOffset, 0);\n     *\n     *     let heightOffset = -100;\n     *     // Entry as normal - 0 when the element first comes into view.\n     *     // Now progress will complete get to 0 when there is still 100px\n     *     // of the element still to be shown since it is virtually 100px shorter.\n     *     let progress =\n     *             mathf.getElementScrolledPercent(this.element, 0, heightOffset);\n     *\n     *     // Now progress will complete when the element has scrolled past\n     *     // the center of the screen since we virually extend the height by\n     *     // 50vh.\n     *     let heightOffset = window.innerHeight * 0.5;\n     *     let progress =\n     *             mathf.getElementScrolledPercent(this.element, 0, heightOffset);\n     *\n     *     // Now progress will complete when the element has scrolled past\n     *     // the very top of the screen.\n     *     let heightOffset = window.innerHeight * 1;\n     *     let progress =\n     *             mathf.getElementScrolledPercent(this.element, 0, heightOffset);\n     *\n     * ```\n     *\n     * Provided the element is larger than the viewport height,\n     * this will return 0% when the element is above the screen,\n     * it increases in value as the user scrolls through the element and\n     * finally when the BOTTOM of the element just passes the bottom of the screen\n     * it returns 1.\n     *\n     * This method assumes that the tracked element is atleast more than 100vh.\n     *\n     * @param {HTMLElement} element The root element.\n     * @param {number} startOffset A positive value (pixel) to offset the top position\n     *     of the element.\n     *     The start offset value should never be negative as technically, offseting\n     *     to before the element comes into view doesn't have an effect and will\n     *     only complicate things for you.\n     *     Changing this value will affect the poitn at which your progress hits\n     *     0 (starts).\n     * @param {number} heightOffset A value (pixel) to add to the total height of\n     *     the element.  Can be positive or negative values.  Think of this,\n     *     shortening or growing your element virually.  Changing this value\n     *     will affect the point at which your progress hits 1 (ends).\n     * @param {boolean} Optionally remove percent clamping.  This means it can return\n     *     values outside 0-1.\n     * @return {number} percent The amount in percentage that the user has scrolled\n     *     in the element.\n     *\n     */\n    static getElementScrolledPercent(element, startOffset = 0, heightOffset = 0, noClamp = false) {\n        const box = element.getBoundingClientRect();\n        const wh = window.innerHeight;\n        // We need to calculate this so that we start the 0% when the element comes\n        // in (the top of the element).  But the 100% is marked when the BOTTOM\n        // of the element passes the bottom of the screen.\n        const current = wh - (box.top + startOffset);\n        const percent = current / (box.height - startOffset + heightOffset);\n        return noClamp ? percent : mathf_1.mathf.clampAsPercent(percent);\n    }\n    /**\n     * Inverse of getElementScrolledPercent.\n     * Given an element on the page, finds the scrollY value in order\n     * to scroll into that element by the provided percent.\n     *\n     * @param element\n     * @param startOffset\n     * @param heightOffset\n     * @param percent A value between 0-1\n     *\n     * ```ts\n     *\n     * // Scroll halfway into the given element.\n     * const scrollY = mathf.getScrollYAtPercent(element, 0, 0, 0.5);\n     * window.scrollTo(0, scrollY);\n     *\n     * // Scroll 0.2 percent into the given element.\n     * const scrollY = mathf.getScrollYAtPercent(element, 0, 0, 0.2);\n     * window.scrollTo(0, scrollY);\n     * ```\n     */\n    static getScrollYAtPercent(element, startOffset = 0, heightOffset = 0, percent) {\n        const wh = window.innerHeight;\n        const top = dom.getScrollTop(element);\n        const start = top - wh + startOffset;\n        const end = top - wh + element.offsetHeight + heightOffset;\n        return mathf_1.mathf.lerp(start, end, percent);\n    }\n    /**\n     * Sets a css variable to an element.\n     *\n     * ```ts\n     *   dom.setCssVariable(\n     *       myElement, '--chapter-height', '100px');\n     * ```\n     *\n     * @param element The element to set the css variable.\n     * @param name The name of the css variable.  Should start with --.  Exampe: --height\n     * @param value The value to set.\n     */\n    static setCssVariable(element, name, value) {\n        if (!element) {\n            throw new Error('You need specificy a valid element to apply a css variable');\n        }\n        element.style.setProperty(name, String(value));\n    }\n    /**\n     * Batch update css variables on an element.  This updates style in a\n     * destructive manner and will override any other style elements.\n     *\n     * ```ts\n     * dom.addVariables(element, { '--height': \"200px\", '--mycssvariable': '20px'});\n     * ```\n     * @param element\n     * @param style\n     */\n    static setCssVariables(element, variables) {\n        for (const key in variables) {\n            element.style.setProperty(key, String(variables[key]));\n        }\n    }\n    /**\n     * Given a set of styles, add it to an element.\n     *\n     * ```ts\n     * dom.addStyles(element, { left: \"200px\", '--mycssvariable': '20px'});\n     * ```\n     * @param element\n     * @param style\n     */\n    static addStyles(element, styles) {\n        for (const key in styles) {\n            if (key.startsWith('--')) {\n                dom.setCssVariable(element, key, styles[key]);\n            }\n        }\n        Object.assign(element.style, styles);\n    }\n    /**\n     * Tests whether a given element is a descendant of another elemenet.\n     *\n     * Examples:\n     * ```ts\n     *  var isChild = dom.testDescendant(\n     *      document.getElementById('button'),\n     *      document.querySelector('.article'));\n     *\n     * // Whether the active focused element is under the article container.\n     *  var isFocused = dom.testDescendant(document.activeElement,\n     *      document.querySelector('.article'));\n     * ```\n     *\n     * @param element The child element\n     * @param parentElement The possible parent element\n     * @return Whether element is a descendant of the provided parent element.\n     */\n    static testDescendant(element, parentElement) {\n        let currentNode = element.parentNode;\n        while (currentNode) {\n            if (currentNode === parentElement) {\n                return true;\n            }\n            currentNode = currentNode.parentNode;\n        }\n        return false;\n    }\n    /**\n     * Tests whether a given video element is playing.\n     * @param videoElement\n     */\n    static testVideoIsPlaying(video) {\n        return !video.paused && !video.ended && video.readyState > 2;\n    }\n    /**\n     * Resets all videos inside of a given element.\n     * @param element The element to search videos in for.\n     */\n    static resetAllVideosInElement(element) {\n        const videos = Array.from(element.querySelectorAll('video'));\n        videos.forEach(video => {\n            video.currentTime = 0;\n        });\n    }\n    /**\n     * Pauses all videos inside of a given element.\n     * @param element The element to search videos in for.\n     * @param reset Whether to pause and reset the video to 0 seconds (start).\n     */\n    static pauseAllVideosInElement(element, reset = false) {\n        const videos = Array.from(element.querySelectorAll('video'));\n        videos.forEach(video => {\n            if (reset) {\n                video.currentTime = 0;\n            }\n            video.pause();\n        });\n    }\n    /**\n     * Plays all videos inside of a given element.\n     * @param element The element to search videos in for.\n     * @param reset Whether to start playing from currentTime 0.\n     */\n    static playAllVideosInElement(element, reset = false) {\n        const videos = Array.from(element.querySelectorAll('video'));\n        videos.forEach(video => {\n            // try {\n            if (reset) {\n                video.currentTime = 0;\n            }\n            if (!dom.testVideoIsPlaying(video)) {\n                const playPromise = video.play();\n                playPromise.then(() => { }).catch();\n            }\n            // } catch(e) {}\n        });\n    }\n    /**\n     * Allows you to make sure that all videos are loaded (readyState 4) in a\n     * given element before executing callback.\n     *\n     * Note that this method executes polling in the background\n     * to check for video state so use carefully.  Defaults to timeout after\n     * 10000ms\n     *\n     * ```ts\n     * // Wait for all videos to be loaded.\n     * dom.whenVideosLoadedInElement(element).then(()=> {\n     *   // Play all videos for example.\n     *   dom.playAllVideosInElement(element);\n     * })\n     *\n     * ```\n     * @param element\n     * @param timeout The amount of time in which to give up polling.\n     * @return Promise\n     */\n    static whenVideosLoadedInElement(element, timeout = 10000) {\n        const videos = Array.from(element.querySelectorAll('video'));\n        return this.whenVideosLoaded(videos, timeout);\n    }\n    /**\n     * Allows you to make sure that all videos are loaded (readyState 4)\n     * before executing callback.\n     *\n     * Note that this method executes polling in the background\n     * to check for video state so use carefully.  Defaults to timeout after\n     * 10000ms\n     *\n     * ```ts\n     * // Wait for all videos to be loaded.\n     * const videos = [videoElement1, videoElement2];\n     * dom.whenVideosLoaded(videos).then(()=> {\n     *   //\n     * })\n     *\n     * ```\n     * @param element\n     * @param timeout The amount of time in which to give up polling.\n     * @return Promise\n     */\n    static whenVideosLoaded(videos, timeout = 10000\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const promises = [];\n        videos.forEach(video => {\n            const defer = new defer_1.Defer();\n            promises.push(defer.getPromise());\n            func_1.func\n                .waitUntil(() => video.readyState === 4, timeout, 10)\n                .then(() => {\n                defer.resolve();\n            });\n        });\n        return Promise.all(promises);\n    }\n    /**\n     * Fires a event on the element.\n     *\n     * ```ts\n     * dom.event(document, 'myCustomEvent', { message: hello});\n     *\n     * // Data gets passed on the event.detail.\n     * document.addEventListener('myCustomEvent', (e)=> {\n     *   console.log(e.detail.message); // Hello\n     * }, false)\n     * ```\n     *\n     * @param element\n     * @param name\n     * @param data\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static event(element, name, data) {\n        const event = new CustomEvent(name, { detail: data });\n        element.dispatchEvent(event);\n    }\n    /**\n     * Creates an html element from a string.\n     * ```\n     * dom.createElementFromString(\"<div>Hohohoho</div>\");\n     * ```\n     * @param htmlString\n     * @param fragMethod Uses a method to create dom from string WITHOUT using innerHTML\n     */\n    static createElementFromString(htmlString, fragMethod = false) {\n        if (fragMethod) {\n            const holder = document.createElement('div');\n            const frag = document.createRange().createContextualFragment(htmlString);\n            holder.appendChild(frag);\n            return holder.firstElementChild;\n        }\n        else {\n            const div = document.createElement('div');\n            div.innerHTML = htmlString.trim();\n            return div.firstChild;\n        }\n    }\n    /**\n     * Removes an element from the dom.\n     * @param element\n     */\n    static removeElement(element) {\n        element.parentNode.removeChild(element);\n    }\n    /**\n     * Executes a callback after window has loaded.\n     * This isn't a simple window load event listening but\n     * first makes a check if the window has already loaded.\n     * If it has, the callback will immediately get executed,\n     * otherwise, it will wait until the load event completes.\n     * @param callback\n     */\n    static runAfterWindowLoad(callback) {\n        // Make sure we are at the bottom of the event\n        // stack (hence setTimeout) - this avoids\n        // edge cases in which windowLoaded is misevaluated.\n        window.setTimeout(() => {\n            if (is_1.is.windowLoaded()) {\n                callback();\n            }\n            else {\n                window.addEventListener('load', () => {\n                    callback();\n                }, { once: true });\n            }\n        });\n    }\n    /**\n     * Executes a callback as soon as the user is not at the top of the screen.\n     *\n     * If the user is at the top of the screen when this is called, it will\n     * wait until the user has scrolled down to execute.  If the user is already\n     * not at the top of the screen, the callback will immediately execute.\n     *\n     * Note that if your document is less than 100vh, your callback will\n     * never get executed because the user can't scroll and will always be at\n     * the top of the screen.\n     *\n     * @param callback\n     */\n    static runAfterNotTopOfScreen(callback) {\n        if (window.scrollY !== 0) {\n            callback();\n        }\n        else {\n            window.addEventListener('scroll', () => {\n                callback();\n            }, { once: true, passive: true });\n        }\n    }\n    /**\n     * Gets the current browser aspect ratio.\n     * 2 --> wide rectangle\n     * 1 --> squre\n     * 0.5 --> tall rectangle\n     */\n    static aspect() {\n        return window.innerWidth / window.innerHeight;\n    }\n    /**\n     * Gets the computed style of a given element .\n     * @param element\n     * @return CSSStyleDeclartion\n     */\n    static getComputedStyle(element) {\n        return window.getComputedStyle(element);\n    }\n    /**\n     * Creates an image in memory that is later deletable so it can\n     * be released from native memory AND image cache.\n     *\n     * This method can be paired with deleteImage.\n     *\n     * // Consider the following:\n     * new Image();\n     * image.src = 'hohoho.jpg';\n     * image.decode().then(()=> {\n     *   // Do something.\n     *   myCanvas.drawImage(image);\n     *   image = null;\n     * })\n     *\n     * This does appear to get GCed and removed from image cache but it is\n     * never flushed from native memory.\n     *\n     * You can observe this by going to Chrome -> Task manager.  Make sure\n     * you have the Memory and also the Image Cache columns.\n     *\n     * Theefore, usage of image.decode() for now, can lead to memory leaks that\n     * can't be cured with image=null.\n     *\n     * The same is observed with ImageBitmaps.\n     *\n     * Related.\n     * https://bugs.webkit.org/show_bug.cgi?id=31253\n     *\n     *\n     * The solution is to use createObjectURL and later revoke that\n     * so memory can be released.\n     *\n     * ```\n     * const imageSource = 'public/image/cat.jpg';\n     *\n     * // Cache the image in browser memory.\n     *    dom.fetchAndMakeImage(imageSource).then((image)=> {\n     *\n     *       // Do something with image.\n     *       myCanvas.drawImage(image);\n     *\n     *       // Delete from memory.\n     *       dom.deleteImage(image);\n     *    })\n     *\n     * ```\n     */\n    static fetchAndMakeImage(source) {\n        return new Promise(resolve => {\n            fetch(source)\n                .then(response => {\n                return response.blob();\n            })\n                .then(response => {\n                const blob = response;\n                const img = document.createElement('img');\n                img.decoding = 'async';\n                img.onload = () => {\n                    resolve(img);\n                };\n                img.src = URL.createObjectURL(blob);\n            });\n        });\n    }\n    /**\n     * Makes images from a blob source.  Can be coupled with\n     * delete image to quickly release memory.\n     * @param blob\n     */\n    static makeImageFromBlob(blob) {\n        return new Promise(resolve => {\n            const img = document.createElement('img');\n            img.decoding = 'async';\n            img.onload = () => {\n                img.onload = null;\n                resolve(img);\n            };\n            img.src = URL.createObjectURL(blob);\n        });\n    }\n    /**\n     * Makes an image from a blob source.  This is an alternative to\n     * URL.createObjectURL is to convert a Blob into a base64-encoded string.\n     *\n     *\n     * Return somethig like:\n     * <img src=\"data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAA\">\n     *\n     * @param blob\n     */\n    static makeBase64ImageFromBlob(blob) {\n        return new Promise(resolve => {\n            const reader = new FileReader();\n            reader.readAsDataURL(blob); // converts the blob to base64 and calls onload\n            reader.addEventListener('load', () => {\n                const img = document.createElement('img');\n                img.src = reader.result;\n                img.onload = () => {\n                    img.onload = null;\n                    resolve(img);\n                };\n            }, { once: true });\n        });\n    }\n    static copyBase64Image(image) {\n        return new Promise(resolve => {\n            const img = document.createElement('img');\n            img.src = image.src;\n            img.onload = () => {\n                img.onload = null;\n                resolve(img);\n            };\n        });\n    }\n    /**\n     * Deletes an image from memory.  Inverse action of\n     * dom.makeBase64ImageFromBlob or dom.makeImageFromBlob.\n     */\n    static deleteImage(image) {\n        if (image) {\n            // Delete ObjectURLs or base64\n            if (image.src &&\n                (image.src.startsWith('blob:') || image.src.startsWith('data:'))) {\n                URL.revokeObjectURL(image.src);\n                image.src = '';\n            }\n            image = null;\n        }\n    }\n    /**\n     * Flushes all video sources in a given element.  This allow the VRAM to\n     * flush.  Use unflushVideos to put it back.\n     *\n     * This is particularly useful to combine with inview.\n     * Where normally, it would take Chrome a couple of seconds\n     * to flush memory of an outview video, this would do it\n     * explicitly release memory much quicker.\n     *\n     *\n     * Current will only work with video with <source> not video with\n     * src.\n     * ```\n     *  <video>\n     *    <source src=\"xxx.mp4\"></source>\n     *    <source src=\"xxx.webm\"></source>\n     * </video>\n     * ```\n     *\n     * Basically, this works by removig the src attribute from each video\n     * and then force reloading it - flushing it from memory.\n     *\n     * ```ts\n     *    let ev = elementVisibility.inview(\n     *       el, {rootMargin: '100px 100px 100px 100px'}, () => {\n     *       if (ev.state().ready) {\n     *         if (ev.state().inview) {\n     *           dom.unflushVideos(el);\n     *         } else {\n     *           dom.flushVideos(el);\n     *         }\n     *       }\n     *     });\n     *\n     * ```\n     *\n     *\n     * You may also have a case where you are lazyloading videos as such:\n     *\n     * ```\n     * <video>\n     *    <source lazyvideo-src=\"xxx.mp4\"></source>\n     * </video>\n     * ```\n     *\n     * In this case, you can use the source attribute to specify the data-attritube\n     * that contains the path to the source.\n     *\n     * ```ts\n     *     dom.flushVideos(el, 'lazyvideo-src');\n     * ```\n     *\n     * https://html.spec.whatwg.org/multipage/media.html#best-practices-for-authors-using-media-elements\n     *\n     * @param el The html element to search\n     * @param sourceAttribute An optional attribute value to acquire the\n     *   video source from.\n     */\n    static flushVideos(el, sourceAttribute = '') {\n        const videos = Array.from(el.querySelectorAll('video'));\n        videos.forEach(video => {\n            const sources = Array.from(video.querySelectorAll('source'));\n            sources.forEach((source) => {\n                const src = source.getAttribute(sourceAttribute) || source.src;\n                source.setAttribute('data-video-src', src);\n                source.removeAttribute('src');\n                source = null;\n            });\n            video.load();\n        });\n    }\n    /**\n     * Puts back video sources and undoes the effect of dom.flushVideos.\n     * @param el The root element.\n     * @param noPlay Whether to suppress autoplaying of videos when videos are\n     *   unflushed.\n     */\n    static unflushVideos(el, noPlay = false) {\n        const videos = Array.from(el.querySelectorAll('video'));\n        videos.forEach(video => {\n            const sources = Array.from(video.querySelectorAll('source'));\n            sources.forEach(source => {\n                if (!source.hasAttribute('data-video-src')) {\n                    return;\n                }\n                const src = source.getAttribute('data-video-src');\n                source.setAttribute('src', src);\n            });\n            video.load();\n        });\n        if (!noPlay) {\n            dom.playAllVideosInElement(el);\n        }\n    }\n    /**\n     * Gets the Y distance of the element from the top of the document.\n     *\n     * ```ts\n     *   const top = dom.getScrollTop(el);\n     *   window.scroll(0, top);\n     * ```\n     *\n     */\n    static getScrollTop(el, includeParent = false) {\n        // Safe guard.\n        if (!el) {\n            return 0;\n        }\n        if (includeParent && el.offsetParent) {\n            return (el.getBoundingClientRect().top -\n                el.offsetParent.getBoundingClientRect().top +\n                window.scrollY);\n        }\n        else {\n            return el.getBoundingClientRect().top + window.scrollY;\n        }\n    }\n    /**\n     * An attempt at override VO focus.\n     * Requires the element to have a tabindex=\"-1\" and then focusing.\n     * To fully reinstante the original state prior to running force focus,\n     * run resetForceFocus().\n     *\n     *\n     * ---\n     *\n     * dom.forceFocus(myElement);\n     *\n     * window.setTimeout(()=> {\n     *\n     *   dom.forceFocus(myElement2);\n     *\n     * }, 2000)\n     *\n     *\n     *\n     * //  Some given time later, undo everything if needed.\n     * dom.resetForceFocus();\n     * ---\n     */\n    static forceFocus(el) {\n        // Check if we previously forced focused element in which case,\n        // revert that to it's previously state.\n        dom.resetForceFocus();\n        const currentIndex = el.getAttribute('tabindex');\n        if (is_1.is.defined(currentIndex) && !is_1.is.null(currentIndex)) {\n            el.setAttribute('forcetabindex', currentIndex);\n        }\n        else {\n            el.setAttribute('forcetabindex', 'none');\n        }\n        el.setAttribute('tabindex', '-1');\n        el.focus();\n    }\n    /**\n     * Undos the effects of forceFocus which overrides the tabindex of focused\n     * elements.\n     */\n    static resetForceFocus() {\n        const previouslyFocusedElement = Array.from(document.querySelectorAll('[forcetabindex]'));\n        previouslyFocusedElement.forEach(element => {\n            const tabIndex = element.getAttribute('forcetabindex');\n            if (is_1.is.defined(tabIndex) && !is_1.is.null(tabIndex) && tabIndex !== 'none') {\n                element.setAttribute('tabindex', tabIndex);\n            }\n            else {\n                element.removeAttribute('tabindex');\n            }\n            element.removeAttribute('forcetabindex');\n        });\n    }\n    /**\n     * Apart from .forceFocus, another alternative workaround for\n     * implementing forces VO focus.\n     * Thank you to: https://silvantroxler.ch/2016/setting-voiceover-focus-with-javascript/\n     * @param el\n     */\n    static forceVOFocus(element, interval = 10, repetition = 10) {\n        const focusInterval = interval; // ms, time between function calls\n        const focusTotalRepetitions = repetition; // number of repetitions\n        element.setAttribute('tabindex', '0');\n        element.blur();\n        let focusRepetitions = 0;\n        const int = window.setInterval(() => {\n            element.focus();\n            focusRepetitions++;\n            if (focusRepetitions >= focusTotalRepetitions) {\n                window.clearInterval(int);\n            }\n        }, focusInterval);\n    }\n    /**\n     * Gets the current styles on a given element.\n     *\n     * ```\n     * var style = dom.getStyle(el);\n     *\n     * style.marginTop;\n     * style.paddingLeft;\n     *\n     * ```\n     */\n    static getStyle(el) {\n        return window.getComputedStyle(el);\n    }\n    /**\n     * Tests whether the provided element is set to display none.\n     */\n    static isDisplayNone(el) {\n        const style = window.getComputedStyle(el).display;\n        return style === 'none';\n    }\n    /**\n     * Tests whether a given element and it's ancestors have\n     * a display:none.  This is useful to see if a given element\n     * is on the screen (based on whether if the element or it's ancestors have\n     * display none.)\n     *\n     * ```\n     * const elementIsVisibleOnScreen = !dom.isDisplayNoneWithAncestors(element);\n     * ```\n     */\n    static isDisplayNoneWithAncestors(el) {\n        if (dom.isDisplayNone(el)) {\n            return true;\n        }\n        if (el.parentElement) {\n            return dom.isDisplayNoneWithAncestors(el.parentElement);\n        }\n        return false;\n    }\n    /**\n     * Tries to determine if the element is currently visible on the\n     * screen.  Note this is an attempt and is not a guarantee as is based\n     * on whether the element or its parents have opacity, visibility or\n     * display set to a hidden state.\n     * @param el\n     */\n    static isVisibleOnScreen(el) {\n        const checkVisibility = (el) => {\n            const styles = dom.getComputedStyle(el);\n            return !(styles.opacity !== '1' ||\n                styles.visibility === 'hidden' ||\n                styles.display === 'none');\n        };\n        const isVisible = checkVisibility(el);\n        if (!isVisible) {\n            return false;\n        }\n        if (el.parentElement) {\n            return this.isVisibleOnScreen(el.parentElement);\n        }\n        return true;\n    }\n    /**\n     * Removes all classes from an element that starts with a given prefix.\n     * https://stackoverflow.com/questions/28608587/how-to-remove-a-class-that-starts-with\n     * @param el\n     * @param prefix\n     */\n    static removeClassByPrefix(el, prefix) {\n        const reg = new RegExp('\\\\b' + prefix + '.*?\\\\b', 'g');\n        el.className = el.className.replace(reg, '');\n        return el;\n    }\n    /**\n     * Returns all text nodes under a given element.\n     * https://stackoverflow.com/questions/10730309/find-all-text-nodes-in-html-page\n     * @param el\n     */\n    static getAllTextNodes(el) {\n        let n;\n        const a = [];\n        const walk = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null, false);\n        while ((n = walk.nextNode()))\n            a.push(n);\n        return a;\n    }\n    static appendAfter(nodeToAdd, nodeToAddAfter) {\n        nodeToAddAfter.parentNode.insertBefore(nodeToAdd, nodeToAddAfter.nextSibling);\n    }\n    /**\n     * Used for cases in which you want to prevent scroll on the page.\n     *\n     * Technically, this prevents wheel and touchmove events.\n     *\n     * ```\n     * // Disable scrolling.\n     * const reenable = dom.domDisableScrolling();\n     *\n     * // Renable.\n     * reenable();\n     * ```\n     */\n    static disableScrolling() {\n        const disabler = (e) => {\n            e.preventDefault();\n        };\n        const domWatcher = new dom_watcher_1.DomWatcher();\n        domWatcher.add({\n            element: window,\n            on: 'wheel',\n            callback: disabler,\n            eventOptions: {\n                passive: false,\n            },\n        });\n        domWatcher.add({\n            element: window,\n            on: 'touchmove',\n            callback: disabler,\n            eventOptions: {\n                passive: false,\n            },\n        });\n        return () => {\n            domWatcher.dispose();\n        };\n    }\n    /**\n     * Adds &nbsps to between the second to last and last word\n     * to avoid unorphanization.\n     *\n     * ```\n     *       // Unorphanize all text nodes.\n     *       dom.unorphan(element as HTMLElement);\n     *\n     *       // No nesting (just the last text node)\n     *       dom.unorphan(element as HTMLElement, true);\n     * ```\n     * @param el\n     */\n    static unorphan(el, lastOnly = false) {\n        let allTextNodes = dom.getAllTextNodes(el);\n        if (lastOnly) {\n            allTextNodes = [allTextNodes[allTextNodes.length - 1]];\n        }\n        const nbsp = '\\xA0';\n        allTextNodes.forEach(node => {\n            node.nodeValue = node.nodeValue.replace(/\\s+([^\\s]*)\\s*$/, nbsp + '$1');\n        });\n    }\n    static getScrollElement() {\n        return document.scrollingElement || document.documentElement;\n    }\n    /**\n     * Determines if two elements are overlapping or not.\n     * @param aElement\n     * @param bElement\n     * https://stackoverflow.com/questions/12066870/how-to-check-if-an-element-is-overlapping-other-elements\n     */\n    static isOverlapping(aElement, bElement) {\n        // Element Can't overlap with itself.\n        if (aElement === bElement) {\n            return false;\n        }\n        const rect1 = aElement.getBoundingClientRect();\n        const rect2 = bElement.getBoundingClientRect();\n        return !(rect1.right < rect2.left ||\n            rect1.left > rect2.right ||\n            rect1.bottom < rect2.top ||\n            rect1.top > rect2.bottom);\n    }\n}\nexports.dom = dom;\n//# sourceMappingURL=dom.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL2RvbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9kb20vZG9tLmpzPzdjMTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRvbSA9IHZvaWQgMDtcbmNvbnN0IG1hdGhmXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvbWF0aGZcIik7XG5jb25zdCBkZWZlcl8xID0gcmVxdWlyZShcIi4uL2Z1bmMvZGVmZXJcIik7XG5jb25zdCBmdW5jXzEgPSByZXF1aXJlKFwiLi4vZnVuYy9mdW5jXCIpO1xuY29uc3QgaXNfMSA9IHJlcXVpcmUoXCIuLi9pcy9pc1wiKTtcbmNvbnN0IGRvbV93YXRjaGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbS13YXRjaGVyXCIpO1xuLyoqXG4gKiBEZWd1IERPTSB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqL1xuY2xhc3MgZG9tIHtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBlbGVtZW50LCByZXR1cm5zIHRoZSBhbW91bnQgdGhhdCB0aGUgZWxlbWVudCBoYXMgYmVlbiBzY3JvbGxlZFxuICAgICAqIHRocm91Z2ggaW4gdGhlIHRoZSB3aW5kb3cuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgd2hlbiB5b3UgaGF2ZSBhIDEwMHZoIHN0aWNreSBlbGVtZW50XG4gICAgICogYW5kIHdhbnQgYSByZWxhdGl2ZSBkaXN0YW5jZSB0cmF2ZWxsZWQgcGVyY2VudGFnZS5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEhUTUxcbiAgICAgKiA8ZGl2IGNsYXNzPVwicGFyZW50XCI+XG4gICAgICogICAgPGRpdiBjbGFzcz1cImNoaWxkXCI+PGRpdiBjbGFzcz1cImNvbnRlbnRcIj48L2Rpdj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKlxuICAgICAqIFNBU1NcbiAgICAgKiAucGFyZW50XG4gICAgICogICBwb3NpdGlvbjogcmVsYXRpdmVcbiAgICAgKiAgIGhlaWdodDogMzAwdmggIC8vIFNob3VsZCBiZSBtb3JlIHRoYW4gMTAwdmhcbiAgICAgKiAuY2hpbGRcbiAgICAgKiAgIHBvc2l0aW9uOiBzdGlja3lcbiAgICAgKiAgIGhlaWdodDogMTAwdmhcbiAgICAgKiAgIHdpZHRoOiAxMDAlXG4gICAgICogICB0b3A6IDBcbiAgICAgKiAuY29udGVudHNcbiAgICAgKiAgIHBvc2l0aW9uOiByZWxhdGl2ZVxuICAgICAqICAgaGVpZ2h0OiAxMDB2aFxuICAgICAqXG4gICAgICogSlNcbiAgICAgKlxuICAgICAqICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4ge1xuICAgICAqICAgICBsZXQgcHJvZ3Jlc3MgPVxuICAgICAqICAgICAgICAgICAgIGRvbS5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMuc3RpY2t5UGFyZW50Xyk7XG4gICAgICogICAgIC8vIDAgd2hlbiB0aGUgYWJvdmUgdGhlIGVsZW1lbnQsXG4gICAgICogICAgIC8vIGluY3JlYXNlcyBhcyB5b3Ugc2Nyb2xsIHRob3J1Z2hcbiAgICAgKiAgICAgLy8gMSB3aGVuIHRoZSBib3R0b20gb2YgdGhlIGVsZW1lbnQgcmVhY2hlcyB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4uXG4gICAgICogICAgIGNvbnNvbGUubG9nKHByb2dyZXNzKTtcbiAgICAgKiAgIH0pO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRvcCBhbmQgYm90dG9tIG9mZnNldC5cbiAgICAgKiBZb3UgY2FuIG9mZnNldCB0aGUgdG9wIGFuZCBib3R0b20gc28gdGhhdCB0aGUgY2FsY3VsYXRpb25zIGFyZSBzaGlmdGVkLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqICAgICBsZXQgc3RhcnRPZmZzZXQgPSAxMDA7XG4gICAgICogICAgIC8vIE5vdyBwcm9ncmVzcyB3aWxsIHN0YXJ0IHdoZW4gdGhlIGVsZW1lbnQgaXMgMTAwcHggaW52aWV3LlxuICAgICAqICAgICAvLyBCdXQgc3RpbGwgd2lsbCBjb21wbGV0ZSBub3JtYWxseSBhdCB0aGUgYm90dG9tLlxuICAgICAqICAgICBsZXQgcHJvZ3Jlc3MgPVxuICAgICAqICAgICAgICAgICAgIG1hdGhmLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5lbGVtZW50LCBzdGFydE9mZnNldCwgMCk7XG4gICAgICpcbiAgICAgKiAgICAgbGV0IHN0YXJ0T2Zmc2V0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAqICAgICAvLyBOb3cgcHJvZ3Jlc3Mgd2hlbiB0aGUgdG9wIG9mIHRoZSBlbGVtZW50IGhpdHMgdGhlIHRvcCBvZiB0aGUgc2NyZWVuLlxuICAgICAqICAgICAvLyBCdXQgc3RpbGwgd2lsbCBjb21wbGV0ZSBub3JtYWxseSBhdCB0aGUgYm90dG9tLlxuICAgICAqICAgICBsZXQgcHJvZ3Jlc3MgPVxuICAgICAqICAgICAgICAgICAgIG1hdGhmLmdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQodGhpcy5lbGVtZW50LCBzdGFydE9mZnNldCwgMCk7XG4gICAgICpcbiAgICAgKiAgICAgbGV0IGhlaWdodE9mZnNldCA9IC0xMDA7XG4gICAgICogICAgIC8vIEVudHJ5IGFzIG5vcm1hbCAtIDAgd2hlbiB0aGUgZWxlbWVudCBmaXJzdCBjb21lcyBpbnRvIHZpZXcuXG4gICAgICogICAgIC8vIE5vdyBwcm9ncmVzcyB3aWxsIGNvbXBsZXRlIGdldCB0byAwIHdoZW4gdGhlcmUgaXMgc3RpbGwgMTAwcHhcbiAgICAgKiAgICAgLy8gb2YgdGhlIGVsZW1lbnQgc3RpbGwgdG8gYmUgc2hvd24gc2luY2UgaXQgaXMgdmlydHVhbGx5IDEwMHB4IHNob3J0ZXIuXG4gICAgICogICAgIGxldCBwcm9ncmVzcyA9XG4gICAgICogICAgICAgICAgICAgbWF0aGYuZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudCh0aGlzLmVsZW1lbnQsIDAsIGhlaWdodE9mZnNldCk7XG4gICAgICpcbiAgICAgKiAgICAgLy8gTm93IHByb2dyZXNzIHdpbGwgY29tcGxldGUgd2hlbiB0aGUgZWxlbWVudCBoYXMgc2Nyb2xsZWQgcGFzdFxuICAgICAqICAgICAvLyB0aGUgY2VudGVyIG9mIHRoZSBzY3JlZW4gc2luY2Ugd2UgdmlydWFsbHkgZXh0ZW5kIHRoZSBoZWlnaHQgYnlcbiAgICAgKiAgICAgLy8gNTB2aC5cbiAgICAgKiAgICAgbGV0IGhlaWdodE9mZnNldCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIDAuNTtcbiAgICAgKiAgICAgbGV0IHByb2dyZXNzID1cbiAgICAgKiAgICAgICAgICAgICBtYXRoZi5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMuZWxlbWVudCwgMCwgaGVpZ2h0T2Zmc2V0KTtcbiAgICAgKlxuICAgICAqICAgICAvLyBOb3cgcHJvZ3Jlc3Mgd2lsbCBjb21wbGV0ZSB3aGVuIHRoZSBlbGVtZW50IGhhcyBzY3JvbGxlZCBwYXN0XG4gICAgICogICAgIC8vIHRoZSB2ZXJ5IHRvcCBvZiB0aGUgc2NyZWVuLlxuICAgICAqICAgICBsZXQgaGVpZ2h0T2Zmc2V0ID0gd2luZG93LmlubmVySGVpZ2h0ICogMTtcbiAgICAgKiAgICAgbGV0IHByb2dyZXNzID1cbiAgICAgKiAgICAgICAgICAgICBtYXRoZi5nZXRFbGVtZW50U2Nyb2xsZWRQZXJjZW50KHRoaXMuZWxlbWVudCwgMCwgaGVpZ2h0T2Zmc2V0KTtcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogUHJvdmlkZWQgdGhlIGVsZW1lbnQgaXMgbGFyZ2VyIHRoYW4gdGhlIHZpZXdwb3J0IGhlaWdodCxcbiAgICAgKiB0aGlzIHdpbGwgcmV0dXJuIDAlIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWJvdmUgdGhlIHNjcmVlbixcbiAgICAgKiBpdCBpbmNyZWFzZXMgaW4gdmFsdWUgYXMgdGhlIHVzZXIgc2Nyb2xscyB0aHJvdWdoIHRoZSBlbGVtZW50IGFuZFxuICAgICAqIGZpbmFsbHkgd2hlbiB0aGUgQk9UVE9NIG9mIHRoZSBlbGVtZW50IGp1c3QgcGFzc2VzIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlblxuICAgICAqIGl0IHJldHVybnMgMS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFzc3VtZXMgdGhhdCB0aGUgdHJhY2tlZCBlbGVtZW50IGlzIGF0bGVhc3QgbW9yZSB0aGFuIDEwMHZoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgcm9vdCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydE9mZnNldCBBIHBvc2l0aXZlIHZhbHVlIChwaXhlbCkgdG8gb2Zmc2V0IHRoZSB0b3AgcG9zaXRpb25cbiAgICAgKiAgICAgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogICAgIFRoZSBzdGFydCBvZmZzZXQgdmFsdWUgc2hvdWxkIG5ldmVyIGJlIG5lZ2F0aXZlIGFzIHRlY2huaWNhbGx5LCBvZmZzZXRpbmdcbiAgICAgKiAgICAgdG8gYmVmb3JlIHRoZSBlbGVtZW50IGNvbWVzIGludG8gdmlldyBkb2Vzbid0IGhhdmUgYW4gZWZmZWN0IGFuZCB3aWxsXG4gICAgICogICAgIG9ubHkgY29tcGxpY2F0ZSB0aGluZ3MgZm9yIHlvdS5cbiAgICAgKiAgICAgQ2hhbmdpbmcgdGhpcyB2YWx1ZSB3aWxsIGFmZmVjdCB0aGUgcG9pdG4gYXQgd2hpY2ggeW91ciBwcm9ncmVzcyBoaXRzXG4gICAgICogICAgIDAgKHN0YXJ0cykuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodE9mZnNldCBBIHZhbHVlIChwaXhlbCkgdG8gYWRkIHRvIHRoZSB0b3RhbCBoZWlnaHQgb2ZcbiAgICAgKiAgICAgdGhlIGVsZW1lbnQuICBDYW4gYmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUgdmFsdWVzLiAgVGhpbmsgb2YgdGhpcyxcbiAgICAgKiAgICAgc2hvcnRlbmluZyBvciBncm93aW5nIHlvdXIgZWxlbWVudCB2aXJ1YWxseS4gIENoYW5naW5nIHRoaXMgdmFsdWVcbiAgICAgKiAgICAgd2lsbCBhZmZlY3QgdGhlIHBvaW50IGF0IHdoaWNoIHlvdXIgcHJvZ3Jlc3MgaGl0cyAxIChlbmRzKS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IE9wdGlvbmFsbHkgcmVtb3ZlIHBlcmNlbnQgY2xhbXBpbmcuICBUaGlzIG1lYW5zIGl0IGNhbiByZXR1cm5cbiAgICAgKiAgICAgdmFsdWVzIG91dHNpZGUgMC0xLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gcGVyY2VudCBUaGUgYW1vdW50IGluIHBlcmNlbnRhZ2UgdGhhdCB0aGUgdXNlciBoYXMgc2Nyb2xsZWRcbiAgICAgKiAgICAgaW4gdGhlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RWxlbWVudFNjcm9sbGVkUGVyY2VudChlbGVtZW50LCBzdGFydE9mZnNldCA9IDAsIGhlaWdodE9mZnNldCA9IDAsIG5vQ2xhbXAgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBib3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB3aCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBjYWxjdWxhdGUgdGhpcyBzbyB0aGF0IHdlIHN0YXJ0IHRoZSAwJSB3aGVuIHRoZSBlbGVtZW50IGNvbWVzXG4gICAgICAgIC8vIGluICh0aGUgdG9wIG9mIHRoZSBlbGVtZW50KS4gIEJ1dCB0aGUgMTAwJSBpcyBtYXJrZWQgd2hlbiB0aGUgQk9UVE9NXG4gICAgICAgIC8vIG9mIHRoZSBlbGVtZW50IHBhc3NlcyB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4uXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB3aCAtIChib3gudG9wICsgc3RhcnRPZmZzZXQpO1xuICAgICAgICBjb25zdCBwZXJjZW50ID0gY3VycmVudCAvIChib3guaGVpZ2h0IC0gc3RhcnRPZmZzZXQgKyBoZWlnaHRPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbm9DbGFtcCA/IHBlcmNlbnQgOiBtYXRoZl8xLm1hdGhmLmNsYW1wQXNQZXJjZW50KHBlcmNlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIG9mIGdldEVsZW1lbnRTY3JvbGxlZFBlcmNlbnQuXG4gICAgICogR2l2ZW4gYW4gZWxlbWVudCBvbiB0aGUgcGFnZSwgZmluZHMgdGhlIHNjcm9sbFkgdmFsdWUgaW4gb3JkZXJcbiAgICAgKiB0byBzY3JvbGwgaW50byB0aGF0IGVsZW1lbnQgYnkgdGhlIHByb3ZpZGVkIHBlcmNlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSBzdGFydE9mZnNldFxuICAgICAqIEBwYXJhbSBoZWlnaHRPZmZzZXRcbiAgICAgKiBAcGFyYW0gcGVyY2VudCBBIHZhbHVlIGJldHdlZW4gMC0xXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqXG4gICAgICogLy8gU2Nyb2xsIGhhbGZ3YXkgaW50byB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKiBjb25zdCBzY3JvbGxZID0gbWF0aGYuZ2V0U2Nyb2xsWUF0UGVyY2VudChlbGVtZW50LCAwLCAwLCAwLjUpO1xuICAgICAqIHdpbmRvdy5zY3JvbGxUbygwLCBzY3JvbGxZKTtcbiAgICAgKlxuICAgICAqIC8vIFNjcm9sbCAwLjIgcGVyY2VudCBpbnRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqIGNvbnN0IHNjcm9sbFkgPSBtYXRoZi5nZXRTY3JvbGxZQXRQZXJjZW50KGVsZW1lbnQsIDAsIDAsIDAuMik7XG4gICAgICogd2luZG93LnNjcm9sbFRvKDAsIHNjcm9sbFkpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTY3JvbGxZQXRQZXJjZW50KGVsZW1lbnQsIHN0YXJ0T2Zmc2V0ID0gMCwgaGVpZ2h0T2Zmc2V0ID0gMCwgcGVyY2VudCkge1xuICAgICAgICBjb25zdCB3aCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgY29uc3QgdG9wID0gZG9tLmdldFNjcm9sbFRvcChlbGVtZW50KTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0b3AgLSB3aCArIHN0YXJ0T2Zmc2V0O1xuICAgICAgICBjb25zdCBlbmQgPSB0b3AgLSB3aCArIGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgaGVpZ2h0T2Zmc2V0O1xuICAgICAgICByZXR1cm4gbWF0aGZfMS5tYXRoZi5sZXJwKHN0YXJ0LCBlbmQsIHBlcmNlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY3NzIHZhcmlhYmxlIHRvIGFuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqICAgZG9tLnNldENzc1ZhcmlhYmxlKFxuICAgICAqICAgICAgIG15RWxlbWVudCwgJy0tY2hhcHRlci1oZWlnaHQnLCAnMTAwcHgnKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHNldCB0aGUgY3NzIHZhcmlhYmxlLlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjc3MgdmFyaWFibGUuICBTaG91bGQgc3RhcnQgd2l0aCAtLS4gIEV4YW1wZTogLS1oZWlnaHRcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0Q3NzVmFyaWFibGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHNwZWNpZmljeSBhIHZhbGlkIGVsZW1lbnQgdG8gYXBwbHkgYSBjc3MgdmFyaWFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIFN0cmluZyh2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXRjaCB1cGRhdGUgY3NzIHZhcmlhYmxlcyBvbiBhbiBlbGVtZW50LiAgVGhpcyB1cGRhdGVzIHN0eWxlIGluIGFcbiAgICAgKiBkZXN0cnVjdGl2ZSBtYW5uZXIgYW5kIHdpbGwgb3ZlcnJpZGUgYW55IG90aGVyIHN0eWxlIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBkb20uYWRkVmFyaWFibGVzKGVsZW1lbnQsIHsgJy0taGVpZ2h0JzogXCIyMDBweFwiLCAnLS1teWNzc3ZhcmlhYmxlJzogJzIwcHgnfSk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gc3R5bGVcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0Q3NzVmFyaWFibGVzKGVsZW1lbnQsIHZhcmlhYmxlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJpYWJsZXMpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCBTdHJpbmcodmFyaWFibGVzW2tleV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHNldCBvZiBzdHlsZXMsIGFkZCBpdCB0byBhbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBkb20uYWRkU3R5bGVzKGVsZW1lbnQsIHsgbGVmdDogXCIyMDBweFwiLCAnLS1teWNzc3ZhcmlhYmxlJzogJzIwcHgnfSk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gc3R5bGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZXMpIHtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnLS0nKSkge1xuICAgICAgICAgICAgICAgIGRvbS5zZXRDc3NWYXJpYWJsZShlbGVtZW50LCBrZXksIHN0eWxlc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3RzIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IGlzIGEgZGVzY2VuZGFudCBvZiBhbm90aGVyIGVsZW1lbmV0LlxuICAgICAqXG4gICAgICogRXhhbXBsZXM6XG4gICAgICogYGBgdHNcbiAgICAgKiAgdmFyIGlzQ2hpbGQgPSBkb20udGVzdERlc2NlbmRhbnQoXG4gICAgICogICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnV0dG9uJyksXG4gICAgICogICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYXJ0aWNsZScpKTtcbiAgICAgKlxuICAgICAqIC8vIFdoZXRoZXIgdGhlIGFjdGl2ZSBmb2N1c2VkIGVsZW1lbnQgaXMgdW5kZXIgdGhlIGFydGljbGUgY29udGFpbmVyLlxuICAgICAqICB2YXIgaXNGb2N1c2VkID0gZG9tLnRlc3REZXNjZW5kYW50KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsXG4gICAgICogICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYXJ0aWNsZScpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBjaGlsZCBlbGVtZW50XG4gICAgICogQHBhcmFtIHBhcmVudEVsZW1lbnQgVGhlIHBvc3NpYmxlIHBhcmVudCBlbGVtZW50XG4gICAgICogQHJldHVybiBXaGV0aGVyIGVsZW1lbnQgaXMgYSBkZXNjZW5kYW50IG9mIHRoZSBwcm92aWRlZCBwYXJlbnQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgdGVzdERlc2NlbmRhbnQoZWxlbWVudCwgcGFyZW50RWxlbWVudCkge1xuICAgICAgICBsZXQgY3VycmVudE5vZGUgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlID09PSBwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyB3aGV0aGVyIGEgZ2l2ZW4gdmlkZW8gZWxlbWVudCBpcyBwbGF5aW5nLlxuICAgICAqIEBwYXJhbSB2aWRlb0VsZW1lbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgdGVzdFZpZGVvSXNQbGF5aW5nKHZpZGVvKSB7XG4gICAgICAgIHJldHVybiAhdmlkZW8ucGF1c2VkICYmICF2aWRlby5lbmRlZCAmJiB2aWRlby5yZWFkeVN0YXRlID4gMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCB2aWRlb3MgaW5zaWRlIG9mIGEgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBzZWFyY2ggdmlkZW9zIGluIGZvci5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVzZXRBbGxWaWRlb3NJbkVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCB2aWRlb3MgPSBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgndmlkZW8nKSk7XG4gICAgICAgIHZpZGVvcy5mb3JFYWNoKHZpZGVvID0+IHtcbiAgICAgICAgICAgIHZpZGVvLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdXNlcyBhbGwgdmlkZW9zIGluc2lkZSBvZiBhIGdpdmVuIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gc2VhcmNoIHZpZGVvcyBpbiBmb3IuXG4gICAgICogQHBhcmFtIHJlc2V0IFdoZXRoZXIgdG8gcGF1c2UgYW5kIHJlc2V0IHRoZSB2aWRlbyB0byAwIHNlY29uZHMgKHN0YXJ0KS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGF1c2VBbGxWaWRlb3NJbkVsZW1lbnQoZWxlbWVudCwgcmVzZXQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB2aWRlb3MgPSBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgndmlkZW8nKSk7XG4gICAgICAgIHZpZGVvcy5mb3JFYWNoKHZpZGVvID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgICAgICAgIHZpZGVvLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZGVvLnBhdXNlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGF5cyBhbGwgdmlkZW9zIGluc2lkZSBvZiBhIGdpdmVuIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gc2VhcmNoIHZpZGVvcyBpbiBmb3IuXG4gICAgICogQHBhcmFtIHJlc2V0IFdoZXRoZXIgdG8gc3RhcnQgcGxheWluZyBmcm9tIGN1cnJlbnRUaW1lIDAuXG4gICAgICovXG4gICAgc3RhdGljIHBsYXlBbGxWaWRlb3NJbkVsZW1lbnQoZWxlbWVudCwgcmVzZXQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB2aWRlb3MgPSBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgndmlkZW8nKSk7XG4gICAgICAgIHZpZGVvcy5mb3JFYWNoKHZpZGVvID0+IHtcbiAgICAgICAgICAgIC8vIHRyeSB7XG4gICAgICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICAgICAgICB2aWRlby5jdXJyZW50VGltZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRvbS50ZXN0VmlkZW9Jc1BsYXlpbmcodmlkZW8pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGxheVByb21pc2UgPSB2aWRlby5wbGF5KCk7XG4gICAgICAgICAgICAgICAgcGxheVByb21pc2UudGhlbigoKSA9PiB7IH0pLmNhdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB9IGNhdGNoKGUpIHt9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgeW91IHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCB2aWRlb3MgYXJlIGxvYWRlZCAocmVhZHlTdGF0ZSA0KSBpbiBhXG4gICAgICogZ2l2ZW4gZWxlbWVudCBiZWZvcmUgZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGV4ZWN1dGVzIHBvbGxpbmcgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgKiB0byBjaGVjayBmb3IgdmlkZW8gc3RhdGUgc28gdXNlIGNhcmVmdWxseS4gIERlZmF1bHRzIHRvIHRpbWVvdXQgYWZ0ZXJcbiAgICAgKiAxMDAwMG1zXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIC8vIFdhaXQgZm9yIGFsbCB2aWRlb3MgdG8gYmUgbG9hZGVkLlxuICAgICAqIGRvbS53aGVuVmlkZW9zTG9hZGVkSW5FbGVtZW50KGVsZW1lbnQpLnRoZW4oKCk9PiB7XG4gICAgICogICAvLyBQbGF5IGFsbCB2aWRlb3MgZm9yIGV4YW1wbGUuXG4gICAgICogICBkb20ucGxheUFsbFZpZGVvc0luRWxlbWVudChlbGVtZW50KTtcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gdGltZW91dCBUaGUgYW1vdW50IG9mIHRpbWUgaW4gd2hpY2ggdG8gZ2l2ZSB1cCBwb2xsaW5nLlxuICAgICAqIEByZXR1cm4gUHJvbWlzZVxuICAgICAqL1xuICAgIHN0YXRpYyB3aGVuVmlkZW9zTG9hZGVkSW5FbGVtZW50KGVsZW1lbnQsIHRpbWVvdXQgPSAxMDAwMCkge1xuICAgICAgICBjb25zdCB2aWRlb3MgPSBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgndmlkZW8nKSk7XG4gICAgICAgIHJldHVybiB0aGlzLndoZW5WaWRlb3NMb2FkZWQodmlkZW9zLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHlvdSB0byBtYWtlIHN1cmUgdGhhdCBhbGwgdmlkZW9zIGFyZSBsb2FkZWQgKHJlYWR5U3RhdGUgNClcbiAgICAgKiBiZWZvcmUgZXhlY3V0aW5nIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGV4ZWN1dGVzIHBvbGxpbmcgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgKiB0byBjaGVjayBmb3IgdmlkZW8gc3RhdGUgc28gdXNlIGNhcmVmdWxseS4gIERlZmF1bHRzIHRvIHRpbWVvdXQgYWZ0ZXJcbiAgICAgKiAxMDAwMG1zXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIC8vIFdhaXQgZm9yIGFsbCB2aWRlb3MgdG8gYmUgbG9hZGVkLlxuICAgICAqIGNvbnN0IHZpZGVvcyA9IFt2aWRlb0VsZW1lbnQxLCB2aWRlb0VsZW1lbnQyXTtcbiAgICAgKiBkb20ud2hlblZpZGVvc0xvYWRlZCh2aWRlb3MpLnRoZW4oKCk9PiB7XG4gICAgICogICAvL1xuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB0aW1lb3V0IFRoZSBhbW91bnQgb2YgdGltZSBpbiB3aGljaCB0byBnaXZlIHVwIHBvbGxpbmcuXG4gICAgICogQHJldHVybiBQcm9taXNlXG4gICAgICovXG4gICAgc3RhdGljIHdoZW5WaWRlb3NMb2FkZWQodmlkZW9zLCB0aW1lb3V0ID0gMTAwMDBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICB2aWRlb3MuZm9yRWFjaCh2aWRlbyA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWZlciA9IG5ldyBkZWZlcl8xLkRlZmVyKCk7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRlZmVyLmdldFByb21pc2UoKSk7XG4gICAgICAgICAgICBmdW5jXzEuZnVuY1xuICAgICAgICAgICAgICAgIC53YWl0VW50aWwoKCkgPT4gdmlkZW8ucmVhZHlTdGF0ZSA9PT0gNCwgdGltZW91dCwgMTApXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmlyZXMgYSBldmVudCBvbiB0aGUgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogZG9tLmV2ZW50KGRvY3VtZW50LCAnbXlDdXN0b21FdmVudCcsIHsgbWVzc2FnZTogaGVsbG99KTtcbiAgICAgKlxuICAgICAqIC8vIERhdGEgZ2V0cyBwYXNzZWQgb24gdGhlIGV2ZW50LmRldGFpbC5cbiAgICAgKiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdteUN1c3RvbUV2ZW50JywgKGUpPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coZS5kZXRhaWwubWVzc2FnZSk7IC8vIEhlbGxvXG4gICAgICogfSwgZmFsc2UpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBldmVudChlbGVtZW50LCBuYW1lLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KG5hbWUsIHsgZGV0YWlsOiBkYXRhIH0pO1xuICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGh0bWwgZWxlbWVudCBmcm9tIGEgc3RyaW5nLlxuICAgICAqIGBgYFxuICAgICAqIGRvbS5jcmVhdGVFbGVtZW50RnJvbVN0cmluZyhcIjxkaXY+SG9ob2hvaG88L2Rpdj5cIik7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGh0bWxTdHJpbmdcbiAgICAgKiBAcGFyYW0gZnJhZ01ldGhvZCBVc2VzIGEgbWV0aG9kIHRvIGNyZWF0ZSBkb20gZnJvbSBzdHJpbmcgV0lUSE9VVCB1c2luZyBpbm5lckhUTUxcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRWxlbWVudEZyb21TdHJpbmcoaHRtbFN0cmluZywgZnJhZ01ldGhvZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChmcmFnTWV0aG9kKSB7XG4gICAgICAgICAgICBjb25zdCBob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGNvbnN0IGZyYWcgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChodG1sU3RyaW5nKTtcbiAgICAgICAgICAgIGhvbGRlci5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgICAgICAgIHJldHVybiBob2xkZXIuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBodG1sU3RyaW5nLnRyaW0oKTtcbiAgICAgICAgICAgIHJldHVybiBkaXYuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgZG9tLlxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICovXG4gICAgc3RhdGljIHJlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGEgY2FsbGJhY2sgYWZ0ZXIgd2luZG93IGhhcyBsb2FkZWQuXG4gICAgICogVGhpcyBpc24ndCBhIHNpbXBsZSB3aW5kb3cgbG9hZCBldmVudCBsaXN0ZW5pbmcgYnV0XG4gICAgICogZmlyc3QgbWFrZXMgYSBjaGVjayBpZiB0aGUgd2luZG93IGhhcyBhbHJlYWR5IGxvYWRlZC5cbiAgICAgKiBJZiBpdCBoYXMsIHRoZSBjYWxsYmFjayB3aWxsIGltbWVkaWF0ZWx5IGdldCBleGVjdXRlZCxcbiAgICAgKiBvdGhlcndpc2UsIGl0IHdpbGwgd2FpdCB1bnRpbCB0aGUgbG9hZCBldmVudCBjb21wbGV0ZXMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG4gICAgc3RhdGljIHJ1bkFmdGVyV2luZG93TG9hZChjYWxsYmFjaykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgYXJlIGF0IHRoZSBib3R0b20gb2YgdGhlIGV2ZW50XG4gICAgICAgIC8vIHN0YWNrIChoZW5jZSBzZXRUaW1lb3V0KSAtIHRoaXMgYXZvaWRzXG4gICAgICAgIC8vIGVkZ2UgY2FzZXMgaW4gd2hpY2ggd2luZG93TG9hZGVkIGlzIG1pc2V2YWx1YXRlZC5cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzXzEuaXMud2luZG93TG9hZGVkKCkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYSBjYWxsYmFjayBhcyBzb29uIGFzIHRoZSB1c2VyIGlzIG5vdCBhdCB0aGUgdG9wIG9mIHRoZSBzY3JlZW4uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdXNlciBpcyBhdCB0aGUgdG9wIG9mIHRoZSBzY3JlZW4gd2hlbiB0aGlzIGlzIGNhbGxlZCwgaXQgd2lsbFxuICAgICAqIHdhaXQgdW50aWwgdGhlIHVzZXIgaGFzIHNjcm9sbGVkIGRvd24gdG8gZXhlY3V0ZS4gIElmIHRoZSB1c2VyIGlzIGFscmVhZHlcbiAgICAgKiBub3QgYXQgdGhlIHRvcCBvZiB0aGUgc2NyZWVuLCB0aGUgY2FsbGJhY2sgd2lsbCBpbW1lZGlhdGVseSBleGVjdXRlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGlmIHlvdXIgZG9jdW1lbnQgaXMgbGVzcyB0aGFuIDEwMHZoLCB5b3VyIGNhbGxiYWNrIHdpbGxcbiAgICAgKiBuZXZlciBnZXQgZXhlY3V0ZWQgYmVjYXVzZSB0aGUgdXNlciBjYW4ndCBzY3JvbGwgYW5kIHdpbGwgYWx3YXlzIGJlIGF0XG4gICAgICogdGhlIHRvcCBvZiB0aGUgc2NyZWVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG4gICAgc3RhdGljIHJ1bkFmdGVyTm90VG9wT2ZTY3JlZW4oY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHdpbmRvdy5zY3JvbGxZICE9PSAwKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSwgeyBvbmNlOiB0cnVlLCBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgYnJvd3NlciBhc3BlY3QgcmF0aW8uXG4gICAgICogMiAtLT4gd2lkZSByZWN0YW5nbGVcbiAgICAgKiAxIC0tPiBzcXVyZVxuICAgICAqIDAuNSAtLT4gdGFsbCByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYXNwZWN0KCkge1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbXB1dGVkIHN0eWxlIG9mIGEgZ2l2ZW4gZWxlbWVudCAuXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIENTU1N0eWxlRGVjbGFydGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGltYWdlIGluIG1lbW9yeSB0aGF0IGlzIGxhdGVyIGRlbGV0YWJsZSBzbyBpdCBjYW5cbiAgICAgKiBiZSByZWxlYXNlZCBmcm9tIG5hdGl2ZSBtZW1vcnkgQU5EIGltYWdlIGNhY2hlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIHBhaXJlZCB3aXRoIGRlbGV0ZUltYWdlLlxuICAgICAqXG4gICAgICogLy8gQ29uc2lkZXIgdGhlIGZvbGxvd2luZzpcbiAgICAgKiBuZXcgSW1hZ2UoKTtcbiAgICAgKiBpbWFnZS5zcmMgPSAnaG9ob2hvLmpwZyc7XG4gICAgICogaW1hZ2UuZGVjb2RlKCkudGhlbigoKT0+IHtcbiAgICAgKiAgIC8vIERvIHNvbWV0aGluZy5cbiAgICAgKiAgIG15Q2FudmFzLmRyYXdJbWFnZShpbWFnZSk7XG4gICAgICogICBpbWFnZSA9IG51bGw7XG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIFRoaXMgZG9lcyBhcHBlYXIgdG8gZ2V0IEdDZWQgYW5kIHJlbW92ZWQgZnJvbSBpbWFnZSBjYWNoZSBidXQgaXQgaXNcbiAgICAgKiBuZXZlciBmbHVzaGVkIGZyb20gbmF0aXZlIG1lbW9yeS5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gb2JzZXJ2ZSB0aGlzIGJ5IGdvaW5nIHRvIENocm9tZSAtPiBUYXNrIG1hbmFnZXIuICBNYWtlIHN1cmVcbiAgICAgKiB5b3UgaGF2ZSB0aGUgTWVtb3J5IGFuZCBhbHNvIHRoZSBJbWFnZSBDYWNoZSBjb2x1bW5zLlxuICAgICAqXG4gICAgICogVGhlZWZvcmUsIHVzYWdlIG9mIGltYWdlLmRlY29kZSgpIGZvciBub3csIGNhbiBsZWFkIHRvIG1lbW9yeSBsZWFrcyB0aGF0XG4gICAgICogY2FuJ3QgYmUgY3VyZWQgd2l0aCBpbWFnZT1udWxsLlxuICAgICAqXG4gICAgICogVGhlIHNhbWUgaXMgb2JzZXJ2ZWQgd2l0aCBJbWFnZUJpdG1hcHMuXG4gICAgICpcbiAgICAgKiBSZWxhdGVkLlxuICAgICAqIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0zMTI1M1xuICAgICAqXG4gICAgICpcbiAgICAgKiBUaGUgc29sdXRpb24gaXMgdG8gdXNlIGNyZWF0ZU9iamVjdFVSTCBhbmQgbGF0ZXIgcmV2b2tlIHRoYXRcbiAgICAgKiBzbyBtZW1vcnkgY2FuIGJlIHJlbGVhc2VkLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgaW1hZ2VTb3VyY2UgPSAncHVibGljL2ltYWdlL2NhdC5qcGcnO1xuICAgICAqXG4gICAgICogLy8gQ2FjaGUgdGhlIGltYWdlIGluIGJyb3dzZXIgbWVtb3J5LlxuICAgICAqICAgIGRvbS5mZXRjaEFuZE1ha2VJbWFnZShpbWFnZVNvdXJjZSkudGhlbigoaW1hZ2UpPT4ge1xuICAgICAqXG4gICAgICogICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggaW1hZ2UuXG4gICAgICogICAgICAgbXlDYW52YXMuZHJhd0ltYWdlKGltYWdlKTtcbiAgICAgKlxuICAgICAqICAgICAgIC8vIERlbGV0ZSBmcm9tIG1lbW9yeS5cbiAgICAgKiAgICAgICBkb20uZGVsZXRlSW1hZ2UoaW1hZ2UpO1xuICAgICAqICAgIH0pXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgZmV0Y2hBbmRNYWtlSW1hZ2Uoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGZldGNoKHNvdXJjZSlcbiAgICAgICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICBpbWcuZGVjb2RpbmcgPSAnYXN5bmMnO1xuICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaW1nKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGltZy5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBpbWFnZXMgZnJvbSBhIGJsb2Igc291cmNlLiAgQ2FuIGJlIGNvdXBsZWQgd2l0aFxuICAgICAqIGRlbGV0ZSBpbWFnZSB0byBxdWlja2x5IHJlbGVhc2UgbWVtb3J5LlxuICAgICAqIEBwYXJhbSBibG9iXG4gICAgICovXG4gICAgc3RhdGljIG1ha2VJbWFnZUZyb21CbG9iKGJsb2IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgICBpbWcuZGVjb2RpbmcgPSAnYXN5bmMnO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGltZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhbiBpbWFnZSBmcm9tIGEgYmxvYiBzb3VyY2UuICBUaGlzIGlzIGFuIGFsdGVybmF0aXZlIHRvXG4gICAgICogVVJMLmNyZWF0ZU9iamVjdFVSTCBpcyB0byBjb252ZXJ0IGEgQmxvYiBpbnRvIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBSZXR1cm4gc29tZXRoaWcgbGlrZTpcbiAgICAgKiA8aW1nIHNyYz1cImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxSMGxHT0RsaERBQU1BS0lGQUY1TEFQL3p4QUFBQU55dUFQL2dhUC8vL3dBQUFBQVwiPlxuICAgICAqXG4gICAgICogQHBhcmFtIGJsb2JcbiAgICAgKi9cbiAgICBzdGF0aWMgbWFrZUJhc2U2NEltYWdlRnJvbUJsb2IoYmxvYikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7IC8vIGNvbnZlcnRzIHRoZSBibG9iIHRvIGJhc2U2NCBhbmQgY2FsbHMgb25sb2FkXG4gICAgICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgY29weUJhc2U2NEltYWdlKGltYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICAgICAgaW1nLnNyYyA9IGltYWdlLnNyYztcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShpbWcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYW4gaW1hZ2UgZnJvbSBtZW1vcnkuICBJbnZlcnNlIGFjdGlvbiBvZlxuICAgICAqIGRvbS5tYWtlQmFzZTY0SW1hZ2VGcm9tQmxvYiBvciBkb20ubWFrZUltYWdlRnJvbUJsb2IuXG4gICAgICovXG4gICAgc3RhdGljIGRlbGV0ZUltYWdlKGltYWdlKSB7XG4gICAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAgICAgLy8gRGVsZXRlIE9iamVjdFVSTHMgb3IgYmFzZTY0XG4gICAgICAgICAgICBpZiAoaW1hZ2Uuc3JjICYmXG4gICAgICAgICAgICAgICAgKGltYWdlLnNyYy5zdGFydHNXaXRoKCdibG9iOicpIHx8IGltYWdlLnNyYy5zdGFydHNXaXRoKCdkYXRhOicpKSkge1xuICAgICAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoaW1hZ2Uuc3JjKTtcbiAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltYWdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGFsbCB2aWRlbyBzb3VyY2VzIGluIGEgZ2l2ZW4gZWxlbWVudC4gIFRoaXMgYWxsb3cgdGhlIFZSQU0gdG9cbiAgICAgKiBmbHVzaC4gIFVzZSB1bmZsdXNoVmlkZW9zIHRvIHB1dCBpdCBiYWNrLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIHRvIGNvbWJpbmUgd2l0aCBpbnZpZXcuXG4gICAgICogV2hlcmUgbm9ybWFsbHksIGl0IHdvdWxkIHRha2UgQ2hyb21lIGEgY291cGxlIG9mIHNlY29uZHNcbiAgICAgKiB0byBmbHVzaCBtZW1vcnkgb2YgYW4gb3V0dmlldyB2aWRlbywgdGhpcyB3b3VsZCBkbyBpdFxuICAgICAqIGV4cGxpY2l0bHkgcmVsZWFzZSBtZW1vcnkgbXVjaCBxdWlja2VyLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBDdXJyZW50IHdpbGwgb25seSB3b3JrIHdpdGggdmlkZW8gd2l0aCA8c291cmNlPiBub3QgdmlkZW8gd2l0aFxuICAgICAqIHNyYy5cbiAgICAgKiBgYGBcbiAgICAgKiAgPHZpZGVvPlxuICAgICAqICAgIDxzb3VyY2Ugc3JjPVwieHh4Lm1wNFwiPjwvc291cmNlPlxuICAgICAqICAgIDxzb3VyY2Ugc3JjPVwieHh4LndlYm1cIj48L3NvdXJjZT5cbiAgICAgKiA8L3ZpZGVvPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQmFzaWNhbGx5LCB0aGlzIHdvcmtzIGJ5IHJlbW92aWcgdGhlIHNyYyBhdHRyaWJ1dGUgZnJvbSBlYWNoIHZpZGVvXG4gICAgICogYW5kIHRoZW4gZm9yY2UgcmVsb2FkaW5nIGl0IC0gZmx1c2hpbmcgaXQgZnJvbSBtZW1vcnkuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqICAgIGxldCBldiA9IGVsZW1lbnRWaXNpYmlsaXR5LmludmlldyhcbiAgICAgKiAgICAgICBlbCwge3Jvb3RNYXJnaW46ICcxMDBweCAxMDBweCAxMDBweCAxMDBweCd9LCAoKSA9PiB7XG4gICAgICogICAgICAgaWYgKGV2LnN0YXRlKCkucmVhZHkpIHtcbiAgICAgKiAgICAgICAgIGlmIChldi5zdGF0ZSgpLmludmlldykge1xuICAgICAqICAgICAgICAgICBkb20udW5mbHVzaFZpZGVvcyhlbCk7XG4gICAgICogICAgICAgICB9IGVsc2Uge1xuICAgICAqICAgICAgICAgICBkb20uZmx1c2hWaWRlb3MoZWwpO1xuICAgICAqICAgICAgICAgfVxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgfSk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqXG4gICAgICogWW91IG1heSBhbHNvIGhhdmUgYSBjYXNlIHdoZXJlIHlvdSBhcmUgbGF6eWxvYWRpbmcgdmlkZW9zIGFzIHN1Y2g6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8dmlkZW8+XG4gICAgICogICAgPHNvdXJjZSBsYXp5dmlkZW8tc3JjPVwieHh4Lm1wNFwiPjwvc291cmNlPlxuICAgICAqIDwvdmlkZW8+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGNhc2UsIHlvdSBjYW4gdXNlIHRoZSBzb3VyY2UgYXR0cmlidXRlIHRvIHNwZWNpZnkgdGhlIGRhdGEtYXR0cml0dWJlXG4gICAgICogdGhhdCBjb250YWlucyB0aGUgcGF0aCB0byB0aGUgc291cmNlLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiAgICAgZG9tLmZsdXNoVmlkZW9zKGVsLCAnbGF6eXZpZGVvLXNyYycpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvbWVkaWEuaHRtbCNiZXN0LXByYWN0aWNlcy1mb3ItYXV0aG9ycy11c2luZy1tZWRpYS1lbGVtZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIGVsIFRoZSBodG1sIGVsZW1lbnQgdG8gc2VhcmNoXG4gICAgICogQHBhcmFtIHNvdXJjZUF0dHJpYnV0ZSBBbiBvcHRpb25hbCBhdHRyaWJ1dGUgdmFsdWUgdG8gYWNxdWlyZSB0aGVcbiAgICAgKiAgIHZpZGVvIHNvdXJjZSBmcm9tLlxuICAgICAqL1xuICAgIHN0YXRpYyBmbHVzaFZpZGVvcyhlbCwgc291cmNlQXR0cmlidXRlID0gJycpIHtcbiAgICAgICAgY29uc3QgdmlkZW9zID0gQXJyYXkuZnJvbShlbC5xdWVyeVNlbGVjdG9yQWxsKCd2aWRlbycpKTtcbiAgICAgICAgdmlkZW9zLmZvckVhY2godmlkZW8gPT4ge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlcyA9IEFycmF5LmZyb20odmlkZW8ucXVlcnlTZWxlY3RvckFsbCgnc291cmNlJykpO1xuICAgICAgICAgICAgc291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcmMgPSBzb3VyY2UuZ2V0QXR0cmlidXRlKHNvdXJjZUF0dHJpYnV0ZSkgfHwgc291cmNlLnNyYztcbiAgICAgICAgICAgICAgICBzb3VyY2Uuc2V0QXR0cmlidXRlKCdkYXRhLXZpZGVvLXNyYycsIHNyYyk7XG4gICAgICAgICAgICAgICAgc291cmNlLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICAgICAgc291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmlkZW8ubG9hZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHV0cyBiYWNrIHZpZGVvIHNvdXJjZXMgYW5kIHVuZG9lcyB0aGUgZWZmZWN0IG9mIGRvbS5mbHVzaFZpZGVvcy5cbiAgICAgKiBAcGFyYW0gZWwgVGhlIHJvb3QgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gbm9QbGF5IFdoZXRoZXIgdG8gc3VwcHJlc3MgYXV0b3BsYXlpbmcgb2YgdmlkZW9zIHdoZW4gdmlkZW9zIGFyZVxuICAgICAqICAgdW5mbHVzaGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyB1bmZsdXNoVmlkZW9zKGVsLCBub1BsYXkgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB2aWRlb3MgPSBBcnJheS5mcm9tKGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3ZpZGVvJykpO1xuICAgICAgICB2aWRlb3MuZm9yRWFjaCh2aWRlbyA9PiB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VzID0gQXJyYXkuZnJvbSh2aWRlby5xdWVyeVNlbGVjdG9yQWxsKCdzb3VyY2UnKSk7XG4gICAgICAgICAgICBzb3VyY2VzLmZvckVhY2goc291cmNlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtdmlkZW8tc3JjJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzcmMgPSBzb3VyY2UuZ2V0QXR0cmlidXRlKCdkYXRhLXZpZGVvLXNyYycpO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHNyYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZpZGVvLmxvYWQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghbm9QbGF5KSB7XG4gICAgICAgICAgICBkb20ucGxheUFsbFZpZGVvc0luRWxlbWVudChlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgWSBkaXN0YW5jZSBvZiB0aGUgZWxlbWVudCBmcm9tIHRoZSB0b3Agb2YgdGhlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiAgIGNvbnN0IHRvcCA9IGRvbS5nZXRTY3JvbGxUb3AoZWwpO1xuICAgICAqICAgd2luZG93LnNjcm9sbCgwLCB0b3ApO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGdldFNjcm9sbFRvcChlbCwgaW5jbHVkZVBhcmVudCA9IGZhbHNlKSB7XG4gICAgICAgIC8vIFNhZmUgZ3VhcmQuXG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNsdWRlUGFyZW50ICYmIGVsLm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIChlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLVxuICAgICAgICAgICAgICAgIGVsLm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgK1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxZKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBhdHRlbXB0IGF0IG92ZXJyaWRlIFZPIGZvY3VzLlxuICAgICAqIFJlcXVpcmVzIHRoZSBlbGVtZW50IHRvIGhhdmUgYSB0YWJpbmRleD1cIi0xXCIgYW5kIHRoZW4gZm9jdXNpbmcuXG4gICAgICogVG8gZnVsbHkgcmVpbnN0YW50ZSB0aGUgb3JpZ2luYWwgc3RhdGUgcHJpb3IgdG8gcnVubmluZyBmb3JjZSBmb2N1cyxcbiAgICAgKiBydW4gcmVzZXRGb3JjZUZvY3VzKCkuXG4gICAgICpcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqXG4gICAgICogZG9tLmZvcmNlRm9jdXMobXlFbGVtZW50KTtcbiAgICAgKlxuICAgICAqIHdpbmRvdy5zZXRUaW1lb3V0KCgpPT4ge1xuICAgICAqXG4gICAgICogICBkb20uZm9yY2VGb2N1cyhteUVsZW1lbnQyKTtcbiAgICAgKlxuICAgICAqIH0sIDIwMDApXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICogLy8gIFNvbWUgZ2l2ZW4gdGltZSBsYXRlciwgdW5kbyBldmVyeXRoaW5nIGlmIG5lZWRlZC5cbiAgICAgKiBkb20ucmVzZXRGb3JjZUZvY3VzKCk7XG4gICAgICogLS0tXG4gICAgICovXG4gICAgc3RhdGljIGZvcmNlRm9jdXMoZWwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgcHJldmlvdXNseSBmb3JjZWQgZm9jdXNlZCBlbGVtZW50IGluIHdoaWNoIGNhc2UsXG4gICAgICAgIC8vIHJldmVydCB0aGF0IHRvIGl0J3MgcHJldmlvdXNseSBzdGF0ZS5cbiAgICAgICAgZG9tLnJlc2V0Rm9yY2VGb2N1cygpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBlbC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgIGlmIChpc18xLmlzLmRlZmluZWQoY3VycmVudEluZGV4KSAmJiAhaXNfMS5pcy5udWxsKGN1cnJlbnRJbmRleCkpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZm9yY2V0YWJpbmRleCcsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2ZvcmNldGFiaW5kZXgnLCAnbm9uZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgZWwuZm9jdXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5kb3MgdGhlIGVmZmVjdHMgb2YgZm9yY2VGb2N1cyB3aGljaCBvdmVycmlkZXMgdGhlIHRhYmluZGV4IG9mIGZvY3VzZWRcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVzZXRGb3JjZUZvY3VzKCkge1xuICAgICAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tmb3JjZXRhYmluZGV4XScpKTtcbiAgICAgICAgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50LmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YWJJbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdmb3JjZXRhYmluZGV4Jyk7XG4gICAgICAgICAgICBpZiAoaXNfMS5pcy5kZWZpbmVkKHRhYkluZGV4KSAmJiAhaXNfMS5pcy5udWxsKHRhYkluZGV4KSAmJiB0YWJJbmRleCAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgdGFiSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZm9yY2V0YWJpbmRleCcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBhcnQgZnJvbSAuZm9yY2VGb2N1cywgYW5vdGhlciBhbHRlcm5hdGl2ZSB3b3JrYXJvdW5kIGZvclxuICAgICAqIGltcGxlbWVudGluZyBmb3JjZXMgVk8gZm9jdXMuXG4gICAgICogVGhhbmsgeW91IHRvOiBodHRwczovL3NpbHZhbnRyb3hsZXIuY2gvMjAxNi9zZXR0aW5nLXZvaWNlb3Zlci1mb2N1cy13aXRoLWphdmFzY3JpcHQvXG4gICAgICogQHBhcmFtIGVsXG4gICAgICovXG4gICAgc3RhdGljIGZvcmNlVk9Gb2N1cyhlbGVtZW50LCBpbnRlcnZhbCA9IDEwLCByZXBldGl0aW9uID0gMTApIHtcbiAgICAgICAgY29uc3QgZm9jdXNJbnRlcnZhbCA9IGludGVydmFsOyAvLyBtcywgdGltZSBiZXR3ZWVuIGZ1bmN0aW9uIGNhbGxzXG4gICAgICAgIGNvbnN0IGZvY3VzVG90YWxSZXBldGl0aW9ucyA9IHJlcGV0aXRpb247IC8vIG51bWJlciBvZiByZXBldGl0aW9uc1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgICBlbGVtZW50LmJsdXIoKTtcbiAgICAgICAgbGV0IGZvY3VzUmVwZXRpdGlvbnMgPSAwO1xuICAgICAgICBjb25zdCBpbnQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgZm9jdXNSZXBldGl0aW9ucysrO1xuICAgICAgICAgICAgaWYgKGZvY3VzUmVwZXRpdGlvbnMgPj0gZm9jdXNUb3RhbFJlcGV0aXRpb25zKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwoaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZm9jdXNJbnRlcnZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgc3R5bGVzIG9uIGEgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZhciBzdHlsZSA9IGRvbS5nZXRTdHlsZShlbCk7XG4gICAgICpcbiAgICAgKiBzdHlsZS5tYXJnaW5Ub3A7XG4gICAgICogc3R5bGUucGFkZGluZ0xlZnQ7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U3R5bGUoZWwpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdHMgd2hldGhlciB0aGUgcHJvdmlkZWQgZWxlbWVudCBpcyBzZXQgdG8gZGlzcGxheSBub25lLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Rpc3BsYXlOb25lKGVsKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmRpc3BsYXk7XG4gICAgICAgIHJldHVybiBzdHlsZSA9PT0gJ25vbmUnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyB3aGV0aGVyIGEgZ2l2ZW4gZWxlbWVudCBhbmQgaXQncyBhbmNlc3RvcnMgaGF2ZVxuICAgICAqIGEgZGlzcGxheTpub25lLiAgVGhpcyBpcyB1c2VmdWwgdG8gc2VlIGlmIGEgZ2l2ZW4gZWxlbWVudFxuICAgICAqIGlzIG9uIHRoZSBzY3JlZW4gKGJhc2VkIG9uIHdoZXRoZXIgaWYgdGhlIGVsZW1lbnQgb3IgaXQncyBhbmNlc3RvcnMgaGF2ZVxuICAgICAqIGRpc3BsYXkgbm9uZS4pXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBlbGVtZW50SXNWaXNpYmxlT25TY3JlZW4gPSAhZG9tLmlzRGlzcGxheU5vbmVXaXRoQW5jZXN0b3JzKGVsZW1lbnQpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBpc0Rpc3BsYXlOb25lV2l0aEFuY2VzdG9ycyhlbCkge1xuICAgICAgICBpZiAoZG9tLmlzRGlzcGxheU5vbmUoZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbS5pc0Rpc3BsYXlOb25lV2l0aEFuY2VzdG9ycyhlbC5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWVzIHRvIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgdmlzaWJsZSBvbiB0aGVcbiAgICAgKiBzY3JlZW4uICBOb3RlIHRoaXMgaXMgYW4gYXR0ZW1wdCBhbmQgaXMgbm90IGEgZ3VhcmFudGVlIGFzIGlzIGJhc2VkXG4gICAgICogb24gd2hldGhlciB0aGUgZWxlbWVudCBvciBpdHMgcGFyZW50cyBoYXZlIG9wYWNpdHksIHZpc2liaWxpdHkgb3JcbiAgICAgKiBkaXNwbGF5IHNldCB0byBhIGhpZGRlbiBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gZWxcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNWaXNpYmxlT25TY3JlZW4oZWwpIHtcbiAgICAgICAgY29uc3QgY2hlY2tWaXNpYmlsaXR5ID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZXMgPSBkb20uZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgICAgICByZXR1cm4gIShzdHlsZXMub3BhY2l0eSAhPT0gJzEnIHx8XG4gICAgICAgICAgICAgICAgc3R5bGVzLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nIHx8XG4gICAgICAgICAgICAgICAgc3R5bGVzLmRpc3BsYXkgPT09ICdub25lJyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGNoZWNrVmlzaWJpbGl0eShlbCk7XG4gICAgICAgIGlmICghaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmlzaWJsZU9uU2NyZWVuKGVsLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBjbGFzc2VzIGZyb20gYW4gZWxlbWVudCB0aGF0IHN0YXJ0cyB3aXRoIGEgZ2l2ZW4gcHJlZml4LlxuICAgICAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI4NjA4NTg3L2hvdy10by1yZW1vdmUtYS1jbGFzcy10aGF0LXN0YXJ0cy13aXRoXG4gICAgICogQHBhcmFtIGVsXG4gICAgICogQHBhcmFtIHByZWZpeFxuICAgICAqL1xuICAgIHN0YXRpYyByZW1vdmVDbGFzc0J5UHJlZml4KGVsLCBwcmVmaXgpIHtcbiAgICAgICAgY29uc3QgcmVnID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgcHJlZml4ICsgJy4qP1xcXFxiJywgJ2cnKTtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UocmVnLCAnJyk7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgdGV4dCBub2RlcyB1bmRlciBhIGdpdmVuIGVsZW1lbnQuXG4gICAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA3MzAzMDkvZmluZC1hbGwtdGV4dC1ub2Rlcy1pbi1odG1sLXBhZ2VcbiAgICAgKiBAcGFyYW0gZWxcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QWxsVGV4dE5vZGVzKGVsKSB7XG4gICAgICAgIGxldCBuO1xuICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgIGNvbnN0IHdhbGsgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsLCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCwgZmFsc2UpO1xuICAgICAgICB3aGlsZSAoKG4gPSB3YWxrLm5leHROb2RlKCkpKVxuICAgICAgICAgICAgYS5wdXNoKG4pO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgc3RhdGljIGFwcGVuZEFmdGVyKG5vZGVUb0FkZCwgbm9kZVRvQWRkQWZ0ZXIpIHtcbiAgICAgICAgbm9kZVRvQWRkQWZ0ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZVRvQWRkLCBub2RlVG9BZGRBZnRlci5uZXh0U2libGluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGNhc2VzIGluIHdoaWNoIHlvdSB3YW50IHRvIHByZXZlbnQgc2Nyb2xsIG9uIHRoZSBwYWdlLlxuICAgICAqXG4gICAgICogVGVjaG5pY2FsbHksIHRoaXMgcHJldmVudHMgd2hlZWwgYW5kIHRvdWNobW92ZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAvLyBEaXNhYmxlIHNjcm9sbGluZy5cbiAgICAgKiBjb25zdCByZWVuYWJsZSA9IGRvbS5kb21EaXNhYmxlU2Nyb2xsaW5nKCk7XG4gICAgICpcbiAgICAgKiAvLyBSZW5hYmxlLlxuICAgICAqIHJlZW5hYmxlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGRpc2FibGVTY3JvbGxpbmcoKSB7XG4gICAgICAgIGNvbnN0IGRpc2FibGVyID0gKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZG9tV2F0Y2hlciA9IG5ldyBkb21fd2F0Y2hlcl8xLkRvbVdhdGNoZXIoKTtcbiAgICAgICAgZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgICAgICAgb246ICd3aGVlbCcsXG4gICAgICAgICAgICBjYWxsYmFjazogZGlzYWJsZXIsXG4gICAgICAgICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBkb21XYXRjaGVyLmFkZCh7XG4gICAgICAgICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICAgICAgICBvbjogJ3RvdWNobW92ZScsXG4gICAgICAgICAgICBjYWxsYmFjazogZGlzYWJsZXIsXG4gICAgICAgICAgICBldmVudE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZG9tV2F0Y2hlci5kaXNwb3NlKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgJm5ic3BzIHRvIGJldHdlZW4gdGhlIHNlY29uZCB0byBsYXN0IGFuZCBsYXN0IHdvcmRcbiAgICAgKiB0byBhdm9pZCB1bm9ycGhhbml6YXRpb24uXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgICAgICAvLyBVbm9ycGhhbml6ZSBhbGwgdGV4dCBub2Rlcy5cbiAgICAgKiAgICAgICBkb20udW5vcnBoYW4oZWxlbWVudCBhcyBIVE1MRWxlbWVudCk7XG4gICAgICpcbiAgICAgKiAgICAgICAvLyBObyBuZXN0aW5nIChqdXN0IHRoZSBsYXN0IHRleHQgbm9kZSlcbiAgICAgKiAgICAgICBkb20udW5vcnBoYW4oZWxlbWVudCBhcyBIVE1MRWxlbWVudCwgdHJ1ZSk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGVsXG4gICAgICovXG4gICAgc3RhdGljIHVub3JwaGFuKGVsLCBsYXN0T25seSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBhbGxUZXh0Tm9kZXMgPSBkb20uZ2V0QWxsVGV4dE5vZGVzKGVsKTtcbiAgICAgICAgaWYgKGxhc3RPbmx5KSB7XG4gICAgICAgICAgICBhbGxUZXh0Tm9kZXMgPSBbYWxsVGV4dE5vZGVzW2FsbFRleHROb2Rlcy5sZW5ndGggLSAxXV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmJzcCA9ICdcXHhBMCc7XG4gICAgICAgIGFsbFRleHROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSBub2RlLm5vZGVWYWx1ZS5yZXBsYWNlKC9cXHMrKFteXFxzXSopXFxzKiQvLCBuYnNwICsgJyQxJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0U2Nyb2xsRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHR3byBlbGVtZW50cyBhcmUgb3ZlcmxhcHBpbmcgb3Igbm90LlxuICAgICAqIEBwYXJhbSBhRWxlbWVudFxuICAgICAqIEBwYXJhbSBiRWxlbWVudFxuICAgICAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyMDY2ODcwL2hvdy10by1jaGVjay1pZi1hbi1lbGVtZW50LWlzLW92ZXJsYXBwaW5nLW90aGVyLWVsZW1lbnRzXG4gICAgICovXG4gICAgc3RhdGljIGlzT3ZlcmxhcHBpbmcoYUVsZW1lbnQsIGJFbGVtZW50KSB7XG4gICAgICAgIC8vIEVsZW1lbnQgQ2FuJ3Qgb3ZlcmxhcCB3aXRoIGl0c2VsZi5cbiAgICAgICAgaWYgKGFFbGVtZW50ID09PSBiRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlY3QxID0gYUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHJlY3QyID0gYkVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiAhKHJlY3QxLnJpZ2h0IDwgcmVjdDIubGVmdCB8fFxuICAgICAgICAgICAgcmVjdDEubGVmdCA+IHJlY3QyLnJpZ2h0IHx8XG4gICAgICAgICAgICByZWN0MS5ib3R0b20gPCByZWN0Mi50b3AgfHxcbiAgICAgICAgICAgIHJlY3QxLnRvcCA+IHJlY3QyLmJvdHRvbSk7XG4gICAgfVxufVxuZXhwb3J0cy5kb20gPSBkb207XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb20uanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/dom/dom.js\n");

/***/ }),

/***/ "./lib/dom/element-visibility.js":
/*!***************************************!*\
  !*** ./lib/dom/element-visibility.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.elementVisibility = void 0;\nconst defer_1 = __webpack_require__(/*! ../func/defer */ \"./lib/func/defer.js\");\n/**\n * A composition around the IntersectionObserver API.\n * Support is fairly good but if you want legacy browsers, look into polyfills.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n */\nclass elementVisibility {\n    /**\n     * Uses the interaction API to detect element visibility.\n     * @param {Element} el The element to observe\n     * @param {Object?} options Interaction api options.\n     *   This includes, root, threshold and rootMargin.\n     *   @see https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n     * @param {Function} callback A callback function that is called on each change.\n     *   The callback returns the element, changes, done.  Done is called to stop\n     *   observiing.\n     * @return {Object} The intersection observer.\n     *\n     * Basic usage:\n     *\n     *\n     * ```ts\n     *\n     * let ev = elementVisibility.inview(element);\n     *\n     * // EV takes a moment to boot up so promise provided.\n     * ev.readyPromise.then(())=> {\n     *   console.log(ev.state().inview); // Is the elmeent inview.\n     * });\n     * ev.dispose();\n     *\n     * ```\n     *\n     *\n     * Basic usage with callback structure.\n     * ```ts\n     *\n     *\n     *   elementVisibility.inview(element, { threshold: 0.3 },\n     *     // Note that your callback will get immediately\n     *     // called once to check visibility\n     *     (element, changes, dispose)=> {\n     *       if(changes.isIntersecting) {\n     *         // The element is visibile.\n     *\n     *         dispose(); // Dispose if you want.\n     *       }\n     *     }\n     *   );\n     *\n     *\n     * ```\n     *\n     *\n     * Element visibility internally caches the last known changes so you\n     * can use that in your app.\n     *\n     * This is often an easier way to do things that use the callback.\n     *\n     *\n     * ```ts\n     * let ev = elementVisibility.inview(element);\n     *\n     * console.log(ev.state().inview); // Is the elmeent inview now?\n     *\n     * window.setTimeout(()=> {\n     *    console.log(ev.state().inview); // Is it inview now after 3 seconds.\n     * }, 3000);\n     *\n     * window.addEventListener('scroll', () => {\n     *    console.log(ev.state().inview); // Check to see it is in view.\n     * });\n     *\n     * ev.state().changes; // A list of all known last changes.\n     *                   Contains IntersectionObserverEntry list.\n     * ev.state().lastChange; // Just the last known IntersectionObserverEntry.\n     *\n     *\n     * ev.dispose(); // Remember to dispose.\n     *\n     * ```\n     *\n     *\n     * --> I want to check if my element is inview just once.\n     *\n     * ```ts\n     * let ev = elementVisibility.inview(element, {});\n     *\n     * // This could be falsy since ev takes a moment to boot up.\n     * ev.inview; // True or False.\n     *\n     * // Instead\n     * if(ev.state().ready) {\n     *   ev.inview; // True or False.\n     * }\n     *\n     * // Or\n     * ev.readyPromise.then(()=> {\n     *   ev.inview; // True or False.\n     * })\n     *\n     *\n     *\n     * ev.dipose(); // Dispose it.\n     * ```\n     *\n     * --> I want to run scroll events only when the element is inview.\n     * See [[DomWatcher]] for an example of this.\n     *\n     *\n     */\n    static inview(element, options = {}, callback) {\n        // Cache the last known state in the closure.\n        let cachedChanges = null;\n        let cachedLastChange = null;\n        let cachedInview = null;\n        let ready = false;\n        const readyPromise = new defer_1.Defer();\n        /**\n         * Get the last known state values of inview.\n         */\n        const state = () => {\n            return {\n                changes: cachedChanges,\n                lastChange: cachedLastChange,\n                inview: cachedInview,\n                ready: ready,\n            };\n        };\n        const onChange = (entries) => {\n            // Cache the values only if there was a change\n            // so that it maintains the last known change.\n            if (entries.length >= 1) {\n                cachedChanges = entries;\n                cachedLastChange = entries.slice(-1)[0];\n                cachedInview = cachedLastChange.isIntersecting;\n                ready = true;\n                readyPromise.resolve();\n            }\n            // Callback always passes the \"current\" entries even if there\n            // are none.\n            callback && callback(element, entries.slice(-1)[0], dispose);\n        };\n        /**\n         * If evBypass=true is the url parameter, we allow IntersectionObserver\n         * to be bypassed and we immediately return true for inview.  This is\n         * useful for automated testing.\n         */\n        let inviewBypassParam = window.location.search.split('evBypass=')[1];\n        inviewBypassParam = inviewBypassParam && inviewBypassParam.split('&')[0];\n        if (inviewBypassParam === 'true') {\n            window.setTimeout(() => {\n                callback &&\n                    callback(element, {\n                        isIntersecting: true,\n                        isVisible: true,\n                    }, () => { });\n                readyPromise.resolve();\n            });\n            return {\n                observer: null,\n                dispose: () => { },\n                state: () => {\n                    return {\n                        ready: true,\n                        inview: true,\n                    };\n                },\n                readyPromise: readyPromise.getPromise(),\n            };\n        }\n        const dispose = () => {\n            observer && observer.unobserve(element);\n            observer && observer.disconnect();\n            cachedChanges = [];\n            cachedLastChange = null;\n        };\n        const observer = new IntersectionObserver(onChange, options);\n        observer.observe(element);\n        return {\n            observer: observer,\n            dispose: dispose,\n            /**\n             * A method you can call to acquire the last known inview state.\n             */\n            state: state,\n            /**\n             * A promise that resolved when the observer is ready.\n             */\n            readyPromise: readyPromise.getPromise(),\n        };\n    }\n}\nexports.elementVisibility = elementVisibility;\n//# sourceMappingURL=element-visibility.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL2VsZW1lbnQtdmlzaWJpbGl0eS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9kb20vZWxlbWVudC12aXNpYmlsaXR5LmpzPzU3MTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVsZW1lbnRWaXNpYmlsaXR5ID0gdm9pZCAwO1xuY29uc3QgZGVmZXJfMSA9IHJlcXVpcmUoXCIuLi9mdW5jL2RlZmVyXCIpO1xuLyoqXG4gKiBBIGNvbXBvc2l0aW9uIGFyb3VuZCB0aGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgQVBJLlxuICogU3VwcG9ydCBpcyBmYWlybHkgZ29vZCBidXQgaWYgeW91IHdhbnQgbGVnYWN5IGJyb3dzZXJzLCBsb29rIGludG8gcG9seWZpbGxzLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW50ZXJzZWN0aW9uX09ic2VydmVyX0FQSVxuICovXG5jbGFzcyBlbGVtZW50VmlzaWJpbGl0eSB7XG4gICAgLyoqXG4gICAgICogVXNlcyB0aGUgaW50ZXJhY3Rpb24gQVBJIHRvIGRldGVjdCBlbGVtZW50IHZpc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbCBUaGUgZWxlbWVudCB0byBvYnNlcnZlXG4gICAgICogQHBhcmFtIHtPYmplY3Q/fSBvcHRpb25zIEludGVyYWN0aW9uIGFwaSBvcHRpb25zLlxuICAgICAqICAgVGhpcyBpbmNsdWRlcywgcm9vdCwgdGhyZXNob2xkIGFuZCByb290TWFyZ2luLlxuICAgICAqICAgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW50ZXJzZWN0aW9uX09ic2VydmVyX0FQSVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gZWFjaCBjaGFuZ2UuXG4gICAgICogICBUaGUgY2FsbGJhY2sgcmV0dXJucyB0aGUgZWxlbWVudCwgY2hhbmdlcywgZG9uZS4gIERvbmUgaXMgY2FsbGVkIHRvIHN0b3BcbiAgICAgKiAgIG9ic2VydmlpbmcuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgaW50ZXJzZWN0aW9uIG9ic2VydmVyLlxuICAgICAqXG4gICAgICogQmFzaWMgdXNhZ2U6XG4gICAgICpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKiBsZXQgZXYgPSBlbGVtZW50VmlzaWJpbGl0eS5pbnZpZXcoZWxlbWVudCk7XG4gICAgICpcbiAgICAgKiAvLyBFViB0YWtlcyBhIG1vbWVudCB0byBib290IHVwIHNvIHByb21pc2UgcHJvdmlkZWQuXG4gICAgICogZXYucmVhZHlQcm9taXNlLnRoZW4oKCkpPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coZXYuc3RhdGUoKS5pbnZpZXcpOyAvLyBJcyB0aGUgZWxtZWVudCBpbnZpZXcuXG4gICAgICogfSk7XG4gICAgICogZXYuZGlzcG9zZSgpO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKlxuICAgICAqIEJhc2ljIHVzYWdlIHdpdGggY2FsbGJhY2sgc3RydWN0dXJlLlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKlxuICAgICAqICAgZWxlbWVudFZpc2liaWxpdHkuaW52aWV3KGVsZW1lbnQsIHsgdGhyZXNob2xkOiAwLjMgfSxcbiAgICAgKiAgICAgLy8gTm90ZSB0aGF0IHlvdXIgY2FsbGJhY2sgd2lsbCBnZXQgaW1tZWRpYXRlbHlcbiAgICAgKiAgICAgLy8gY2FsbGVkIG9uY2UgdG8gY2hlY2sgdmlzaWJpbGl0eVxuICAgICAqICAgICAoZWxlbWVudCwgY2hhbmdlcywgZGlzcG9zZSk9PiB7XG4gICAgICogICAgICAgaWYoY2hhbmdlcy5pc0ludGVyc2VjdGluZykge1xuICAgICAqICAgICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgdmlzaWJpbGUuXG4gICAgICpcbiAgICAgKiAgICAgICAgIGRpc3Bvc2UoKTsgLy8gRGlzcG9zZSBpZiB5b3Ugd2FudC5cbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiAgICk7XG4gICAgICpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICpcbiAgICAgKiBFbGVtZW50IHZpc2liaWxpdHkgaW50ZXJuYWxseSBjYWNoZXMgdGhlIGxhc3Qga25vd24gY2hhbmdlcyBzbyB5b3VcbiAgICAgKiBjYW4gdXNlIHRoYXQgaW4geW91ciBhcHAuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG9mdGVuIGFuIGVhc2llciB3YXkgdG8gZG8gdGhpbmdzIHRoYXQgdXNlIHRoZSBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBsZXQgZXYgPSBlbGVtZW50VmlzaWJpbGl0eS5pbnZpZXcoZWxlbWVudCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldi5zdGF0ZSgpLmludmlldyk7IC8vIElzIHRoZSBlbG1lZW50IGludmlldyBub3c/XG4gICAgICpcbiAgICAgKiB3aW5kb3cuc2V0VGltZW91dCgoKT0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhldi5zdGF0ZSgpLmludmlldyk7IC8vIElzIGl0IGludmlldyBub3cgYWZ0ZXIgMyBzZWNvbmRzLlxuICAgICAqIH0sIDMwMDApO1xuICAgICAqXG4gICAgICogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsICgpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZyhldi5zdGF0ZSgpLmludmlldyk7IC8vIENoZWNrIHRvIHNlZSBpdCBpcyBpbiB2aWV3LlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZXYuc3RhdGUoKS5jaGFuZ2VzOyAvLyBBIGxpc3Qgb2YgYWxsIGtub3duIGxhc3QgY2hhbmdlcy5cbiAgICAgKiAgICAgICAgICAgICAgICAgICBDb250YWlucyBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5IGxpc3QuXG4gICAgICogZXYuc3RhdGUoKS5sYXN0Q2hhbmdlOyAvLyBKdXN0IHRoZSBsYXN0IGtub3duIEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkuXG4gICAgICpcbiAgICAgKlxuICAgICAqIGV2LmRpc3Bvc2UoKTsgLy8gUmVtZW1iZXIgdG8gZGlzcG9zZS5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICpcbiAgICAgKiAtLT4gSSB3YW50IHRvIGNoZWNrIGlmIG15IGVsZW1lbnQgaXMgaW52aWV3IGp1c3Qgb25jZS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbGV0IGV2ID0gZWxlbWVudFZpc2liaWxpdHkuaW52aWV3KGVsZW1lbnQsIHt9KTtcbiAgICAgKlxuICAgICAqIC8vIFRoaXMgY291bGQgYmUgZmFsc3kgc2luY2UgZXYgdGFrZXMgYSBtb21lbnQgdG8gYm9vdCB1cC5cbiAgICAgKiBldi5pbnZpZXc7IC8vIFRydWUgb3IgRmFsc2UuXG4gICAgICpcbiAgICAgKiAvLyBJbnN0ZWFkXG4gICAgICogaWYoZXYuc3RhdGUoKS5yZWFkeSkge1xuICAgICAqICAgZXYuaW52aWV3OyAvLyBUcnVlIG9yIEZhbHNlLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIC8vIE9yXG4gICAgICogZXYucmVhZHlQcm9taXNlLnRoZW4oKCk9PiB7XG4gICAgICogICBldi5pbnZpZXc7IC8vIFRydWUgb3IgRmFsc2UuXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBldi5kaXBvc2UoKTsgLy8gRGlzcG9zZSBpdC5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIC0tPiBJIHdhbnQgdG8gcnVuIHNjcm9sbCBldmVudHMgb25seSB3aGVuIHRoZSBlbGVtZW50IGlzIGludmlldy5cbiAgICAgKiBTZWUgW1tEb21XYXRjaGVyXV0gZm9yIGFuIGV4YW1wbGUgb2YgdGhpcy5cbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGludmlldyhlbGVtZW50LCBvcHRpb25zID0ge30sIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIENhY2hlIHRoZSBsYXN0IGtub3duIHN0YXRlIGluIHRoZSBjbG9zdXJlLlxuICAgICAgICBsZXQgY2FjaGVkQ2hhbmdlcyA9IG51bGw7XG4gICAgICAgIGxldCBjYWNoZWRMYXN0Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgbGV0IGNhY2hlZEludmlldyA9IG51bGw7XG4gICAgICAgIGxldCByZWFkeSA9IGZhbHNlO1xuICAgICAgICBjb25zdCByZWFkeVByb21pc2UgPSBuZXcgZGVmZXJfMS5EZWZlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBsYXN0IGtub3duIHN0YXRlIHZhbHVlcyBvZiBpbnZpZXcuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzdGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2hhbmdlczogY2FjaGVkQ2hhbmdlcyxcbiAgICAgICAgICAgICAgICBsYXN0Q2hhbmdlOiBjYWNoZWRMYXN0Q2hhbmdlLFxuICAgICAgICAgICAgICAgIGludmlldzogY2FjaGVkSW52aWV3LFxuICAgICAgICAgICAgICAgIHJlYWR5OiByZWFkeSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uQ2hhbmdlID0gKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIC8vIENhY2hlIHRoZSB2YWx1ZXMgb25seSBpZiB0aGVyZSB3YXMgYSBjaGFuZ2VcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgaXQgbWFpbnRhaW5zIHRoZSBsYXN0IGtub3duIGNoYW5nZS5cbiAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkQ2hhbmdlcyA9IGVudHJpZXM7XG4gICAgICAgICAgICAgICAgY2FjaGVkTGFzdENoYW5nZSA9IGVudHJpZXMuc2xpY2UoLTEpWzBdO1xuICAgICAgICAgICAgICAgIGNhY2hlZEludmlldyA9IGNhY2hlZExhc3RDaGFuZ2UuaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAgICAgcmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlYWR5UHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxsYmFjayBhbHdheXMgcGFzc2VzIHRoZSBcImN1cnJlbnRcIiBlbnRyaWVzIGV2ZW4gaWYgdGhlcmVcbiAgICAgICAgICAgIC8vIGFyZSBub25lLlxuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZWxlbWVudCwgZW50cmllcy5zbGljZSgtMSlbMF0sIGRpc3Bvc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZXZCeXBhc3M9dHJ1ZSBpcyB0aGUgdXJsIHBhcmFtZXRlciwgd2UgYWxsb3cgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICAgICAgICogdG8gYmUgYnlwYXNzZWQgYW5kIHdlIGltbWVkaWF0ZWx5IHJldHVybiB0cnVlIGZvciBpbnZpZXcuICBUaGlzIGlzXG4gICAgICAgICAqIHVzZWZ1bCBmb3IgYXV0b21hdGVkIHRlc3RpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgaW52aWV3QnlwYXNzUGFyYW0gPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnNwbGl0KCdldkJ5cGFzcz0nKVsxXTtcbiAgICAgICAgaW52aWV3QnlwYXNzUGFyYW0gPSBpbnZpZXdCeXBhc3NQYXJhbSAmJiBpbnZpZXdCeXBhc3NQYXJhbS5zcGxpdCgnJicpWzBdO1xuICAgICAgICBpZiAoaW52aWV3QnlwYXNzUGFyYW0gPT09ICd0cnVlJykge1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSW50ZXJzZWN0aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LCAoKSA9PiB7IH0pO1xuICAgICAgICAgICAgICAgIHJlYWR5UHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4geyB9LFxuICAgICAgICAgICAgICAgIHN0YXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkeTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmlldzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlYWR5UHJvbWlzZTogcmVhZHlQcm9taXNlLmdldFByb21pc2UoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzcG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIG9ic2VydmVyICYmIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIG9ic2VydmVyICYmIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGNhY2hlZENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGNhY2hlZExhc3RDaGFuZ2UgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihvbkNoYW5nZSwgb3B0aW9ucyk7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvYnNlcnZlcjogb2JzZXJ2ZXIsXG4gICAgICAgICAgICBkaXNwb3NlOiBkaXNwb3NlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIG1ldGhvZCB5b3UgY2FuIGNhbGwgdG8gYWNxdWlyZSB0aGUgbGFzdCBrbm93biBpbnZpZXcgc3RhdGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBwcm9taXNlIHRoYXQgcmVzb2x2ZWQgd2hlbiB0aGUgb2JzZXJ2ZXIgaXMgcmVhZHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlYWR5UHJvbWlzZTogcmVhZHlQcm9taXNlLmdldFByb21pc2UoKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLmVsZW1lbnRWaXNpYmlsaXR5ID0gZWxlbWVudFZpc2liaWxpdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVtZW50LXZpc2liaWxpdHkuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/dom/element-visibility.js\n");

/***/ }),

/***/ "./lib/dom/inview.js":
/*!***************************!*\
  !*** ./lib/dom/inview.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Inview = void 0;\nconst raf_1 = __webpack_require__(/*! ../raf/raf */ \"./lib/raf/raf.js\");\nconst dom_watcher_1 = __webpack_require__(/*! ../dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst InviewDefaultClassNames = {\n    READY: 'ready',\n    IN: 'in',\n    IN_ONCE: 'in-once',\n    IN_FOLD: 'in-fold',\n    DOWN: 'down',\n    UP: 'up',\n    OUT: 'out',\n};\n/**\n * Implements a basic type 1 inview.\n *\n * ```\n *        new Inview({\n *           element: document.getElementById('test2'),\n *           elementBaseline: 0,\n *           viewportOffset: 0.2,\n *           waitForOutOfViewToRefireInview: false,\n *           downOnlyMode: false,\n *           // Optionally override default class names.\n *           inviewClassNames: {\n *             IN: 'mymodule--in'\n *           }\n *       });\n * ```\n *\n *\n * Type 1 inview:\n * - will add an '.in' class to an element when the element is at\n *   at certain percentage of the viewport. (viewport offset) or\n *   when an X percentage of the element is visible or BOTH!.  See below.\n * - will add an '.in-once' when inview happens the first time.\n * - will immediately remove the '.in' class when the element goes out of\n *   view\n * - will immediately add '.out' class when the element goes out of\n *   view\n * - will add 'up' and 'down' class to the element based on the scroll direction\n *   allowing you to add directional inview.\n *\n * - waitForOutOfViewToRefireInview, downOnlyMode are options to modify the\n *   inview triggers.\n *\n *\n * # Inview Logic\n * The \"logic\" of how inview is calculated is important.  Two factors\n * are taken into consideration.\n *\n * The first is the elementBaseline.\n * The elementBaseline defaults to the very top of the element as that is the\n * most common case.  However, this is the line or point in the element in which the\n * trigger point is evaluated.  You can set it to a given percentage of\n * the element (like the very bottom of the element instead of the top).\n *\n * The second is the viewport offset.\n * The viewport offset ranges from 0-1 in which 0 is the bottom of the viewport window\n * and the 1 is the top.\n *\n *\n * Here are some examples of different settings.\n *\n * elementBaseline - 0 (top), viewportOffset - 0.2\n * => inview should happen when the top of the element crosses the bottom 20% of the window.\n *\n * elementBaseline - 0 (top), viewportOffset - 0.5\n * => inview should happen when the top of the element crosses the middle of the window.\n *\n * elementBaseline - 1 (bottom), viewportOffset - 0.5\n * => inview should happen when the bottom of the element crosses the middle of the window.\n *\n * elementBaseline - 0.2, viewportOffset - 0\n * => inview should happen when 20% of the element is visible.\n *\n * elementBaseline - 0.5, viewportOffset - 0\n * => inview should happen when 50% of the element is visible.\n *\n * elementBaseline - 0.5, viewportOffset - 0.5\n * => inview should happen when 50% of the element cross the middle of the screen.\n *\n * elementBaseline - 0, viewportOffset - 1\n * => inview should happen when then top of the element 0%, hits the top of the screen.\n *\n *\n *\n * # FOUC\n * While inview is booting up, there is a split second where it needs to evaluate the\n * inview state.  When inview is ready, the element will receive '.ready' class.\n *\n * You can do something like:\n *\n * ```\n * .myelement\n *    visibility: hidden\n * .myelement.ready\n *    visibility: visible\n *\n * ```\n *\n *\n * # outviewOnlyOnElementExit Mode\n * This changes the behavior of inview a bit.\n *\n * You can set it so that the outview doesn't fire based on the elementBaseline\n * but instead, when the full elmement, top and bottom are out of view.\n *\n * In short, once inview is fired, the element will stay in an inview state\n * until the element is compeltely out off view.\n *\n *\n * To clarify:\n * When scrolling back and up, based on your inview trigger point, the\n * user might see the element go from an instate to outstate back and forth.\n * For example, let's say you trigger at the top of the element (elementBaseline 0)\n * and 0.2 viewport offset.  As the user scrolls down,\n * the top of the element hits the bottom 20%\n * of the viewport, the element becomes in an inview state.  If the user scrolls back\n * up immediately, and the element is at 0.19, the element goes back to outview.\n *\n * This might be undesired.    By setting this option, it will fire outview until the\n * element has completely exited and therefore, preventing refiring of inview multiple\n * times while the element is inview.\n *\n * # downOnlyMode Mode\n * Downonly modes assumes your primary experience is scrolling down.  So\n * it will add an inview, when the element crosses the inview threshold when\n * scrolling down and then \"KEEP\" that inview attached.  Outview is ONLY\n * fired when the element is completley out of view AND below the viewport.\n *\n *\n *\n */\nclass Inview {\n    constructor(config) {\n        /**\n         * Last known scroll direction. 1 down, -1 up, 0 no direction.\n         */\n        this.scrollDirection = 0;\n        /**\n         * A flag to keep track of whether the element was inview atleast once.\n         */\n        this.inOnce = false;\n        /**\n         * A flag to keep track of in or out state.\n         */\n        this.isInState = false;\n        /**\n         * A caching flag. Set on events that would change the inview status of an\n         * element, cleared when a RAF loop has run.\n         * This will improve performance by culling RAF runs before work is done.\n         */\n        this.shouldRun = false;\n        // Establish defaults on the config as needed and then handle errors for bad\n        // configs.\n        this.config = Inview.assignDefaultsToConfig(config);\n        if (!this.config.element) {\n            throw new Error('No element is defined for inview');\n        }\n        // Assign property values\n        this.raf = new raf_1.Raf(() => this.onRaf());\n        this.readWrite = new raf_1.Raf();\n        this.watcher = new dom_watcher_1.DomWatcher();\n        this.inviewClassNames = Object.assign({}, InviewDefaultClassNames, config.inviewClassNames || {});\n        this.scrollY = window.scrollY;\n        this.targetElements = Inview.gatherTargetElements(this.config);\n        // Initialize the class and properties\n        this.init();\n    }\n    static gatherTargetElements(config) {\n        const targetElements = [config.element];\n        if (config.childSelector) {\n            Array.from(config.element.querySelectorAll(config.childSelector)).forEach(el => targetElements.push(el));\n        }\n        return targetElements;\n    }\n    static assignDefaultsToConfig(config) {\n        return Object.assign({\n            elementBaseline: 0,\n            viewportOffset: 0,\n            outviewOnlyOnElementExit: false,\n            downOnlyMode: false,\n        }, config);\n    }\n    runInviewState(force) {\n        if (this.isInState && !force) {\n            return;\n        }\n        this.readWrite.write(() => {\n            this.targetElements.forEach(el => {\n                el.classList.remove(this.inviewClassNames.OUT);\n                el.classList.add(this.inviewClassNames.IN);\n                if (!this.inOnce) {\n                    el.classList.add(this.inviewClassNames.IN_ONCE);\n                    this.inOnce = true;\n                    if (window.scrollY === 0) {\n                        el.classList.add(this.inviewClassNames.IN_FOLD);\n                    }\n                }\n                const isScrollingUp = this.scrollDirection === -1;\n                el.classList.remove(isScrollingUp\n                    ? this.inviewClassNames.DOWN\n                    : this.inviewClassNames.UP);\n                el.classList.add(isScrollingUp\n                    ? this.inviewClassNames.UP\n                    : this.inviewClassNames.DOWN);\n                this.isInState = true;\n            });\n        });\n    }\n    runOutviewState(force) {\n        if (!this.isInState && !force) {\n            return;\n        }\n        this.readWrite.write(() => {\n            this.targetElements.forEach(el => {\n                el.classList.add(this.inviewClassNames.OUT);\n                el.classList.remove(this.inviewClassNames.IN);\n                el.classList.remove(this.inviewClassNames.UP);\n                el.classList.remove(this.inviewClassNames.DOWN);\n                el.classList.add(this.scrollDirection === -1\n                    ? this.inviewClassNames.UP\n                    : this.inviewClassNames.DOWN);\n                this.isInState = false;\n            });\n        });\n    }\n    dispose() {\n        this.raf.dispose();\n        this.raf.dispose();\n        this.watcher.dispose();\n    }\n    init() {\n        this.initDomWatcher();\n        this.addInviewIndicesToTargetElements();\n        this.readyTargetElements();\n        this.initInview();\n        // Force update the state.\n        this.onRaf(true);\n    }\n    initDomWatcher() {\n        this.watcher.add({\n            element: window,\n            on: 'scroll',\n            callback: () => this.onWindowScroll(),\n            eventOptions: { passive: true },\n        });\n        this.watcher.add({\n            element: window,\n            on: 'smartResize',\n            callback: () => this.onWindowScroll(),\n            eventOptions: { passive: true },\n        });\n    }\n    addInviewIndicesToTargetElements() {\n        // Do nothing if there is only a single target element\n        if (this.targetElements.length <= 1) {\n            return;\n        }\n        this.readWrite.write(() => {\n            this.targetElements.forEach((target, i) => {\n                target.setAttribute('inview-index', `${i}`);\n            });\n        });\n    }\n    readyTargetElements() {\n        this.readWrite.write(() => {\n            this.targetElements.forEach((target) => {\n                target.classList.add(this.inviewClassNames.READY);\n            });\n        });\n    }\n    initInview() {\n        const intersectionObserverOptions = this.config\n            .evIntersectionObserverOptions || { rootMargin: '100px 0px 100px 0px' };\n        const inviewPromise = this.raf.runWhenElementIsInview(this.config.element, intersectionObserverOptions);\n        inviewPromise.then(() => this.raf.start());\n    }\n    onWindowScroll() {\n        this.raf.read(() => {\n            // Calculate the scroll direction.\n            const scrollY = window.scrollY;\n            this.scrollDirection = mathf_1.mathf.direction(this.scrollY, scrollY);\n            this.scrollY = scrollY;\n            this.shouldRun = true;\n        });\n    }\n    /**\n     * Request Animation Frame handle.  This runs only when the element is\n     * in the viewport.\n     */\n    onRaf(force) {\n        if (!force && !this.shouldRun) {\n            // Flag was not set, skip this iteration as there is not reason to expect\n            // any changes.\n            return;\n        }\n        this.shouldRun = false; // Clear the flag as the iteration is set to run\n        // Figure out how much of this element is visible.\n        this.readWrite.read(() => {\n            // Since generally, since we think in terms of scrolling down, 0 - 1 would\n            // be represented as:\n            // 1 ---> top of screen\n            // 0.5 --> middle of screen\n            // 0 --> bottom of screen\n            //\n            // Therefore, progress is represented as 0-1 where it goes from the bottom\n            // of the screen to the top.\n            //\n            // Additionally, we need to know, what point in the element should be used\n            // to see where the element resides.  We could use the top, center or\n            // bottom.\n            //\n            // The elementBaseline is used to factor this in.  The default state is\n            // calculated from the top of the element.\n            const wh = window.innerHeight;\n            const box = this.config.element.getBoundingClientRect();\n            const elementBaseline = box.top + this.config.elementBaseline * box.height;\n            // This is the percent of where element baseline is.\n            // So 0 would mean the elementbaseline is at the bottom of the viewport.\n            // 1 would mean elementBaseline is at the top of the viewport.\n            // A value less than viewport offset would mean that the element is above\n            // the viewport == outview.\n            const inPercent = 1 - mathf_1.mathf.inverseLerp(0, wh, elementBaseline, true);\n            // This is the percent of where the BOTTOM of the element is in the\n            // viewport.\n            // We want to use this to valuate whether the element is out of view.\n            // A value greater than 1 would mean that the element is above the\n            // viewport == outview.\n            const outPercent = 1 - mathf_1.mathf.inverseLerp(0, wh, box.top + box.height, true);\n            if (this.config.outviewOnlyOnElementExit) {\n                // This is the percent where the TOP of the element is in the viewport.\n                const topPercent = 1 - mathf_1.mathf.inverseLerp(0, wh, box.top, true);\n                // AKA\n                const bottomPercent = outPercent;\n                const completelyOutOfView = !mathf_1.mathf.isBetween(topPercent, 0, 1) &&\n                    !mathf_1.mathf.isBetween(bottomPercent, 0, 1);\n                if (inPercent < this.config.viewportOffset || outPercent >= 1) {\n                    if (completelyOutOfView) {\n                        this.runOutviewState(force);\n                    }\n                }\n                else {\n                    this.runInviewState(force);\n                }\n            }\n            else if (this.config.downOnlyMode) {\n                // This is the percent where the TOP of the element is in the viewport.\n                const topPercent = 1 - mathf_1.mathf.inverseLerp(0, wh, box.top, true);\n                const bottomPercent = outPercent;\n                // Down only mode.\n                const topOfElementIsBelowViewport = topPercent < 0;\n                const bottomOfElementIsAboveViewport = bottomPercent >= 1;\n                if (inPercent < this.config.viewportOffset || outPercent >= 1) {\n                    if (topOfElementIsBelowViewport) {\n                        this.runOutviewState(force);\n                    }\n                    // If the bottom of the element is above the viewport, we should\n                    // ensure it is in the instate.\n                    if (bottomOfElementIsAboveViewport) {\n                        this.runInviewState(force);\n                    }\n                }\n                else {\n                    this.runInviewState(force);\n                }\n            }\n            else {\n                // NORMAL INVIEW\n                // The outview conditions are in the outpercent (bottom of the element)\n                // is greater than 1\n                // or the inpercent (the element baseline) is below 0 under the screen.\n                if (inPercent < this.config.viewportOffset || outPercent >= 1) {\n                    this.runOutviewState(force);\n                }\n                else {\n                    this.runInviewState(force);\n                }\n            }\n        });\n    }\n}\nexports.Inview = Inview;\n//# sourceMappingURL=inview.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL2ludmlldy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9kb20vaW52aWV3LmpzPzg2OTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludmlldyA9IHZvaWQgMDtcbmNvbnN0IHJhZl8xID0gcmVxdWlyZShcIi4uL3JhZi9yYWZcIik7XG5jb25zdCBkb21fd2F0Y2hlcl8xID0gcmVxdWlyZShcIi4uL2RvbS9kb20td2F0Y2hlclwiKTtcbmNvbnN0IG1hdGhmXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvbWF0aGZcIik7XG5jb25zdCBJbnZpZXdEZWZhdWx0Q2xhc3NOYW1lcyA9IHtcbiAgICBSRUFEWTogJ3JlYWR5JyxcbiAgICBJTjogJ2luJyxcbiAgICBJTl9PTkNFOiAnaW4tb25jZScsXG4gICAgSU5fRk9MRDogJ2luLWZvbGQnLFxuICAgIERPV046ICdkb3duJyxcbiAgICBVUDogJ3VwJyxcbiAgICBPVVQ6ICdvdXQnLFxufTtcbi8qKlxuICogSW1wbGVtZW50cyBhIGJhc2ljIHR5cGUgMSBpbnZpZXcuXG4gKlxuICogYGBgXG4gKiAgICAgICAgbmV3IEludmlldyh7XG4gKiAgICAgICAgICAgZWxlbWVudDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rlc3QyJyksXG4gKiAgICAgICAgICAgZWxlbWVudEJhc2VsaW5lOiAwLFxuICogICAgICAgICAgIHZpZXdwb3J0T2Zmc2V0OiAwLjIsXG4gKiAgICAgICAgICAgd2FpdEZvck91dE9mVmlld1RvUmVmaXJlSW52aWV3OiBmYWxzZSxcbiAqICAgICAgICAgICBkb3duT25seU1vZGU6IGZhbHNlLFxuICogICAgICAgICAgIC8vIE9wdGlvbmFsbHkgb3ZlcnJpZGUgZGVmYXVsdCBjbGFzcyBuYW1lcy5cbiAqICAgICAgICAgICBpbnZpZXdDbGFzc05hbWVzOiB7XG4gKiAgICAgICAgICAgICBJTjogJ215bW9kdWxlLS1pbidcbiAqICAgICAgICAgICB9XG4gKiAgICAgICB9KTtcbiAqIGBgYFxuICpcbiAqXG4gKiBUeXBlIDEgaW52aWV3OlxuICogLSB3aWxsIGFkZCBhbiAnLmluJyBjbGFzcyB0byBhbiBlbGVtZW50IHdoZW4gdGhlIGVsZW1lbnQgaXMgYXRcbiAqICAgYXQgY2VydGFpbiBwZXJjZW50YWdlIG9mIHRoZSB2aWV3cG9ydC4gKHZpZXdwb3J0IG9mZnNldCkgb3JcbiAqICAgd2hlbiBhbiBYIHBlcmNlbnRhZ2Ugb2YgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBCT1RIIS4gIFNlZSBiZWxvdy5cbiAqIC0gd2lsbCBhZGQgYW4gJy5pbi1vbmNlJyB3aGVuIGludmlldyBoYXBwZW5zIHRoZSBmaXJzdCB0aW1lLlxuICogLSB3aWxsIGltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgJy5pbicgY2xhc3Mgd2hlbiB0aGUgZWxlbWVudCBnb2VzIG91dCBvZlxuICogICB2aWV3XG4gKiAtIHdpbGwgaW1tZWRpYXRlbHkgYWRkICcub3V0JyBjbGFzcyB3aGVuIHRoZSBlbGVtZW50IGdvZXMgb3V0IG9mXG4gKiAgIHZpZXdcbiAqIC0gd2lsbCBhZGQgJ3VwJyBhbmQgJ2Rvd24nIGNsYXNzIHRvIHRoZSBlbGVtZW50IGJhc2VkIG9uIHRoZSBzY3JvbGwgZGlyZWN0aW9uXG4gKiAgIGFsbG93aW5nIHlvdSB0byBhZGQgZGlyZWN0aW9uYWwgaW52aWV3LlxuICpcbiAqIC0gd2FpdEZvck91dE9mVmlld1RvUmVmaXJlSW52aWV3LCBkb3duT25seU1vZGUgYXJlIG9wdGlvbnMgdG8gbW9kaWZ5IHRoZVxuICogICBpbnZpZXcgdHJpZ2dlcnMuXG4gKlxuICpcbiAqICMgSW52aWV3IExvZ2ljXG4gKiBUaGUgXCJsb2dpY1wiIG9mIGhvdyBpbnZpZXcgaXMgY2FsY3VsYXRlZCBpcyBpbXBvcnRhbnQuICBUd28gZmFjdG9yc1xuICogYXJlIHRha2VuIGludG8gY29uc2lkZXJhdGlvbi5cbiAqXG4gKiBUaGUgZmlyc3QgaXMgdGhlIGVsZW1lbnRCYXNlbGluZS5cbiAqIFRoZSBlbGVtZW50QmFzZWxpbmUgZGVmYXVsdHMgdG8gdGhlIHZlcnkgdG9wIG9mIHRoZSBlbGVtZW50IGFzIHRoYXQgaXMgdGhlXG4gKiBtb3N0IGNvbW1vbiBjYXNlLiAgSG93ZXZlciwgdGhpcyBpcyB0aGUgbGluZSBvciBwb2ludCBpbiB0aGUgZWxlbWVudCBpbiB3aGljaCB0aGVcbiAqIHRyaWdnZXIgcG9pbnQgaXMgZXZhbHVhdGVkLiAgWW91IGNhbiBzZXQgaXQgdG8gYSBnaXZlbiBwZXJjZW50YWdlIG9mXG4gKiB0aGUgZWxlbWVudCAobGlrZSB0aGUgdmVyeSBib3R0b20gb2YgdGhlIGVsZW1lbnQgaW5zdGVhZCBvZiB0aGUgdG9wKS5cbiAqXG4gKiBUaGUgc2Vjb25kIGlzIHRoZSB2aWV3cG9ydCBvZmZzZXQuXG4gKiBUaGUgdmlld3BvcnQgb2Zmc2V0IHJhbmdlcyBmcm9tIDAtMSBpbiB3aGljaCAwIGlzIHRoZSBib3R0b20gb2YgdGhlIHZpZXdwb3J0IHdpbmRvd1xuICogYW5kIHRoZSAxIGlzIHRoZSB0b3AuXG4gKlxuICpcbiAqIEhlcmUgYXJlIHNvbWUgZXhhbXBsZXMgb2YgZGlmZmVyZW50IHNldHRpbmdzLlxuICpcbiAqIGVsZW1lbnRCYXNlbGluZSAtIDAgKHRvcCksIHZpZXdwb3J0T2Zmc2V0IC0gMC4yXG4gKiA9PiBpbnZpZXcgc2hvdWxkIGhhcHBlbiB3aGVuIHRoZSB0b3Agb2YgdGhlIGVsZW1lbnQgY3Jvc3NlcyB0aGUgYm90dG9tIDIwJSBvZiB0aGUgd2luZG93LlxuICpcbiAqIGVsZW1lbnRCYXNlbGluZSAtIDAgKHRvcCksIHZpZXdwb3J0T2Zmc2V0IC0gMC41XG4gKiA9PiBpbnZpZXcgc2hvdWxkIGhhcHBlbiB3aGVuIHRoZSB0b3Agb2YgdGhlIGVsZW1lbnQgY3Jvc3NlcyB0aGUgbWlkZGxlIG9mIHRoZSB3aW5kb3cuXG4gKlxuICogZWxlbWVudEJhc2VsaW5lIC0gMSAoYm90dG9tKSwgdmlld3BvcnRPZmZzZXQgLSAwLjVcbiAqID0+IGludmlldyBzaG91bGQgaGFwcGVuIHdoZW4gdGhlIGJvdHRvbSBvZiB0aGUgZWxlbWVudCBjcm9zc2VzIHRoZSBtaWRkbGUgb2YgdGhlIHdpbmRvdy5cbiAqXG4gKiBlbGVtZW50QmFzZWxpbmUgLSAwLjIsIHZpZXdwb3J0T2Zmc2V0IC0gMFxuICogPT4gaW52aWV3IHNob3VsZCBoYXBwZW4gd2hlbiAyMCUgb2YgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZS5cbiAqXG4gKiBlbGVtZW50QmFzZWxpbmUgLSAwLjUsIHZpZXdwb3J0T2Zmc2V0IC0gMFxuICogPT4gaW52aWV3IHNob3VsZCBoYXBwZW4gd2hlbiA1MCUgb2YgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZS5cbiAqXG4gKiBlbGVtZW50QmFzZWxpbmUgLSAwLjUsIHZpZXdwb3J0T2Zmc2V0IC0gMC41XG4gKiA9PiBpbnZpZXcgc2hvdWxkIGhhcHBlbiB3aGVuIDUwJSBvZiB0aGUgZWxlbWVudCBjcm9zcyB0aGUgbWlkZGxlIG9mIHRoZSBzY3JlZW4uXG4gKlxuICogZWxlbWVudEJhc2VsaW5lIC0gMCwgdmlld3BvcnRPZmZzZXQgLSAxXG4gKiA9PiBpbnZpZXcgc2hvdWxkIGhhcHBlbiB3aGVuIHRoZW4gdG9wIG9mIHRoZSBlbGVtZW50IDAlLCBoaXRzIHRoZSB0b3Agb2YgdGhlIHNjcmVlbi5cbiAqXG4gKlxuICpcbiAqICMgRk9VQ1xuICogV2hpbGUgaW52aWV3IGlzIGJvb3RpbmcgdXAsIHRoZXJlIGlzIGEgc3BsaXQgc2Vjb25kIHdoZXJlIGl0IG5lZWRzIHRvIGV2YWx1YXRlIHRoZVxuICogaW52aWV3IHN0YXRlLiAgV2hlbiBpbnZpZXcgaXMgcmVhZHksIHRoZSBlbGVtZW50IHdpbGwgcmVjZWl2ZSAnLnJlYWR5JyBjbGFzcy5cbiAqXG4gKiBZb3UgY2FuIGRvIHNvbWV0aGluZyBsaWtlOlxuICpcbiAqIGBgYFxuICogLm15ZWxlbWVudFxuICogICAgdmlzaWJpbGl0eTogaGlkZGVuXG4gKiAubXllbGVtZW50LnJlYWR5XG4gKiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlXG4gKlxuICogYGBgXG4gKlxuICpcbiAqICMgb3V0dmlld09ubHlPbkVsZW1lbnRFeGl0IE1vZGVcbiAqIFRoaXMgY2hhbmdlcyB0aGUgYmVoYXZpb3Igb2YgaW52aWV3IGEgYml0LlxuICpcbiAqIFlvdSBjYW4gc2V0IGl0IHNvIHRoYXQgdGhlIG91dHZpZXcgZG9lc24ndCBmaXJlIGJhc2VkIG9uIHRoZSBlbGVtZW50QmFzZWxpbmVcbiAqIGJ1dCBpbnN0ZWFkLCB3aGVuIHRoZSBmdWxsIGVsbWVtZW50LCB0b3AgYW5kIGJvdHRvbSBhcmUgb3V0IG9mIHZpZXcuXG4gKlxuICogSW4gc2hvcnQsIG9uY2UgaW52aWV3IGlzIGZpcmVkLCB0aGUgZWxlbWVudCB3aWxsIHN0YXkgaW4gYW4gaW52aWV3IHN0YXRlXG4gKiB1bnRpbCB0aGUgZWxlbWVudCBpcyBjb21wZWx0ZWx5IG91dCBvZmYgdmlldy5cbiAqXG4gKlxuICogVG8gY2xhcmlmeTpcbiAqIFdoZW4gc2Nyb2xsaW5nIGJhY2sgYW5kIHVwLCBiYXNlZCBvbiB5b3VyIGludmlldyB0cmlnZ2VyIHBvaW50LCB0aGVcbiAqIHVzZXIgbWlnaHQgc2VlIHRoZSBlbGVtZW50IGdvIGZyb20gYW4gaW5zdGF0ZSB0byBvdXRzdGF0ZSBiYWNrIGFuZCBmb3J0aC5cbiAqIEZvciBleGFtcGxlLCBsZXQncyBzYXkgeW91IHRyaWdnZXIgYXQgdGhlIHRvcCBvZiB0aGUgZWxlbWVudCAoZWxlbWVudEJhc2VsaW5lIDApXG4gKiBhbmQgMC4yIHZpZXdwb3J0IG9mZnNldC4gIEFzIHRoZSB1c2VyIHNjcm9sbHMgZG93bixcbiAqIHRoZSB0b3Agb2YgdGhlIGVsZW1lbnQgaGl0cyB0aGUgYm90dG9tIDIwJVxuICogb2YgdGhlIHZpZXdwb3J0LCB0aGUgZWxlbWVudCBiZWNvbWVzIGluIGFuIGludmlldyBzdGF0ZS4gIElmIHRoZSB1c2VyIHNjcm9sbHMgYmFja1xuICogdXAgaW1tZWRpYXRlbHksIGFuZCB0aGUgZWxlbWVudCBpcyBhdCAwLjE5LCB0aGUgZWxlbWVudCBnb2VzIGJhY2sgdG8gb3V0dmlldy5cbiAqXG4gKiBUaGlzIG1pZ2h0IGJlIHVuZGVzaXJlZC4gICAgQnkgc2V0dGluZyB0aGlzIG9wdGlvbiwgaXQgd2lsbCBmaXJlIG91dHZpZXcgdW50aWwgdGhlXG4gKiBlbGVtZW50IGhhcyBjb21wbGV0ZWx5IGV4aXRlZCBhbmQgdGhlcmVmb3JlLCBwcmV2ZW50aW5nIHJlZmlyaW5nIG9mIGludmlldyBtdWx0aXBsZVxuICogdGltZXMgd2hpbGUgdGhlIGVsZW1lbnQgaXMgaW52aWV3LlxuICpcbiAqICMgZG93bk9ubHlNb2RlIE1vZGVcbiAqIERvd25vbmx5IG1vZGVzIGFzc3VtZXMgeW91ciBwcmltYXJ5IGV4cGVyaWVuY2UgaXMgc2Nyb2xsaW5nIGRvd24uICBTb1xuICogaXQgd2lsbCBhZGQgYW4gaW52aWV3LCB3aGVuIHRoZSBlbGVtZW50IGNyb3NzZXMgdGhlIGludmlldyB0aHJlc2hvbGQgd2hlblxuICogc2Nyb2xsaW5nIGRvd24gYW5kIHRoZW4gXCJLRUVQXCIgdGhhdCBpbnZpZXcgYXR0YWNoZWQuICBPdXR2aWV3IGlzIE9OTFlcbiAqIGZpcmVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgY29tcGxldGxleSBvdXQgb2YgdmlldyBBTkQgYmVsb3cgdGhlIHZpZXdwb3J0LlxuICpcbiAqXG4gKlxuICovXG5jbGFzcyBJbnZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICAvKipcbiAgICAgICAgICogTGFzdCBrbm93biBzY3JvbGwgZGlyZWN0aW9uLiAxIGRvd24sIC0xIHVwLCAwIG5vIGRpcmVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsRGlyZWN0aW9uID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZmxhZyB0byBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlIGVsZW1lbnQgd2FzIGludmlldyBhdGxlYXN0IG9uY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluT25jZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIHRvIGtlZXAgdHJhY2sgb2YgaW4gb3Igb3V0IHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0luU3RhdGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2FjaGluZyBmbGFnLiBTZXQgb24gZXZlbnRzIHRoYXQgd291bGQgY2hhbmdlIHRoZSBpbnZpZXcgc3RhdHVzIG9mIGFuXG4gICAgICAgICAqIGVsZW1lbnQsIGNsZWFyZWQgd2hlbiBhIFJBRiBsb29wIGhhcyBydW4uXG4gICAgICAgICAqIFRoaXMgd2lsbCBpbXByb3ZlIHBlcmZvcm1hbmNlIGJ5IGN1bGxpbmcgUkFGIHJ1bnMgYmVmb3JlIHdvcmsgaXMgZG9uZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvdWxkUnVuID0gZmFsc2U7XG4gICAgICAgIC8vIEVzdGFibGlzaCBkZWZhdWx0cyBvbiB0aGUgY29uZmlnIGFzIG5lZWRlZCBhbmQgdGhlbiBoYW5kbGUgZXJyb3JzIGZvciBiYWRcbiAgICAgICAgLy8gY29uZmlncy5cbiAgICAgICAgdGhpcy5jb25maWcgPSBJbnZpZXcuYXNzaWduRGVmYXVsdHNUb0NvbmZpZyhjb25maWcpO1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpcyBkZWZpbmVkIGZvciBpbnZpZXcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBc3NpZ24gcHJvcGVydHkgdmFsdWVzXG4gICAgICAgIHRoaXMucmFmID0gbmV3IHJhZl8xLlJhZigoKSA9PiB0aGlzLm9uUmFmKCkpO1xuICAgICAgICB0aGlzLnJlYWRXcml0ZSA9IG5ldyByYWZfMS5SYWYoKTtcbiAgICAgICAgdGhpcy53YXRjaGVyID0gbmV3IGRvbV93YXRjaGVyXzEuRG9tV2F0Y2hlcigpO1xuICAgICAgICB0aGlzLmludmlld0NsYXNzTmFtZXMgPSBPYmplY3QuYXNzaWduKHt9LCBJbnZpZXdEZWZhdWx0Q2xhc3NOYW1lcywgY29uZmlnLmludmlld0NsYXNzTmFtZXMgfHwge30pO1xuICAgICAgICB0aGlzLnNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50cyA9IEludmlldy5nYXRoZXJUYXJnZXRFbGVtZW50cyh0aGlzLmNvbmZpZyk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGNsYXNzIGFuZCBwcm9wZXJ0aWVzXG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2F0aGVyVGFyZ2V0RWxlbWVudHMoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnRzID0gW2NvbmZpZy5lbGVtZW50XTtcbiAgICAgICAgaWYgKGNvbmZpZy5jaGlsZFNlbGVjdG9yKSB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKGNvbmZpZy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY29uZmlnLmNoaWxkU2VsZWN0b3IpKS5mb3JFYWNoKGVsID0+IHRhcmdldEVsZW1lbnRzLnB1c2goZWwpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0RWxlbWVudHM7XG4gICAgfVxuICAgIHN0YXRpYyBhc3NpZ25EZWZhdWx0c1RvQ29uZmlnKGNvbmZpZykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBlbGVtZW50QmFzZWxpbmU6IDAsXG4gICAgICAgICAgICB2aWV3cG9ydE9mZnNldDogMCxcbiAgICAgICAgICAgIG91dHZpZXdPbmx5T25FbGVtZW50RXhpdDogZmFsc2UsXG4gICAgICAgICAgICBkb3duT25seU1vZGU6IGZhbHNlLFxuICAgICAgICB9LCBjb25maWcpO1xuICAgIH1cbiAgICBydW5JbnZpZXdTdGF0ZShmb3JjZSkge1xuICAgICAgICBpZiAodGhpcy5pc0luU3RhdGUgJiYgIWZvcmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkV3JpdGUud3JpdGUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuaW52aWV3Q2xhc3NOYW1lcy5PVVQpO1xuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQodGhpcy5pbnZpZXdDbGFzc05hbWVzLklOKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5PbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQodGhpcy5pbnZpZXdDbGFzc05hbWVzLklOX09OQ0UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluT25jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuc2Nyb2xsWSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCh0aGlzLmludmlld0NsYXNzTmFtZXMuSU5fRk9MRCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTY3JvbGxpbmdVcCA9IHRoaXMuc2Nyb2xsRGlyZWN0aW9uID09PSAtMTtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGlzU2Nyb2xsaW5nVXBcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmludmlld0NsYXNzTmFtZXMuRE9XTlxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuaW52aWV3Q2xhc3NOYW1lcy5VUCk7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChpc1Njcm9sbGluZ1VwXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5pbnZpZXdDbGFzc05hbWVzLlVQXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5pbnZpZXdDbGFzc05hbWVzLkRPV04pO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNJblN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcnVuT3V0dmlld1N0YXRlKGZvcmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0luU3RhdGUgJiYgIWZvcmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkV3JpdGUud3JpdGUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKHRoaXMuaW52aWV3Q2xhc3NOYW1lcy5PVVQpO1xuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5pbnZpZXdDbGFzc05hbWVzLklOKTtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuaW52aWV3Q2xhc3NOYW1lcy5VUCk7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmludmlld0NsYXNzTmFtZXMuRE9XTik7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCh0aGlzLnNjcm9sbERpcmVjdGlvbiA9PT0gLTFcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmludmlld0NsYXNzTmFtZXMuVVBcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmludmlld0NsYXNzTmFtZXMuRE9XTik7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0luU3RhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5yYWYuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnJhZi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMud2F0Y2hlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuaW5pdERvbVdhdGNoZXIoKTtcbiAgICAgICAgdGhpcy5hZGRJbnZpZXdJbmRpY2VzVG9UYXJnZXRFbGVtZW50cygpO1xuICAgICAgICB0aGlzLnJlYWR5VGFyZ2V0RWxlbWVudHMoKTtcbiAgICAgICAgdGhpcy5pbml0SW52aWV3KCk7XG4gICAgICAgIC8vIEZvcmNlIHVwZGF0ZSB0aGUgc3RhdGUuXG4gICAgICAgIHRoaXMub25SYWYodHJ1ZSk7XG4gICAgfVxuICAgIGluaXREb21XYXRjaGVyKCkge1xuICAgICAgICB0aGlzLndhdGNoZXIuYWRkKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgICAgICAgIG9uOiAnc2Nyb2xsJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLm9uV2luZG93U2Nyb2xsKCksXG4gICAgICAgICAgICBldmVudE9wdGlvbnM6IHsgcGFzc2l2ZTogdHJ1ZSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53YXRjaGVyLmFkZCh7XG4gICAgICAgICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICAgICAgICBvbjogJ3NtYXJ0UmVzaXplJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLm9uV2luZG93U2Nyb2xsKCksXG4gICAgICAgICAgICBldmVudE9wdGlvbnM6IHsgcGFzc2l2ZTogdHJ1ZSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkSW52aWV3SW5kaWNlc1RvVGFyZ2V0RWxlbWVudHMoKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgdGhlcmUgaXMgb25seSBhIHNpbmdsZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICBpZiAodGhpcy50YXJnZXRFbGVtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhZFdyaXRlLndyaXRlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RWxlbWVudHMuZm9yRWFjaCgodGFyZ2V0LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnaW52aWV3LWluZGV4JywgYCR7aX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVhZHlUYXJnZXRFbGVtZW50cygpIHtcbiAgICAgICAgdGhpcy5yZWFkV3JpdGUud3JpdGUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRFbGVtZW50cy5mb3JFYWNoKCh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCh0aGlzLmludmlld0NsYXNzTmFtZXMuUkVBRFkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0SW52aWV3KCkge1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb25PYnNlcnZlck9wdGlvbnMgPSB0aGlzLmNvbmZpZ1xuICAgICAgICAgICAgLmV2SW50ZXJzZWN0aW9uT2JzZXJ2ZXJPcHRpb25zIHx8IHsgcm9vdE1hcmdpbjogJzEwMHB4IDBweCAxMDBweCAwcHgnIH07XG4gICAgICAgIGNvbnN0IGludmlld1Byb21pc2UgPSB0aGlzLnJhZi5ydW5XaGVuRWxlbWVudElzSW52aWV3KHRoaXMuY29uZmlnLmVsZW1lbnQsIGludGVyc2VjdGlvbk9ic2VydmVyT3B0aW9ucyk7XG4gICAgICAgIGludmlld1Byb21pc2UudGhlbigoKSA9PiB0aGlzLnJhZi5zdGFydCgpKTtcbiAgICB9XG4gICAgb25XaW5kb3dTY3JvbGwoKSB7XG4gICAgICAgIHRoaXMucmFmLnJlYWQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzY3JvbGwgZGlyZWN0aW9uLlxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsWSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxEaXJlY3Rpb24gPSBtYXRoZl8xLm1hdGhmLmRpcmVjdGlvbih0aGlzLnNjcm9sbFksIHNjcm9sbFkpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxZID0gc2Nyb2xsWTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkUnVuID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgQW5pbWF0aW9uIEZyYW1lIGhhbmRsZS4gIFRoaXMgcnVucyBvbmx5IHdoZW4gdGhlIGVsZW1lbnQgaXNcbiAgICAgKiBpbiB0aGUgdmlld3BvcnQuXG4gICAgICovXG4gICAgb25SYWYoZm9yY2UpIHtcbiAgICAgICAgaWYgKCFmb3JjZSAmJiAhdGhpcy5zaG91bGRSdW4pIHtcbiAgICAgICAgICAgIC8vIEZsYWcgd2FzIG5vdCBzZXQsIHNraXAgdGhpcyBpdGVyYXRpb24gYXMgdGhlcmUgaXMgbm90IHJlYXNvbiB0byBleHBlY3RcbiAgICAgICAgICAgIC8vIGFueSBjaGFuZ2VzLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hvdWxkUnVuID0gZmFsc2U7IC8vIENsZWFyIHRoZSBmbGFnIGFzIHRoZSBpdGVyYXRpb24gaXMgc2V0IHRvIHJ1blxuICAgICAgICAvLyBGaWd1cmUgb3V0IGhvdyBtdWNoIG9mIHRoaXMgZWxlbWVudCBpcyB2aXNpYmxlLlxuICAgICAgICB0aGlzLnJlYWRXcml0ZS5yZWFkKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFNpbmNlIGdlbmVyYWxseSwgc2luY2Ugd2UgdGhpbmsgaW4gdGVybXMgb2Ygc2Nyb2xsaW5nIGRvd24sIDAgLSAxIHdvdWxkXG4gICAgICAgICAgICAvLyBiZSByZXByZXNlbnRlZCBhczpcbiAgICAgICAgICAgIC8vIDEgLS0tPiB0b3Agb2Ygc2NyZWVuXG4gICAgICAgICAgICAvLyAwLjUgLS0+IG1pZGRsZSBvZiBzY3JlZW5cbiAgICAgICAgICAgIC8vIDAgLS0+IGJvdHRvbSBvZiBzY3JlZW5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGVyZWZvcmUsIHByb2dyZXNzIGlzIHJlcHJlc2VudGVkIGFzIDAtMSB3aGVyZSBpdCBnb2VzIGZyb20gdGhlIGJvdHRvbVxuICAgICAgICAgICAgLy8gb2YgdGhlIHNjcmVlbiB0byB0aGUgdG9wLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEFkZGl0aW9uYWxseSwgd2UgbmVlZCB0byBrbm93LCB3aGF0IHBvaW50IGluIHRoZSBlbGVtZW50IHNob3VsZCBiZSB1c2VkXG4gICAgICAgICAgICAvLyB0byBzZWUgd2hlcmUgdGhlIGVsZW1lbnQgcmVzaWRlcy4gIFdlIGNvdWxkIHVzZSB0aGUgdG9wLCBjZW50ZXIgb3JcbiAgICAgICAgICAgIC8vIGJvdHRvbS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudEJhc2VsaW5lIGlzIHVzZWQgdG8gZmFjdG9yIHRoaXMgaW4uICBUaGUgZGVmYXVsdCBzdGF0ZSBpc1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlZCBmcm9tIHRoZSB0b3Agb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgICAgICBjb25zdCB3aCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGJveCA9IHRoaXMuY29uZmlnLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50QmFzZWxpbmUgPSBib3gudG9wICsgdGhpcy5jb25maWcuZWxlbWVudEJhc2VsaW5lICogYm94LmhlaWdodDtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHBlcmNlbnQgb2Ygd2hlcmUgZWxlbWVudCBiYXNlbGluZSBpcy5cbiAgICAgICAgICAgIC8vIFNvIDAgd291bGQgbWVhbiB0aGUgZWxlbWVudGJhc2VsaW5lIGlzIGF0IHRoZSBib3R0b20gb2YgdGhlIHZpZXdwb3J0LlxuICAgICAgICAgICAgLy8gMSB3b3VsZCBtZWFuIGVsZW1lbnRCYXNlbGluZSBpcyBhdCB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgICAgIC8vIEEgdmFsdWUgbGVzcyB0aGFuIHZpZXdwb3J0IG9mZnNldCB3b3VsZCBtZWFuIHRoYXQgdGhlIGVsZW1lbnQgaXMgYWJvdmVcbiAgICAgICAgICAgIC8vIHRoZSB2aWV3cG9ydCA9PSBvdXR2aWV3LlxuICAgICAgICAgICAgY29uc3QgaW5QZXJjZW50ID0gMSAtIG1hdGhmXzEubWF0aGYuaW52ZXJzZUxlcnAoMCwgd2gsIGVsZW1lbnRCYXNlbGluZSwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBwZXJjZW50IG9mIHdoZXJlIHRoZSBCT1RUT00gb2YgdGhlIGVsZW1lbnQgaXMgaW4gdGhlXG4gICAgICAgICAgICAvLyB2aWV3cG9ydC5cbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gdXNlIHRoaXMgdG8gdmFsdWF0ZSB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIG91dCBvZiB2aWV3LlxuICAgICAgICAgICAgLy8gQSB2YWx1ZSBncmVhdGVyIHRoYW4gMSB3b3VsZCBtZWFuIHRoYXQgdGhlIGVsZW1lbnQgaXMgYWJvdmUgdGhlXG4gICAgICAgICAgICAvLyB2aWV3cG9ydCA9PSBvdXR2aWV3LlxuICAgICAgICAgICAgY29uc3Qgb3V0UGVyY2VudCA9IDEgLSBtYXRoZl8xLm1hdGhmLmludmVyc2VMZXJwKDAsIHdoLCBib3gudG9wICsgYm94LmhlaWdodCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcub3V0dmlld09ubHlPbkVsZW1lbnRFeGl0KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcGVyY2VudCB3aGVyZSB0aGUgVE9QIG9mIHRoZSBlbGVtZW50IGlzIGluIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgICAgICAgICBjb25zdCB0b3BQZXJjZW50ID0gMSAtIG1hdGhmXzEubWF0aGYuaW52ZXJzZUxlcnAoMCwgd2gsIGJveC50b3AsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIEFLQVxuICAgICAgICAgICAgICAgIGNvbnN0IGJvdHRvbVBlcmNlbnQgPSBvdXRQZXJjZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlbHlPdXRPZlZpZXcgPSAhbWF0aGZfMS5tYXRoZi5pc0JldHdlZW4odG9wUGVyY2VudCwgMCwgMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIW1hdGhmXzEubWF0aGYuaXNCZXR3ZWVuKGJvdHRvbVBlcmNlbnQsIDAsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChpblBlcmNlbnQgPCB0aGlzLmNvbmZpZy52aWV3cG9ydE9mZnNldCB8fCBvdXRQZXJjZW50ID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlbHlPdXRPZlZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnVuT3V0dmlld1N0YXRlKGZvcmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5JbnZpZXdTdGF0ZShmb3JjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25maWcuZG93bk9ubHlNb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcGVyY2VudCB3aGVyZSB0aGUgVE9QIG9mIHRoZSBlbGVtZW50IGlzIGluIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgICAgICAgICBjb25zdCB0b3BQZXJjZW50ID0gMSAtIG1hdGhmXzEubWF0aGYuaW52ZXJzZUxlcnAoMCwgd2gsIGJveC50b3AsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvdHRvbVBlcmNlbnQgPSBvdXRQZXJjZW50O1xuICAgICAgICAgICAgICAgIC8vIERvd24gb25seSBtb2RlLlxuICAgICAgICAgICAgICAgIGNvbnN0IHRvcE9mRWxlbWVudElzQmVsb3dWaWV3cG9ydCA9IHRvcFBlcmNlbnQgPCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvdHRvbU9mRWxlbWVudElzQWJvdmVWaWV3cG9ydCA9IGJvdHRvbVBlcmNlbnQgPj0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaW5QZXJjZW50IDwgdGhpcy5jb25maWcudmlld3BvcnRPZmZzZXQgfHwgb3V0UGVyY2VudCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3BPZkVsZW1lbnRJc0JlbG93Vmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnVuT3V0dmlld1N0YXRlKGZvcmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYm90dG9tIG9mIHRoZSBlbGVtZW50IGlzIGFib3ZlIHRoZSB2aWV3cG9ydCwgd2Ugc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBpdCBpcyBpbiB0aGUgaW5zdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvdHRvbU9mRWxlbWVudElzQWJvdmVWaWV3cG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5JbnZpZXdTdGF0ZShmb3JjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuSW52aWV3U3RhdGUoZm9yY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5PUk1BTCBJTlZJRVdcbiAgICAgICAgICAgICAgICAvLyBUaGUgb3V0dmlldyBjb25kaXRpb25zIGFyZSBpbiB0aGUgb3V0cGVyY2VudCAoYm90dG9tIG9mIHRoZSBlbGVtZW50KVxuICAgICAgICAgICAgICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiAxXG4gICAgICAgICAgICAgICAgLy8gb3IgdGhlIGlucGVyY2VudCAodGhlIGVsZW1lbnQgYmFzZWxpbmUpIGlzIGJlbG93IDAgdW5kZXIgdGhlIHNjcmVlbi5cbiAgICAgICAgICAgICAgICBpZiAoaW5QZXJjZW50IDwgdGhpcy5jb25maWcudmlld3BvcnRPZmZzZXQgfHwgb3V0UGVyY2VudCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuT3V0dmlld1N0YXRlKGZvcmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuSW52aWV3U3RhdGUoZm9yY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZpZXcgPSBJbnZpZXc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZpZXcuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/dom/inview.js\n");

/***/ }),

/***/ "./lib/dom/mouse-tracker.js":
/*!**********************************!*\
  !*** ./lib/dom/mouse-tracker.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MouseTracker = void 0;\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst vector_1 = __webpack_require__(/*! ../mathf/vector */ \"./lib/mathf/vector.js\");\nconst is_1 = __webpack_require__(/*! ../is/is */ \"./lib/is/is.js\");\nconst dom_watcher_1 = __webpack_require__(/*! ./dom-watcher */ \"./lib/dom/dom-watcher.js\");\n/**\n * Class that helps with mouse tracking.\n * TODO (uxder): This is from a really old class.  I need to upgrade it.\n *      Could also still be buggy.\n * @unstable\n * @hidden\n */\nclass MouseTracker {\n    /**\n     * @constructor\n     */\n    constructor(rootElement, moveCallBack, disableMobile) {\n        this.rootElement_ = rootElement;\n        this.dimensions_ = {};\n        this.moveCallBack = moveCallBack;\n        this.mouseData = {};\n        this.position = vector_1.Vector.ZERO;\n        this.windowY = window.scrollY;\n        this.lastWindowY = window.scrollY;\n        this.lastPosition = vector_1.Vector.ZERO;\n        this.calculateRootElementDimensions_();\n        this.watcher = new dom_watcher_1.DomWatcher();\n        this.watcher.add({\n            element: window,\n            on: 'resize',\n            callback: this.calculateRootElementDimensions_.bind(this),\n            eventOptions: { passive: true },\n        });\n        this.watcher.add({\n            element: window,\n            on: 'scroll',\n            callback: this.onScroll.bind(this),\n            eventOptions: { passive: true },\n        });\n        if (!disableMobile && is_1.is.supportingDeviceOrientation()) {\n            this.watcher.add({\n                element: window,\n                on: 'deviceorientation',\n                callback: this.onDeviceOrientation.bind(this),\n                eventOptions: { passive: true },\n            });\n        }\n        this.watcher.add({\n            element: document.body,\n            on: 'mousemove',\n            callback: this.onMouseMove.bind(this),\n            eventOptions: { passive: true },\n        });\n        this.watcher.add({\n            element: document.body,\n            on: 'touchmove',\n            callback: this.onMouseMove.bind(this),\n            eventOptions: { passive: true },\n        });\n    }\n    /**\n     * Calculates the base dimensions of the rootElement.\n     */\n    calculateRootElementDimensions_() {\n        const docRect = document.body.getBoundingClientRect();\n        const rect = this.rootElement_.getBoundingClientRect();\n        // Calculate the center point.\n        const xCenter = rect.left + rect.width / 2;\n        const yCenter = rect.top + rect.height / 2;\n        this.dimensions_ = {\n            width: rect.width,\n            height: rect.height,\n            halfWidth: rect.width / 2,\n            halfHeight: rect.height / 2,\n            top: rect.top,\n            left: rect.left,\n            xCenter: xCenter,\n            yCenter: yCenter,\n            docWidth: docRect.width,\n            docHeight: docRect.height,\n        };\n    }\n    /**\n     * On scroll update the Y position so that the mouse\n     * position always updates.\n     */\n    onScroll() {\n        this.windowY = window.scrollY;\n        const offset = this.windowY - this.lastWindowY;\n        const y = this.lastPosition.y + offset;\n        this.updateMouseData(this.lastPosition.x, y);\n        this.moveCallBack && this.moveCallBack(this.mouseData);\n    }\n    /**\n     * Handles the mouseRootElement move.\n     * @type {MouseEvent}\n     */\n    onMouseMove(e) {\n        const x = e.pageX || e.clientX;\n        const y = e.pageY || e.clientY;\n        this.lastWindowY = window.scrollY;\n        this.lastPosition = this.position.clone();\n        this.updateMouseData(x, y);\n        this.moveCallBack && this.moveCallBack(this.mouseData);\n    }\n    updateMouseData(x, y) {\n        this.position.x = x;\n        this.position.y = y;\n        this.mouseData = {\n            position: this.position,\n            x: x,\n            y: y,\n            deltaX: x - this.dimensions_.xCenter,\n            deltaY: y - this.dimensions_.yCenter,\n            percentageX: ((x - this.dimensions_.xCenter) / this.dimensions_.docWidth) * 100,\n            percentageY: ((y - this.dimensions_.yCenter) / this.dimensions_.docHeight) * 100,\n        };\n    }\n    /**\n     * Handles the device orientation.\n     * @type {MouseEvent}\n     */\n    onDeviceOrientation(event) {\n        const x = mathf_1.mathf.clamp(-50, 50, event.gamma);\n        const y = mathf_1.mathf.clamp(-50, 50, event.beta);\n        this.mouseData = {\n            x: 0,\n            y: 0,\n            deltaX: 0,\n            deltaY: 0,\n            percentageX: x,\n            percentageY: y,\n        };\n        this.moveCallBack && this.moveCallBack(this.mouseData);\n    }\n    /**\n     * Gets the mouse positions.\n     */\n    getMousePosition() {\n        return this.mouseData;\n    }\n    dispose() {\n        this.watcher.dispose();\n    }\n}\nexports.MouseTracker = MouseTracker;\n//# sourceMappingURL=mouse-tracker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL21vdXNlLXRyYWNrZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL21vdXNlLXRyYWNrZXIuanM/NDE0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW91c2VUcmFja2VyID0gdm9pZCAwO1xuY29uc3QgbWF0aGZfMSA9IHJlcXVpcmUoXCIuLi9tYXRoZi9tYXRoZlwiKTtcbmNvbnN0IHZlY3Rvcl8xID0gcmVxdWlyZShcIi4uL21hdGhmL3ZlY3RvclwiKTtcbmNvbnN0IGlzXzEgPSByZXF1aXJlKFwiLi4vaXMvaXNcIik7XG5jb25zdCBkb21fd2F0Y2hlcl8xID0gcmVxdWlyZShcIi4vZG9tLXdhdGNoZXJcIik7XG4vKipcbiAqIENsYXNzIHRoYXQgaGVscHMgd2l0aCBtb3VzZSB0cmFja2luZy5cbiAqIFRPRE8gKHV4ZGVyKTogVGhpcyBpcyBmcm9tIGEgcmVhbGx5IG9sZCBjbGFzcy4gIEkgbmVlZCB0byB1cGdyYWRlIGl0LlxuICogICAgICBDb3VsZCBhbHNvIHN0aWxsIGJlIGJ1Z2d5LlxuICogQHVuc3RhYmxlXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE1vdXNlVHJhY2tlciB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iocm9vdEVsZW1lbnQsIG1vdmVDYWxsQmFjaywgZGlzYWJsZU1vYmlsZSkge1xuICAgICAgICB0aGlzLnJvb3RFbGVtZW50XyA9IHJvb3RFbGVtZW50O1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnNfID0ge307XG4gICAgICAgIHRoaXMubW92ZUNhbGxCYWNrID0gbW92ZUNhbGxCYWNrO1xuICAgICAgICB0aGlzLm1vdXNlRGF0YSA9IHt9O1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gdmVjdG9yXzEuVmVjdG9yLlpFUk87XG4gICAgICAgIHRoaXMud2luZG93WSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICB0aGlzLmxhc3RXaW5kb3dZID0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgIHRoaXMubGFzdFBvc2l0aW9uID0gdmVjdG9yXzEuVmVjdG9yLlpFUk87XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUm9vdEVsZW1lbnREaW1lbnNpb25zXygpO1xuICAgICAgICB0aGlzLndhdGNoZXIgPSBuZXcgZG9tX3dhdGNoZXJfMS5Eb21XYXRjaGVyKCk7XG4gICAgICAgIHRoaXMud2F0Y2hlci5hZGQoe1xuICAgICAgICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgICAgICAgb246ICdyZXNpemUnLFxuICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMuY2FsY3VsYXRlUm9vdEVsZW1lbnREaW1lbnNpb25zXy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZXZlbnRPcHRpb25zOiB7IHBhc3NpdmU6IHRydWUgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud2F0Y2hlci5hZGQoe1xuICAgICAgICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgICAgICAgb246ICdzY3JvbGwnLFxuICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMub25TY3JvbGwuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uczogeyBwYXNzaXZlOiB0cnVlIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWRpc2FibGVNb2JpbGUgJiYgaXNfMS5pcy5zdXBwb3J0aW5nRGV2aWNlT3JpZW50YXRpb24oKSkge1xuICAgICAgICAgICAgdGhpcy53YXRjaGVyLmFkZCh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgICAgICAgICAgIG9uOiAnZGV2aWNlb3JpZW50YXRpb24nLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0aGlzLm9uRGV2aWNlT3JpZW50YXRpb24uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICBldmVudE9wdGlvbnM6IHsgcGFzc2l2ZTogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXRjaGVyLmFkZCh7XG4gICAgICAgICAgICBlbGVtZW50OiBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgb246ICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uczogeyBwYXNzaXZlOiB0cnVlIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndhdGNoZXIuYWRkKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICBvbjogJ3RvdWNobW92ZScsXG4gICAgICAgICAgICBjYWxsYmFjazogdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZXZlbnRPcHRpb25zOiB7IHBhc3NpdmU6IHRydWUgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGJhc2UgZGltZW5zaW9ucyBvZiB0aGUgcm9vdEVsZW1lbnQuXG4gICAgICovXG4gICAgY2FsY3VsYXRlUm9vdEVsZW1lbnREaW1lbnNpb25zXygpIHtcbiAgICAgICAgY29uc3QgZG9jUmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLnJvb3RFbGVtZW50Xy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjZW50ZXIgcG9pbnQuXG4gICAgICAgIGNvbnN0IHhDZW50ZXIgPSByZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgeUNlbnRlciA9IHJlY3QudG9wICsgcmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnNfID0ge1xuICAgICAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgaGFsZldpZHRoOiByZWN0LndpZHRoIC8gMixcbiAgICAgICAgICAgIGhhbGZIZWlnaHQ6IHJlY3QuaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIHRvcDogcmVjdC50b3AsXG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgICAgICAgICB4Q2VudGVyOiB4Q2VudGVyLFxuICAgICAgICAgICAgeUNlbnRlcjogeUNlbnRlcixcbiAgICAgICAgICAgIGRvY1dpZHRoOiBkb2NSZWN0LndpZHRoLFxuICAgICAgICAgICAgZG9jSGVpZ2h0OiBkb2NSZWN0LmhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT24gc2Nyb2xsIHVwZGF0ZSB0aGUgWSBwb3NpdGlvbiBzbyB0aGF0IHRoZSBtb3VzZVxuICAgICAqIHBvc2l0aW9uIGFsd2F5cyB1cGRhdGVzLlxuICAgICAqL1xuICAgIG9uU2Nyb2xsKCkge1xuICAgICAgICB0aGlzLndpbmRvd1kgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy53aW5kb3dZIC0gdGhpcy5sYXN0V2luZG93WTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMubGFzdFBvc2l0aW9uLnkgKyBvZmZzZXQ7XG4gICAgICAgIHRoaXMudXBkYXRlTW91c2VEYXRhKHRoaXMubGFzdFBvc2l0aW9uLngsIHkpO1xuICAgICAgICB0aGlzLm1vdmVDYWxsQmFjayAmJiB0aGlzLm1vdmVDYWxsQmFjayh0aGlzLm1vdXNlRGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIG1vdXNlUm9vdEVsZW1lbnQgbW92ZS5cbiAgICAgKiBAdHlwZSB7TW91c2VFdmVudH1cbiAgICAgKi9cbiAgICBvbk1vdXNlTW92ZShlKSB7XG4gICAgICAgIGNvbnN0IHggPSBlLnBhZ2VYIHx8IGUuY2xpZW50WDtcbiAgICAgICAgY29uc3QgeSA9IGUucGFnZVkgfHwgZS5jbGllbnRZO1xuICAgICAgICB0aGlzLmxhc3RXaW5kb3dZID0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgIHRoaXMubGFzdFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1vdXNlRGF0YSh4LCB5KTtcbiAgICAgICAgdGhpcy5tb3ZlQ2FsbEJhY2sgJiYgdGhpcy5tb3ZlQ2FsbEJhY2sodGhpcy5tb3VzZURhdGEpO1xuICAgIH1cbiAgICB1cGRhdGVNb3VzZURhdGEoeCwgeSkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSB4O1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSB5O1xuICAgICAgICB0aGlzLm1vdXNlRGF0YSA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLFxuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBkZWx0YVg6IHggLSB0aGlzLmRpbWVuc2lvbnNfLnhDZW50ZXIsXG4gICAgICAgICAgICBkZWx0YVk6IHkgLSB0aGlzLmRpbWVuc2lvbnNfLnlDZW50ZXIsXG4gICAgICAgICAgICBwZXJjZW50YWdlWDogKCh4IC0gdGhpcy5kaW1lbnNpb25zXy54Q2VudGVyKSAvIHRoaXMuZGltZW5zaW9uc18uZG9jV2lkdGgpICogMTAwLFxuICAgICAgICAgICAgcGVyY2VudGFnZVk6ICgoeSAtIHRoaXMuZGltZW5zaW9uc18ueUNlbnRlcikgLyB0aGlzLmRpbWVuc2lvbnNfLmRvY0hlaWdodCkgKiAxMDAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGRldmljZSBvcmllbnRhdGlvbi5cbiAgICAgKiBAdHlwZSB7TW91c2VFdmVudH1cbiAgICAgKi9cbiAgICBvbkRldmljZU9yaWVudGF0aW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHggPSBtYXRoZl8xLm1hdGhmLmNsYW1wKC01MCwgNTAsIGV2ZW50LmdhbW1hKTtcbiAgICAgICAgY29uc3QgeSA9IG1hdGhmXzEubWF0aGYuY2xhbXAoLTUwLCA1MCwgZXZlbnQuYmV0YSk7XG4gICAgICAgIHRoaXMubW91c2VEYXRhID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICBkZWx0YVg6IDAsXG4gICAgICAgICAgICBkZWx0YVk6IDAsXG4gICAgICAgICAgICBwZXJjZW50YWdlWDogeCxcbiAgICAgICAgICAgIHBlcmNlbnRhZ2VZOiB5LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1vdmVDYWxsQmFjayAmJiB0aGlzLm1vdmVDYWxsQmFjayh0aGlzLm1vdXNlRGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1vdXNlIHBvc2l0aW9ucy5cbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZURhdGE7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMud2F0Y2hlci5kaXNwb3NlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Nb3VzZVRyYWNrZXIgPSBNb3VzZVRyYWNrZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb3VzZS10cmFja2VyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/dom/mouse-tracker.js\n");

/***/ }),

/***/ "./lib/dom/off-screen-canvas.js":
/*!**************************************!*\
  !*** ./lib/dom/off-screen-canvas.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OffScreenCanvas = void 0;\nconst web_worker_1 = __webpack_require__(/*! ./web-worker */ \"./lib/dom/web-worker.js\");\n/**\n * An experimental class that works with offscreen canvas and makes it\n * pretty easy to run tasks on a canvas in a separate thread.\n *\n * This works but there are some gotchas that users should be aware of.\n * As of now, offScreenCanvas is run a separate thread with\n * limitations, thisl class is best used for doing computational tasks\n * that can be wrapped in a task call.\n *\n * It may not be well suited to say try to run a huge 3D application.\n * If you want run a large app, you are probably better off making or finding\n * a different offScreenCanvas implementation.\n *\n * See the example usage in the /examples/off-screen-canvas sample.\n *\n * Read the below for the walk through.  There are several limitations.\n *\n *\n * TODO (uxder): The process of setup and be simplified.  setCanvas for example\n *     seems like an extra step.\n *\n *\n *```ts\n * import { OffScreenCanvas, is } from '@blinkk/degu';\n *\n * // Check for support and handle non-supporting browsers as you see fit.\n * if (!is.supportingOffScreenCanvas()) {\n *     throw new Error('Sorry your browser is not suppported');\n * }\n *\n * // First create an instance of OffScreenCanvas.\n * const offScreenCanvas = new OffScreenCanvas();\n *\n * // Grab the canvas element on your page (or create one).\n * const canvas = document.getElementById('canvas');\n *\n * // Now set the offscreen canvas.  This is a REQUIRED step before\n * // making calls.  It tells offScreenCanvas to prepare this canvas\n * // to be transferable via webWorkers.\n * offScreenCanvas.setCanvas(canvas);\n *\n *\n * // Create a function that will run as a web worker.  This will get executed\n * // on a different threadc.\n * //\n * // Limitation 1: Note that this  code actually ends up getting stringified\n * // (important), bundled and sent to a separate thread.\n * // Therefore, it is sandboxed in it's own world.\n * //\n * //\n * // Limitation 2:\n * // The function should accept only 1 parameter AND it must be named \"params\"\n * // by convention.  You can send any parameters up as an object.  This is done\n * // as a convention and to make it easier to wrap up.  See WebWorker for more.\n * //\n *  const task = (params) => {\n *       // If a command called init was sent, set the canvas\n *        if (params.command === 'init') {\n *           self.canvas = params.canvas;\n *           console.log(\"Hello\", params.name);\n *           self.ctx = canvas.getContext('2d');\n *        }\n *\n *       // Defines an animation loop.\n *       var animate = () => {\n *           // Do something cool.\n *           // This will draw on the canvas (on your main thread)\n *           ctx.fillRect(0, 0, 150, 75);\n *           requestAnimationFrame(animate);\n *       };\n *\n *       if (params.command === 'animate') {\n *         animate();\n *         // Return a mesagge when animate is sent.\n *         return { message: 'FROM WORKER: started animation' };\n *       }\n *   };\n *\n * // Now bind and set that task to your instanfe of OffScreenCanvas.\n * // This will tell offScreenCanvas to run your task in a separate thread.\n * offScreenCanvas.setCanvasTask(task);\n *\n *\n * // Now initialize offscreen canvas.  The canvas is automatically sent\n * // and will be available in your task with params.canvas.  You can send\n * // additional key/value data.\n *  offScreenCanvas.init({\n *     command: 'init',\n *     name: 'Scott'\n *   }).then((message) => {\n *\n *            // Once initialized, send additional commands with\n *            // sendMessageToCanvas.\n *            offScreenCanvas.sendMessageToCanvas({\n *                command: 'animate',\n *                data: 'John'\n *            }).then((message) => {\n *                console.log(message); // FROM WORKER: started animation\n *            });\n *        });\n *  }\n *\n * // When you are all done, don't forget to terminate the WebWorker.\n * offScreenCanvas.terminate();\n * ```\n *\n *\n * Now assuing you had the canvas you set attached to the DOM, you should\n * see the canvas draw itself.  This is because, when you ran\n * [[OffScreenCanvas.setCanvas]], you basically set it to release control of it\n * to a separate worker.  So the manipulations to the canvas\n * (draw call on context) get updated and visible.\n *\n *\n * @unstable\n */\nclass OffScreenCanvas {\n    constructor() {\n        this.canvas = null;\n        this.offScreenHandler = null;\n        this.worker = null;\n        this.canvasSent = false;\n        this.initialized = false;\n    }\n    /**\n     * Sets the canvas to be used as offSetCanvas.  Save the canvas to be\n     * used.\n     * @param canvas\n     */\n    setCanvas(canvas) {\n        this.canvas = canvas;\n        // Make this into an offscreen canvas.\n        this.canvas = this.canvas['transferControlToOffscreen']();\n    }\n    /**\n     * The handler for the offscreen canvas worker.\n     * Note that the contents of this task are stringified and send to a separate\n     * thread so the contents of the task are sandboxed.  Same limitations as\n     * regular webworkers applieds (no access to DOM for exmaple)\n     * @param message\n     */\n    setCanvasTask(task) {\n        this.offScreenHandler = task;\n        this.worker = new web_worker_1.WebWorker(this.offScreenHandler);\n    }\n    /**\n     * Sends the first message to the worker with the transferable canvas\n     */\n    init(message) {\n        if (!this.canvas) {\n            throw new Error('Set your canvas first.');\n        }\n        if (!this.worker) {\n            throw new Error('Set off screen handler first.');\n        }\n        this.initialized = true;\n        message['canvas'] = this.canvas;\n        this.canvasSent = true;\n        return this.worker.run(message, [this.canvas]);\n    }\n    /**\n     * Sends a message to the worker.\n     * @param message\n     */\n    sendMessageToCanvas(message) {\n        if (!this.canvasSent || !this.worker || !this.canvas || !this.initialized) {\n            throw new Error('You must initialize must.');\n        }\n        return this.worker.run(message);\n    }\n    dispose() {\n        this.worker && this.worker.terminate();\n    }\n}\nexports.OffScreenCanvas = OffScreenCanvas;\n//# sourceMappingURL=off-screen-canvas.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL29mZi1zY3JlZW4tY2FudmFzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2RvbS9vZmYtc2NyZWVuLWNhbnZhcy5qcz8xZjg3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PZmZTY3JlZW5DYW52YXMgPSB2b2lkIDA7XG5jb25zdCB3ZWJfd29ya2VyXzEgPSByZXF1aXJlKFwiLi93ZWItd29ya2VyXCIpO1xuLyoqXG4gKiBBbiBleHBlcmltZW50YWwgY2xhc3MgdGhhdCB3b3JrcyB3aXRoIG9mZnNjcmVlbiBjYW52YXMgYW5kIG1ha2VzIGl0XG4gKiBwcmV0dHkgZWFzeSB0byBydW4gdGFza3Mgb24gYSBjYW52YXMgaW4gYSBzZXBhcmF0ZSB0aHJlYWQuXG4gKlxuICogVGhpcyB3b3JrcyBidXQgdGhlcmUgYXJlIHNvbWUgZ290Y2hhcyB0aGF0IHVzZXJzIHNob3VsZCBiZSBhd2FyZSBvZi5cbiAqIEFzIG9mIG5vdywgb2ZmU2NyZWVuQ2FudmFzIGlzIHJ1biBhIHNlcGFyYXRlIHRocmVhZCB3aXRoXG4gKiBsaW1pdGF0aW9ucywgdGhpc2wgY2xhc3MgaXMgYmVzdCB1c2VkIGZvciBkb2luZyBjb21wdXRhdGlvbmFsIHRhc2tzXG4gKiB0aGF0IGNhbiBiZSB3cmFwcGVkIGluIGEgdGFzayBjYWxsLlxuICpcbiAqIEl0IG1heSBub3QgYmUgd2VsbCBzdWl0ZWQgdG8gc2F5IHRyeSB0byBydW4gYSBodWdlIDNEIGFwcGxpY2F0aW9uLlxuICogSWYgeW91IHdhbnQgcnVuIGEgbGFyZ2UgYXBwLCB5b3UgYXJlIHByb2JhYmx5IGJldHRlciBvZmYgbWFraW5nIG9yIGZpbmRpbmdcbiAqIGEgZGlmZmVyZW50IG9mZlNjcmVlbkNhbnZhcyBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBTZWUgdGhlIGV4YW1wbGUgdXNhZ2UgaW4gdGhlIC9leGFtcGxlcy9vZmYtc2NyZWVuLWNhbnZhcyBzYW1wbGUuXG4gKlxuICogUmVhZCB0aGUgYmVsb3cgZm9yIHRoZSB3YWxrIHRocm91Z2guICBUaGVyZSBhcmUgc2V2ZXJhbCBsaW1pdGF0aW9ucy5cbiAqXG4gKlxuICogVE9ETyAodXhkZXIpOiBUaGUgcHJvY2VzcyBvZiBzZXR1cCBhbmQgYmUgc2ltcGxpZmllZC4gIHNldENhbnZhcyBmb3IgZXhhbXBsZVxuICogICAgIHNlZW1zIGxpa2UgYW4gZXh0cmEgc3RlcC5cbiAqXG4gKlxuICpgYGB0c1xuICogaW1wb3J0IHsgT2ZmU2NyZWVuQ2FudmFzLCBpcyB9IGZyb20gJ0BibGlua2svZGVndSc7XG4gKlxuICogLy8gQ2hlY2sgZm9yIHN1cHBvcnQgYW5kIGhhbmRsZSBub24tc3VwcG9ydGluZyBicm93c2VycyBhcyB5b3Ugc2VlIGZpdC5cbiAqIGlmICghaXMuc3VwcG9ydGluZ09mZlNjcmVlbkNhbnZhcygpKSB7XG4gKiAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3JyeSB5b3VyIGJyb3dzZXIgaXMgbm90IHN1cHBwb3J0ZWQnKTtcbiAqIH1cbiAqXG4gKiAvLyBGaXJzdCBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgT2ZmU2NyZWVuQ2FudmFzLlxuICogY29uc3Qgb2ZmU2NyZWVuQ2FudmFzID0gbmV3IE9mZlNjcmVlbkNhbnZhcygpO1xuICpcbiAqIC8vIEdyYWIgdGhlIGNhbnZhcyBlbGVtZW50IG9uIHlvdXIgcGFnZSAob3IgY3JlYXRlIG9uZSkuXG4gKiBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzJyk7XG4gKlxuICogLy8gTm93IHNldCB0aGUgb2Zmc2NyZWVuIGNhbnZhcy4gIFRoaXMgaXMgYSBSRVFVSVJFRCBzdGVwIGJlZm9yZVxuICogLy8gbWFraW5nIGNhbGxzLiAgSXQgdGVsbHMgb2ZmU2NyZWVuQ2FudmFzIHRvIHByZXBhcmUgdGhpcyBjYW52YXNcbiAqIC8vIHRvIGJlIHRyYW5zZmVyYWJsZSB2aWEgd2ViV29ya2Vycy5cbiAqIG9mZlNjcmVlbkNhbnZhcy5zZXRDYW52YXMoY2FudmFzKTtcbiAqXG4gKlxuICogLy8gQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJ1biBhcyBhIHdlYiB3b3JrZXIuICBUaGlzIHdpbGwgZ2V0IGV4ZWN1dGVkXG4gKiAvLyBvbiBhIGRpZmZlcmVudCB0aHJlYWRjLlxuICogLy9cbiAqIC8vIExpbWl0YXRpb24gMTogTm90ZSB0aGF0IHRoaXMgIGNvZGUgYWN0dWFsbHkgZW5kcyB1cCBnZXR0aW5nIHN0cmluZ2lmaWVkXG4gKiAvLyAoaW1wb3J0YW50KSwgYnVuZGxlZCBhbmQgc2VudCB0byBhIHNlcGFyYXRlIHRocmVhZC5cbiAqIC8vIFRoZXJlZm9yZSwgaXQgaXMgc2FuZGJveGVkIGluIGl0J3Mgb3duIHdvcmxkLlxuICogLy9cbiAqIC8vXG4gKiAvLyBMaW1pdGF0aW9uIDI6XG4gKiAvLyBUaGUgZnVuY3Rpb24gc2hvdWxkIGFjY2VwdCBvbmx5IDEgcGFyYW1ldGVyIEFORCBpdCBtdXN0IGJlIG5hbWVkIFwicGFyYW1zXCJcbiAqIC8vIGJ5IGNvbnZlbnRpb24uICBZb3UgY2FuIHNlbmQgYW55IHBhcmFtZXRlcnMgdXAgYXMgYW4gb2JqZWN0LiAgVGhpcyBpcyBkb25lXG4gKiAvLyBhcyBhIGNvbnZlbnRpb24gYW5kIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHdyYXAgdXAuICBTZWUgV2ViV29ya2VyIGZvciBtb3JlLlxuICogLy9cbiAqICBjb25zdCB0YXNrID0gKHBhcmFtcykgPT4ge1xuICogICAgICAgLy8gSWYgYSBjb21tYW5kIGNhbGxlZCBpbml0IHdhcyBzZW50LCBzZXQgdGhlIGNhbnZhc1xuICogICAgICAgIGlmIChwYXJhbXMuY29tbWFuZCA9PT0gJ2luaXQnKSB7XG4gKiAgICAgICAgICAgc2VsZi5jYW52YXMgPSBwYXJhbXMuY2FudmFzO1xuICogICAgICAgICAgIGNvbnNvbGUubG9nKFwiSGVsbG9cIiwgcGFyYW1zLm5hbWUpO1xuICogICAgICAgICAgIHNlbGYuY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gKiAgICAgICAgfVxuICpcbiAqICAgICAgIC8vIERlZmluZXMgYW4gYW5pbWF0aW9uIGxvb3AuXG4gKiAgICAgICB2YXIgYW5pbWF0ZSA9ICgpID0+IHtcbiAqICAgICAgICAgICAvLyBEbyBzb21ldGhpbmcgY29vbC5cbiAqICAgICAgICAgICAvLyBUaGlzIHdpbGwgZHJhdyBvbiB0aGUgY2FudmFzIChvbiB5b3VyIG1haW4gdGhyZWFkKVxuICogICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCAxNTAsIDc1KTtcbiAqICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gKiAgICAgICB9O1xuICpcbiAqICAgICAgIGlmIChwYXJhbXMuY29tbWFuZCA9PT0gJ2FuaW1hdGUnKSB7XG4gKiAgICAgICAgIGFuaW1hdGUoKTtcbiAqICAgICAgICAgLy8gUmV0dXJuIGEgbWVzYWdnZSB3aGVuIGFuaW1hdGUgaXMgc2VudC5cbiAqICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogJ0ZST00gV09SS0VSOiBzdGFydGVkIGFuaW1hdGlvbicgfTtcbiAqICAgICAgIH1cbiAqICAgfTtcbiAqXG4gKiAvLyBOb3cgYmluZCBhbmQgc2V0IHRoYXQgdGFzayB0byB5b3VyIGluc3RhbmZlIG9mIE9mZlNjcmVlbkNhbnZhcy5cbiAqIC8vIFRoaXMgd2lsbCB0ZWxsIG9mZlNjcmVlbkNhbnZhcyB0byBydW4geW91ciB0YXNrIGluIGEgc2VwYXJhdGUgdGhyZWFkLlxuICogb2ZmU2NyZWVuQ2FudmFzLnNldENhbnZhc1Rhc2sodGFzayk7XG4gKlxuICpcbiAqIC8vIE5vdyBpbml0aWFsaXplIG9mZnNjcmVlbiBjYW52YXMuICBUaGUgY2FudmFzIGlzIGF1dG9tYXRpY2FsbHkgc2VudFxuICogLy8gYW5kIHdpbGwgYmUgYXZhaWxhYmxlIGluIHlvdXIgdGFzayB3aXRoIHBhcmFtcy5jYW52YXMuICBZb3UgY2FuIHNlbmRcbiAqIC8vIGFkZGl0aW9uYWwga2V5L3ZhbHVlIGRhdGEuXG4gKiAgb2ZmU2NyZWVuQ2FudmFzLmluaXQoe1xuICogICAgIGNvbW1hbmQ6ICdpbml0JyxcbiAqICAgICBuYW1lOiAnU2NvdHQnXG4gKiAgIH0pLnRoZW4oKG1lc3NhZ2UpID0+IHtcbiAqXG4gKiAgICAgICAgICAgIC8vIE9uY2UgaW5pdGlhbGl6ZWQsIHNlbmQgYWRkaXRpb25hbCBjb21tYW5kcyB3aXRoXG4gKiAgICAgICAgICAgIC8vIHNlbmRNZXNzYWdlVG9DYW52YXMuXG4gKiAgICAgICAgICAgIG9mZlNjcmVlbkNhbnZhcy5zZW5kTWVzc2FnZVRvQ2FudmFzKHtcbiAqICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdhbmltYXRlJyxcbiAqICAgICAgICAgICAgICAgIGRhdGE6ICdKb2huJ1xuICogICAgICAgICAgICB9KS50aGVuKChtZXNzYWdlKSA9PiB7XG4gKiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTsgLy8gRlJPTSBXT1JLRVI6IHN0YXJ0ZWQgYW5pbWF0aW9uXG4gKiAgICAgICAgICAgIH0pO1xuICogICAgICAgIH0pO1xuICogIH1cbiAqXG4gKiAvLyBXaGVuIHlvdSBhcmUgYWxsIGRvbmUsIGRvbid0IGZvcmdldCB0byB0ZXJtaW5hdGUgdGhlIFdlYldvcmtlci5cbiAqIG9mZlNjcmVlbkNhbnZhcy50ZXJtaW5hdGUoKTtcbiAqIGBgYFxuICpcbiAqXG4gKiBOb3cgYXNzdWluZyB5b3UgaGFkIHRoZSBjYW52YXMgeW91IHNldCBhdHRhY2hlZCB0byB0aGUgRE9NLCB5b3Ugc2hvdWxkXG4gKiBzZWUgdGhlIGNhbnZhcyBkcmF3IGl0c2VsZi4gIFRoaXMgaXMgYmVjYXVzZSwgd2hlbiB5b3UgcmFuXG4gKiBbW09mZlNjcmVlbkNhbnZhcy5zZXRDYW52YXNdXSwgeW91IGJhc2ljYWxseSBzZXQgaXQgdG8gcmVsZWFzZSBjb250cm9sIG9mIGl0XG4gKiB0byBhIHNlcGFyYXRlIHdvcmtlci4gIFNvIHRoZSBtYW5pcHVsYXRpb25zIHRvIHRoZSBjYW52YXNcbiAqIChkcmF3IGNhbGwgb24gY29udGV4dCkgZ2V0IHVwZGF0ZWQgYW5kIHZpc2libGUuXG4gKlxuICpcbiAqIEB1bnN0YWJsZVxuICovXG5jbGFzcyBPZmZTY3JlZW5DYW52YXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMub2ZmU2NyZWVuSGFuZGxlciA9IG51bGw7XG4gICAgICAgIHRoaXMud29ya2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW52YXNTZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY2FudmFzIHRvIGJlIHVzZWQgYXMgb2ZmU2V0Q2FudmFzLiAgU2F2ZSB0aGUgY2FudmFzIHRvIGJlXG4gICAgICogdXNlZC5cbiAgICAgKiBAcGFyYW0gY2FudmFzXG4gICAgICovXG4gICAgc2V0Q2FudmFzKGNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgLy8gTWFrZSB0aGlzIGludG8gYW4gb2Zmc2NyZWVuIGNhbnZhcy5cbiAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLmNhbnZhc1sndHJhbnNmZXJDb250cm9sVG9PZmZzY3JlZW4nXSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgaGFuZGxlciBmb3IgdGhlIG9mZnNjcmVlbiBjYW52YXMgd29ya2VyLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgY29udGVudHMgb2YgdGhpcyB0YXNrIGFyZSBzdHJpbmdpZmllZCBhbmQgc2VuZCB0byBhIHNlcGFyYXRlXG4gICAgICogdGhyZWFkIHNvIHRoZSBjb250ZW50cyBvZiB0aGUgdGFzayBhcmUgc2FuZGJveGVkLiAgU2FtZSBsaW1pdGF0aW9ucyBhc1xuICAgICAqIHJlZ3VsYXIgd2Vid29ya2VycyBhcHBsaWVkcyAobm8gYWNjZXNzIHRvIERPTSBmb3IgZXhtYXBsZSlcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgICAqL1xuICAgIHNldENhbnZhc1Rhc2sodGFzaykge1xuICAgICAgICB0aGlzLm9mZlNjcmVlbkhhbmRsZXIgPSB0YXNrO1xuICAgICAgICB0aGlzLndvcmtlciA9IG5ldyB3ZWJfd29ya2VyXzEuV2ViV29ya2VyKHRoaXMub2ZmU2NyZWVuSGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIHRoZSBmaXJzdCBtZXNzYWdlIHRvIHRoZSB3b3JrZXIgd2l0aCB0aGUgdHJhbnNmZXJhYmxlIGNhbnZhc1xuICAgICAqL1xuICAgIGluaXQobWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NldCB5b3VyIGNhbnZhcyBmaXJzdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NldCBvZmYgc2NyZWVuIGhhbmRsZXIgZmlyc3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIG1lc3NhZ2VbJ2NhbnZhcyddID0gdGhpcy5jYW52YXM7XG4gICAgICAgIHRoaXMuY2FudmFzU2VudCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLndvcmtlci5ydW4obWVzc2FnZSwgW3RoaXMuY2FudmFzXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgd29ya2VyLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlXG4gICAgICovXG4gICAgc2VuZE1lc3NhZ2VUb0NhbnZhcyhtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW52YXNTZW50IHx8ICF0aGlzLndvcmtlciB8fCAhdGhpcy5jYW52YXMgfHwgIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgaW5pdGlhbGl6ZSBtdXN0LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndvcmtlci5ydW4obWVzc2FnZSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMud29ya2VyICYmIHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuT2ZmU2NyZWVuQ2FudmFzID0gT2ZmU2NyZWVuQ2FudmFzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2ZmLXNjcmVlbi1jYW52YXMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/dom/off-screen-canvas.js\n");

/***/ }),

/***/ "./lib/dom/scroll-render-fix.js":
/*!**************************************!*\
  !*** ./lib/dom/scroll-render-fix.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ScrollRenderFix = void 0;\nconst raf_1 = __webpack_require__(/*! ../raf/raf */ \"./lib/raf/raf.js\");\nconst dom_watcher_1 = __webpack_require__(/*! ./dom-watcher */ \"./lib/dom/dom-watcher.js\");\nconst noop_1 = __webpack_require__(/*! ../func/noop */ \"./lib/func/noop.js\");\n/**\n * What this class does is, it eats the window.wheel event\n * and eats the scroll.  It allows the rendering to catch up and then\n * once it is done,  it reapplies the scroll to the document.\n *\n * While this sounds counter-intuitive, it allows rendering to catchup\n * and can smooth animations.\n *\n * In short, if you have scroll tied animations or intense animations,\n * this can help fix the issue.\n *\n *\n * Thanks to Angus and Eric for this tip.\n *\n * Since this issue is chrome specific, you might want scope it to only chrome.\n * Usage:\n *\n * ```\n * if (is.chrome()) {\n *   new ScrollRenderFix();\n * }\n * ```\n *\n * To take full advantage, use toolbox mutate or degu.read / writes.\n * ```\n *\n * const raf = new Raf();\n *\n * raf.read(()=> {\n *   // do some reading\n * })\n *\n * raf.writing(()=> {\n *   // do some writing\n * })\n *\n * ```\n *\n *\n *\n */\nclass ScrollRenderFix {\n    constructor(config = {}) {\n        this.currentY = 0;\n        this.targetY = 0;\n        this.raf = new raf_1.Raf();\n        this.beforeScrollCallback = config.beforeScrollCallback || noop_1.noop;\n        this.afterScrollCallback = config.afterScrollCallback || noop_1.noop;\n        this.domWatcher = new dom_watcher_1.DomWatcher();\n        this.domWatcher.add({\n            element: document,\n            on: 'wheel',\n            eventOptions: { passive: false, capture: true },\n            callback: this.wheelHandler.bind(this),\n        });\n    }\n    getScrollElement() {\n        return document.scrollingElement || document.documentElement;\n    }\n    wheelHandler(e) {\n        e.preventDefault();\n        this.raf.read(() => {\n            this.targetY = this.getScrollElement().scrollTop + e.deltaY;\n            this.raf.postWrite(() => {\n                this.beforeScrollCallback();\n                if (this.currentY !== this.targetY) {\n                    this.getScrollElement().scrollTop = this.targetY;\n                    this.currentY = this.targetY;\n                }\n                this.afterScrollCallback();\n            });\n        });\n    }\n    dispose() {\n        this.domWatcher && this.domWatcher.dispose();\n        this.raf && this.raf.dispose();\n    }\n}\nexports.ScrollRenderFix = ScrollRenderFix;\n//# sourceMappingURL=scroll-render-fix.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL3Njcm9sbC1yZW5kZXItZml4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2RvbS9zY3JvbGwtcmVuZGVyLWZpeC5qcz9iMmQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TY3JvbGxSZW5kZXJGaXggPSB2b2lkIDA7XG5jb25zdCByYWZfMSA9IHJlcXVpcmUoXCIuLi9yYWYvcmFmXCIpO1xuY29uc3QgZG9tX3dhdGNoZXJfMSA9IHJlcXVpcmUoXCIuL2RvbS13YXRjaGVyXCIpO1xuY29uc3Qgbm9vcF8xID0gcmVxdWlyZShcIi4uL2Z1bmMvbm9vcFwiKTtcbi8qKlxuICogV2hhdCB0aGlzIGNsYXNzIGRvZXMgaXMsIGl0IGVhdHMgdGhlIHdpbmRvdy53aGVlbCBldmVudFxuICogYW5kIGVhdHMgdGhlIHNjcm9sbC4gIEl0IGFsbG93cyB0aGUgcmVuZGVyaW5nIHRvIGNhdGNoIHVwIGFuZCB0aGVuXG4gKiBvbmNlIGl0IGlzIGRvbmUsICBpdCByZWFwcGxpZXMgdGhlIHNjcm9sbCB0byB0aGUgZG9jdW1lbnQuXG4gKlxuICogV2hpbGUgdGhpcyBzb3VuZHMgY291bnRlci1pbnR1aXRpdmUsIGl0IGFsbG93cyByZW5kZXJpbmcgdG8gY2F0Y2h1cFxuICogYW5kIGNhbiBzbW9vdGggYW5pbWF0aW9ucy5cbiAqXG4gKiBJbiBzaG9ydCwgaWYgeW91IGhhdmUgc2Nyb2xsIHRpZWQgYW5pbWF0aW9ucyBvciBpbnRlbnNlIGFuaW1hdGlvbnMsXG4gKiB0aGlzIGNhbiBoZWxwIGZpeCB0aGUgaXNzdWUuXG4gKlxuICpcbiAqIFRoYW5rcyB0byBBbmd1cyBhbmQgRXJpYyBmb3IgdGhpcyB0aXAuXG4gKlxuICogU2luY2UgdGhpcyBpc3N1ZSBpcyBjaHJvbWUgc3BlY2lmaWMsIHlvdSBtaWdodCB3YW50IHNjb3BlIGl0IHRvIG9ubHkgY2hyb21lLlxuICogVXNhZ2U6XG4gKlxuICogYGBgXG4gKiBpZiAoaXMuY2hyb21lKCkpIHtcbiAqICAgbmV3IFNjcm9sbFJlbmRlckZpeCgpO1xuICogfVxuICogYGBgXG4gKlxuICogVG8gdGFrZSBmdWxsIGFkdmFudGFnZSwgdXNlIHRvb2xib3ggbXV0YXRlIG9yIGRlZ3UucmVhZCAvIHdyaXRlcy5cbiAqIGBgYFxuICpcbiAqIGNvbnN0IHJhZiA9IG5ldyBSYWYoKTtcbiAqXG4gKiByYWYucmVhZCgoKT0+IHtcbiAqICAgLy8gZG8gc29tZSByZWFkaW5nXG4gKiB9KVxuICpcbiAqIHJhZi53cml0aW5nKCgpPT4ge1xuICogICAvLyBkbyBzb21lIHdyaXRpbmdcbiAqIH0pXG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKi9cbmNsYXNzIFNjcm9sbFJlbmRlckZpeCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5jdXJyZW50WSA9IDA7XG4gICAgICAgIHRoaXMudGFyZ2V0WSA9IDA7XG4gICAgICAgIHRoaXMucmFmID0gbmV3IHJhZl8xLlJhZigpO1xuICAgICAgICB0aGlzLmJlZm9yZVNjcm9sbENhbGxiYWNrID0gY29uZmlnLmJlZm9yZVNjcm9sbENhbGxiYWNrIHx8IG5vb3BfMS5ub29wO1xuICAgICAgICB0aGlzLmFmdGVyU2Nyb2xsQ2FsbGJhY2sgPSBjb25maWcuYWZ0ZXJTY3JvbGxDYWxsYmFjayB8fCBub29wXzEubm9vcDtcbiAgICAgICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IGRvbV93YXRjaGVyXzEuRG9tV2F0Y2hlcigpO1xuICAgICAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LFxuICAgICAgICAgICAgb246ICd3aGVlbCcsXG4gICAgICAgICAgICBldmVudE9wdGlvbnM6IHsgcGFzc2l2ZTogZmFsc2UsIGNhcHR1cmU6IHRydWUgfSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiB0aGlzLndoZWVsSGFuZGxlci5iaW5kKHRoaXMpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgICB3aGVlbEhhbmRsZXIoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMucmFmLnJlYWQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRZID0gdGhpcy5nZXRTY3JvbGxFbGVtZW50KCkuc2Nyb2xsVG9wICsgZS5kZWx0YVk7XG4gICAgICAgICAgICB0aGlzLnJhZi5wb3N0V3JpdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYmVmb3JlU2Nyb2xsQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50WSAhPT0gdGhpcy50YXJnZXRZKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2Nyb2xsRWxlbWVudCgpLnNjcm9sbFRvcCA9IHRoaXMudGFyZ2V0WTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50WSA9IHRoaXMudGFyZ2V0WTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5hZnRlclNjcm9sbENhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZG9tV2F0Y2hlciAmJiB0aGlzLmRvbVdhdGNoZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnJhZiAmJiB0aGlzLnJhZi5kaXNwb3NlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TY3JvbGxSZW5kZXJGaXggPSBTY3JvbGxSZW5kZXJGaXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3JvbGwtcmVuZGVyLWZpeC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/dom/scroll-render-fix.js\n");

/***/ }),

/***/ "./lib/dom/text-split.js":
/*!*******************************!*\
  !*** ./lib/dom/text-split.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextSplit = void 0;\nconst dom_1 = __webpack_require__(/*! ./dom */ \"./lib/dom/dom.js\");\n/**\n * Splits the textContent of a given htmlElement and provides css variables\n * that can be used to add various text effects.\n *\n *\n * Here is a basic example.\n * ```ts\n *\n * <div id=\"myElement\">New York City</div>\n *\n * let splitter = new TextSplit({\n *   element: document.getElementById('myElement'),\n *   split: ' ' // Split by spaces.  Use '' to split by character.\n * });\n *\n * // Break up the text and wrap spans around it.\n * splitter.split();\n * ```\n *\n * This results in:\n * ```ts\n * <div id=\"myElement\" class=\"text-split-set\" style=\"--item-total-count:3\">\n *   <span style=\"--item-index:0\">New&nbsp;</span>\n *   <span style=\"--item-index:1\">York&nbsp;</span>\n *   <span style=\"--item-index:2\">City</span>\n * </div>\n *\n * ```\n *\n * Notice that on the root element, you get the total number of items,\n * and also on each element, you get an index.\n *\n * Now you can use css variables to add various effect.\n *\n * ```\n *  @keyframes textIn\n *      from\n *          opacity: 0;\n *      to\n *          opacity: 1;\n *\n *  // Help fight FOUC\n *  #myElement\n *    visiblity: hidden\n *  #myElement.text-split-set\n *    visibility: visible\n *\n *  #myElement span,\n *    position: relative\n *    font-size: 20px\n *    opacity: 0\n *    animation: textIn 1.3s ease-in-out 0s 1 forwards\n *\n *    // Create a 0.2s stagger between each item.\n *    animation-delay: calc(var(--item-index) * 0.2s\n *\n *    // More advanced.  You may not know how many words or character there are\n *    // but you want to the animation to finish in Xs seconds.\n *    // Using item-total-count, you can break the subdivisions.\n *    // Here no matter how many words/characters there are, set it so that the\n *    // stagger animation always completes in 1s.\n *    animation-delay: calc(var(--item-index) * (1s / var(--item-total-count)))\n * ```\n *\n */\nclass TextSplit {\n    constructor(config) {\n        this.config = config;\n        this.convertSpacesToNbsp = this.config.split === ' ';\n        // Patch to get around <sup> at the end of sentances for now.\n        // This is rather hacky and assumes all <sup> in the text\n        // are at the end of sentances.\n        this.sups = Array.from(this.config.element.querySelectorAll('sup'));\n        // Remove sups.\n        this.sups.forEach(sup => {\n            dom_1.dom.removeElement(sup);\n        });\n        // this.originalText = this.config.element.textContent!;\n        this.originalText = this.config.element.textContent;\n        // Convert any &nbsp to space.\n        if (this.convertSpacesToNbsp) {\n            const re = new RegExp(String.fromCharCode(160), 'g');\n            this.originalText = this.originalText.replace(re, ' ');\n        }\n        this.splits = this.originalText.trim().split(this.config.split);\n    }\n    /**\n     * Splits the text and wraps <span> around each sub item.\n     */\n    split() {\n        this.config.element.innerHTML = '';\n        this.splits.forEach((word, i) => {\n            // Add spaces to the end of each word if it's not the last one.\n            if (this.convertSpacesToNbsp && i !== this.splits.length - 1) {\n                word += '&nbsp;';\n            }\n            const element = dom_1.dom.createElementFromString(`<span>${word}</span>`);\n            dom_1.dom.setCssVariable(element, '--item-index', i + '');\n            this.config.element.appendChild(element);\n        });\n        // Futher append any sups.\n        this.sups &&\n            this.sups.forEach((sup, i) => {\n                const span = dom_1.dom.createElementFromString('<span></span>');\n                dom_1.dom.setCssVariable(span, '--item-index', this.splits.length + i + '');\n                span.appendChild(sup);\n                this.config.element.appendChild(span);\n            });\n        // Add total count to root element.\n        dom_1.dom.setCssVariable(this.config.element, '--item-total-count', this.splits.length + '');\n        this.config.element.classList.add('text-split-set');\n    }\n}\nexports.TextSplit = TextSplit;\n//# sourceMappingURL=text-split.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL3RleHQtc3BsaXQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL3RleHQtc3BsaXQuanM/NzRjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGV4dFNwbGl0ID0gdm9pZCAwO1xuY29uc3QgZG9tXzEgPSByZXF1aXJlKFwiLi9kb21cIik7XG4vKipcbiAqIFNwbGl0cyB0aGUgdGV4dENvbnRlbnQgb2YgYSBnaXZlbiBodG1sRWxlbWVudCBhbmQgcHJvdmlkZXMgY3NzIHZhcmlhYmxlc1xuICogdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgdmFyaW91cyB0ZXh0IGVmZmVjdHMuXG4gKlxuICpcbiAqIEhlcmUgaXMgYSBiYXNpYyBleGFtcGxlLlxuICogYGBgdHNcbiAqXG4gKiA8ZGl2IGlkPVwibXlFbGVtZW50XCI+TmV3IFlvcmsgQ2l0eTwvZGl2PlxuICpcbiAqIGxldCBzcGxpdHRlciA9IG5ldyBUZXh0U3BsaXQoe1xuICogICBlbGVtZW50OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXlFbGVtZW50JyksXG4gKiAgIHNwbGl0OiAnICcgLy8gU3BsaXQgYnkgc3BhY2VzLiAgVXNlICcnIHRvIHNwbGl0IGJ5IGNoYXJhY3Rlci5cbiAqIH0pO1xuICpcbiAqIC8vIEJyZWFrIHVwIHRoZSB0ZXh0IGFuZCB3cmFwIHNwYW5zIGFyb3VuZCBpdC5cbiAqIHNwbGl0dGVyLnNwbGl0KCk7XG4gKiBgYGBcbiAqXG4gKiBUaGlzIHJlc3VsdHMgaW46XG4gKiBgYGB0c1xuICogPGRpdiBpZD1cIm15RWxlbWVudFwiIGNsYXNzPVwidGV4dC1zcGxpdC1zZXRcIiBzdHlsZT1cIi0taXRlbS10b3RhbC1jb3VudDozXCI+XG4gKiAgIDxzcGFuIHN0eWxlPVwiLS1pdGVtLWluZGV4OjBcIj5OZXcmbmJzcDs8L3NwYW4+XG4gKiAgIDxzcGFuIHN0eWxlPVwiLS1pdGVtLWluZGV4OjFcIj5Zb3JrJm5ic3A7PC9zcGFuPlxuICogICA8c3BhbiBzdHlsZT1cIi0taXRlbS1pbmRleDoyXCI+Q2l0eTwvc3Bhbj5cbiAqIDwvZGl2PlxuICpcbiAqIGBgYFxuICpcbiAqIE5vdGljZSB0aGF0IG9uIHRoZSByb290IGVsZW1lbnQsIHlvdSBnZXQgdGhlIHRvdGFsIG51bWJlciBvZiBpdGVtcyxcbiAqIGFuZCBhbHNvIG9uIGVhY2ggZWxlbWVudCwgeW91IGdldCBhbiBpbmRleC5cbiAqXG4gKiBOb3cgeW91IGNhbiB1c2UgY3NzIHZhcmlhYmxlcyB0byBhZGQgdmFyaW91cyBlZmZlY3QuXG4gKlxuICogYGBgXG4gKiAgQGtleWZyYW1lcyB0ZXh0SW5cbiAqICAgICAgZnJvbVxuICogICAgICAgICAgb3BhY2l0eTogMDtcbiAqICAgICAgdG9cbiAqICAgICAgICAgIG9wYWNpdHk6IDE7XG4gKlxuICogIC8vIEhlbHAgZmlnaHQgRk9VQ1xuICogICNteUVsZW1lbnRcbiAqICAgIHZpc2libGl0eTogaGlkZGVuXG4gKiAgI215RWxlbWVudC50ZXh0LXNwbGl0LXNldFxuICogICAgdmlzaWJpbGl0eTogdmlzaWJsZVxuICpcbiAqICAjbXlFbGVtZW50IHNwYW4sXG4gKiAgICBwb3NpdGlvbjogcmVsYXRpdmVcbiAqICAgIGZvbnQtc2l6ZTogMjBweFxuICogICAgb3BhY2l0eTogMFxuICogICAgYW5pbWF0aW9uOiB0ZXh0SW4gMS4zcyBlYXNlLWluLW91dCAwcyAxIGZvcndhcmRzXG4gKlxuICogICAgLy8gQ3JlYXRlIGEgMC4ycyBzdGFnZ2VyIGJldHdlZW4gZWFjaCBpdGVtLlxuICogICAgYW5pbWF0aW9uLWRlbGF5OiBjYWxjKHZhcigtLWl0ZW0taW5kZXgpICogMC4yc1xuICpcbiAqICAgIC8vIE1vcmUgYWR2YW5jZWQuICBZb3UgbWF5IG5vdCBrbm93IGhvdyBtYW55IHdvcmRzIG9yIGNoYXJhY3RlciB0aGVyZSBhcmVcbiAqICAgIC8vIGJ1dCB5b3Ugd2FudCB0byB0aGUgYW5pbWF0aW9uIHRvIGZpbmlzaCBpbiBYcyBzZWNvbmRzLlxuICogICAgLy8gVXNpbmcgaXRlbS10b3RhbC1jb3VudCwgeW91IGNhbiBicmVhayB0aGUgc3ViZGl2aXNpb25zLlxuICogICAgLy8gSGVyZSBubyBtYXR0ZXIgaG93IG1hbnkgd29yZHMvY2hhcmFjdGVycyB0aGVyZSBhcmUsIHNldCBpdCBzbyB0aGF0IHRoZVxuICogICAgLy8gc3RhZ2dlciBhbmltYXRpb24gYWx3YXlzIGNvbXBsZXRlcyBpbiAxcy5cbiAqICAgIGFuaW1hdGlvbi1kZWxheTogY2FsYyh2YXIoLS1pdGVtLWluZGV4KSAqICgxcyAvIHZhcigtLWl0ZW0tdG90YWwtY291bnQpKSlcbiAqIGBgYFxuICpcbiAqL1xuY2xhc3MgVGV4dFNwbGl0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuY29udmVydFNwYWNlc1RvTmJzcCA9IHRoaXMuY29uZmlnLnNwbGl0ID09PSAnICc7XG4gICAgICAgIC8vIFBhdGNoIHRvIGdldCBhcm91bmQgPHN1cD4gYXQgdGhlIGVuZCBvZiBzZW50YW5jZXMgZm9yIG5vdy5cbiAgICAgICAgLy8gVGhpcyBpcyByYXRoZXIgaGFja3kgYW5kIGFzc3VtZXMgYWxsIDxzdXA+IGluIHRoZSB0ZXh0XG4gICAgICAgIC8vIGFyZSBhdCB0aGUgZW5kIG9mIHNlbnRhbmNlcy5cbiAgICAgICAgdGhpcy5zdXBzID0gQXJyYXkuZnJvbSh0aGlzLmNvbmZpZy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N1cCcpKTtcbiAgICAgICAgLy8gUmVtb3ZlIHN1cHMuXG4gICAgICAgIHRoaXMuc3Vwcy5mb3JFYWNoKHN1cCA9PiB7XG4gICAgICAgICAgICBkb21fMS5kb20ucmVtb3ZlRWxlbWVudChzdXApO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhpcy5vcmlnaW5hbFRleHQgPSB0aGlzLmNvbmZpZy5lbGVtZW50LnRleHRDb250ZW50ITtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFRleHQgPSB0aGlzLmNvbmZpZy5lbGVtZW50LnRleHRDb250ZW50O1xuICAgICAgICAvLyBDb252ZXJ0IGFueSAmbmJzcCB0byBzcGFjZS5cbiAgICAgICAgaWYgKHRoaXMuY29udmVydFNwYWNlc1RvTmJzcCkge1xuICAgICAgICAgICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKSwgJ2cnKTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxUZXh0ID0gdGhpcy5vcmlnaW5hbFRleHQucmVwbGFjZShyZSwgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNwbGl0cyA9IHRoaXMub3JpZ2luYWxUZXh0LnRyaW0oKS5zcGxpdCh0aGlzLmNvbmZpZy5zcGxpdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwbGl0cyB0aGUgdGV4dCBhbmQgd3JhcHMgPHNwYW4+IGFyb3VuZCBlYWNoIHN1YiBpdGVtLlxuICAgICAqL1xuICAgIHNwbGl0KCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5lbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLnNwbGl0cy5mb3JFYWNoKCh3b3JkLCBpKSA9PiB7XG4gICAgICAgICAgICAvLyBBZGQgc3BhY2VzIHRvIHRoZSBlbmQgb2YgZWFjaCB3b3JkIGlmIGl0J3Mgbm90IHRoZSBsYXN0IG9uZS5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnZlcnRTcGFjZXNUb05ic3AgJiYgaSAhPT0gdGhpcy5zcGxpdHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHdvcmQgKz0gJyZuYnNwOyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9tXzEuZG9tLmNyZWF0ZUVsZW1lbnRGcm9tU3RyaW5nKGA8c3Bhbj4ke3dvcmR9PC9zcGFuPmApO1xuICAgICAgICAgICAgZG9tXzEuZG9tLnNldENzc1ZhcmlhYmxlKGVsZW1lbnQsICctLWl0ZW0taW5kZXgnLCBpICsgJycpO1xuICAgICAgICAgICAgdGhpcy5jb25maWcuZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZ1dGhlciBhcHBlbmQgYW55IHN1cHMuXG4gICAgICAgIHRoaXMuc3VwcyAmJlxuICAgICAgICAgICAgdGhpcy5zdXBzLmZvckVhY2goKHN1cCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBkb21fMS5kb20uY3JlYXRlRWxlbWVudEZyb21TdHJpbmcoJzxzcGFuPjwvc3Bhbj4nKTtcbiAgICAgICAgICAgICAgICBkb21fMS5kb20uc2V0Q3NzVmFyaWFibGUoc3BhbiwgJy0taXRlbS1pbmRleCcsIHRoaXMuc3BsaXRzLmxlbmd0aCArIGkgKyAnJyk7XG4gICAgICAgICAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChzdXApO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmVsZW1lbnQuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgLy8gQWRkIHRvdGFsIGNvdW50IHRvIHJvb3QgZWxlbWVudC5cbiAgICAgICAgZG9tXzEuZG9tLnNldENzc1ZhcmlhYmxlKHRoaXMuY29uZmlnLmVsZW1lbnQsICctLWl0ZW0tdG90YWwtY291bnQnLCB0aGlzLnNwbGl0cy5sZW5ndGggKyAnJyk7XG4gICAgICAgIHRoaXMuY29uZmlnLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgndGV4dC1zcGxpdC1zZXQnKTtcbiAgICB9XG59XG5leHBvcnRzLlRleHRTcGxpdCA9IFRleHRTcGxpdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHQtc3BsaXQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/dom/text-split.js\n");

/***/ }),

/***/ "./lib/dom/vector-dom-force.js":
/*!*************************************!*\
  !*** ./lib/dom/vector-dom-force.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorDomForce = void 0;\nconst vector_1 = __webpack_require__(/*! ../mathf/vector */ \"./lib/mathf/vector.js\");\n/**\n * A component class that adds external forces options to DOM vector.\n * @unstable\n * @hidden\n */\nclass VectorDomForce {\n    constructor(vc) {\n        this.host = vc;\n        this.element = vc.element;\n        this.rotationMouseForce = vector_1.Vector.ZERO;\n        this.rotationScrollYForce = vector_1.Vector.ZERO;\n    }\n    /**\n     * Takes the distance to the mouse position as a force and applies an\n     * effect where the mouse \"pushes\" the element.  This creates a slight\n     * interaction effect.\n     *\n     * The push force is added to the rotation vector.\n     *\n     * Note this is rather experiemental at this point and it may cause\n     * side effects.\n     *\n     * This method should be called PRIOR to calling render in the render loop.\n     *\n     *\n     * Example:\n     *\n     * ```ts\n     *\n     * let myVector = new VectorDom(element);\n     *\n     * new Raf(()=> {\n     *\n     *   myVector._.force.mouseRotationForce();\n     *   myVector.render();\n     *\n     * }).start();\n     *\n     *\n     * ```\n     *\n     *\n     * To pull the element towards the mouse, you can pass negative scale values.\n     *\n     * ```ts\n     *\n     * let myVector = new VectorDom(element);\n     * new Raf(()=> {\n     *   myVector._.force.mouseRotationForce(-0.0005, -0.0005, 0, 0.03);\n     *   myVector.render();\n     * }).start();\n     *\n     * ```\n     */\n    mouseRotationForce(xScalar = 0.0005, yScalar = 0.0005, zScalar = 0) {\n        const mouse = this.host.mouse;\n        const globalElementCenterPosition = this.host.globalElementCenterPosition;\n        const globalMousePosition = mouse.position.clone();\n        globalMousePosition.y = globalMousePosition.y - window.scrollY;\n        // Get the angle difference between target and the center of this element.\n        const angleDelta = vector_1.Vector.getXyzRotationTo(globalElementCenterPosition, globalMousePosition);\n        // Scale the angleDelta.\n        angleDelta[0] = angleDelta[0] * xScalar;\n        angleDelta[1] = angleDelta[1] * yScalar * 0;\n        angleDelta[2] = angleDelta[2] * zScalar * 0;\n        // Make that into a vector.\n        const targetRotation = vector_1.Vector.fromArray(angleDelta);\n        // TODO (uxder) Is rx inverted?\n        targetRotation.x = -targetRotation.x;\n        console.log(targetRotation.x);\n        // // Now lerp the cachec rotationMouseForce.\n        // this.rotationMouseForce.lerp(targetRotation, lerp);\n        // // Now figure out closest direction to reach the target rotation.\n        // // What this helps with is when the element is complmetely reverted,\n        // // it still maintains the same mouse force effect (non inverted).\n        // let xDistance = mathf.angleDistanceRadian(targetRotation.x, diff.x);\n        // let yDistance = mathf.angleDistanceRadian(targetRotation.y, diff.y);\n        // let zDistance = mathf.angleDistanceRadian(targetRotation.z, diff.z);\n        // let force = new Vector(xDistance, yDistance, zDistance);\n        this.host.rotation = this.host.rotation.clone().add(targetRotation);\n    }\n    /**\n     * Based on the center of the window, adds a rotational force to this element.\n     * Basically, when the element reaches the center of the screen, this\n     * force would be 0 and the farther it gets aways from the center, more\n     * rotatonal force is applied to the element.\n     *\n     * Since this is based only the y axis, you can apply the force in different ways.\n     *\n     *\n     * This example is a basic example in which the element gets pulls in\n     * rotationY based on its distance to the center Y of the screen.\n     *\n     * ```ts\n     *\n     * let myVector = new VectorDom(element);\n     * new Raf(()=> {\n     *   myVector._.force.scrollYRotationForce();\n     *   myVector.render();\n     * }).start();\n     *\n     * ```\n     *\n     *\n     *\n     * This example is a basic example in which the element gets pulls in\n     * rotationX based on its distance to the center Y of the screen.\n     *\n     * ```ts\n     *\n     * let myVector = new VectorDom(element);\n     * new Raf(()=> {\n     *   myVector._.force.scrollYRotationForce(-0.0004, 0);\n     *   myVector.render();\n     * }).start();\n     *\n     * ```\n     */\n    scrollYRotationForce(xScalar = 0, yScalar = 0.0005, zScalar = 0, lerp = 0.02) {\n        const globalElementCenterPosition = this.host.globalElementCenterPosition;\n        const windowCenter = new vector_1.Vector(window.innerWidth / 2, window.innerHeight / 2);\n        // Override the x and z values to the same coordinate as the element\n        // sicne we don't care about the delta between those.\n        windowCenter.x = globalElementCenterPosition.x;\n        windowCenter.z = globalElementCenterPosition.z;\n        // Get the angle difference between window center and the center of this element.\n        const angleDelta = vector_1.Vector.getXyzRotationTo(globalElementCenterPosition, windowCenter);\n        // Since this is adding scrollY force, the amount of force we add to\n        // the x and z is going to be the distance delta of y.\n        angleDelta[0] = angleDelta[1] * xScalar;\n        angleDelta[2] = angleDelta[2] * zScalar;\n        // Scale the y angleDelta.\n        angleDelta[1] = angleDelta[1] * yScalar;\n        // Make that into a vector.\n        const targetRotation = vector_1.Vector.fromArray(angleDelta);\n        // TODO (uxder) Is rx inverted?\n        targetRotation.x = -targetRotation.x;\n        // We want an effect where the mouse \"PUSHes\" away the element\n        // The getXyzRotationTo is a more pull so we negate the value.\n        // targetRotation.negate();\n        // Now in memory lerp that rotationMouseForce (an internal mouse rotation\n        // only value).\n        this.rotationScrollYForce.lerp(targetRotation, lerp);\n        // Now get the difference between the target rotation and rotationmouseForce.\n        // and apply that to the main rotation vector.\n        // This effectively, applies the force to the main rotation vector\n        // but as the internal rotationMouseForce gets closer to the target rotation\n        // value the force will lessen.  It effectively, clamps the rotations.\n        const diffVector = vector_1.Vector.subtract(this.rotationScrollYForce, targetRotation);\n        this.host.rotation.add(diffVector);\n    }\n    render() { }\n    init() { }\n    resize() { }\n    dispose() { }\n}\nexports.VectorDomForce = VectorDomForce;\n//# sourceMappingURL=vector-dom-force.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL3ZlY3Rvci1kb20tZm9yY2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL3ZlY3Rvci1kb20tZm9yY2UuanM/ZjlhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmVjdG9yRG9tRm9yY2UgPSB2b2lkIDA7XG5jb25zdCB2ZWN0b3JfMSA9IHJlcXVpcmUoXCIuLi9tYXRoZi92ZWN0b3JcIik7XG4vKipcbiAqIEEgY29tcG9uZW50IGNsYXNzIHRoYXQgYWRkcyBleHRlcm5hbCBmb3JjZXMgb3B0aW9ucyB0byBET00gdmVjdG9yLlxuICogQHVuc3RhYmxlXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFZlY3RvckRvbUZvcmNlIHtcbiAgICBjb25zdHJ1Y3Rvcih2Yykge1xuICAgICAgICB0aGlzLmhvc3QgPSB2YztcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gdmMuZWxlbWVudDtcbiAgICAgICAgdGhpcy5yb3RhdGlvbk1vdXNlRm9yY2UgPSB2ZWN0b3JfMS5WZWN0b3IuWkVSTztcbiAgICAgICAgdGhpcy5yb3RhdGlvblNjcm9sbFlGb3JjZSA9IHZlY3Rvcl8xLlZlY3Rvci5aRVJPO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlcyB0aGUgZGlzdGFuY2UgdG8gdGhlIG1vdXNlIHBvc2l0aW9uIGFzIGEgZm9yY2UgYW5kIGFwcGxpZXMgYW5cbiAgICAgKiBlZmZlY3Qgd2hlcmUgdGhlIG1vdXNlIFwicHVzaGVzXCIgdGhlIGVsZW1lbnQuICBUaGlzIGNyZWF0ZXMgYSBzbGlnaHRcbiAgICAgKiBpbnRlcmFjdGlvbiBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBUaGUgcHVzaCBmb3JjZSBpcyBhZGRlZCB0byB0aGUgcm90YXRpb24gdmVjdG9yLlxuICAgICAqXG4gICAgICogTm90ZSB0aGlzIGlzIHJhdGhlciBleHBlcmllbWVudGFsIGF0IHRoaXMgcG9pbnQgYW5kIGl0IG1heSBjYXVzZVxuICAgICAqIHNpZGUgZWZmZWN0cy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgUFJJT1IgdG8gY2FsbGluZyByZW5kZXIgaW4gdGhlIHJlbmRlciBsb29wLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIGxldCBteVZlY3RvciA9IG5ldyBWZWN0b3JEb20oZWxlbWVudCk7XG4gICAgICpcbiAgICAgKiBuZXcgUmFmKCgpPT4ge1xuICAgICAqXG4gICAgICogICBteVZlY3Rvci5fLmZvcmNlLm1vdXNlUm90YXRpb25Gb3JjZSgpO1xuICAgICAqICAgbXlWZWN0b3IucmVuZGVyKCk7XG4gICAgICpcbiAgICAgKiB9KS5zdGFydCgpO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqXG4gICAgICogVG8gcHVsbCB0aGUgZWxlbWVudCB0b3dhcmRzIHRoZSBtb3VzZSwgeW91IGNhbiBwYXNzIG5lZ2F0aXZlIHNjYWxlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKiBsZXQgbXlWZWN0b3IgPSBuZXcgVmVjdG9yRG9tKGVsZW1lbnQpO1xuICAgICAqIG5ldyBSYWYoKCk9PiB7XG4gICAgICogICBteVZlY3Rvci5fLmZvcmNlLm1vdXNlUm90YXRpb25Gb3JjZSgtMC4wMDA1LCAtMC4wMDA1LCAwLCAwLjAzKTtcbiAgICAgKiAgIG15VmVjdG9yLnJlbmRlcigpO1xuICAgICAqIH0pLnN0YXJ0KCk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBtb3VzZVJvdGF0aW9uRm9yY2UoeFNjYWxhciA9IDAuMDAwNSwgeVNjYWxhciA9IDAuMDAwNSwgelNjYWxhciA9IDApIHtcbiAgICAgICAgY29uc3QgbW91c2UgPSB0aGlzLmhvc3QubW91c2U7XG4gICAgICAgIGNvbnN0IGdsb2JhbEVsZW1lbnRDZW50ZXJQb3NpdGlvbiA9IHRoaXMuaG9zdC5nbG9iYWxFbGVtZW50Q2VudGVyUG9zaXRpb247XG4gICAgICAgIGNvbnN0IGdsb2JhbE1vdXNlUG9zaXRpb24gPSBtb3VzZS5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICBnbG9iYWxNb3VzZVBvc2l0aW9uLnkgPSBnbG9iYWxNb3VzZVBvc2l0aW9uLnkgLSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgLy8gR2V0IHRoZSBhbmdsZSBkaWZmZXJlbmNlIGJldHdlZW4gdGFyZ2V0IGFuZCB0aGUgY2VudGVyIG9mIHRoaXMgZWxlbWVudC5cbiAgICAgICAgY29uc3QgYW5nbGVEZWx0YSA9IHZlY3Rvcl8xLlZlY3Rvci5nZXRYeXpSb3RhdGlvblRvKGdsb2JhbEVsZW1lbnRDZW50ZXJQb3NpdGlvbiwgZ2xvYmFsTW91c2VQb3NpdGlvbik7XG4gICAgICAgIC8vIFNjYWxlIHRoZSBhbmdsZURlbHRhLlxuICAgICAgICBhbmdsZURlbHRhWzBdID0gYW5nbGVEZWx0YVswXSAqIHhTY2FsYXI7XG4gICAgICAgIGFuZ2xlRGVsdGFbMV0gPSBhbmdsZURlbHRhWzFdICogeVNjYWxhciAqIDA7XG4gICAgICAgIGFuZ2xlRGVsdGFbMl0gPSBhbmdsZURlbHRhWzJdICogelNjYWxhciAqIDA7XG4gICAgICAgIC8vIE1ha2UgdGhhdCBpbnRvIGEgdmVjdG9yLlxuICAgICAgICBjb25zdCB0YXJnZXRSb3RhdGlvbiA9IHZlY3Rvcl8xLlZlY3Rvci5mcm9tQXJyYXkoYW5nbGVEZWx0YSk7XG4gICAgICAgIC8vIFRPRE8gKHV4ZGVyKSBJcyByeCBpbnZlcnRlZD9cbiAgICAgICAgdGFyZ2V0Um90YXRpb24ueCA9IC10YXJnZXRSb3RhdGlvbi54O1xuICAgICAgICBjb25zb2xlLmxvZyh0YXJnZXRSb3RhdGlvbi54KTtcbiAgICAgICAgLy8gLy8gTm93IGxlcnAgdGhlIGNhY2hlYyByb3RhdGlvbk1vdXNlRm9yY2UuXG4gICAgICAgIC8vIHRoaXMucm90YXRpb25Nb3VzZUZvcmNlLmxlcnAodGFyZ2V0Um90YXRpb24sIGxlcnApO1xuICAgICAgICAvLyAvLyBOb3cgZmlndXJlIG91dCBjbG9zZXN0IGRpcmVjdGlvbiB0byByZWFjaCB0aGUgdGFyZ2V0IHJvdGF0aW9uLlxuICAgICAgICAvLyAvLyBXaGF0IHRoaXMgaGVscHMgd2l0aCBpcyB3aGVuIHRoZSBlbGVtZW50IGlzIGNvbXBsbWV0ZWx5IHJldmVydGVkLFxuICAgICAgICAvLyAvLyBpdCBzdGlsbCBtYWludGFpbnMgdGhlIHNhbWUgbW91c2UgZm9yY2UgZWZmZWN0IChub24gaW52ZXJ0ZWQpLlxuICAgICAgICAvLyBsZXQgeERpc3RhbmNlID0gbWF0aGYuYW5nbGVEaXN0YW5jZVJhZGlhbih0YXJnZXRSb3RhdGlvbi54LCBkaWZmLngpO1xuICAgICAgICAvLyBsZXQgeURpc3RhbmNlID0gbWF0aGYuYW5nbGVEaXN0YW5jZVJhZGlhbih0YXJnZXRSb3RhdGlvbi55LCBkaWZmLnkpO1xuICAgICAgICAvLyBsZXQgekRpc3RhbmNlID0gbWF0aGYuYW5nbGVEaXN0YW5jZVJhZGlhbih0YXJnZXRSb3RhdGlvbi56LCBkaWZmLnopO1xuICAgICAgICAvLyBsZXQgZm9yY2UgPSBuZXcgVmVjdG9yKHhEaXN0YW5jZSwgeURpc3RhbmNlLCB6RGlzdGFuY2UpO1xuICAgICAgICB0aGlzLmhvc3Qucm90YXRpb24gPSB0aGlzLmhvc3Qucm90YXRpb24uY2xvbmUoKS5hZGQodGFyZ2V0Um90YXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB0aGUgY2VudGVyIG9mIHRoZSB3aW5kb3csIGFkZHMgYSByb3RhdGlvbmFsIGZvcmNlIHRvIHRoaXMgZWxlbWVudC5cbiAgICAgKiBCYXNpY2FsbHksIHdoZW4gdGhlIGVsZW1lbnQgcmVhY2hlcyB0aGUgY2VudGVyIG9mIHRoZSBzY3JlZW4sIHRoaXNcbiAgICAgKiBmb3JjZSB3b3VsZCBiZSAwIGFuZCB0aGUgZmFydGhlciBpdCBnZXRzIGF3YXlzIGZyb20gdGhlIGNlbnRlciwgbW9yZVxuICAgICAqIHJvdGF0b25hbCBmb3JjZSBpcyBhcHBsaWVkIHRvIHRoZSBlbGVtZW50LlxuICAgICAqXG4gICAgICogU2luY2UgdGhpcyBpcyBiYXNlZCBvbmx5IHRoZSB5IGF4aXMsIHlvdSBjYW4gYXBwbHkgdGhlIGZvcmNlIGluIGRpZmZlcmVudCB3YXlzLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBUaGlzIGV4YW1wbGUgaXMgYSBiYXNpYyBleGFtcGxlIGluIHdoaWNoIHRoZSBlbGVtZW50IGdldHMgcHVsbHMgaW5cbiAgICAgKiByb3RhdGlvblkgYmFzZWQgb24gaXRzIGRpc3RhbmNlIHRvIHRoZSBjZW50ZXIgWSBvZiB0aGUgc2NyZWVuLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIGxldCBteVZlY3RvciA9IG5ldyBWZWN0b3JEb20oZWxlbWVudCk7XG4gICAgICogbmV3IFJhZigoKT0+IHtcbiAgICAgKiAgIG15VmVjdG9yLl8uZm9yY2Uuc2Nyb2xsWVJvdGF0aW9uRm9yY2UoKTtcbiAgICAgKiAgIG15VmVjdG9yLnJlbmRlcigpO1xuICAgICAqIH0pLnN0YXJ0KCk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBUaGlzIGV4YW1wbGUgaXMgYSBiYXNpYyBleGFtcGxlIGluIHdoaWNoIHRoZSBlbGVtZW50IGdldHMgcHVsbHMgaW5cbiAgICAgKiByb3RhdGlvblggYmFzZWQgb24gaXRzIGRpc3RhbmNlIHRvIHRoZSBjZW50ZXIgWSBvZiB0aGUgc2NyZWVuLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIGxldCBteVZlY3RvciA9IG5ldyBWZWN0b3JEb20oZWxlbWVudCk7XG4gICAgICogbmV3IFJhZigoKT0+IHtcbiAgICAgKiAgIG15VmVjdG9yLl8uZm9yY2Uuc2Nyb2xsWVJvdGF0aW9uRm9yY2UoLTAuMDAwNCwgMCk7XG4gICAgICogICBteVZlY3Rvci5yZW5kZXIoKTtcbiAgICAgKiB9KS5zdGFydCgpO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2Nyb2xsWVJvdGF0aW9uRm9yY2UoeFNjYWxhciA9IDAsIHlTY2FsYXIgPSAwLjAwMDUsIHpTY2FsYXIgPSAwLCBsZXJwID0gMC4wMikge1xuICAgICAgICBjb25zdCBnbG9iYWxFbGVtZW50Q2VudGVyUG9zaXRpb24gPSB0aGlzLmhvc3QuZ2xvYmFsRWxlbWVudENlbnRlclBvc2l0aW9uO1xuICAgICAgICBjb25zdCB3aW5kb3dDZW50ZXIgPSBuZXcgdmVjdG9yXzEuVmVjdG9yKHdpbmRvdy5pbm5lcldpZHRoIC8gMiwgd2luZG93LmlubmVySGVpZ2h0IC8gMik7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRoZSB4IGFuZCB6IHZhbHVlcyB0byB0aGUgc2FtZSBjb29yZGluYXRlIGFzIHRoZSBlbGVtZW50XG4gICAgICAgIC8vIHNpY25lIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGRlbHRhIGJldHdlZW4gdGhvc2UuXG4gICAgICAgIHdpbmRvd0NlbnRlci54ID0gZ2xvYmFsRWxlbWVudENlbnRlclBvc2l0aW9uLng7XG4gICAgICAgIHdpbmRvd0NlbnRlci56ID0gZ2xvYmFsRWxlbWVudENlbnRlclBvc2l0aW9uLno7XG4gICAgICAgIC8vIEdldCB0aGUgYW5nbGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHdpbmRvdyBjZW50ZXIgYW5kIHRoZSBjZW50ZXIgb2YgdGhpcyBlbGVtZW50LlxuICAgICAgICBjb25zdCBhbmdsZURlbHRhID0gdmVjdG9yXzEuVmVjdG9yLmdldFh5elJvdGF0aW9uVG8oZ2xvYmFsRWxlbWVudENlbnRlclBvc2l0aW9uLCB3aW5kb3dDZW50ZXIpO1xuICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGFkZGluZyBzY3JvbGxZIGZvcmNlLCB0aGUgYW1vdW50IG9mIGZvcmNlIHdlIGFkZCB0b1xuICAgICAgICAvLyB0aGUgeCBhbmQgeiBpcyBnb2luZyB0byBiZSB0aGUgZGlzdGFuY2UgZGVsdGEgb2YgeS5cbiAgICAgICAgYW5nbGVEZWx0YVswXSA9IGFuZ2xlRGVsdGFbMV0gKiB4U2NhbGFyO1xuICAgICAgICBhbmdsZURlbHRhWzJdID0gYW5nbGVEZWx0YVsyXSAqIHpTY2FsYXI7XG4gICAgICAgIC8vIFNjYWxlIHRoZSB5IGFuZ2xlRGVsdGEuXG4gICAgICAgIGFuZ2xlRGVsdGFbMV0gPSBhbmdsZURlbHRhWzFdICogeVNjYWxhcjtcbiAgICAgICAgLy8gTWFrZSB0aGF0IGludG8gYSB2ZWN0b3IuXG4gICAgICAgIGNvbnN0IHRhcmdldFJvdGF0aW9uID0gdmVjdG9yXzEuVmVjdG9yLmZyb21BcnJheShhbmdsZURlbHRhKTtcbiAgICAgICAgLy8gVE9ETyAodXhkZXIpIElzIHJ4IGludmVydGVkP1xuICAgICAgICB0YXJnZXRSb3RhdGlvbi54ID0gLXRhcmdldFJvdGF0aW9uLng7XG4gICAgICAgIC8vIFdlIHdhbnQgYW4gZWZmZWN0IHdoZXJlIHRoZSBtb3VzZSBcIlBVU0hlc1wiIGF3YXkgdGhlIGVsZW1lbnRcbiAgICAgICAgLy8gVGhlIGdldFh5elJvdGF0aW9uVG8gaXMgYSBtb3JlIHB1bGwgc28gd2UgbmVnYXRlIHRoZSB2YWx1ZS5cbiAgICAgICAgLy8gdGFyZ2V0Um90YXRpb24ubmVnYXRlKCk7XG4gICAgICAgIC8vIE5vdyBpbiBtZW1vcnkgbGVycCB0aGF0IHJvdGF0aW9uTW91c2VGb3JjZSAoYW4gaW50ZXJuYWwgbW91c2Ugcm90YXRpb25cbiAgICAgICAgLy8gb25seSB2YWx1ZSkuXG4gICAgICAgIHRoaXMucm90YXRpb25TY3JvbGxZRm9yY2UubGVycCh0YXJnZXRSb3RhdGlvbiwgbGVycCk7XG4gICAgICAgIC8vIE5vdyBnZXQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdGFyZ2V0IHJvdGF0aW9uIGFuZCByb3RhdGlvbm1vdXNlRm9yY2UuXG4gICAgICAgIC8vIGFuZCBhcHBseSB0aGF0IHRvIHRoZSBtYWluIHJvdGF0aW9uIHZlY3Rvci5cbiAgICAgICAgLy8gVGhpcyBlZmZlY3RpdmVseSwgYXBwbGllcyB0aGUgZm9yY2UgdG8gdGhlIG1haW4gcm90YXRpb24gdmVjdG9yXG4gICAgICAgIC8vIGJ1dCBhcyB0aGUgaW50ZXJuYWwgcm90YXRpb25Nb3VzZUZvcmNlIGdldHMgY2xvc2VyIHRvIHRoZSB0YXJnZXQgcm90YXRpb25cbiAgICAgICAgLy8gdmFsdWUgdGhlIGZvcmNlIHdpbGwgbGVzc2VuLiAgSXQgZWZmZWN0aXZlbHksIGNsYW1wcyB0aGUgcm90YXRpb25zLlxuICAgICAgICBjb25zdCBkaWZmVmVjdG9yID0gdmVjdG9yXzEuVmVjdG9yLnN1YnRyYWN0KHRoaXMucm90YXRpb25TY3JvbGxZRm9yY2UsIHRhcmdldFJvdGF0aW9uKTtcbiAgICAgICAgdGhpcy5ob3N0LnJvdGF0aW9uLmFkZChkaWZmVmVjdG9yKTtcbiAgICB9XG4gICAgcmVuZGVyKCkgeyB9XG4gICAgaW5pdCgpIHsgfVxuICAgIHJlc2l6ZSgpIHsgfVxuICAgIGRpc3Bvc2UoKSB7IH1cbn1cbmV4cG9ydHMuVmVjdG9yRG9tRm9yY2UgPSBWZWN0b3JEb21Gb3JjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlY3Rvci1kb20tZm9yY2UuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/dom/vector-dom-force.js\n");

/***/ }),

/***/ "./lib/dom/vector-dom-timeline.js":
/*!****************************************!*\
  !*** ./lib/dom/vector-dom-timeline.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorDomTimeline = void 0;\nconst dom_1 = __webpack_require__(/*! ../dom/dom */ \"./lib/dom/dom.js\");\nconst ease_1 = __webpack_require__(/*! ../ease/ease */ \"./lib/ease/ease.js\");\nconst func_1 = __webpack_require__(/*! ../func/func */ \"./lib/func/func.js\");\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst vector_1 = __webpack_require__(/*! ../mathf/vector */ \"./lib/mathf/vector.js\");\nconst is_1 = __webpack_require__(/*! ../is/is */ \"./lib/is/is.js\");\nconst hermite_curve_1 = __webpack_require__(/*! ../mathf/hermite-curve */ \"./lib/mathf/hermite-curve.js\");\nconst interpolate_1 = __webpack_require__(/*! ../interpolate/interpolate */ \"./lib/interpolate/interpolate.js\");\n/**\n * A list of keys in timeline object that should be skipped.\n */\nconst skipKeys = ['progress', 'easingFunction'];\n/**\n *\n * A component class of VectorDom that adds timeline functionality to VectorDOM.\n *\n * #### Basic Example\n *\n * The timeline feature is a component of VectorDom to make sequential animations.\n *\n * The timeline feature will directly update element properties including,\n * x, y, z, rx, ry, rz, alpha.  In addition, you can append any css variable and\n * timeline will take care of the interpolations.\n *\n *\n * Here is a basic example:\n *\n * ```ts\n *\n *  // Notice how we add the css var --blur here.\n * .myelement {\n *     filter: blur(calc(var(--blur) * 4px));\n * }\n *\n *\n * // In the timeline, define storyboard out the animations.\n * // Any key that starts with '--' will automatically be available\n * // as a css var on the element.\n * var timeline = [\n *    {\n *      progress: 0,\n *      x: 0,\n *      y: 0,\n *      z: 0.3 - 1,\n *      alpha: 0.2,\n *      '--blur': 1\n *    },\n *    {\n *      progress: 0.2,\n *      x: 100,\n *      y: 200,\n *      z: 0.8 - 1,\n *      alpha: 0.2,\n *      '--blur': 0.2\n *      easingFunction: EASE.easeInOutCubic\n *     },\n *    {\n *      progress: 0.5,\n *      x: 20,\n *      y: 20,\n *      z: 1 - 1,\n *      '--blur': 1\n *      alpha: 1\n *     },\n *     {\n *      progress: 1,\n *      x: 100,\n *      y: 20,\n *      z: 0.2 - 1,\n *      '--blur': 1\n *      alpha: 1\n *     }\n * ]\n *\n * let element = document.getElementById('myelmeent');\n * let vector = new VectorDom(element);\n *\n * // Access the timeline component and set the timeline.\n * vector._.timeline.setTimeline(timeline);\n *\n * // Now update the vector to a specific \"progress\" in the timeline.\n * let currentProgress = 0.2; // Could be amount of scroll, range input, whatever.\n *\n * // At this point the internal, position, rotational vectors will get updated.\n * vector._.timeline.updateProgress(currentProgress);\n *\n * // Now render it...it will render at where the values are at 20%\n * vector.render();\n * ```\n *\n *\n *\n * ### Catmull Rom Mode.\n * Timeline goes step to step in your progress but this can often lead to\n * rather robotic movement.  Instead of a linear progresss, you can create a\n * a smoothed spline from your points.\n *\n * ```ts\n *\n * // Set the timeline.\n * vector._.timeline.setTimeline(timeline);\n *\n * // Set the timeline mode to catmullrom.  Any easing functions\n * // will get ignored.\n * vector._.timeline.catmullRomMode = true;\n *\n * // Change the default tension if you wish.\n * vector._.timeline.catmullRomTension = 1.2;\n *\n * ```\n *\n *\n * ### Using CSS vars Only.\n * If you want to use VectorDom only with css variables or prevent VectorDom\n * from updating the style properties, pass the cssOnly option.\n *\n *\n * ```ts\n *\n * let myVector = new VectorDom(myElement);\n * vector._.timeline.setTimeline(timeline, { timeline: cssOnly: true}});\n *\n * ```\n *\n * alternatively, which results in the same thing.\n * ```ts\n * let myVector = new VectorDom(myElement);\n * myVector.disableStyleRenders = true;\n *\n * ```\n *\n *\n * ### How the timeline is evalualted.\n * For the timeline you declare, a storyboard is internally generated per\n * property.  This measn that for each keyframe, you can skip certain properties\n * and the interpolations will make the best effort correctly go between\n * your keyframes.  If you don't declare a start (0) and end (1) progress\n * the first and last keyframes you declare will be used in place.\n *\n * Easing functions are used in forward progression so there is no point in\n * adding an easing function to your last keyframe since that is the end.\n *\n *\n * Consider the following:\n * ```ts\n *\n * timeline = [\n *    { progress: 0.2, alpha: 1, x: 200, easingFunction: EASE.easeInOutCubic},\n *    { progress: 0.5, x: 500},\n *    { progress: 0.8, alpha: 0.2},\n *    { progress: 1, alpha: 0, x: 100}\n * ]\n *\n * ```\n * Here x and alpha are not declared on each keyframe.  VectorDomTimeline\n * will generate a storyboard like this for each frame.\n *\n * ```ts\n *\n * storyboard = {\n *    alpha: [\n *      { progress: 0.2, alpha: 1, easingFunction: EASE.easeInOutCubic},\n *      { progress: 0.8, alpha: 0.2},\n *      { progress: 1, alpha: 0}\n *    ],\n *    x: [\n *      { progress: 0.2, x: 200, easingFunction: EASE.easeInOutCubic},\n *      { progress: 0.5, x: 500},\n *      { progress: 1, x: 100}\n *    ]\n * }\n *\n * ```\n * For alpha, the alpha storyboard will be used as the final interpolation\n * values and points.  Same goes with x.\n *\n *\n * For this reason, it's best practice to try to declare 0 and 1 keyframes to\n * make it easier to understand your storyboard.\n *\n * @unstable\n * @hidden\n */\nclass VectorDomTimeline {\n    /**\n     * @param vc  The vectorDom that this component is attached to.\n     */\n    constructor(vc) {\n        /**\n         * An internal list of all recorded timeline keys.\n         */\n        this.timelineKeys = [];\n        this.host = vc;\n        this.options = vc.options.timeline || {};\n        this.element = vc.element;\n        this.cssKeys = {};\n        this.timeline = [];\n        this.timeline = null;\n        this.timelineKeys = [];\n        this.catmullRomMode = false;\n        this.catmullRomTension = 1;\n        this.storyboard = {};\n        // Cull unncessary requests to setCssKeys.\n        this.setCssKeys_ = func_1.func.runOnceOnChange(this.setCssKeys_.bind(this));\n        if (this.options.cssOnly) {\n            this.host.disableStyleRenders = true;\n        }\n    }\n    init() { }\n    /**\n     * Sets the timeline to be used and internally generates the storyboard\n     * to be used for interpolations.\n     */\n    setTimeline(timeline) {\n        this.sortTimeline();\n        this.timelineKeys = [];\n        this.timeline = timeline.map(timeline => {\n            // Save any new keys.\n            const keys = Object.keys(timeline);\n            // Add the keys to timelineKeys while deduping.\n            this.timelineKeys = [\n                ...new Set([...this.timelineKeys, ...keys]),\n            ];\n            return timeline;\n        });\n        // Generate storyboard.\n        this.storyboard = VectorDomTimeline.generateStoryboard(this.timelineKeys, this.timeline);\n    }\n    /**\n     * Sorts the maintimeline.\n     */\n    sortTimeline() {\n        if (!this.timeline) {\n            return;\n        }\n        // Sort the timeline.\n        this.timeline = this.timeline.sort((a, b) => {\n            return a.progress - b.progress;\n        });\n    }\n    /**\n     * Generates a storyboard from the provided timeline.\n     *\n     * Given a timeline like the following, a storyboard is timeline\n     * by a specific key.  Notice how alpha is not declared in every step\n     * of the timeline.\n     *\n     * The storyboard will also ALWAYs creates a progress 0 and 1 timeline\n     * based on the first available.\n     *\n     * const timeline = [\n     *   { progress: 0, x: 1200 },\n     *   { progress: 0.2, alpha: 0.2, x: 1500, ease: EASING.easeInOutBounce },\n     *   { progress: 0.5, x: 1500 },\n     *   { progress: 0.8, alpha: 0.6, x: 1500 },\n     *   { progress: 1, x: 1500 }\n     * ]\n     *\n     * The resulting storyboard would be:\n     * {\n     *   alpha: [\n     *     { progress: 0, alpha: 0.2},  // Added\n     *     { progress: 0.2, alpha: 0.2, ease: EASING.easeInOutBounce},\n     *     { progress: 0.8, alpha: 0.6},\n     *     { progress: 1, alpha: 0.6}  // Added\n     *   ],\n     *   x: [\n     *   { progress: 0, x: 1200},\n     *   { progress: 0.2, x: 1500, ease: EASING.easeInOutBounce},\n     *   { progress: 0.5, x: 1500 },\n     *   { progress: 0.8, x: 1500},\n     *   { progress: 1, x: 1500}\n     *   ]\n     * }\n     *\n     * This storyboard is basically then used for interporlations when\n     * the progress value is updated.\n     */\n    static generateStoryboard(keys, timeline) {\n        const storyboard = {};\n        keys.forEach(key => {\n            if (skipKeys.includes(key)) {\n                return;\n            }\n            let keyStoryboard = timeline.filter(t => {\n                return is_1.is.defined(t[key]);\n            });\n            // Make a copy and also remove keys that are not related to this\n            // storyboard.\n            keyStoryboard = keyStoryboard.map(t => {\n                const copy = Object.assign({}, t);\n                for (const k in copy) {\n                    if (k !== key && !skipKeys.includes(k)) {\n                        delete copy[k];\n                    }\n                }\n                return copy;\n            });\n            storyboard[key] = keyStoryboard;\n        });\n        for (const key in storyboard) {\n            const keyStory = storyboard[key];\n            // Check that the first item is progress 0.  If not, artificially\n            // generate it so that the progress starts at 0.\n            if (keyStory[0].progress !== 0) {\n                const copy = Object.assign({}, keyStory[0]);\n                copy.progress = 0;\n                keyStory.unshift(copy);\n            }\n            // Check that the last item is progress 1.  If not, artificially\n            // generate it and add it to the end.\n            const last = keyStory.length - 1;\n            if (keyStory[last].progress !== 1) {\n                const copy = Object.assign({}, keyStory[last]);\n                copy.progress = 1;\n                keyStory.push(copy);\n            }\n        }\n        return storyboard;\n    }\n    /**\n     * Given a storyboard and the current progress, finds the start and end\n     * timeline objects and return them.\n     *\n     * ```ts\n     * let storyboard = {\n     *    alpha: [\n     *       { progress: 0, alpha: 0 },\n     *      { progress: 0.2, alpha: 0 },\n     *       { progress: 0.8, alpha: 0.6 },\n     *      { progress: 1, alpha: 0.6 }\n     *   ]\n     * }\n     *\n     * // Find the start and end points if the progress were 0.1\n     * VectorDomTimeline.getStartAndEndTimelineFromStoryboard(storyboard, 'alpha', 0.1);\n     *\n     *\n     *\n     * //Returns:\n     * //  {\n     * //      start: { progress: 0, alpha: 0 },\n     * //      end: { progress: 0.2, alpha: 0 },\n     * //  }\n     *\n     * ```\n     *\n     * @param storyboard Object\n     * @param key\n     * @param progress\n     */\n    static getStartAndEndTimelineFromStoryboard(storyboard, key, progress) {\n        // Loop through the storyboard and figure out the correct start and\n        // end points.\n        const activeStoryboard = storyboard[key];\n        if (!activeStoryboard) {\n            return null;\n        }\n        // By default we assume progress is at 0.\n        let start = activeStoryboard[0];\n        let end = activeStoryboard[1];\n        let done = false;\n        let previous = activeStoryboard[0];\n        activeStoryboard.forEach((timeline) => {\n            // Loop until the timeline progress is greater or equal than current\n            // progress\n            if (!done && timeline.progress >= progress && progress > 0) {\n                start = previous;\n                end = timeline;\n                done = true;\n            }\n            previous = timeline;\n        });\n        return {\n            start: start,\n            end: end,\n        };\n    }\n    updateProgress(progress) {\n        for (const key in this.storyboard) {\n            const startEnd = VectorDomTimeline.getStartAndEndTimelineFromStoryboard(this.storyboard, key, progress);\n            const startTimeline = startEnd.start;\n            const endTimeline = startEnd.end;\n            // The start and end values.\n            const start = startTimeline[key];\n            const end = endTimeline[key];\n            const easing = startTimeline.easingFunction;\n            // Create a child progress between the start and end.\n            const childProgress = mathf_1.mathf.clamp01(mathf_1.mathf.childProgress(progress, startTimeline.progress, endTimeline.progress));\n            // Safe guard.\n            if (is_1.is.nan(childProgress)) {\n                return;\n            }\n            let value;\n            // If the value is a numberical.\n            if (is_1.is.number(start) && is_1.is.number(end)) {\n                const diff = end - start;\n                if (!this.catmullRomMode || mathf_1.mathf.absZero(diff) === 0) {\n                    value = mathf_1.mathf.ease(start, end, childProgress, easing || ease_1.EASE.linear);\n                }\n                else {\n                    const tension = this.catmullRomTension;\n                    // Technically, not a catmull rom but create a similar\n                    // spline out of HermiteCurves.\n                    const vector = hermite_curve_1.HermiteCurve.getPoint(childProgress, new vector_1.Vector(start, start), new vector_1.Vector(start * tension, start * tension), new vector_1.Vector(end, end), new vector_1.Vector(end * tension, end * tension));\n                    if (vector) {\n                        value = vector.x;\n                    }\n                }\n            }\n            else {\n                // If string values were passed, process it via Interpolate.\n                // to be able to use css units.\n                value = new interpolate_1.Interpolate({\n                    from: start,\n                    to: end,\n                    easeFunction: easing || ease_1.EASE.linear,\n                }).calculate(childProgress);\n            }\n            if (is_1.is.defined(value)) {\n                // If the key is a css var, internally cache it.  Otherwise,\n                // update the value on the host.\n                if (key.startsWith('--')) {\n                    this.cssKeys[key] = value;\n                }\n                else {\n                    const vectorDomKey = key;\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    this.host[vectorDomKey] = value;\n                }\n            }\n        }\n    }\n    /**\n     * Applies the css variables.  Unneccesary calls get culled by\n     * func.runOnceOnChange.\n     */\n    setCssKeys_(cssVars) {\n        /**\n         * Render this element only when it is inview\n         * for performance boost.\n         */\n        if (this.host.renderOnlyWhenInview &&\n            this.host.elementVisibility.state().ready &&\n            !this.host.elementVisibility.state().inview) {\n            return;\n        }\n        for (const key in cssVars) {\n            dom_1.dom.setCssVariable(this.element, key, cssVars[key]);\n        }\n    }\n    render() {\n        this.setCssKeys_(this.cssKeys);\n    }\n    resize() { }\n    dispose() { }\n}\nexports.VectorDomTimeline = VectorDomTimeline;\n//# sourceMappingURL=vector-dom-timeline.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL3ZlY3Rvci1kb20tdGltZWxpbmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL3ZlY3Rvci1kb20tdGltZWxpbmUuanM/MGZmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmVjdG9yRG9tVGltZWxpbmUgPSB2b2lkIDA7XG5jb25zdCBkb21fMSA9IHJlcXVpcmUoXCIuLi9kb20vZG9tXCIpO1xuY29uc3QgZWFzZV8xID0gcmVxdWlyZShcIi4uL2Vhc2UvZWFzZVwiKTtcbmNvbnN0IGZ1bmNfMSA9IHJlcXVpcmUoXCIuLi9mdW5jL2Z1bmNcIik7XG5jb25zdCBtYXRoZl8xID0gcmVxdWlyZShcIi4uL21hdGhmL21hdGhmXCIpO1xuY29uc3QgdmVjdG9yXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvdmVjdG9yXCIpO1xuY29uc3QgaXNfMSA9IHJlcXVpcmUoXCIuLi9pcy9pc1wiKTtcbmNvbnN0IGhlcm1pdGVfY3VydmVfMSA9IHJlcXVpcmUoXCIuLi9tYXRoZi9oZXJtaXRlLWN1cnZlXCIpO1xuY29uc3QgaW50ZXJwb2xhdGVfMSA9IHJlcXVpcmUoXCIuLi9pbnRlcnBvbGF0ZS9pbnRlcnBvbGF0ZVwiKTtcbi8qKlxuICogQSBsaXN0IG9mIGtleXMgaW4gdGltZWxpbmUgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHNraXBwZWQuXG4gKi9cbmNvbnN0IHNraXBLZXlzID0gWydwcm9ncmVzcycsICdlYXNpbmdGdW5jdGlvbiddO1xuLyoqXG4gKlxuICogQSBjb21wb25lbnQgY2xhc3Mgb2YgVmVjdG9yRG9tIHRoYXQgYWRkcyB0aW1lbGluZSBmdW5jdGlvbmFsaXR5IHRvIFZlY3RvckRPTS5cbiAqXG4gKiAjIyMjIEJhc2ljIEV4YW1wbGVcbiAqXG4gKiBUaGUgdGltZWxpbmUgZmVhdHVyZSBpcyBhIGNvbXBvbmVudCBvZiBWZWN0b3JEb20gdG8gbWFrZSBzZXF1ZW50aWFsIGFuaW1hdGlvbnMuXG4gKlxuICogVGhlIHRpbWVsaW5lIGZlYXR1cmUgd2lsbCBkaXJlY3RseSB1cGRhdGUgZWxlbWVudCBwcm9wZXJ0aWVzIGluY2x1ZGluZyxcbiAqIHgsIHksIHosIHJ4LCByeSwgcnosIGFscGhhLiAgSW4gYWRkaXRpb24sIHlvdSBjYW4gYXBwZW5kIGFueSBjc3MgdmFyaWFibGUgYW5kXG4gKiB0aW1lbGluZSB3aWxsIHRha2UgY2FyZSBvZiB0aGUgaW50ZXJwb2xhdGlvbnMuXG4gKlxuICpcbiAqIEhlcmUgaXMgYSBiYXNpYyBleGFtcGxlOlxuICpcbiAqIGBgYHRzXG4gKlxuICogIC8vIE5vdGljZSBob3cgd2UgYWRkIHRoZSBjc3MgdmFyIC0tYmx1ciBoZXJlLlxuICogLm15ZWxlbWVudCB7XG4gKiAgICAgZmlsdGVyOiBibHVyKGNhbGModmFyKC0tYmx1cikgKiA0cHgpKTtcbiAqIH1cbiAqXG4gKlxuICogLy8gSW4gdGhlIHRpbWVsaW5lLCBkZWZpbmUgc3Rvcnlib2FyZCBvdXQgdGhlIGFuaW1hdGlvbnMuXG4gKiAvLyBBbnkga2V5IHRoYXQgc3RhcnRzIHdpdGggJy0tJyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgYXZhaWxhYmxlXG4gKiAvLyBhcyBhIGNzcyB2YXIgb24gdGhlIGVsZW1lbnQuXG4gKiB2YXIgdGltZWxpbmUgPSBbXG4gKiAgICB7XG4gKiAgICAgIHByb2dyZXNzOiAwLFxuICogICAgICB4OiAwLFxuICogICAgICB5OiAwLFxuICogICAgICB6OiAwLjMgLSAxLFxuICogICAgICBhbHBoYTogMC4yLFxuICogICAgICAnLS1ibHVyJzogMVxuICogICAgfSxcbiAqICAgIHtcbiAqICAgICAgcHJvZ3Jlc3M6IDAuMixcbiAqICAgICAgeDogMTAwLFxuICogICAgICB5OiAyMDAsXG4gKiAgICAgIHo6IDAuOCAtIDEsXG4gKiAgICAgIGFscGhhOiAwLjIsXG4gKiAgICAgICctLWJsdXInOiAwLjJcbiAqICAgICAgZWFzaW5nRnVuY3Rpb246IEVBU0UuZWFzZUluT3V0Q3ViaWNcbiAqICAgICB9LFxuICogICAge1xuICogICAgICBwcm9ncmVzczogMC41LFxuICogICAgICB4OiAyMCxcbiAqICAgICAgeTogMjAsXG4gKiAgICAgIHo6IDEgLSAxLFxuICogICAgICAnLS1ibHVyJzogMVxuICogICAgICBhbHBoYTogMVxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICBwcm9ncmVzczogMSxcbiAqICAgICAgeDogMTAwLFxuICogICAgICB5OiAyMCxcbiAqICAgICAgejogMC4yIC0gMSxcbiAqICAgICAgJy0tYmx1cic6IDFcbiAqICAgICAgYWxwaGE6IDFcbiAqICAgICB9XG4gKiBdXG4gKlxuICogbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXllbG1lZW50Jyk7XG4gKiBsZXQgdmVjdG9yID0gbmV3IFZlY3RvckRvbShlbGVtZW50KTtcbiAqXG4gKiAvLyBBY2Nlc3MgdGhlIHRpbWVsaW5lIGNvbXBvbmVudCBhbmQgc2V0IHRoZSB0aW1lbGluZS5cbiAqIHZlY3Rvci5fLnRpbWVsaW5lLnNldFRpbWVsaW5lKHRpbWVsaW5lKTtcbiAqXG4gKiAvLyBOb3cgdXBkYXRlIHRoZSB2ZWN0b3IgdG8gYSBzcGVjaWZpYyBcInByb2dyZXNzXCIgaW4gdGhlIHRpbWVsaW5lLlxuICogbGV0IGN1cnJlbnRQcm9ncmVzcyA9IDAuMjsgLy8gQ291bGQgYmUgYW1vdW50IG9mIHNjcm9sbCwgcmFuZ2UgaW5wdXQsIHdoYXRldmVyLlxuICpcbiAqIC8vIEF0IHRoaXMgcG9pbnQgdGhlIGludGVybmFsLCBwb3NpdGlvbiwgcm90YXRpb25hbCB2ZWN0b3JzIHdpbGwgZ2V0IHVwZGF0ZWQuXG4gKiB2ZWN0b3IuXy50aW1lbGluZS51cGRhdGVQcm9ncmVzcyhjdXJyZW50UHJvZ3Jlc3MpO1xuICpcbiAqIC8vIE5vdyByZW5kZXIgaXQuLi5pdCB3aWxsIHJlbmRlciBhdCB3aGVyZSB0aGUgdmFsdWVzIGFyZSBhdCAyMCVcbiAqIHZlY3Rvci5yZW5kZXIoKTtcbiAqIGBgYFxuICpcbiAqXG4gKlxuICogIyMjIENhdG11bGwgUm9tIE1vZGUuXG4gKiBUaW1lbGluZSBnb2VzIHN0ZXAgdG8gc3RlcCBpbiB5b3VyIHByb2dyZXNzIGJ1dCB0aGlzIGNhbiBvZnRlbiBsZWFkIHRvXG4gKiByYXRoZXIgcm9ib3RpYyBtb3ZlbWVudC4gIEluc3RlYWQgb2YgYSBsaW5lYXIgcHJvZ3Jlc3NzLCB5b3UgY2FuIGNyZWF0ZSBhXG4gKiBhIHNtb290aGVkIHNwbGluZSBmcm9tIHlvdXIgcG9pbnRzLlxuICpcbiAqIGBgYHRzXG4gKlxuICogLy8gU2V0IHRoZSB0aW1lbGluZS5cbiAqIHZlY3Rvci5fLnRpbWVsaW5lLnNldFRpbWVsaW5lKHRpbWVsaW5lKTtcbiAqXG4gKiAvLyBTZXQgdGhlIHRpbWVsaW5lIG1vZGUgdG8gY2F0bXVsbHJvbS4gIEFueSBlYXNpbmcgZnVuY3Rpb25zXG4gKiAvLyB3aWxsIGdldCBpZ25vcmVkLlxuICogdmVjdG9yLl8udGltZWxpbmUuY2F0bXVsbFJvbU1vZGUgPSB0cnVlO1xuICpcbiAqIC8vIENoYW5nZSB0aGUgZGVmYXVsdCB0ZW5zaW9uIGlmIHlvdSB3aXNoLlxuICogdmVjdG9yLl8udGltZWxpbmUuY2F0bXVsbFJvbVRlbnNpb24gPSAxLjI7XG4gKlxuICogYGBgXG4gKlxuICpcbiAqICMjIyBVc2luZyBDU1MgdmFycyBPbmx5LlxuICogSWYgeW91IHdhbnQgdG8gdXNlIFZlY3RvckRvbSBvbmx5IHdpdGggY3NzIHZhcmlhYmxlcyBvciBwcmV2ZW50IFZlY3RvckRvbVxuICogZnJvbSB1cGRhdGluZyB0aGUgc3R5bGUgcHJvcGVydGllcywgcGFzcyB0aGUgY3NzT25seSBvcHRpb24uXG4gKlxuICpcbiAqIGBgYHRzXG4gKlxuICogbGV0IG15VmVjdG9yID0gbmV3IFZlY3RvckRvbShteUVsZW1lbnQpO1xuICogdmVjdG9yLl8udGltZWxpbmUuc2V0VGltZWxpbmUodGltZWxpbmUsIHsgdGltZWxpbmU6IGNzc09ubHk6IHRydWV9fSk7XG4gKlxuICogYGBgXG4gKlxuICogYWx0ZXJuYXRpdmVseSwgd2hpY2ggcmVzdWx0cyBpbiB0aGUgc2FtZSB0aGluZy5cbiAqIGBgYHRzXG4gKiBsZXQgbXlWZWN0b3IgPSBuZXcgVmVjdG9yRG9tKG15RWxlbWVudCk7XG4gKiBteVZlY3Rvci5kaXNhYmxlU3R5bGVSZW5kZXJzID0gdHJ1ZTtcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICogIyMjIEhvdyB0aGUgdGltZWxpbmUgaXMgZXZhbHVhbHRlZC5cbiAqIEZvciB0aGUgdGltZWxpbmUgeW91IGRlY2xhcmUsIGEgc3Rvcnlib2FyZCBpcyBpbnRlcm5hbGx5IGdlbmVyYXRlZCBwZXJcbiAqIHByb3BlcnR5LiAgVGhpcyBtZWFzbiB0aGF0IGZvciBlYWNoIGtleWZyYW1lLCB5b3UgY2FuIHNraXAgY2VydGFpbiBwcm9wZXJ0aWVzXG4gKiBhbmQgdGhlIGludGVycG9sYXRpb25zIHdpbGwgbWFrZSB0aGUgYmVzdCBlZmZvcnQgY29ycmVjdGx5IGdvIGJldHdlZW5cbiAqIHlvdXIga2V5ZnJhbWVzLiAgSWYgeW91IGRvbid0IGRlY2xhcmUgYSBzdGFydCAoMCkgYW5kIGVuZCAoMSkgcHJvZ3Jlc3NcbiAqIHRoZSBmaXJzdCBhbmQgbGFzdCBrZXlmcmFtZXMgeW91IGRlY2xhcmUgd2lsbCBiZSB1c2VkIGluIHBsYWNlLlxuICpcbiAqIEVhc2luZyBmdW5jdGlvbnMgYXJlIHVzZWQgaW4gZm9yd2FyZCBwcm9ncmVzc2lvbiBzbyB0aGVyZSBpcyBubyBwb2ludCBpblxuICogYWRkaW5nIGFuIGVhc2luZyBmdW5jdGlvbiB0byB5b3VyIGxhc3Qga2V5ZnJhbWUgc2luY2UgdGhhdCBpcyB0aGUgZW5kLlxuICpcbiAqXG4gKiBDb25zaWRlciB0aGUgZm9sbG93aW5nOlxuICogYGBgdHNcbiAqXG4gKiB0aW1lbGluZSA9IFtcbiAqICAgIHsgcHJvZ3Jlc3M6IDAuMiwgYWxwaGE6IDEsIHg6IDIwMCwgZWFzaW5nRnVuY3Rpb246IEVBU0UuZWFzZUluT3V0Q3ViaWN9LFxuICogICAgeyBwcm9ncmVzczogMC41LCB4OiA1MDB9LFxuICogICAgeyBwcm9ncmVzczogMC44LCBhbHBoYTogMC4yfSxcbiAqICAgIHsgcHJvZ3Jlc3M6IDEsIGFscGhhOiAwLCB4OiAxMDB9XG4gKiBdXG4gKlxuICogYGBgXG4gKiBIZXJlIHggYW5kIGFscGhhIGFyZSBub3QgZGVjbGFyZWQgb24gZWFjaCBrZXlmcmFtZS4gIFZlY3RvckRvbVRpbWVsaW5lXG4gKiB3aWxsIGdlbmVyYXRlIGEgc3Rvcnlib2FyZCBsaWtlIHRoaXMgZm9yIGVhY2ggZnJhbWUuXG4gKlxuICogYGBgdHNcbiAqXG4gKiBzdG9yeWJvYXJkID0ge1xuICogICAgYWxwaGE6IFtcbiAqICAgICAgeyBwcm9ncmVzczogMC4yLCBhbHBoYTogMSwgZWFzaW5nRnVuY3Rpb246IEVBU0UuZWFzZUluT3V0Q3ViaWN9LFxuICogICAgICB7IHByb2dyZXNzOiAwLjgsIGFscGhhOiAwLjJ9LFxuICogICAgICB7IHByb2dyZXNzOiAxLCBhbHBoYTogMH1cbiAqICAgIF0sXG4gKiAgICB4OiBbXG4gKiAgICAgIHsgcHJvZ3Jlc3M6IDAuMiwgeDogMjAwLCBlYXNpbmdGdW5jdGlvbjogRUFTRS5lYXNlSW5PdXRDdWJpY30sXG4gKiAgICAgIHsgcHJvZ3Jlc3M6IDAuNSwgeDogNTAwfSxcbiAqICAgICAgeyBwcm9ncmVzczogMSwgeDogMTAwfVxuICogICAgXVxuICogfVxuICpcbiAqIGBgYFxuICogRm9yIGFscGhhLCB0aGUgYWxwaGEgc3Rvcnlib2FyZCB3aWxsIGJlIHVzZWQgYXMgdGhlIGZpbmFsIGludGVycG9sYXRpb25cbiAqIHZhbHVlcyBhbmQgcG9pbnRzLiAgU2FtZSBnb2VzIHdpdGggeC5cbiAqXG4gKlxuICogRm9yIHRoaXMgcmVhc29uLCBpdCdzIGJlc3QgcHJhY3RpY2UgdG8gdHJ5IHRvIGRlY2xhcmUgMCBhbmQgMSBrZXlmcmFtZXMgdG9cbiAqIG1ha2UgaXQgZWFzaWVyIHRvIHVuZGVyc3RhbmQgeW91ciBzdG9yeWJvYXJkLlxuICpcbiAqIEB1bnN0YWJsZVxuICogQGhpZGRlblxuICovXG5jbGFzcyBWZWN0b3JEb21UaW1lbGluZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZjICBUaGUgdmVjdG9yRG9tIHRoYXQgdGhpcyBjb21wb25lbnQgaXMgYXR0YWNoZWQgdG8uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVybmFsIGxpc3Qgb2YgYWxsIHJlY29yZGVkIHRpbWVsaW5lIGtleXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpbWVsaW5lS2V5cyA9IFtdO1xuICAgICAgICB0aGlzLmhvc3QgPSB2YztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdmMub3B0aW9ucy50aW1lbGluZSB8fCB7fTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gdmMuZWxlbWVudDtcbiAgICAgICAgdGhpcy5jc3NLZXlzID0ge307XG4gICAgICAgIHRoaXMudGltZWxpbmUgPSBbXTtcbiAgICAgICAgdGhpcy50aW1lbGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZWxpbmVLZXlzID0gW107XG4gICAgICAgIHRoaXMuY2F0bXVsbFJvbU1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYXRtdWxsUm9tVGVuc2lvbiA9IDE7XG4gICAgICAgIHRoaXMuc3Rvcnlib2FyZCA9IHt9O1xuICAgICAgICAvLyBDdWxsIHVubmNlc3NhcnkgcmVxdWVzdHMgdG8gc2V0Q3NzS2V5cy5cbiAgICAgICAgdGhpcy5zZXRDc3NLZXlzXyA9IGZ1bmNfMS5mdW5jLnJ1bk9uY2VPbkNoYW5nZSh0aGlzLnNldENzc0tleXNfLmJpbmQodGhpcykpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgICAgIHRoaXMuaG9zdC5kaXNhYmxlU3R5bGVSZW5kZXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0KCkgeyB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGltZWxpbmUgdG8gYmUgdXNlZCBhbmQgaW50ZXJuYWxseSBnZW5lcmF0ZXMgdGhlIHN0b3J5Ym9hcmRcbiAgICAgKiB0byBiZSB1c2VkIGZvciBpbnRlcnBvbGF0aW9ucy5cbiAgICAgKi9cbiAgICBzZXRUaW1lbGluZSh0aW1lbGluZSkge1xuICAgICAgICB0aGlzLnNvcnRUaW1lbGluZSgpO1xuICAgICAgICB0aGlzLnRpbWVsaW5lS2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gdGltZWxpbmUubWFwKHRpbWVsaW5lID0+IHtcbiAgICAgICAgICAgIC8vIFNhdmUgYW55IG5ldyBrZXlzLlxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRpbWVsaW5lKTtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUga2V5cyB0byB0aW1lbGluZUtleXMgd2hpbGUgZGVkdXBpbmcuXG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lS2V5cyA9IFtcbiAgICAgICAgICAgICAgICAuLi5uZXcgU2V0KFsuLi50aGlzLnRpbWVsaW5lS2V5cywgLi4ua2V5c10pLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiB0aW1lbGluZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEdlbmVyYXRlIHN0b3J5Ym9hcmQuXG4gICAgICAgIHRoaXMuc3Rvcnlib2FyZCA9IFZlY3RvckRvbVRpbWVsaW5lLmdlbmVyYXRlU3Rvcnlib2FyZCh0aGlzLnRpbWVsaW5lS2V5cywgdGhpcy50aW1lbGluZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSBtYWludGltZWxpbmUuXG4gICAgICovXG4gICAgc29ydFRpbWVsaW5lKCkge1xuICAgICAgICBpZiAoIXRoaXMudGltZWxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0IHRoZSB0aW1lbGluZS5cbiAgICAgICAgdGhpcy50aW1lbGluZSA9IHRoaXMudGltZWxpbmUuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJvZ3Jlc3MgLSBiLnByb2dyZXNzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgc3Rvcnlib2FyZCBmcm9tIHRoZSBwcm92aWRlZCB0aW1lbGluZS5cbiAgICAgKlxuICAgICAqIEdpdmVuIGEgdGltZWxpbmUgbGlrZSB0aGUgZm9sbG93aW5nLCBhIHN0b3J5Ym9hcmQgaXMgdGltZWxpbmVcbiAgICAgKiBieSBhIHNwZWNpZmljIGtleS4gIE5vdGljZSBob3cgYWxwaGEgaXMgbm90IGRlY2xhcmVkIGluIGV2ZXJ5IHN0ZXBcbiAgICAgKiBvZiB0aGUgdGltZWxpbmUuXG4gICAgICpcbiAgICAgKiBUaGUgc3Rvcnlib2FyZCB3aWxsIGFsc28gQUxXQVlzIGNyZWF0ZXMgYSBwcm9ncmVzcyAwIGFuZCAxIHRpbWVsaW5lXG4gICAgICogYmFzZWQgb24gdGhlIGZpcnN0IGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIGNvbnN0IHRpbWVsaW5lID0gW1xuICAgICAqICAgeyBwcm9ncmVzczogMCwgeDogMTIwMCB9LFxuICAgICAqICAgeyBwcm9ncmVzczogMC4yLCBhbHBoYTogMC4yLCB4OiAxNTAwLCBlYXNlOiBFQVNJTkcuZWFzZUluT3V0Qm91bmNlIH0sXG4gICAgICogICB7IHByb2dyZXNzOiAwLjUsIHg6IDE1MDAgfSxcbiAgICAgKiAgIHsgcHJvZ3Jlc3M6IDAuOCwgYWxwaGE6IDAuNiwgeDogMTUwMCB9LFxuICAgICAqICAgeyBwcm9ncmVzczogMSwgeDogMTUwMCB9XG4gICAgICogXVxuICAgICAqXG4gICAgICogVGhlIHJlc3VsdGluZyBzdG9yeWJvYXJkIHdvdWxkIGJlOlxuICAgICAqIHtcbiAgICAgKiAgIGFscGhhOiBbXG4gICAgICogICAgIHsgcHJvZ3Jlc3M6IDAsIGFscGhhOiAwLjJ9LCAgLy8gQWRkZWRcbiAgICAgKiAgICAgeyBwcm9ncmVzczogMC4yLCBhbHBoYTogMC4yLCBlYXNlOiBFQVNJTkcuZWFzZUluT3V0Qm91bmNlfSxcbiAgICAgKiAgICAgeyBwcm9ncmVzczogMC44LCBhbHBoYTogMC42fSxcbiAgICAgKiAgICAgeyBwcm9ncmVzczogMSwgYWxwaGE6IDAuNn0gIC8vIEFkZGVkXG4gICAgICogICBdLFxuICAgICAqICAgeDogW1xuICAgICAqICAgeyBwcm9ncmVzczogMCwgeDogMTIwMH0sXG4gICAgICogICB7IHByb2dyZXNzOiAwLjIsIHg6IDE1MDAsIGVhc2U6IEVBU0lORy5lYXNlSW5PdXRCb3VuY2V9LFxuICAgICAqICAgeyBwcm9ncmVzczogMC41LCB4OiAxNTAwIH0sXG4gICAgICogICB7IHByb2dyZXNzOiAwLjgsIHg6IDE1MDB9LFxuICAgICAqICAgeyBwcm9ncmVzczogMSwgeDogMTUwMH1cbiAgICAgKiAgIF1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBUaGlzIHN0b3J5Ym9hcmQgaXMgYmFzaWNhbGx5IHRoZW4gdXNlZCBmb3IgaW50ZXJwb3JsYXRpb25zIHdoZW5cbiAgICAgKiB0aGUgcHJvZ3Jlc3MgdmFsdWUgaXMgdXBkYXRlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2VuZXJhdGVTdG9yeWJvYXJkKGtleXMsIHRpbWVsaW5lKSB7XG4gICAgICAgIGNvbnN0IHN0b3J5Ym9hcmQgPSB7fTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAoc2tpcEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBrZXlTdG9yeWJvYXJkID0gdGltZWxpbmUuZmlsdGVyKHQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc18xLmlzLmRlZmluZWQodFtrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgYW5kIGFsc28gcmVtb3ZlIGtleXMgdGhhdCBhcmUgbm90IHJlbGF0ZWQgdG8gdGhpc1xuICAgICAgICAgICAgLy8gc3Rvcnlib2FyZC5cbiAgICAgICAgICAgIGtleVN0b3J5Ym9hcmQgPSBrZXlTdG9yeWJvYXJkLm1hcCh0ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgdCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIGNvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgIT09IGtleSAmJiAhc2tpcEtleXMuaW5jbHVkZXMoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb3B5W2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdG9yeWJvYXJkW2tleV0gPSBrZXlTdG9yeWJvYXJkO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc3Rvcnlib2FyZCkge1xuICAgICAgICAgICAgY29uc3Qga2V5U3RvcnkgPSBzdG9yeWJvYXJkW2tleV07XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBmaXJzdCBpdGVtIGlzIHByb2dyZXNzIDAuICBJZiBub3QsIGFydGlmaWNpYWxseVxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgaXQgc28gdGhhdCB0aGUgcHJvZ3Jlc3Mgc3RhcnRzIGF0IDAuXG4gICAgICAgICAgICBpZiAoa2V5U3RvcnlbMF0ucHJvZ3Jlc3MgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwga2V5U3RvcnlbMF0pO1xuICAgICAgICAgICAgICAgIGNvcHkucHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgICAgIGtleVN0b3J5LnVuc2hpZnQoY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBsYXN0IGl0ZW0gaXMgcHJvZ3Jlc3MgMS4gIElmIG5vdCwgYXJ0aWZpY2lhbGx5XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBpdCBhbmQgYWRkIGl0IHRvIHRoZSBlbmQuXG4gICAgICAgICAgICBjb25zdCBsYXN0ID0ga2V5U3RvcnkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChrZXlTdG9yeVtsYXN0XS5wcm9ncmVzcyAhPT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBrZXlTdG9yeVtsYXN0XSk7XG4gICAgICAgICAgICAgICAgY29weS5wcm9ncmVzcyA9IDE7XG4gICAgICAgICAgICAgICAga2V5U3RvcnkucHVzaChjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Rvcnlib2FyZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBzdG9yeWJvYXJkIGFuZCB0aGUgY3VycmVudCBwcm9ncmVzcywgZmluZHMgdGhlIHN0YXJ0IGFuZCBlbmRcbiAgICAgKiB0aW1lbGluZSBvYmplY3RzIGFuZCByZXR1cm4gdGhlbS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbGV0IHN0b3J5Ym9hcmQgPSB7XG4gICAgICogICAgYWxwaGE6IFtcbiAgICAgKiAgICAgICB7IHByb2dyZXNzOiAwLCBhbHBoYTogMCB9LFxuICAgICAqICAgICAgeyBwcm9ncmVzczogMC4yLCBhbHBoYTogMCB9LFxuICAgICAqICAgICAgIHsgcHJvZ3Jlc3M6IDAuOCwgYWxwaGE6IDAuNiB9LFxuICAgICAqICAgICAgeyBwcm9ncmVzczogMSwgYWxwaGE6IDAuNiB9XG4gICAgICogICBdXG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gRmluZCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgaWYgdGhlIHByb2dyZXNzIHdlcmUgMC4xXG4gICAgICogVmVjdG9yRG9tVGltZWxpbmUuZ2V0U3RhcnRBbmRFbmRUaW1lbGluZUZyb21TdG9yeWJvYXJkKHN0b3J5Ym9hcmQsICdhbHBoYScsIDAuMSk7XG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICogLy9SZXR1cm5zOlxuICAgICAqIC8vICB7XG4gICAgICogLy8gICAgICBzdGFydDogeyBwcm9ncmVzczogMCwgYWxwaGE6IDAgfSxcbiAgICAgKiAvLyAgICAgIGVuZDogeyBwcm9ncmVzczogMC4yLCBhbHBoYTogMCB9LFxuICAgICAqIC8vICB9XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdG9yeWJvYXJkIE9iamVjdFxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0gcHJvZ3Jlc3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U3RhcnRBbmRFbmRUaW1lbGluZUZyb21TdG9yeWJvYXJkKHN0b3J5Ym9hcmQsIGtleSwgcHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSBzdG9yeWJvYXJkIGFuZCBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IHN0YXJ0IGFuZFxuICAgICAgICAvLyBlbmQgcG9pbnRzLlxuICAgICAgICBjb25zdCBhY3RpdmVTdG9yeWJvYXJkID0gc3Rvcnlib2FyZFtrZXldO1xuICAgICAgICBpZiAoIWFjdGl2ZVN0b3J5Ym9hcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQgd2UgYXNzdW1lIHByb2dyZXNzIGlzIGF0IDAuXG4gICAgICAgIGxldCBzdGFydCA9IGFjdGl2ZVN0b3J5Ym9hcmRbMF07XG4gICAgICAgIGxldCBlbmQgPSBhY3RpdmVTdG9yeWJvYXJkWzFdO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICBsZXQgcHJldmlvdXMgPSBhY3RpdmVTdG9yeWJvYXJkWzBdO1xuICAgICAgICBhY3RpdmVTdG9yeWJvYXJkLmZvckVhY2goKHRpbWVsaW5lKSA9PiB7XG4gICAgICAgICAgICAvLyBMb29wIHVudGlsIHRoZSB0aW1lbGluZSBwcm9ncmVzcyBpcyBncmVhdGVyIG9yIGVxdWFsIHRoYW4gY3VycmVudFxuICAgICAgICAgICAgLy8gcHJvZ3Jlc3NcbiAgICAgICAgICAgIGlmICghZG9uZSAmJiB0aW1lbGluZS5wcm9ncmVzcyA+PSBwcm9ncmVzcyAmJiBwcm9ncmVzcyA+IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgIGVuZCA9IHRpbWVsaW5lO1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXMgPSB0aW1lbGluZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5zdG9yeWJvYXJkKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydEVuZCA9IFZlY3RvckRvbVRpbWVsaW5lLmdldFN0YXJ0QW5kRW5kVGltZWxpbmVGcm9tU3Rvcnlib2FyZCh0aGlzLnN0b3J5Ym9hcmQsIGtleSwgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lbGluZSA9IHN0YXJ0RW5kLnN0YXJ0O1xuICAgICAgICAgICAgY29uc3QgZW5kVGltZWxpbmUgPSBzdGFydEVuZC5lbmQ7XG4gICAgICAgICAgICAvLyBUaGUgc3RhcnQgYW5kIGVuZCB2YWx1ZXMuXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHN0YXJ0VGltZWxpbmVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGVuZFRpbWVsaW5lW2tleV07XG4gICAgICAgICAgICBjb25zdCBlYXNpbmcgPSBzdGFydFRpbWVsaW5lLmVhc2luZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY2hpbGQgcHJvZ3Jlc3MgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZC5cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkUHJvZ3Jlc3MgPSBtYXRoZl8xLm1hdGhmLmNsYW1wMDEobWF0aGZfMS5tYXRoZi5jaGlsZFByb2dyZXNzKHByb2dyZXNzLCBzdGFydFRpbWVsaW5lLnByb2dyZXNzLCBlbmRUaW1lbGluZS5wcm9ncmVzcykpO1xuICAgICAgICAgICAgLy8gU2FmZSBndWFyZC5cbiAgICAgICAgICAgIGlmIChpc18xLmlzLm5hbihjaGlsZFByb2dyZXNzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIG51bWJlcmljYWwuXG4gICAgICAgICAgICBpZiAoaXNfMS5pcy5udW1iZXIoc3RhcnQpICYmIGlzXzEuaXMubnVtYmVyKGVuZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNhdG11bGxSb21Nb2RlIHx8IG1hdGhmXzEubWF0aGYuYWJzWmVybyhkaWZmKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1hdGhmXzEubWF0aGYuZWFzZShzdGFydCwgZW5kLCBjaGlsZFByb2dyZXNzLCBlYXNpbmcgfHwgZWFzZV8xLkVBU0UubGluZWFyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbnNpb24gPSB0aGlzLmNhdG11bGxSb21UZW5zaW9uO1xuICAgICAgICAgICAgICAgICAgICAvLyBUZWNobmljYWxseSwgbm90IGEgY2F0bXVsbCByb20gYnV0IGNyZWF0ZSBhIHNpbWlsYXJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BsaW5lIG91dCBvZiBIZXJtaXRlQ3VydmVzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZWN0b3IgPSBoZXJtaXRlX2N1cnZlXzEuSGVybWl0ZUN1cnZlLmdldFBvaW50KGNoaWxkUHJvZ3Jlc3MsIG5ldyB2ZWN0b3JfMS5WZWN0b3Ioc3RhcnQsIHN0YXJ0KSwgbmV3IHZlY3Rvcl8xLlZlY3RvcihzdGFydCAqIHRlbnNpb24sIHN0YXJ0ICogdGVuc2lvbiksIG5ldyB2ZWN0b3JfMS5WZWN0b3IoZW5kLCBlbmQpLCBuZXcgdmVjdG9yXzEuVmVjdG9yKGVuZCAqIHRlbnNpb24sIGVuZCAqIHRlbnNpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2ZWN0b3IueDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHN0cmluZyB2YWx1ZXMgd2VyZSBwYXNzZWQsIHByb2Nlc3MgaXQgdmlhIEludGVycG9sYXRlLlxuICAgICAgICAgICAgICAgIC8vIHRvIGJlIGFibGUgdG8gdXNlIGNzcyB1bml0cy5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBpbnRlcnBvbGF0ZV8xLkludGVycG9sYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHRvOiBlbmQsXG4gICAgICAgICAgICAgICAgICAgIGVhc2VGdW5jdGlvbjogZWFzaW5nIHx8IGVhc2VfMS5FQVNFLmxpbmVhcixcbiAgICAgICAgICAgICAgICB9KS5jYWxjdWxhdGUoY2hpbGRQcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNfMS5pcy5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBrZXkgaXMgYSBjc3MgdmFyLCBpbnRlcm5hbGx5IGNhY2hlIGl0LiAgT3RoZXJ3aXNlLFxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWUgb24gdGhlIGhvc3QuXG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCctLScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3NzS2V5c1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZWN0b3JEb21LZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaG9zdFt2ZWN0b3JEb21LZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGNzcyB2YXJpYWJsZXMuICBVbm5lY2Nlc2FyeSBjYWxscyBnZXQgY3VsbGVkIGJ5XG4gICAgICogZnVuYy5ydW5PbmNlT25DaGFuZ2UuXG4gICAgICovXG4gICAgc2V0Q3NzS2V5c18oY3NzVmFycykge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyIHRoaXMgZWxlbWVudCBvbmx5IHdoZW4gaXQgaXMgaW52aWV3XG4gICAgICAgICAqIGZvciBwZXJmb3JtYW5jZSBib29zdC5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmhvc3QucmVuZGVyT25seVdoZW5JbnZpZXcgJiZcbiAgICAgICAgICAgIHRoaXMuaG9zdC5lbGVtZW50VmlzaWJpbGl0eS5zdGF0ZSgpLnJlYWR5ICYmXG4gICAgICAgICAgICAhdGhpcy5ob3N0LmVsZW1lbnRWaXNpYmlsaXR5LnN0YXRlKCkuaW52aWV3KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3NzVmFycykge1xuICAgICAgICAgICAgZG9tXzEuZG9tLnNldENzc1ZhcmlhYmxlKHRoaXMuZWxlbWVudCwga2V5LCBjc3NWYXJzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5zZXRDc3NLZXlzXyh0aGlzLmNzc0tleXMpO1xuICAgIH1cbiAgICByZXNpemUoKSB7IH1cbiAgICBkaXNwb3NlKCkgeyB9XG59XG5leHBvcnRzLlZlY3RvckRvbVRpbWVsaW5lID0gVmVjdG9yRG9tVGltZWxpbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZWN0b3ItZG9tLXRpbWVsaW5lLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/dom/vector-dom-timeline.js\n");

/***/ }),

/***/ "./lib/dom/vector-dom.js":
/*!*******************************!*\
  !*** ./lib/dom/vector-dom.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VectorDom = void 0;\nconst document_mouse_tracker_1 = __webpack_require__(/*! ./document-mouse-tracker */ \"./lib/dom/document-mouse-tracker.js\");\nconst ease_1 = __webpack_require__(/*! ../ease/ease */ \"./lib/ease/ease.js\");\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst matrixIV_1 = __webpack_require__(/*! ../mathf/matrixIV */ \"./lib/mathf/matrixIV.js\");\nconst vector_1 = __webpack_require__(/*! ../mathf/vector */ \"./lib/mathf/vector.js\");\nconst quaternion_1 = __webpack_require__(/*! ../mathf/quaternion */ \"./lib/mathf/quaternion.js\");\nconst func_1 = __webpack_require__(/*! ../func/func */ \"./lib/func/func.js\");\nconst is_1 = __webpack_require__(/*! ../is/is */ \"./lib/is/is.js\");\nconst dom_watcher_1 = __webpack_require__(/*! ./dom-watcher */ \"./lib/dom/dom-watcher.js\");\nconst element_visibility_1 = __webpack_require__(/*! ./element-visibility */ \"./lib/dom/element-visibility.js\");\nconst vector_dom_timeline_1 = __webpack_require__(/*! ./vector-dom-timeline */ \"./lib/dom/vector-dom-timeline.js\");\nconst vector_dom_force_1 = __webpack_require__(/*! ./vector-dom-force */ \"./lib/dom/vector-dom-force.js\");\n/**\n * VectorDom is a general object is similar to a GameObject in many engines (but\n * much simpler).\n *\n * Vector-DOM allows you to specify the position (vec3), rotation (Quaternion) of\n * an html element using matrix3d transforms.\n *\n * The z value of the position vector gets translated as the scale and z-index\n * is automatically adjusted based on the depth.\n *\n *\n * #### Basic Usage:\n *\n * ```ts\n *\n * const element = document.getElementById('myelement');\n * const vectorElement = new VectorDom(element);\n *\n * // By default the vector element will have an anchor at the center\n * // of the element but override if needed.  This anchor value is generally\n * // used for translate offset while rotation and scale offsets are\n * // controlled by transforOrigin.\n * // Here we set it to the top left.  Default is 0.5.\n * vectorElement.anchorX = 0;\n * vectorElement.anchorY = 0;\n *\n *\n * // Update the transform origin if you want. Default center center.\n * vectorElement.transformOrigin = 'center center'\n *\n * // Set the initial position, rotation of the vector dom.\n * //  z indicates scale.\n * // The z is shifted by 1.  So -1 = 0%.  0 = 100%; 1 = 200%.\n * vectorElement.setPosition( new Vector(0, 0, 0));\n *\n * // Sets the Eular based rotation. See more on rotation below.\n * vectorElement.setRotation( new Vector(30, 20, 10));\n *\n * // Optionally set the global offset.  Here we center this element to the\n * // center of the screen.\n * vectorElement.setOffset( new Vector(\n *      window.innerWidth/ 2,  window.innerHeight /2, 0));\n *\n * // After setting intial positions and options, run initialize.\n * vectorElement.init();\n *\n *\n * new Raf(()=> {\n *   // On each raf, let's rotate the element.\n *   this.vectorElement.rx += 0.03;\n *   this.vectorElement.ry += 0.03;\n *   this.vectorElement.rz += 0.03;\n *\n *   // Move the element up 1px on each raf.\n *   let up = new Vector(1, 0, 0);\n *   this.vectorElement.position.add(rotate);\n *\n *   // Render updates the style.  It is automatically culled so only updated\n *   // when values change.\n *   this.vectorElement.render(true);\n * })\n *\n * ```\n *\n * #### Element Visibility\n *\n * Each vector dom also tracks its visility on the page using elementVisiblity.\n * You can access the element state with it.\n *\n * ```ts\n *\n * let v = new VectorDom(myElement);\n * v.state().inview; // true or false.  The element is current inview.\n * v.state().inview && doSomething();\n *\n * ```\n *\n *\n * #### Render When in View\n *\n * By default, the DOM will update when the element is inview.\n * You can turn of this feature by setting it to false which will update the\n * DOM even when the element is out of view.\n *\n * ```ts\n *\n * vectorDom.renderOnlyWhenInview = false;\n *\n * ```\n *\n * #### Rotations\n *\n * VectorDom uses Quaternions under the hood but provides ways to think in terms\n * of Euler rotations.\n *\n * In the object, internal Euler rotations are cached in `eulerRotation` and\n * the quaternion rotation is cache in `rotation`.\n *\n * At the core, on each render, the quaternion rotation is USED to create the\n * rotation matrix.  This means that ultimately, VectorDOM is a quaternion\n * based system to avoid the issues associated with Euler rotation (gimbal lock).\n *\n * So while you can update the values of `eularRotation`, changing those\n * values, will have NO effect unless, you sync it and tell VectorDOM to\n * use the current eularRotation values and apply that to VectorDOM.\n *\n *\n * To do this, run `syncEularRotation` and VectorDOM will internally,\n * convert the current eularRotation values and OVERWRITE the rotation quaternion\n * values - effectively, setting and applying the eular rotation to the VectorDOM.\n *\n * ```ts\n *\n * // Tell Vector dom to update internal rotation with the values of\n * // eularRotation.\n * vectorDom.syncEularRotation();\n * vectorDom.render();\n *\n * ```\n *\n * By using this, you can manipulate the rotation values in Euler.\n *\n * ```ts\n *\n * vectorDom.rx = 90;  // Set rotationX to 90 degrees.\n * vectorDom.eularRotation.x = 90;  // Same as above, set rotationX to 90 degrees.\n *\n * // Sync it and render it.\n * vectorDom.syncEularRotation();\n * vectorDom.render();\n *\n *\n * // Sets the euler rotation and quaternion rotation at once at anytime.\n * vectorDom.setRotation(new Vector(180, 90, 0));\n *\n * ```\n *\n * To keep it short you can also just pass, `true` to the render, which will tell\n * VectorDom that you want to sync on every render.\n *\n * ```ts\n *\n * vectorDom.render(true);\n *\n * ```\n *\n *\n * Now if you prefer to use quaternions, you can access the internal rotation\n * and NOT sync the eular rotation.  Using quaternions will have more flexibility.\n *\n *\n * ```ts\n * // Set the X rotation to 90.\n * let q = Quaternion.fromEuler(90, 0, 0);\n * vectorDom.rotation = q;\n * vectorDom.render();\n *\n * ```\n *\n * You can do more advanced things as well.\n *\n * ```ts\n * // Set initial rotation.\n * vectorDom.rotation = Quaternion.fromEular(30,30,30);\n *\n * // Add 90 degrees in X rotation to whatever it is now.\n * vectorDom.rotation.addEular(90, 0, 0);\n *\n * // Another way to do it.\n * // Add rotation by 90 degrees in X and 20 degress in y and 10 on the Z.\n * let xRadian = mathf.degreesToRadian(90);\n * let yRadian = mathf.degreesToRadian(20);\n * let zRadian = mathf.degreesToRadian(10);\n * let q1 = Quaternion.IDENTITY.angleAxis(xRadian, Vector.RIGHT); // x\n * let q2 = Quaternion.IDENTITY.angleAxis(yRadian, Vector.UP); /// y\n * let q3 = Quaternion.IDENTITY.angleAxis(yRadian, Vector.FORWARD); /// Z\n * vectorDOm.rotation.multiply(q1).multiply(q2).multiply(q3);\n *\n *\n * // Slerp to a specific Euler degree.\n *  let target = Quaternion.fromEuler(90, 20, 0);\n *  myQuat.slerp(target, this.progress);\n *\n *\n * // Lastely render without the sync option.\n * vectorDom.render();\n * ```\n *\n * Getting Eular values from Quaternion.  In general, it is a one way street\n * for now in which you can convert from Euler -> Quaternion but not the other\n * way around.  If needed, you can use the following but there are some rare\n * accuracy issues at the moment.\n *\n * ```ts\n * let eularRotation = vectorDom.rotation.toEulerVector();\n * eularRotation.x // the x rotation in degrees\n * eularRotation.y // the y rotation in degrees\n * eularRotation.z // the z rotation in degrees\n *\n * ```\n *\n * To reiterate, the sync option overwrite the Eular rotation so doing this\n * won't work.\n *\n * ```ts\n *\n * // Internally update the quaternion rotation.\n *  let target = Quaternion.fromEuler(90, 20, 0);\n *  myQuat.slerp(target, this.progress);\n *\n * // Now the eularRotation which was still at 0,0,0 overwrote the internal\n * // quaternion values.\n * this.syncEularRotation();\n *\n * // vectorDom will remain at 0,0,0.\n * vectorDom.render();\n * ```\n *\n *\n * The best of both worlds is that Quaternions are good at slerping and euler\n * is more intuitive.  You can use the internal rx, ry, rz values in degrees,\n * then apply that to the final quaternion rotation.\n *\n * ```ts\n *\n * // Add some rotation to eularRotation and then slerp the quaternion rotation.\n * this.flowerVector.eularRotation.x += 0.1;\n * this.flowerVector.rotation.slerpEulerVector(\n *     this.flowerVector.eularRotation, 0.08);\n * this.render();\n *\n * ```\n *\n *\n * #### Components\n *\n * VectorDom extends functionality via components.\n * Components can be access via `.components` or `._` for shorthand.\n *\n * These two are the same thing.\n *\n * ```ts\n *\n * vectorDom.components.timeline.setProgress(0.4);\n * vectorDom._.timeline.setProgress(0.4);\n *\n * ```\n *\n * See more demo in /examples/vector-dom and /examples/scroll-demo\n *\n *\n * #### Other notes\n * - globalPosition\n *   Don't add padding to body element.\n *   In order to avoid layout thrashing, VectorDom internally calculates the\n *   globalPosition.  However this relies on the document.body to not have\n *   padding.\n * - globalPosition\n *   Global position attempts to optimize calls to getBoundClientRect.\n *   If you are having issues with this, try setting useBoundsForGlobalCalculation\n *   to true.\n *\n * @unstable\n */\nclass VectorDom {\n    constructor(element, options) {\n        this.element = element;\n        this.offset = vector_1.Vector.ZERO;\n        this.position = vector_1.Vector.ZERO;\n        this.acceleration = vector_1.Vector.ZERO;\n        this.velocity = vector_1.Vector.ZERO;\n        this.rotation = quaternion_1.Quaternion.IDENTITY;\n        this.eularRotation = vector_1.Vector.ZERO;\n        this.transformOrigin = 'center center';\n        this.width = element.offsetWidth;\n        this.height = element.offsetHeight;\n        this.anchorX = 0.5;\n        this.anchorY = 0.5;\n        this.alpha = 1;\n        this.forcedZIndex = null;\n        this.zIndexScalar = 30;\n        this.mouse = document_mouse_tracker_1.default;\n        this.watcher = new dom_watcher_1.DomWatcher();\n        this.renderOnlyWhenInview = true;\n        this.options = options || {};\n        this.disableStyleRenders = false;\n        this.useBoundsForGlobalCalculation = false;\n        this.eularRotationAsRotationMatrix = false;\n        this.renderWith3dProjectMatrix = true;\n        this.gx_ = 0;\n        this.gy_ = 0;\n        // Add element visibility to the VectorDom.\n        this.elementVisibility = element_visibility_1.elementVisibility.inview(this.element);\n        this.watcher.add({\n            element: window,\n            on: 'resize',\n            callback: this.resize.bind(this),\n            eventOptions: { passive: true },\n        });\n        // Initialize all components.\n        this.components = {\n            /**\n             * The vector dom timeline component.\n             */\n            timeline: new vector_dom_timeline_1.VectorDomTimeline(this),\n            /**\n             * The vector dom force component.\n             */\n            force: new vector_dom_force_1.VectorDomForce(this),\n        };\n        // Create an alias to components.\n        this._ = this.components;\n        // Memoize getBoundingClient .\n        this.getBoundingClient = func_1.func.memoizeSimple(this.getBoundingClient.bind(this));\n        // Make sure render only runs when changes are detected.\n        this.render_ = func_1.func.runOnceOnChange(this.render_.bind(this));\n    }\n    init() {\n        this.resize();\n        this.setTransformOrigin();\n        for (const key in this.components) {\n            this.components[key].init();\n        }\n    }\n    resize() {\n        this.width = this.element.offsetWidth;\n        this.height = this.element.offsetHeight;\n        // Cache the global gx_ and gy_ values.\n        const bounds = this.bounds;\n        this.gx_ = bounds.left;\n        this.gy_ = bounds.top + window.scrollY;\n        // Update components.\n        for (const key in this.components) {\n            this.components[key].resize();\n        }\n    }\n    setTransformOrigin(value = 'center center') {\n        if (this.disableStyleRenders) {\n            return;\n        }\n        this.transformOrigin = value;\n        this.element.style.transformOrigin = 'center center';\n    }\n    setPosition(v) {\n        this.position = v;\n    }\n    // /**\n    //  * Returns the eularRotation Vector.\n    //  */\n    // get eularRotation() {\n    //     return Quaternion.toEulerVector(this.rotation);\n    // }\n    get x() {\n        return this.position.x;\n    }\n    set x(value) {\n        this.position.x = value;\n    }\n    get y() {\n        return this.position.y;\n    }\n    set y(value) {\n        this.position.y = value;\n    }\n    get z() {\n        return this.position.z;\n    }\n    set z(value) {\n        this.position.z = value;\n    }\n    get vx() {\n        return this.velocity.x;\n    }\n    set vx(value) {\n        this.velocity.x = value;\n    }\n    get vy() {\n        return this.velocity.y;\n    }\n    set vy(value) {\n        this.velocity.y = value;\n    }\n    get vz() {\n        return this.velocity.z;\n    }\n    set vz(value) {\n        this.velocity.z = value;\n    }\n    get ax() {\n        return this.acceleration.x;\n    }\n    set ax(value) {\n        this.acceleration.x = value;\n    }\n    get ay() {\n        return this.acceleration.y;\n    }\n    set ay(value) {\n        this.acceleration.y = value;\n    }\n    get az() {\n        return this.acceleration.z;\n    }\n    set az(value) {\n        this.acceleration.z = value;\n    }\n    get rx() {\n        return this.eularRotation.x;\n    }\n    set rx(value) {\n        this.eularRotation.x = value;\n    }\n    get ry() {\n        return this.eularRotation.y;\n    }\n    set ry(value) {\n        this.eularRotation.y = value;\n    }\n    get rz() {\n        return this.eularRotation.z;\n    }\n    set rz(value) {\n        this.eularRotation.z = value;\n    }\n    /**\n     * Gets the global position of this element in relation to the window.\n     * If the element is in the top, left of the window, this value would\n     * would return 0,0.\n     *\n     * This value can be incorrect if you element is in the sticky container\n     * in which case, set the useBoundForGlobalCalculation to true.\n     */\n    get globalPosition() {\n        let x = 0;\n        let y = 0;\n        const anchorOffsetVector = this.anchorOffsetVector;\n        if (!this.useBoundsForGlobalCalculation) {\n            x = this.gx_ + this.offset.x + anchorOffsetVector.x;\n            y = this.gy_ - window.scrollY + this.offset.y + anchorOffsetVector.y;\n        }\n        else {\n            x = this.bounds.left;\n            y = this.bounds.top;\n        }\n        return new vector_1.Vector(x, y, this.position.z);\n    }\n    /**\n     * Returns the amount to offset to the center of the vectorDom\n     * based on the anchor.\n     */\n    get anchorOffsetVector() {\n        const anchorOffsetVector = new vector_1.Vector(-(this.anchorX * this.width), -(this.anchorY * this.height), 0);\n        return anchorOffsetVector;\n    }\n    /**\n     * The global element center position.  This is the x,y in relation to\n     * the current window view to the center of the element.   If this value\n     * is 0,0, the \"center\" of the element is at the top left of the window.\n     *\n     * In short, this is asking, where on the screen is the center coordinates\n     * of the element.\n     */\n    get globalElementCenterPosition() {\n        const g = this.globalPosition.clone();\n        let hw = this.width / 2;\n        let hh = this.height / 2;\n        if (this.useBoundsForGlobalCalculation) {\n            hw = this.bounds.width / 2;\n            hh = this.bounds.height / 2;\n        }\n        const x = g.x + hw;\n        const y = g.y + hh;\n        return new vector_1.Vector(x, y, this.position.z);\n    }\n    /**\n     * The element bounds including left, top, width, height. Watch out calling\n     * this on RAF since it can cause layout thrashing.  If possible,\n     * use other values since they are cached.  Consider using globalPosition instead\n     * which is more optimized.\n     *\n     * Since this is using getBoundingClientRect() it is the\n     * rendered width / height versus actual.\n     */\n    get bounds() {\n        const bounds = this.getBoundingClient();\n        return bounds;\n    }\n    /**\n     * Gets the bounding client rect. The scrollY, window width and height are\n     * passed to memoize results and reevaluation happens when those values have\n     * changed.\n     */\n    getBoundingClient() {\n        return this.element.getBoundingClientRect();\n    }\n    setOffset(v) {\n        this.offset = v;\n    }\n    /**\n     * Set the rotation with a Eular degree vector.  Note this method will\n     * overwrite the internal Quaternion rotation.\n     *\n     * ```ts\n     *\n     * vectorDom.setRotation(new Vector(360, 0, 0));\n     * ```\n     * @param v\n     */\n    setRotation(v) {\n        this.rotation = quaternion_1.Quaternion.fromEulerVector(v);\n        this.syncEularRotation();\n    }\n    /**\n     * Tells VectorDom to use the eularRotation values and overrite the internal\n     * Quaternion rotation (which is ultimately used to calculate and generate\n     * the rotational matrix.)\n     */\n    syncEularRotation() {\n        this.rotation = quaternion_1.Quaternion.fromEulerVector(this.eularRotation);\n    }\n    /**\n     * Similar to syncEularRotation, syncs and overwrites the quaternion\n     * rotation execpt does it with a slerp.  Use in place of syncEularRotation\n     * and add a slerp amount.\n     *\n     * In raf loop:\n     * ```ts\n     *\n     * vectorDom.rx += 1\n     * vectorDom.slerpEularRotation(0.08);\n     * // Note we don't pass true here since we don't want to sync.\n     * vectorDom.render();\n     *\n     * ```\n     * @param amount The amount to slerp.\n     */\n    slerpEularRotation(amount) {\n        this.rotation.slerpEulerVector(this.eularRotation, amount);\n    }\n    /**\n     * Forces a zIndex on this VectorDom.  Normally, zIndex is auto calculated\n     * by VectorDom based on the depth of the object.  This allows you to\n     * force a given zIndex.  Pass null to release zIndex control back to\n     * VectorDom.\n     *\n     * ```ts\n     *\n     * vectorDom.forceZIndex(20);\n     * vectorDom.forceZIndex(null); // release control\n     *\n     * ```\n     *\n     * @param zIndex\n     */\n    forceZIndex(zIndex) {\n        this.forcedZIndex = zIndex;\n    }\n    /**\n     * Takes the current position x,y,z vector points and converts it over to\n     * a 4x4 matrix with just consideration for translation.\n     * [\n     *  0 0 0 x\n     *  0 0 0 y\n     *  0 0 0 z\n     *  0 0 0 1\n     * ]\n     *\n     *\n     * Example of applying vector positions to dom elements.\n     *\n     * ```ts\n     *\n     * // Create a vector\n     *  let ballPosition = new Vector(100, 200, 0);\n     *\n     *\n     * // Take those vector positions and convert that into a translation matrix.\n     * let matrix = ballPosition.toTranslationMatrixIV()\n     *\n     * // Convert that to a css 3d translation.\n     * let ms = matrix.toCss3dMatrix();\n     * ball.style.transform = ms;\n     *\n     * ```\n     *\n     * @return {MartrixIV}\n     */\n    toTranslationMatrixIV() {\n        const positionVector = this.position.clone();\n        const matrix = new matrixIV_1.MatrixIV();\n        matrix.setVectorColumn(3, positionVector);\n        return matrix;\n    }\n    /**\n     * Takes the rotation, scale and translation matrices and combines them\n     * into one.\n     */\n    toMatrixIV() {\n        const translationMatrix = this.toTranslationMatrixIV();\n        // Account for anchor offsets.\n        const anchorOffsetVector = new vector_1.Vector(-(this.anchorX * this.width), -(this.anchorY * this.height), 0);\n        const offsetMatrix = new matrixIV_1.MatrixIV();\n        const offsetVector = this.offset.clone().add(anchorOffsetVector);\n        offsetMatrix.setVectorColumn(3, offsetVector);\n        // Scale based on the z position.\n        const z = mathf_1.mathf.clamp(-1, 10, this.position.z + 1);\n        const scaleMatrix = new matrixIV_1.MatrixIV().scaleXyz(z, z, z);\n        scaleMatrix.value[15] = 1;\n        // Don't use YPR Eular because of gimble lock unless really needed.\n        let rotationMatrix;\n        if (this.eularRotationAsRotationMatrix) {\n            const radianEular = this.eularRotation.clone().degreeToRadians();\n            rotationMatrix = new matrixIV_1.MatrixIV().ypr(-radianEular.y, -radianEular.x, radianEular.z);\n        }\n        else {\n            rotationMatrix = matrixIV_1.MatrixIV.fromQuaternion(this.rotation);\n        }\n        // Apply SRT.\n        const baseMatrix = matrixIV_1.MatrixIV.IDENTITY.multiply(scaleMatrix)\n            .multiply(rotationMatrix)\n            .multiply(translationMatrix)\n            .multiply(offsetMatrix);\n        if (!this.renderWith3dProjectMatrix) {\n            return baseMatrix;\n        }\n        else {\n            const projectionMatrix = new matrixIV_1.MatrixIV().perspective(mathf_1.mathf.degreeToRadian(90), 1, -1, 100);\n            const viewMatrix = new matrixIV_1.MatrixIV().lookAt(new vector_1.Vector(0, 0, 1), new vector_1.Vector(0, 0, 0), vector_1.Vector.DOWN);\n            return projectionMatrix.multiply(viewMatrix).multiply(baseMatrix);\n        }\n    }\n    toCss3dMatrix() {\n        const matrixValue = this.toMatrixIV().toCss3dMatrix();\n        return matrixValue;\n    }\n    /**\n     * Renders the VectorDom.\n     * @param {syncEularRotation} Whether to sync the eular rotation on each\n     *   render.  Defaults to true but turn off if you want to manipulate the\n     *   internal quaternion rotation.\n     */\n    render(syncEularRotation = false) {\n        if (syncEularRotation) {\n            this.syncEularRotation();\n        }\n        // Components render out first.\n        for (const key in this.components) {\n            this.components[key].render();\n        }\n        // Update the position based on velocity and acceleration.\n        // Has not effect if you just directly update the position.\n        this.velocity.ease(this.acceleration, 1, ease_1.EASE.linear);\n        this.position.add(this.velocity);\n        const matrixValue = this.toCss3dMatrix();\n        this.render_(matrixValue, this.alpha);\n    }\n    /**\n     * Applies the css transform to this object.  Unneccesary calls get culled by\n     * func.runOnceOnChange.\n     */\n    render_(transform, alpha) {\n        if (this.disableStyleRenders) {\n            return;\n        }\n        /**\n         * Render this element only when it is inview for performance boost.\n         */\n        if (this.renderOnlyWhenInview &&\n            this.elementVisibility.state().ready &&\n            !this.elementVisibility.state().inview) {\n            return;\n        }\n        this.element.style.transform = transform;\n        this.element.style.opacity = alpha + '';\n        if (!is_1.is.null(this.forcedZIndex)) {\n            this.element.style.zIndex = this.forcedZIndex + '';\n        }\n        else {\n            this.element.style.zIndex =\n                ((this.zIndexScalar * (this.position.z + 1)) >> 0) + '';\n        }\n    }\n    dispose() {\n        for (const key in this.components) {\n            this.components[key].dispose();\n        }\n        this.watcher.dispose();\n        this.elementVisibility.dispose();\n    }\n}\nexports.VectorDom = VectorDom;\n//# sourceMappingURL=vector-dom.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL3ZlY3Rvci1kb20uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL3ZlY3Rvci1kb20uanM/ZGNmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmVjdG9yRG9tID0gdm9pZCAwO1xuY29uc3QgZG9jdW1lbnRfbW91c2VfdHJhY2tlcl8xID0gcmVxdWlyZShcIi4vZG9jdW1lbnQtbW91c2UtdHJhY2tlclwiKTtcbmNvbnN0IGVhc2VfMSA9IHJlcXVpcmUoXCIuLi9lYXNlL2Vhc2VcIik7XG5jb25zdCBtYXRoZl8xID0gcmVxdWlyZShcIi4uL21hdGhmL21hdGhmXCIpO1xuY29uc3QgbWF0cml4SVZfMSA9IHJlcXVpcmUoXCIuLi9tYXRoZi9tYXRyaXhJVlwiKTtcbmNvbnN0IHZlY3Rvcl8xID0gcmVxdWlyZShcIi4uL21hdGhmL3ZlY3RvclwiKTtcbmNvbnN0IHF1YXRlcm5pb25fMSA9IHJlcXVpcmUoXCIuLi9tYXRoZi9xdWF0ZXJuaW9uXCIpO1xuY29uc3QgZnVuY18xID0gcmVxdWlyZShcIi4uL2Z1bmMvZnVuY1wiKTtcbmNvbnN0IGlzXzEgPSByZXF1aXJlKFwiLi4vaXMvaXNcIik7XG5jb25zdCBkb21fd2F0Y2hlcl8xID0gcmVxdWlyZShcIi4vZG9tLXdhdGNoZXJcIik7XG5jb25zdCBlbGVtZW50X3Zpc2liaWxpdHlfMSA9IHJlcXVpcmUoXCIuL2VsZW1lbnQtdmlzaWJpbGl0eVwiKTtcbmNvbnN0IHZlY3Rvcl9kb21fdGltZWxpbmVfMSA9IHJlcXVpcmUoXCIuL3ZlY3Rvci1kb20tdGltZWxpbmVcIik7XG5jb25zdCB2ZWN0b3JfZG9tX2ZvcmNlXzEgPSByZXF1aXJlKFwiLi92ZWN0b3ItZG9tLWZvcmNlXCIpO1xuLyoqXG4gKiBWZWN0b3JEb20gaXMgYSBnZW5lcmFsIG9iamVjdCBpcyBzaW1pbGFyIHRvIGEgR2FtZU9iamVjdCBpbiBtYW55IGVuZ2luZXMgKGJ1dFxuICogbXVjaCBzaW1wbGVyKS5cbiAqXG4gKiBWZWN0b3ItRE9NIGFsbG93cyB5b3UgdG8gc3BlY2lmeSB0aGUgcG9zaXRpb24gKHZlYzMpLCByb3RhdGlvbiAoUXVhdGVybmlvbikgb2ZcbiAqIGFuIGh0bWwgZWxlbWVudCB1c2luZyBtYXRyaXgzZCB0cmFuc2Zvcm1zLlxuICpcbiAqIFRoZSB6IHZhbHVlIG9mIHRoZSBwb3NpdGlvbiB2ZWN0b3IgZ2V0cyB0cmFuc2xhdGVkIGFzIHRoZSBzY2FsZSBhbmQgei1pbmRleFxuICogaXMgYXV0b21hdGljYWxseSBhZGp1c3RlZCBiYXNlZCBvbiB0aGUgZGVwdGguXG4gKlxuICpcbiAqICMjIyMgQmFzaWMgVXNhZ2U6XG4gKlxuICogYGBgdHNcbiAqXG4gKiBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215ZWxlbWVudCcpO1xuICogY29uc3QgdmVjdG9yRWxlbWVudCA9IG5ldyBWZWN0b3JEb20oZWxlbWVudCk7XG4gKlxuICogLy8gQnkgZGVmYXVsdCB0aGUgdmVjdG9yIGVsZW1lbnQgd2lsbCBoYXZlIGFuIGFuY2hvciBhdCB0aGUgY2VudGVyXG4gKiAvLyBvZiB0aGUgZWxlbWVudCBidXQgb3ZlcnJpZGUgaWYgbmVlZGVkLiAgVGhpcyBhbmNob3IgdmFsdWUgaXMgZ2VuZXJhbGx5XG4gKiAvLyB1c2VkIGZvciB0cmFuc2xhdGUgb2Zmc2V0IHdoaWxlIHJvdGF0aW9uIGFuZCBzY2FsZSBvZmZzZXRzIGFyZVxuICogLy8gY29udHJvbGxlZCBieSB0cmFuc2Zvck9yaWdpbi5cbiAqIC8vIEhlcmUgd2Ugc2V0IGl0IHRvIHRoZSB0b3AgbGVmdC4gIERlZmF1bHQgaXMgMC41LlxuICogdmVjdG9yRWxlbWVudC5hbmNob3JYID0gMDtcbiAqIHZlY3RvckVsZW1lbnQuYW5jaG9yWSA9IDA7XG4gKlxuICpcbiAqIC8vIFVwZGF0ZSB0aGUgdHJhbnNmb3JtIG9yaWdpbiBpZiB5b3Ugd2FudC4gRGVmYXVsdCBjZW50ZXIgY2VudGVyLlxuICogdmVjdG9yRWxlbWVudC50cmFuc2Zvcm1PcmlnaW4gPSAnY2VudGVyIGNlbnRlcidcbiAqXG4gKiAvLyBTZXQgdGhlIGluaXRpYWwgcG9zaXRpb24sIHJvdGF0aW9uIG9mIHRoZSB2ZWN0b3IgZG9tLlxuICogLy8gIHogaW5kaWNhdGVzIHNjYWxlLlxuICogLy8gVGhlIHogaXMgc2hpZnRlZCBieSAxLiAgU28gLTEgPSAwJS4gIDAgPSAxMDAlOyAxID0gMjAwJS5cbiAqIHZlY3RvckVsZW1lbnQuc2V0UG9zaXRpb24oIG5ldyBWZWN0b3IoMCwgMCwgMCkpO1xuICpcbiAqIC8vIFNldHMgdGhlIEV1bGFyIGJhc2VkIHJvdGF0aW9uLiBTZWUgbW9yZSBvbiByb3RhdGlvbiBiZWxvdy5cbiAqIHZlY3RvckVsZW1lbnQuc2V0Um90YXRpb24oIG5ldyBWZWN0b3IoMzAsIDIwLCAxMCkpO1xuICpcbiAqIC8vIE9wdGlvbmFsbHkgc2V0IHRoZSBnbG9iYWwgb2Zmc2V0LiAgSGVyZSB3ZSBjZW50ZXIgdGhpcyBlbGVtZW50IHRvIHRoZVxuICogLy8gY2VudGVyIG9mIHRoZSBzY3JlZW4uXG4gKiB2ZWN0b3JFbGVtZW50LnNldE9mZnNldCggbmV3IFZlY3RvcihcbiAqICAgICAgd2luZG93LmlubmVyV2lkdGgvIDIsICB3aW5kb3cuaW5uZXJIZWlnaHQgLzIsIDApKTtcbiAqXG4gKiAvLyBBZnRlciBzZXR0aW5nIGludGlhbCBwb3NpdGlvbnMgYW5kIG9wdGlvbnMsIHJ1biBpbml0aWFsaXplLlxuICogdmVjdG9yRWxlbWVudC5pbml0KCk7XG4gKlxuICpcbiAqIG5ldyBSYWYoKCk9PiB7XG4gKiAgIC8vIE9uIGVhY2ggcmFmLCBsZXQncyByb3RhdGUgdGhlIGVsZW1lbnQuXG4gKiAgIHRoaXMudmVjdG9yRWxlbWVudC5yeCArPSAwLjAzO1xuICogICB0aGlzLnZlY3RvckVsZW1lbnQucnkgKz0gMC4wMztcbiAqICAgdGhpcy52ZWN0b3JFbGVtZW50LnJ6ICs9IDAuMDM7XG4gKlxuICogICAvLyBNb3ZlIHRoZSBlbGVtZW50IHVwIDFweCBvbiBlYWNoIHJhZi5cbiAqICAgbGV0IHVwID0gbmV3IFZlY3RvcigxLCAwLCAwKTtcbiAqICAgdGhpcy52ZWN0b3JFbGVtZW50LnBvc2l0aW9uLmFkZChyb3RhdGUpO1xuICpcbiAqICAgLy8gUmVuZGVyIHVwZGF0ZXMgdGhlIHN0eWxlLiAgSXQgaXMgYXV0b21hdGljYWxseSBjdWxsZWQgc28gb25seSB1cGRhdGVkXG4gKiAgIC8vIHdoZW4gdmFsdWVzIGNoYW5nZS5cbiAqICAgdGhpcy52ZWN0b3JFbGVtZW50LnJlbmRlcih0cnVlKTtcbiAqIH0pXG4gKlxuICogYGBgXG4gKlxuICogIyMjIyBFbGVtZW50IFZpc2liaWxpdHlcbiAqXG4gKiBFYWNoIHZlY3RvciBkb20gYWxzbyB0cmFja3MgaXRzIHZpc2lsaXR5IG9uIHRoZSBwYWdlIHVzaW5nIGVsZW1lbnRWaXNpYmxpdHkuXG4gKiBZb3UgY2FuIGFjY2VzcyB0aGUgZWxlbWVudCBzdGF0ZSB3aXRoIGl0LlxuICpcbiAqIGBgYHRzXG4gKlxuICogbGV0IHYgPSBuZXcgVmVjdG9yRG9tKG15RWxlbWVudCk7XG4gKiB2LnN0YXRlKCkuaW52aWV3OyAvLyB0cnVlIG9yIGZhbHNlLiAgVGhlIGVsZW1lbnQgaXMgY3VycmVudCBpbnZpZXcuXG4gKiB2LnN0YXRlKCkuaW52aWV3ICYmIGRvU29tZXRoaW5nKCk7XG4gKlxuICogYGBgXG4gKlxuICpcbiAqICMjIyMgUmVuZGVyIFdoZW4gaW4gVmlld1xuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZSBET00gd2lsbCB1cGRhdGUgd2hlbiB0aGUgZWxlbWVudCBpcyBpbnZpZXcuXG4gKiBZb3UgY2FuIHR1cm4gb2YgdGhpcyBmZWF0dXJlIGJ5IHNldHRpbmcgaXQgdG8gZmFsc2Ugd2hpY2ggd2lsbCB1cGRhdGUgdGhlXG4gKiBET00gZXZlbiB3aGVuIHRoZSBlbGVtZW50IGlzIG91dCBvZiB2aWV3LlxuICpcbiAqIGBgYHRzXG4gKlxuICogdmVjdG9yRG9tLnJlbmRlck9ubHlXaGVuSW52aWV3ID0gZmFsc2U7XG4gKlxuICogYGBgXG4gKlxuICogIyMjIyBSb3RhdGlvbnNcbiAqXG4gKiBWZWN0b3JEb20gdXNlcyBRdWF0ZXJuaW9ucyB1bmRlciB0aGUgaG9vZCBidXQgcHJvdmlkZXMgd2F5cyB0byB0aGluayBpbiB0ZXJtc1xuICogb2YgRXVsZXIgcm90YXRpb25zLlxuICpcbiAqIEluIHRoZSBvYmplY3QsIGludGVybmFsIEV1bGVyIHJvdGF0aW9ucyBhcmUgY2FjaGVkIGluIGBldWxlclJvdGF0aW9uYCBhbmRcbiAqIHRoZSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGlzIGNhY2hlIGluIGByb3RhdGlvbmAuXG4gKlxuICogQXQgdGhlIGNvcmUsIG9uIGVhY2ggcmVuZGVyLCB0aGUgcXVhdGVybmlvbiByb3RhdGlvbiBpcyBVU0VEIHRvIGNyZWF0ZSB0aGVcbiAqIHJvdGF0aW9uIG1hdHJpeC4gIFRoaXMgbWVhbnMgdGhhdCB1bHRpbWF0ZWx5LCBWZWN0b3JET00gaXMgYSBxdWF0ZXJuaW9uXG4gKiBiYXNlZCBzeXN0ZW0gdG8gYXZvaWQgdGhlIGlzc3VlcyBhc3NvY2lhdGVkIHdpdGggRXVsZXIgcm90YXRpb24gKGdpbWJhbCBsb2NrKS5cbiAqXG4gKiBTbyB3aGlsZSB5b3UgY2FuIHVwZGF0ZSB0aGUgdmFsdWVzIG9mIGBldWxhclJvdGF0aW9uYCwgY2hhbmdpbmcgdGhvc2VcbiAqIHZhbHVlcywgd2lsbCBoYXZlIE5PIGVmZmVjdCB1bmxlc3MsIHlvdSBzeW5jIGl0IGFuZCB0ZWxsIFZlY3RvckRPTSB0b1xuICogdXNlIHRoZSBjdXJyZW50IGV1bGFyUm90YXRpb24gdmFsdWVzIGFuZCBhcHBseSB0aGF0IHRvIFZlY3RvckRPTS5cbiAqXG4gKlxuICogVG8gZG8gdGhpcywgcnVuIGBzeW5jRXVsYXJSb3RhdGlvbmAgYW5kIFZlY3RvckRPTSB3aWxsIGludGVybmFsbHksXG4gKiBjb252ZXJ0IHRoZSBjdXJyZW50IGV1bGFyUm90YXRpb24gdmFsdWVzIGFuZCBPVkVSV1JJVEUgdGhlIHJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIHZhbHVlcyAtIGVmZmVjdGl2ZWx5LCBzZXR0aW5nIGFuZCBhcHBseWluZyB0aGUgZXVsYXIgcm90YXRpb24gdG8gdGhlIFZlY3RvckRPTS5cbiAqXG4gKiBgYGB0c1xuICpcbiAqIC8vIFRlbGwgVmVjdG9yIGRvbSB0byB1cGRhdGUgaW50ZXJuYWwgcm90YXRpb24gd2l0aCB0aGUgdmFsdWVzIG9mXG4gKiAvLyBldWxhclJvdGF0aW9uLlxuICogdmVjdG9yRG9tLnN5bmNFdWxhclJvdGF0aW9uKCk7XG4gKiB2ZWN0b3JEb20ucmVuZGVyKCk7XG4gKlxuICogYGBgXG4gKlxuICogQnkgdXNpbmcgdGhpcywgeW91IGNhbiBtYW5pcHVsYXRlIHRoZSByb3RhdGlvbiB2YWx1ZXMgaW4gRXVsZXIuXG4gKlxuICogYGBgdHNcbiAqXG4gKiB2ZWN0b3JEb20ucnggPSA5MDsgIC8vIFNldCByb3RhdGlvblggdG8gOTAgZGVncmVlcy5cbiAqIHZlY3RvckRvbS5ldWxhclJvdGF0aW9uLnggPSA5MDsgIC8vIFNhbWUgYXMgYWJvdmUsIHNldCByb3RhdGlvblggdG8gOTAgZGVncmVlcy5cbiAqXG4gKiAvLyBTeW5jIGl0IGFuZCByZW5kZXIgaXQuXG4gKiB2ZWN0b3JEb20uc3luY0V1bGFyUm90YXRpb24oKTtcbiAqIHZlY3RvckRvbS5yZW5kZXIoKTtcbiAqXG4gKlxuICogLy8gU2V0cyB0aGUgZXVsZXIgcm90YXRpb24gYW5kIHF1YXRlcm5pb24gcm90YXRpb24gYXQgb25jZSBhdCBhbnl0aW1lLlxuICogdmVjdG9yRG9tLnNldFJvdGF0aW9uKG5ldyBWZWN0b3IoMTgwLCA5MCwgMCkpO1xuICpcbiAqIGBgYFxuICpcbiAqIFRvIGtlZXAgaXQgc2hvcnQgeW91IGNhbiBhbHNvIGp1c3QgcGFzcywgYHRydWVgIHRvIHRoZSByZW5kZXIsIHdoaWNoIHdpbGwgdGVsbFxuICogVmVjdG9yRG9tIHRoYXQgeW91IHdhbnQgdG8gc3luYyBvbiBldmVyeSByZW5kZXIuXG4gKlxuICogYGBgdHNcbiAqXG4gKiB2ZWN0b3JEb20ucmVuZGVyKHRydWUpO1xuICpcbiAqIGBgYFxuICpcbiAqXG4gKiBOb3cgaWYgeW91IHByZWZlciB0byB1c2UgcXVhdGVybmlvbnMsIHlvdSBjYW4gYWNjZXNzIHRoZSBpbnRlcm5hbCByb3RhdGlvblxuICogYW5kIE5PVCBzeW5jIHRoZSBldWxhciByb3RhdGlvbi4gIFVzaW5nIHF1YXRlcm5pb25zIHdpbGwgaGF2ZSBtb3JlIGZsZXhpYmlsaXR5LlxuICpcbiAqXG4gKiBgYGB0c1xuICogLy8gU2V0IHRoZSBYIHJvdGF0aW9uIHRvIDkwLlxuICogbGV0IHEgPSBRdWF0ZXJuaW9uLmZyb21FdWxlcig5MCwgMCwgMCk7XG4gKiB2ZWN0b3JEb20ucm90YXRpb24gPSBxO1xuICogdmVjdG9yRG9tLnJlbmRlcigpO1xuICpcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gZG8gbW9yZSBhZHZhbmNlZCB0aGluZ3MgYXMgd2VsbC5cbiAqXG4gKiBgYGB0c1xuICogLy8gU2V0IGluaXRpYWwgcm90YXRpb24uXG4gKiB2ZWN0b3JEb20ucm90YXRpb24gPSBRdWF0ZXJuaW9uLmZyb21FdWxhcigzMCwzMCwzMCk7XG4gKlxuICogLy8gQWRkIDkwIGRlZ3JlZXMgaW4gWCByb3RhdGlvbiB0byB3aGF0ZXZlciBpdCBpcyBub3cuXG4gKiB2ZWN0b3JEb20ucm90YXRpb24uYWRkRXVsYXIoOTAsIDAsIDApO1xuICpcbiAqIC8vIEFub3RoZXIgd2F5IHRvIGRvIGl0LlxuICogLy8gQWRkIHJvdGF0aW9uIGJ5IDkwIGRlZ3JlZXMgaW4gWCBhbmQgMjAgZGVncmVzcyBpbiB5IGFuZCAxMCBvbiB0aGUgWi5cbiAqIGxldCB4UmFkaWFuID0gbWF0aGYuZGVncmVlc1RvUmFkaWFuKDkwKTtcbiAqIGxldCB5UmFkaWFuID0gbWF0aGYuZGVncmVlc1RvUmFkaWFuKDIwKTtcbiAqIGxldCB6UmFkaWFuID0gbWF0aGYuZGVncmVlc1RvUmFkaWFuKDEwKTtcbiAqIGxldCBxMSA9IFF1YXRlcm5pb24uSURFTlRJVFkuYW5nbGVBeGlzKHhSYWRpYW4sIFZlY3Rvci5SSUdIVCk7IC8vIHhcbiAqIGxldCBxMiA9IFF1YXRlcm5pb24uSURFTlRJVFkuYW5nbGVBeGlzKHlSYWRpYW4sIFZlY3Rvci5VUCk7IC8vLyB5XG4gKiBsZXQgcTMgPSBRdWF0ZXJuaW9uLklERU5USVRZLmFuZ2xlQXhpcyh5UmFkaWFuLCBWZWN0b3IuRk9SV0FSRCk7IC8vLyBaXG4gKiB2ZWN0b3JET20ucm90YXRpb24ubXVsdGlwbHkocTEpLm11bHRpcGx5KHEyKS5tdWx0aXBseShxMyk7XG4gKlxuICpcbiAqIC8vIFNsZXJwIHRvIGEgc3BlY2lmaWMgRXVsZXIgZGVncmVlLlxuICogIGxldCB0YXJnZXQgPSBRdWF0ZXJuaW9uLmZyb21FdWxlcig5MCwgMjAsIDApO1xuICogIG15UXVhdC5zbGVycCh0YXJnZXQsIHRoaXMucHJvZ3Jlc3MpO1xuICpcbiAqXG4gKiAvLyBMYXN0ZWx5IHJlbmRlciB3aXRob3V0IHRoZSBzeW5jIG9wdGlvbi5cbiAqIHZlY3RvckRvbS5yZW5kZXIoKTtcbiAqIGBgYFxuICpcbiAqIEdldHRpbmcgRXVsYXIgdmFsdWVzIGZyb20gUXVhdGVybmlvbi4gIEluIGdlbmVyYWwsIGl0IGlzIGEgb25lIHdheSBzdHJlZXRcbiAqIGZvciBub3cgaW4gd2hpY2ggeW91IGNhbiBjb252ZXJ0IGZyb20gRXVsZXIgLT4gUXVhdGVybmlvbiBidXQgbm90IHRoZSBvdGhlclxuICogd2F5IGFyb3VuZC4gIElmIG5lZWRlZCwgeW91IGNhbiB1c2UgdGhlIGZvbGxvd2luZyBidXQgdGhlcmUgYXJlIHNvbWUgcmFyZVxuICogYWNjdXJhY3kgaXNzdWVzIGF0IHRoZSBtb21lbnQuXG4gKlxuICogYGBgdHNcbiAqIGxldCBldWxhclJvdGF0aW9uID0gdmVjdG9yRG9tLnJvdGF0aW9uLnRvRXVsZXJWZWN0b3IoKTtcbiAqIGV1bGFyUm90YXRpb24ueCAvLyB0aGUgeCByb3RhdGlvbiBpbiBkZWdyZWVzXG4gKiBldWxhclJvdGF0aW9uLnkgLy8gdGhlIHkgcm90YXRpb24gaW4gZGVncmVlc1xuICogZXVsYXJSb3RhdGlvbi56IC8vIHRoZSB6IHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAqXG4gKiBgYGBcbiAqXG4gKiBUbyByZWl0ZXJhdGUsIHRoZSBzeW5jIG9wdGlvbiBvdmVyd3JpdGUgdGhlIEV1bGFyIHJvdGF0aW9uIHNvIGRvaW5nIHRoaXNcbiAqIHdvbid0IHdvcmsuXG4gKlxuICogYGBgdHNcbiAqXG4gKiAvLyBJbnRlcm5hbGx5IHVwZGF0ZSB0aGUgcXVhdGVybmlvbiByb3RhdGlvbi5cbiAqICBsZXQgdGFyZ2V0ID0gUXVhdGVybmlvbi5mcm9tRXVsZXIoOTAsIDIwLCAwKTtcbiAqICBteVF1YXQuc2xlcnAodGFyZ2V0LCB0aGlzLnByb2dyZXNzKTtcbiAqXG4gKiAvLyBOb3cgdGhlIGV1bGFyUm90YXRpb24gd2hpY2ggd2FzIHN0aWxsIGF0IDAsMCwwIG92ZXJ3cm90ZSB0aGUgaW50ZXJuYWxcbiAqIC8vIHF1YXRlcm5pb24gdmFsdWVzLlxuICogdGhpcy5zeW5jRXVsYXJSb3RhdGlvbigpO1xuICpcbiAqIC8vIHZlY3RvckRvbSB3aWxsIHJlbWFpbiBhdCAwLDAsMC5cbiAqIHZlY3RvckRvbS5yZW5kZXIoKTtcbiAqIGBgYFxuICpcbiAqXG4gKiBUaGUgYmVzdCBvZiBib3RoIHdvcmxkcyBpcyB0aGF0IFF1YXRlcm5pb25zIGFyZSBnb29kIGF0IHNsZXJwaW5nIGFuZCBldWxlclxuICogaXMgbW9yZSBpbnR1aXRpdmUuICBZb3UgY2FuIHVzZSB0aGUgaW50ZXJuYWwgcngsIHJ5LCByeiB2YWx1ZXMgaW4gZGVncmVlcyxcbiAqIHRoZW4gYXBwbHkgdGhhdCB0byB0aGUgZmluYWwgcXVhdGVybmlvbiByb3RhdGlvbi5cbiAqXG4gKiBgYGB0c1xuICpcbiAqIC8vIEFkZCBzb21lIHJvdGF0aW9uIHRvIGV1bGFyUm90YXRpb24gYW5kIHRoZW4gc2xlcnAgdGhlIHF1YXRlcm5pb24gcm90YXRpb24uXG4gKiB0aGlzLmZsb3dlclZlY3Rvci5ldWxhclJvdGF0aW9uLnggKz0gMC4xO1xuICogdGhpcy5mbG93ZXJWZWN0b3Iucm90YXRpb24uc2xlcnBFdWxlclZlY3RvcihcbiAqICAgICB0aGlzLmZsb3dlclZlY3Rvci5ldWxhclJvdGF0aW9uLCAwLjA4KTtcbiAqIHRoaXMucmVuZGVyKCk7XG4gKlxuICogYGBgXG4gKlxuICpcbiAqICMjIyMgQ29tcG9uZW50c1xuICpcbiAqIFZlY3RvckRvbSBleHRlbmRzIGZ1bmN0aW9uYWxpdHkgdmlhIGNvbXBvbmVudHMuXG4gKiBDb21wb25lbnRzIGNhbiBiZSBhY2Nlc3MgdmlhIGAuY29tcG9uZW50c2Agb3IgYC5fYCBmb3Igc2hvcnRoYW5kLlxuICpcbiAqIFRoZXNlIHR3byBhcmUgdGhlIHNhbWUgdGhpbmcuXG4gKlxuICogYGBgdHNcbiAqXG4gKiB2ZWN0b3JEb20uY29tcG9uZW50cy50aW1lbGluZS5zZXRQcm9ncmVzcygwLjQpO1xuICogdmVjdG9yRG9tLl8udGltZWxpbmUuc2V0UHJvZ3Jlc3MoMC40KTtcbiAqXG4gKiBgYGBcbiAqXG4gKiBTZWUgbW9yZSBkZW1vIGluIC9leGFtcGxlcy92ZWN0b3ItZG9tIGFuZCAvZXhhbXBsZXMvc2Nyb2xsLWRlbW9cbiAqXG4gKlxuICogIyMjIyBPdGhlciBub3Rlc1xuICogLSBnbG9iYWxQb3NpdGlvblxuICogICBEb24ndCBhZGQgcGFkZGluZyB0byBib2R5IGVsZW1lbnQuXG4gKiAgIEluIG9yZGVyIHRvIGF2b2lkIGxheW91dCB0aHJhc2hpbmcsIFZlY3RvckRvbSBpbnRlcm5hbGx5IGNhbGN1bGF0ZXMgdGhlXG4gKiAgIGdsb2JhbFBvc2l0aW9uLiAgSG93ZXZlciB0aGlzIHJlbGllcyBvbiB0aGUgZG9jdW1lbnQuYm9keSB0byBub3QgaGF2ZVxuICogICBwYWRkaW5nLlxuICogLSBnbG9iYWxQb3NpdGlvblxuICogICBHbG9iYWwgcG9zaXRpb24gYXR0ZW1wdHMgdG8gb3B0aW1pemUgY2FsbHMgdG8gZ2V0Qm91bmRDbGllbnRSZWN0LlxuICogICBJZiB5b3UgYXJlIGhhdmluZyBpc3N1ZXMgd2l0aCB0aGlzLCB0cnkgc2V0dGluZyB1c2VCb3VuZHNGb3JHbG9iYWxDYWxjdWxhdGlvblxuICogICB0byB0cnVlLlxuICpcbiAqIEB1bnN0YWJsZVxuICovXG5jbGFzcyBWZWN0b3JEb20ge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB2ZWN0b3JfMS5WZWN0b3IuWkVSTztcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHZlY3Rvcl8xLlZlY3Rvci5aRVJPO1xuICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IHZlY3Rvcl8xLlZlY3Rvci5aRVJPO1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdmVjdG9yXzEuVmVjdG9yLlpFUk87XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBxdWF0ZXJuaW9uXzEuUXVhdGVybmlvbi5JREVOVElUWTtcbiAgICAgICAgdGhpcy5ldWxhclJvdGF0aW9uID0gdmVjdG9yXzEuVmVjdG9yLlpFUk87XG4gICAgICAgIHRoaXMudHJhbnNmb3JtT3JpZ2luID0gJ2NlbnRlciBjZW50ZXInO1xuICAgICAgICB0aGlzLndpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgdGhpcy5hbmNob3JYID0gMC41O1xuICAgICAgICB0aGlzLmFuY2hvclkgPSAwLjU7XG4gICAgICAgIHRoaXMuYWxwaGEgPSAxO1xuICAgICAgICB0aGlzLmZvcmNlZFpJbmRleCA9IG51bGw7XG4gICAgICAgIHRoaXMuekluZGV4U2NhbGFyID0gMzA7XG4gICAgICAgIHRoaXMubW91c2UgPSBkb2N1bWVudF9tb3VzZV90cmFja2VyXzEuZGVmYXVsdDtcbiAgICAgICAgdGhpcy53YXRjaGVyID0gbmV3IGRvbV93YXRjaGVyXzEuRG9tV2F0Y2hlcigpO1xuICAgICAgICB0aGlzLnJlbmRlck9ubHlXaGVuSW52aWV3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5kaXNhYmxlU3R5bGVSZW5kZXJzID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXNlQm91bmRzRm9yR2xvYmFsQ2FsY3VsYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldWxhclJvdGF0aW9uQXNSb3RhdGlvbk1hdHJpeCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbmRlcldpdGgzZFByb2plY3RNYXRyaXggPSB0cnVlO1xuICAgICAgICB0aGlzLmd4XyA9IDA7XG4gICAgICAgIHRoaXMuZ3lfID0gMDtcbiAgICAgICAgLy8gQWRkIGVsZW1lbnQgdmlzaWJpbGl0eSB0byB0aGUgVmVjdG9yRG9tLlxuICAgICAgICB0aGlzLmVsZW1lbnRWaXNpYmlsaXR5ID0gZWxlbWVudF92aXNpYmlsaXR5XzEuZWxlbWVudFZpc2liaWxpdHkuaW52aWV3KHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHRoaXMud2F0Y2hlci5hZGQoe1xuICAgICAgICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgICAgICAgb246ICdyZXNpemUnLFxuICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMucmVzaXplLmJpbmQodGhpcyksXG4gICAgICAgICAgICBldmVudE9wdGlvbnM6IHsgcGFzc2l2ZTogdHJ1ZSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhbGwgY29tcG9uZW50cy5cbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdmVjdG9yIGRvbSB0aW1lbGluZSBjb21wb25lbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRpbWVsaW5lOiBuZXcgdmVjdG9yX2RvbV90aW1lbGluZV8xLlZlY3RvckRvbVRpbWVsaW5lKHRoaXMpLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdmVjdG9yIGRvbSBmb3JjZSBjb21wb25lbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvcmNlOiBuZXcgdmVjdG9yX2RvbV9mb3JjZV8xLlZlY3RvckRvbUZvcmNlKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICAvLyBDcmVhdGUgYW4gYWxpYXMgdG8gY29tcG9uZW50cy5cbiAgICAgICAgdGhpcy5fID0gdGhpcy5jb21wb25lbnRzO1xuICAgICAgICAvLyBNZW1vaXplIGdldEJvdW5kaW5nQ2xpZW50IC5cbiAgICAgICAgdGhpcy5nZXRCb3VuZGluZ0NsaWVudCA9IGZ1bmNfMS5mdW5jLm1lbW9pemVTaW1wbGUodGhpcy5nZXRCb3VuZGluZ0NsaWVudC5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHJlbmRlciBvbmx5IHJ1bnMgd2hlbiBjaGFuZ2VzIGFyZSBkZXRlY3RlZC5cbiAgICAgICAgdGhpcy5yZW5kZXJfID0gZnVuY18xLmZ1bmMucnVuT25jZU9uQ2hhbmdlKHRoaXMucmVuZGVyXy5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1PcmlnaW4oKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNba2V5XS5pbml0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzaXplKCkge1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIC8vIENhY2hlIHRoZSBnbG9iYWwgZ3hfIGFuZCBneV8gdmFsdWVzLlxuICAgICAgICBjb25zdCBib3VuZHMgPSB0aGlzLmJvdW5kcztcbiAgICAgICAgdGhpcy5neF8gPSBib3VuZHMubGVmdDtcbiAgICAgICAgdGhpcy5neV8gPSBib3VuZHMudG9wICsgd2luZG93LnNjcm9sbFk7XG4gICAgICAgIC8vIFVwZGF0ZSBjb21wb25lbnRzLlxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1trZXldLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFRyYW5zZm9ybU9yaWdpbih2YWx1ZSA9ICdjZW50ZXIgY2VudGVyJykge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlU3R5bGVSZW5kZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2Zvcm1PcmlnaW4gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICdjZW50ZXIgY2VudGVyJztcbiAgICB9XG4gICAgc2V0UG9zaXRpb24odikge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gdjtcbiAgICB9XG4gICAgLy8gLyoqXG4gICAgLy8gICogUmV0dXJucyB0aGUgZXVsYXJSb3RhdGlvbiBWZWN0b3IuXG4gICAgLy8gICovXG4gICAgLy8gZ2V0IGV1bGFyUm90YXRpb24oKSB7XG4gICAgLy8gICAgIHJldHVybiBRdWF0ZXJuaW9uLnRvRXVsZXJWZWN0b3IodGhpcy5yb3RhdGlvbik7XG4gICAgLy8gfVxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xuICAgIH1cbiAgICBzZXQgeCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XG4gICAgfVxuICAgIHNldCB5KHZhbHVlKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgeigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24uejtcbiAgICB9XG4gICAgc2V0IHoodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi56ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCB2eCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVsb2NpdHkueDtcbiAgICB9XG4gICAgc2V0IHZ4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmVsb2NpdHkueCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlbG9jaXR5Lnk7XG4gICAgfVxuICAgIHNldCB2eSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZlbG9jaXR5LnkgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHZ6KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWxvY2l0eS56O1xuICAgIH1cbiAgICBzZXQgdnoodmFsdWUpIHtcbiAgICAgICAgdGhpcy52ZWxvY2l0eS56ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBheCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZWxlcmF0aW9uLng7XG4gICAgfVxuICAgIHNldCBheCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbi54ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZWxlcmF0aW9uLnk7XG4gICAgfVxuICAgIHNldCBheSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbi55ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBheigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZWxlcmF0aW9uLno7XG4gICAgfVxuICAgIHNldCBheih2YWx1ZSkge1xuICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbi56ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCByeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXVsYXJSb3RhdGlvbi54O1xuICAgIH1cbiAgICBzZXQgcngodmFsdWUpIHtcbiAgICAgICAgdGhpcy5ldWxhclJvdGF0aW9uLnggPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldWxhclJvdGF0aW9uLnk7XG4gICAgfVxuICAgIHNldCByeSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmV1bGFyUm90YXRpb24ueSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgcnooKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV1bGFyUm90YXRpb24uejtcbiAgICB9XG4gICAgc2V0IHJ6KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZXVsYXJSb3RhdGlvbi56ID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGdsb2JhbCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnQgaW4gcmVsYXRpb24gdG8gdGhlIHdpbmRvdy5cbiAgICAgKiBJZiB0aGUgZWxlbWVudCBpcyBpbiB0aGUgdG9wLCBsZWZ0IG9mIHRoZSB3aW5kb3csIHRoaXMgdmFsdWUgd291bGRcbiAgICAgKiB3b3VsZCByZXR1cm4gMCwwLlxuICAgICAqXG4gICAgICogVGhpcyB2YWx1ZSBjYW4gYmUgaW5jb3JyZWN0IGlmIHlvdSBlbGVtZW50IGlzIGluIHRoZSBzdGlja3kgY29udGFpbmVyXG4gICAgICogaW4gd2hpY2ggY2FzZSwgc2V0IHRoZSB1c2VCb3VuZEZvckdsb2JhbENhbGN1bGF0aW9uIHRvIHRydWUuXG4gICAgICovXG4gICAgZ2V0IGdsb2JhbFBvc2l0aW9uKCkge1xuICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgIGxldCB5ID0gMDtcbiAgICAgICAgY29uc3QgYW5jaG9yT2Zmc2V0VmVjdG9yID0gdGhpcy5hbmNob3JPZmZzZXRWZWN0b3I7XG4gICAgICAgIGlmICghdGhpcy51c2VCb3VuZHNGb3JHbG9iYWxDYWxjdWxhdGlvbikge1xuICAgICAgICAgICAgeCA9IHRoaXMuZ3hfICsgdGhpcy5vZmZzZXQueCArIGFuY2hvck9mZnNldFZlY3Rvci54O1xuICAgICAgICAgICAgeSA9IHRoaXMuZ3lfIC0gd2luZG93LnNjcm9sbFkgKyB0aGlzLm9mZnNldC55ICsgYW5jaG9yT2Zmc2V0VmVjdG9yLnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4ID0gdGhpcy5ib3VuZHMubGVmdDtcbiAgICAgICAgICAgIHkgPSB0aGlzLmJvdW5kcy50b3A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3JfMS5WZWN0b3IoeCwgeSwgdGhpcy5wb3NpdGlvbi56KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYW1vdW50IHRvIG9mZnNldCB0byB0aGUgY2VudGVyIG9mIHRoZSB2ZWN0b3JEb21cbiAgICAgKiBiYXNlZCBvbiB0aGUgYW5jaG9yLlxuICAgICAqL1xuICAgIGdldCBhbmNob3JPZmZzZXRWZWN0b3IoKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvck9mZnNldFZlY3RvciA9IG5ldyB2ZWN0b3JfMS5WZWN0b3IoLSh0aGlzLmFuY2hvclggKiB0aGlzLndpZHRoKSwgLSh0aGlzLmFuY2hvclkgKiB0aGlzLmhlaWdodCksIDApO1xuICAgICAgICByZXR1cm4gYW5jaG9yT2Zmc2V0VmVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZ2xvYmFsIGVsZW1lbnQgY2VudGVyIHBvc2l0aW9uLiAgVGhpcyBpcyB0aGUgeCx5IGluIHJlbGF0aW9uIHRvXG4gICAgICogdGhlIGN1cnJlbnQgd2luZG93IHZpZXcgdG8gdGhlIGNlbnRlciBvZiB0aGUgZWxlbWVudC4gICBJZiB0aGlzIHZhbHVlXG4gICAgICogaXMgMCwwLCB0aGUgXCJjZW50ZXJcIiBvZiB0aGUgZWxlbWVudCBpcyBhdCB0aGUgdG9wIGxlZnQgb2YgdGhlIHdpbmRvdy5cbiAgICAgKlxuICAgICAqIEluIHNob3J0LCB0aGlzIGlzIGFza2luZywgd2hlcmUgb24gdGhlIHNjcmVlbiBpcyB0aGUgY2VudGVyIGNvb3JkaW5hdGVzXG4gICAgICogb2YgdGhlIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0IGdsb2JhbEVsZW1lbnRDZW50ZXJQb3NpdGlvbigpIHtcbiAgICAgICAgY29uc3QgZyA9IHRoaXMuZ2xvYmFsUG9zaXRpb24uY2xvbmUoKTtcbiAgICAgICAgbGV0IGh3ID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIGxldCBoaCA9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgaWYgKHRoaXMudXNlQm91bmRzRm9yR2xvYmFsQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgICAgIGh3ID0gdGhpcy5ib3VuZHMud2lkdGggLyAyO1xuICAgICAgICAgICAgaGggPSB0aGlzLmJvdW5kcy5oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHggPSBnLnggKyBodztcbiAgICAgICAgY29uc3QgeSA9IGcueSArIGhoO1xuICAgICAgICByZXR1cm4gbmV3IHZlY3Rvcl8xLlZlY3Rvcih4LCB5LCB0aGlzLnBvc2l0aW9uLnopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZWxlbWVudCBib3VuZHMgaW5jbHVkaW5nIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodC4gV2F0Y2ggb3V0IGNhbGxpbmdcbiAgICAgKiB0aGlzIG9uIFJBRiBzaW5jZSBpdCBjYW4gY2F1c2UgbGF5b3V0IHRocmFzaGluZy4gIElmIHBvc3NpYmxlLFxuICAgICAqIHVzZSBvdGhlciB2YWx1ZXMgc2luY2UgdGhleSBhcmUgY2FjaGVkLiAgQ29uc2lkZXIgdXNpbmcgZ2xvYmFsUG9zaXRpb24gaW5zdGVhZFxuICAgICAqIHdoaWNoIGlzIG1vcmUgb3B0aW1pemVkLlxuICAgICAqXG4gICAgICogU2luY2UgdGhpcyBpcyB1c2luZyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBpdCBpcyB0aGVcbiAgICAgKiByZW5kZXJlZCB3aWR0aCAvIGhlaWdodCB2ZXJzdXMgYWN0dWFsLlxuICAgICAqL1xuICAgIGdldCBib3VuZHMoKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnQoKTtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYm91bmRpbmcgY2xpZW50IHJlY3QuIFRoZSBzY3JvbGxZLCB3aW5kb3cgd2lkdGggYW5kIGhlaWdodCBhcmVcbiAgICAgKiBwYXNzZWQgdG8gbWVtb2l6ZSByZXN1bHRzIGFuZCByZWV2YWx1YXRpb24gaGFwcGVucyB3aGVuIHRob3NlIHZhbHVlcyBoYXZlXG4gICAgICogY2hhbmdlZC5cbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ0NsaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gICAgc2V0T2Zmc2V0KHYpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHJvdGF0aW9uIHdpdGggYSBFdWxhciBkZWdyZWUgdmVjdG9yLiAgTm90ZSB0aGlzIG1ldGhvZCB3aWxsXG4gICAgICogb3ZlcndyaXRlIHRoZSBpbnRlcm5hbCBRdWF0ZXJuaW9uIHJvdGF0aW9uLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIHZlY3RvckRvbS5zZXRSb3RhdGlvbihuZXcgVmVjdG9yKDM2MCwgMCwgMCkpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB2XG4gICAgICovXG4gICAgc2V0Um90YXRpb24odikge1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gcXVhdGVybmlvbl8xLlF1YXRlcm5pb24uZnJvbUV1bGVyVmVjdG9yKHYpO1xuICAgICAgICB0aGlzLnN5bmNFdWxhclJvdGF0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlbGxzIFZlY3RvckRvbSB0byB1c2UgdGhlIGV1bGFyUm90YXRpb24gdmFsdWVzIGFuZCBvdmVycml0ZSB0aGUgaW50ZXJuYWxcbiAgICAgKiBRdWF0ZXJuaW9uIHJvdGF0aW9uICh3aGljaCBpcyB1bHRpbWF0ZWx5IHVzZWQgdG8gY2FsY3VsYXRlIGFuZCBnZW5lcmF0ZVxuICAgICAqIHRoZSByb3RhdGlvbmFsIG1hdHJpeC4pXG4gICAgICovXG4gICAgc3luY0V1bGFyUm90YXRpb24oKSB7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBxdWF0ZXJuaW9uXzEuUXVhdGVybmlvbi5mcm9tRXVsZXJWZWN0b3IodGhpcy5ldWxhclJvdGF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBzeW5jRXVsYXJSb3RhdGlvbiwgc3luY3MgYW5kIG92ZXJ3cml0ZXMgdGhlIHF1YXRlcm5pb25cbiAgICAgKiByb3RhdGlvbiBleGVjcHQgZG9lcyBpdCB3aXRoIGEgc2xlcnAuICBVc2UgaW4gcGxhY2Ugb2Ygc3luY0V1bGFyUm90YXRpb25cbiAgICAgKiBhbmQgYWRkIGEgc2xlcnAgYW1vdW50LlxuICAgICAqXG4gICAgICogSW4gcmFmIGxvb3A6XG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIHZlY3RvckRvbS5yeCArPSAxXG4gICAgICogdmVjdG9yRG9tLnNsZXJwRXVsYXJSb3RhdGlvbigwLjA4KTtcbiAgICAgKiAvLyBOb3RlIHdlIGRvbid0IHBhc3MgdHJ1ZSBoZXJlIHNpbmNlIHdlIGRvbid0IHdhbnQgdG8gc3luYy5cbiAgICAgKiB2ZWN0b3JEb20ucmVuZGVyKCk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gYW1vdW50IFRoZSBhbW91bnQgdG8gc2xlcnAuXG4gICAgICovXG4gICAgc2xlcnBFdWxhclJvdGF0aW9uKGFtb3VudCkge1xuICAgICAgICB0aGlzLnJvdGF0aW9uLnNsZXJwRXVsZXJWZWN0b3IodGhpcy5ldWxhclJvdGF0aW9uLCBhbW91bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgYSB6SW5kZXggb24gdGhpcyBWZWN0b3JEb20uICBOb3JtYWxseSwgekluZGV4IGlzIGF1dG8gY2FsY3VsYXRlZFxuICAgICAqIGJ5IFZlY3RvckRvbSBiYXNlZCBvbiB0aGUgZGVwdGggb2YgdGhlIG9iamVjdC4gIFRoaXMgYWxsb3dzIHlvdSB0b1xuICAgICAqIGZvcmNlIGEgZ2l2ZW4gekluZGV4LiAgUGFzcyBudWxsIHRvIHJlbGVhc2UgekluZGV4IGNvbnRyb2wgYmFjayB0b1xuICAgICAqIFZlY3RvckRvbS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKiB2ZWN0b3JEb20uZm9yY2VaSW5kZXgoMjApO1xuICAgICAqIHZlY3RvckRvbS5mb3JjZVpJbmRleChudWxsKTsgLy8gcmVsZWFzZSBjb250cm9sXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB6SW5kZXhcbiAgICAgKi9cbiAgICBmb3JjZVpJbmRleCh6SW5kZXgpIHtcbiAgICAgICAgdGhpcy5mb3JjZWRaSW5kZXggPSB6SW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2VzIHRoZSBjdXJyZW50IHBvc2l0aW9uIHgseSx6IHZlY3RvciBwb2ludHMgYW5kIGNvbnZlcnRzIGl0IG92ZXIgdG9cbiAgICAgKiBhIDR4NCBtYXRyaXggd2l0aCBqdXN0IGNvbnNpZGVyYXRpb24gZm9yIHRyYW5zbGF0aW9uLlxuICAgICAqIFtcbiAgICAgKiAgMCAwIDAgeFxuICAgICAqICAwIDAgMCB5XG4gICAgICogIDAgMCAwIHpcbiAgICAgKiAgMCAwIDAgMVxuICAgICAqIF1cbiAgICAgKlxuICAgICAqXG4gICAgICogRXhhbXBsZSBvZiBhcHBseWluZyB2ZWN0b3IgcG9zaXRpb25zIHRvIGRvbSBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgYSB2ZWN0b3JcbiAgICAgKiAgbGV0IGJhbGxQb3NpdGlvbiA9IG5ldyBWZWN0b3IoMTAwLCAyMDAsIDApO1xuICAgICAqXG4gICAgICpcbiAgICAgKiAvLyBUYWtlIHRob3NlIHZlY3RvciBwb3NpdGlvbnMgYW5kIGNvbnZlcnQgdGhhdCBpbnRvIGEgdHJhbnNsYXRpb24gbWF0cml4LlxuICAgICAqIGxldCBtYXRyaXggPSBiYWxsUG9zaXRpb24udG9UcmFuc2xhdGlvbk1hdHJpeElWKClcbiAgICAgKlxuICAgICAqIC8vIENvbnZlcnQgdGhhdCB0byBhIGNzcyAzZCB0cmFuc2xhdGlvbi5cbiAgICAgKiBsZXQgbXMgPSBtYXRyaXgudG9Dc3MzZE1hdHJpeCgpO1xuICAgICAqIGJhbGwuc3R5bGUudHJhbnNmb3JtID0gbXM7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge01hcnRyaXhJVn1cbiAgICAgKi9cbiAgICB0b1RyYW5zbGF0aW9uTWF0cml4SVYoKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uVmVjdG9yID0gdGhpcy5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgbWF0cml4SVZfMS5NYXRyaXhJVigpO1xuICAgICAgICBtYXRyaXguc2V0VmVjdG9yQ29sdW1uKDMsIHBvc2l0aW9uVmVjdG9yKTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgdGhlIHJvdGF0aW9uLCBzY2FsZSBhbmQgdHJhbnNsYXRpb24gbWF0cmljZXMgYW5kIGNvbWJpbmVzIHRoZW1cbiAgICAgKiBpbnRvIG9uZS5cbiAgICAgKi9cbiAgICB0b01hdHJpeElWKCkge1xuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbk1hdHJpeCA9IHRoaXMudG9UcmFuc2xhdGlvbk1hdHJpeElWKCk7XG4gICAgICAgIC8vIEFjY291bnQgZm9yIGFuY2hvciBvZmZzZXRzLlxuICAgICAgICBjb25zdCBhbmNob3JPZmZzZXRWZWN0b3IgPSBuZXcgdmVjdG9yXzEuVmVjdG9yKC0odGhpcy5hbmNob3JYICogdGhpcy53aWR0aCksIC0odGhpcy5hbmNob3JZICogdGhpcy5oZWlnaHQpLCAwKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0TWF0cml4ID0gbmV3IG1hdHJpeElWXzEuTWF0cml4SVYoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0VmVjdG9yID0gdGhpcy5vZmZzZXQuY2xvbmUoKS5hZGQoYW5jaG9yT2Zmc2V0VmVjdG9yKTtcbiAgICAgICAgb2Zmc2V0TWF0cml4LnNldFZlY3RvckNvbHVtbigzLCBvZmZzZXRWZWN0b3IpO1xuICAgICAgICAvLyBTY2FsZSBiYXNlZCBvbiB0aGUgeiBwb3NpdGlvbi5cbiAgICAgICAgY29uc3QgeiA9IG1hdGhmXzEubWF0aGYuY2xhbXAoLTEsIDEwLCB0aGlzLnBvc2l0aW9uLnogKyAxKTtcbiAgICAgICAgY29uc3Qgc2NhbGVNYXRyaXggPSBuZXcgbWF0cml4SVZfMS5NYXRyaXhJVigpLnNjYWxlWHl6KHosIHosIHopO1xuICAgICAgICBzY2FsZU1hdHJpeC52YWx1ZVsxNV0gPSAxO1xuICAgICAgICAvLyBEb24ndCB1c2UgWVBSIEV1bGFyIGJlY2F1c2Ugb2YgZ2ltYmxlIGxvY2sgdW5sZXNzIHJlYWxseSBuZWVkZWQuXG4gICAgICAgIGxldCByb3RhdGlvbk1hdHJpeDtcbiAgICAgICAgaWYgKHRoaXMuZXVsYXJSb3RhdGlvbkFzUm90YXRpb25NYXRyaXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhZGlhbkV1bGFyID0gdGhpcy5ldWxhclJvdGF0aW9uLmNsb25lKCkuZGVncmVlVG9SYWRpYW5zKCk7XG4gICAgICAgICAgICByb3RhdGlvbk1hdHJpeCA9IG5ldyBtYXRyaXhJVl8xLk1hdHJpeElWKCkueXByKC1yYWRpYW5FdWxhci55LCAtcmFkaWFuRXVsYXIueCwgcmFkaWFuRXVsYXIueik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3RhdGlvbk1hdHJpeCA9IG1hdHJpeElWXzEuTWF0cml4SVYuZnJvbVF1YXRlcm5pb24odGhpcy5yb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwbHkgU1JULlxuICAgICAgICBjb25zdCBiYXNlTWF0cml4ID0gbWF0cml4SVZfMS5NYXRyaXhJVi5JREVOVElUWS5tdWx0aXBseShzY2FsZU1hdHJpeClcbiAgICAgICAgICAgIC5tdWx0aXBseShyb3RhdGlvbk1hdHJpeClcbiAgICAgICAgICAgIC5tdWx0aXBseSh0cmFuc2xhdGlvbk1hdHJpeClcbiAgICAgICAgICAgIC5tdWx0aXBseShvZmZzZXRNYXRyaXgpO1xuICAgICAgICBpZiAoIXRoaXMucmVuZGVyV2l0aDNkUHJvamVjdE1hdHJpeCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VNYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gbmV3IG1hdHJpeElWXzEuTWF0cml4SVYoKS5wZXJzcGVjdGl2ZShtYXRoZl8xLm1hdGhmLmRlZ3JlZVRvUmFkaWFuKDkwKSwgMSwgLTEsIDEwMCk7XG4gICAgICAgICAgICBjb25zdCB2aWV3TWF0cml4ID0gbmV3IG1hdHJpeElWXzEuTWF0cml4SVYoKS5sb29rQXQobmV3IHZlY3Rvcl8xLlZlY3RvcigwLCAwLCAxKSwgbmV3IHZlY3Rvcl8xLlZlY3RvcigwLCAwLCAwKSwgdmVjdG9yXzEuVmVjdG9yLkRPV04pO1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3Rpb25NYXRyaXgubXVsdGlwbHkodmlld01hdHJpeCkubXVsdGlwbHkoYmFzZU1hdHJpeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9Dc3MzZE1hdHJpeCgpIHtcbiAgICAgICAgY29uc3QgbWF0cml4VmFsdWUgPSB0aGlzLnRvTWF0cml4SVYoKS50b0NzczNkTWF0cml4KCk7XG4gICAgICAgIHJldHVybiBtYXRyaXhWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgVmVjdG9yRG9tLlxuICAgICAqIEBwYXJhbSB7c3luY0V1bGFyUm90YXRpb259IFdoZXRoZXIgdG8gc3luYyB0aGUgZXVsYXIgcm90YXRpb24gb24gZWFjaFxuICAgICAqICAgcmVuZGVyLiAgRGVmYXVsdHMgdG8gdHJ1ZSBidXQgdHVybiBvZmYgaWYgeW91IHdhbnQgdG8gbWFuaXB1bGF0ZSB0aGVcbiAgICAgKiAgIGludGVybmFsIHF1YXRlcm5pb24gcm90YXRpb24uXG4gICAgICovXG4gICAgcmVuZGVyKHN5bmNFdWxhclJvdGF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHN5bmNFdWxhclJvdGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN5bmNFdWxhclJvdGF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcG9uZW50cyByZW5kZXIgb3V0IGZpcnN0LlxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1trZXldLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcG9zaXRpb24gYmFzZWQgb24gdmVsb2NpdHkgYW5kIGFjY2VsZXJhdGlvbi5cbiAgICAgICAgLy8gSGFzIG5vdCBlZmZlY3QgaWYgeW91IGp1c3QgZGlyZWN0bHkgdXBkYXRlIHRoZSBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy52ZWxvY2l0eS5lYXNlKHRoaXMuYWNjZWxlcmF0aW9uLCAxLCBlYXNlXzEuRUFTRS5saW5lYXIpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uLmFkZCh0aGlzLnZlbG9jaXR5KTtcbiAgICAgICAgY29uc3QgbWF0cml4VmFsdWUgPSB0aGlzLnRvQ3NzM2RNYXRyaXgoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJfKG1hdHJpeFZhbHVlLCB0aGlzLmFscGhhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgY3NzIHRyYW5zZm9ybSB0byB0aGlzIG9iamVjdC4gIFVubmVjY2VzYXJ5IGNhbGxzIGdldCBjdWxsZWQgYnlcbiAgICAgKiBmdW5jLnJ1bk9uY2VPbkNoYW5nZS5cbiAgICAgKi9cbiAgICByZW5kZXJfKHRyYW5zZm9ybSwgYWxwaGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZVN0eWxlUmVuZGVycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhpcyBlbGVtZW50IG9ubHkgd2hlbiBpdCBpcyBpbnZpZXcgZm9yIHBlcmZvcm1hbmNlIGJvb3N0LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMucmVuZGVyT25seVdoZW5JbnZpZXcgJiZcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudFZpc2liaWxpdHkuc3RhdGUoKS5yZWFkeSAmJlxuICAgICAgICAgICAgIXRoaXMuZWxlbWVudFZpc2liaWxpdHkuc3RhdGUoKS5pbnZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IGFscGhhICsgJyc7XG4gICAgICAgIGlmICghaXNfMS5pcy5udWxsKHRoaXMuZm9yY2VkWkluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnpJbmRleCA9IHRoaXMuZm9yY2VkWkluZGV4ICsgJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuekluZGV4ID1cbiAgICAgICAgICAgICAgICAoKHRoaXMuekluZGV4U2NhbGFyICogKHRoaXMucG9zaXRpb24ueiArIDEpKSA+PiAwKSArICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuY29tcG9uZW50cykge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW2tleV0uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2F0Y2hlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudFZpc2liaWxpdHkuZGlzcG9zZSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuVmVjdG9yRG9tID0gVmVjdG9yRG9tO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVjdG9yLWRvbS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/dom/vector-dom.js\n");

/***/ }),

/***/ "./lib/dom/video-player.js":
/*!*********************************!*\
  !*** ./lib/dom/video-player.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VideoPlayer = void 0;\nconst defer_1 = __webpack_require__(/*! ../func/defer */ \"./lib/func/defer.js\");\nconst func_1 = __webpack_require__(/*! ../func/func */ \"./lib/func/func.js\");\nconst dom_1 = __webpack_require__(/*! ../dom/dom */ \"./lib/dom/dom.js\");\nconst raf_1 = __webpack_require__(/*! ../raf/raf */ \"./lib/raf/raf.js\");\n/**\n * Utility class to handle playing / stopping / playing segments of\n * a given video element.\n *\n * ```ts\n * let video = document.getElementById('video');\n * let videoPlayer = new VideoPlayer(video, {\n *       rafCallback: ()=> {\n *           console.log(videoPlayer.getTime());\n *       }\n * });\n *\n * videoPlayer.load().then(()=> {\n *   console.log(\"loaded\");\n * })\n *\n *\n * videoPlayer.setPointer(1.2);\n * videoPlayer.play();\n * videoPlayer.pause();\n * videoPlayer.playToAndStop(4);\n * videoPlayer.playFrom(5,6);\n *\n * ```\n */\nclass VideoPlayer {\n    constructor(video, options) {\n        /**\n         * A stop queue.\n         */\n        this.stopQueue = null;\n        this.video = video;\n        if (!this.video) {\n            throw new Error('Oops, video is not found');\n        }\n        this.raf = new raf_1.Raf(this.onRaf.bind(this));\n        this.raf\n            .runWhenElementIsInview(this.video, {\n            rootMargin: '500px 0px 500px 0px',\n        })\n            .then(() => {\n            this.raf.start();\n        });\n        // Ensure we don't run into autoplay issues.\n        this.video.muted = true;\n        this.video.playsInline = true;\n        this.video.autoplay = false;\n        this.settingsData = {\n            ...{\n                loop: false,\n                rafCallback: null,\n            },\n            ...(options || {}),\n        };\n        this.videoReady = new defer_1.Defer();\n    }\n    /**\n     * Loads the video competely first.\n     * TODO (uxder): Look for a better way to check completely readyState of video\n     *     besides polling.\n     */\n    load() {\n        this.video.load();\n        if (this.video.readyState === 4) {\n            this.videoReady.resolve();\n        }\n        else {\n            func_1.func\n                .waitUntil(() => this.video.readyState === 4)\n                .then(() => {\n                this.videoReady.resolve();\n            });\n        }\n        return this.videoReady.getPromise();\n    }\n    /**\n     * Tests whether the video is currently playing.\n     */\n    isPlaying() {\n        return dom_1.dom.testVideoIsPlaying(this.video);\n    }\n    /**\n     * Pauses a video.  Does not reset the pointer.\n     *\n     * ```\n     * // Pause where it at.\n     * videoPlayer.pause();\n     *\n     * // Pauses and resets pointer to 0 mark.\n     * videoPlayer.pause();\n     * videoPlayer.reset();\n     * ```\n     */\n    pause() {\n        this.video.pause();\n    }\n    /**\n     * Resets the video to the start.\n     */\n    reset() {\n        this.video.currentTime = 0;\n    }\n    /**\n     * Plays a video from the current pointer.\n     */\n    play() {\n        if (!this.isPlaying()) {\n            const playPromise = this.video.play();\n            playPromise.then(() => { }).catch(() => { });\n        }\n    }\n    /**\n     * Sets the video currentTime to a specific position.\n     * @param seconds\n     */\n    setPointer(seconds) {\n        this.video.currentTime = seconds;\n    }\n    /**\n     * Starts playing from the current pointer and stops at a specific time.\n     * If the current time\n     */\n    playToAndStop(seconds) {\n        this.stopQueue = seconds;\n        this.play();\n    }\n    /**\n     * Plays a specific segment of the video.\n     * @param seconds\n     */\n    playFromTo(fromSeconds, toSeconds) {\n        this.setPointer(fromSeconds);\n        this.playToAndStop(toSeconds);\n    }\n    /**\n     * Gets the video element.\n     */\n    getVideo() {\n        return this.video;\n    }\n    /**\n     * Gets the current time.\n     */\n    getTime() {\n        return this.video.currentTime;\n    }\n    /**\n     * Internal clock to check status of video.  We could use\n     * timeupdate event on the video but it seems to be slow.\n     */\n    onRaf() {\n        this.settingsData.rafCallback && this.settingsData.rafCallback();\n        if (this.stopQueue && this.getTime() >= this.stopQueue) {\n            this.pause();\n            this.stopQueue = null;\n        }\n    }\n    /**\n     * Disposes the class.\n     */\n    dispose() {\n        this.raf.dispose();\n    }\n}\nexports.VideoPlayer = VideoPlayer;\n//# sourceMappingURL=video-player.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL3ZpZGVvLXBsYXllci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9kb20vdmlkZW8tcGxheWVyLmpzP2FlZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZpZGVvUGxheWVyID0gdm9pZCAwO1xuY29uc3QgZGVmZXJfMSA9IHJlcXVpcmUoXCIuLi9mdW5jL2RlZmVyXCIpO1xuY29uc3QgZnVuY18xID0gcmVxdWlyZShcIi4uL2Z1bmMvZnVuY1wiKTtcbmNvbnN0IGRvbV8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21cIik7XG5jb25zdCByYWZfMSA9IHJlcXVpcmUoXCIuLi9yYWYvcmFmXCIpO1xuLyoqXG4gKiBVdGlsaXR5IGNsYXNzIHRvIGhhbmRsZSBwbGF5aW5nIC8gc3RvcHBpbmcgLyBwbGF5aW5nIHNlZ21lbnRzIG9mXG4gKiBhIGdpdmVuIHZpZGVvIGVsZW1lbnQuXG4gKlxuICogYGBgdHNcbiAqIGxldCB2aWRlbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aWRlbycpO1xuICogbGV0IHZpZGVvUGxheWVyID0gbmV3IFZpZGVvUGxheWVyKHZpZGVvLCB7XG4gKiAgICAgICByYWZDYWxsYmFjazogKCk9PiB7XG4gKiAgICAgICAgICAgY29uc29sZS5sb2codmlkZW9QbGF5ZXIuZ2V0VGltZSgpKTtcbiAqICAgICAgIH1cbiAqIH0pO1xuICpcbiAqIHZpZGVvUGxheWVyLmxvYWQoKS50aGVuKCgpPT4ge1xuICogICBjb25zb2xlLmxvZyhcImxvYWRlZFwiKTtcbiAqIH0pXG4gKlxuICpcbiAqIHZpZGVvUGxheWVyLnNldFBvaW50ZXIoMS4yKTtcbiAqIHZpZGVvUGxheWVyLnBsYXkoKTtcbiAqIHZpZGVvUGxheWVyLnBhdXNlKCk7XG4gKiB2aWRlb1BsYXllci5wbGF5VG9BbmRTdG9wKDQpO1xuICogdmlkZW9QbGF5ZXIucGxheUZyb20oNSw2KTtcbiAqXG4gKiBgYGBcbiAqL1xuY2xhc3MgVmlkZW9QbGF5ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZGVvLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHN0b3AgcXVldWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BRdWV1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmlkZW8gPSB2aWRlbztcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09vcHMsIHZpZGVvIGlzIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmFmID0gbmV3IHJhZl8xLlJhZih0aGlzLm9uUmFmLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnJhZlxuICAgICAgICAgICAgLnJ1bldoZW5FbGVtZW50SXNJbnZpZXcodGhpcy52aWRlbywge1xuICAgICAgICAgICAgcm9vdE1hcmdpbjogJzUwMHB4IDBweCA1MDBweCAwcHgnLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBydW4gaW50byBhdXRvcGxheSBpc3N1ZXMuXG4gICAgICAgIHRoaXMudmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnZpZGVvLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aWRlby5hdXRvcGxheSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldHRpbmdzRGF0YSA9IHtcbiAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICBsb29wOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByYWZDYWxsYmFjazogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi4ob3B0aW9ucyB8fCB7fSksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudmlkZW9SZWFkeSA9IG5ldyBkZWZlcl8xLkRlZmVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSB2aWRlbyBjb21wZXRlbHkgZmlyc3QuXG4gICAgICogVE9ETyAodXhkZXIpOiBMb29rIGZvciBhIGJldHRlciB3YXkgdG8gY2hlY2sgY29tcGxldGVseSByZWFkeVN0YXRlIG9mIHZpZGVvXG4gICAgICogICAgIGJlc2lkZXMgcG9sbGluZy5cbiAgICAgKi9cbiAgICBsb2FkKCkge1xuICAgICAgICB0aGlzLnZpZGVvLmxvYWQoKTtcbiAgICAgICAgaWYgKHRoaXMudmlkZW8ucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgdGhpcy52aWRlb1JlYWR5LnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZ1bmNfMS5mdW5jXG4gICAgICAgICAgICAgICAgLndhaXRVbnRpbCgoKSA9PiB0aGlzLnZpZGVvLnJlYWR5U3RhdGUgPT09IDQpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9SZWFkeS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aWRlb1JlYWR5LmdldFByb21pc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdHMgd2hldGhlciB0aGUgdmlkZW8gaXMgY3VycmVudGx5IHBsYXlpbmcuXG4gICAgICovXG4gICAgaXNQbGF5aW5nKCkge1xuICAgICAgICByZXR1cm4gZG9tXzEuZG9tLnRlc3RWaWRlb0lzUGxheWluZyh0aGlzLnZpZGVvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2VzIGEgdmlkZW8uICBEb2VzIG5vdCByZXNldCB0aGUgcG9pbnRlci5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIC8vIFBhdXNlIHdoZXJlIGl0IGF0LlxuICAgICAqIHZpZGVvUGxheWVyLnBhdXNlKCk7XG4gICAgICpcbiAgICAgKiAvLyBQYXVzZXMgYW5kIHJlc2V0cyBwb2ludGVyIHRvIDAgbWFyay5cbiAgICAgKiB2aWRlb1BsYXllci5wYXVzZSgpO1xuICAgICAqIHZpZGVvUGxheWVyLnJlc2V0KCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMudmlkZW8ucGF1c2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSB2aWRlbyB0byB0aGUgc3RhcnQuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMudmlkZW8uY3VycmVudFRpbWUgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGF5cyBhIHZpZGVvIGZyb20gdGhlIGN1cnJlbnQgcG9pbnRlci5cbiAgICAgKi9cbiAgICBwbGF5KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNQbGF5aW5nKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsYXlQcm9taXNlID0gdGhpcy52aWRlby5wbGF5KCk7XG4gICAgICAgICAgICBwbGF5UHJvbWlzZS50aGVuKCgpID0+IHsgfSkuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aWRlbyBjdXJyZW50VGltZSB0byBhIHNwZWNpZmljIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSBzZWNvbmRzXG4gICAgICovXG4gICAgc2V0UG9pbnRlcihzZWNvbmRzKSB7XG4gICAgICAgIHRoaXMudmlkZW8uY3VycmVudFRpbWUgPSBzZWNvbmRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgcGxheWluZyBmcm9tIHRoZSBjdXJyZW50IHBvaW50ZXIgYW5kIHN0b3BzIGF0IGEgc3BlY2lmaWMgdGltZS5cbiAgICAgKiBJZiB0aGUgY3VycmVudCB0aW1lXG4gICAgICovXG4gICAgcGxheVRvQW5kU3RvcChzZWNvbmRzKSB7XG4gICAgICAgIHRoaXMuc3RvcFF1ZXVlID0gc2Vjb25kcztcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBsYXlzIGEgc3BlY2lmaWMgc2VnbWVudCBvZiB0aGUgdmlkZW8uXG4gICAgICogQHBhcmFtIHNlY29uZHNcbiAgICAgKi9cbiAgICBwbGF5RnJvbVRvKGZyb21TZWNvbmRzLCB0b1NlY29uZHMpIHtcbiAgICAgICAgdGhpcy5zZXRQb2ludGVyKGZyb21TZWNvbmRzKTtcbiAgICAgICAgdGhpcy5wbGF5VG9BbmRTdG9wKHRvU2Vjb25kcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZGVvIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0VmlkZW8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZGVvO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgICovXG4gICAgZ2V0VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW8uY3VycmVudFRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGNsb2NrIHRvIGNoZWNrIHN0YXR1cyBvZiB2aWRlby4gIFdlIGNvdWxkIHVzZVxuICAgICAqIHRpbWV1cGRhdGUgZXZlbnQgb24gdGhlIHZpZGVvIGJ1dCBpdCBzZWVtcyB0byBiZSBzbG93LlxuICAgICAqL1xuICAgIG9uUmFmKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzRGF0YS5yYWZDYWxsYmFjayAmJiB0aGlzLnNldHRpbmdzRGF0YS5yYWZDYWxsYmFjaygpO1xuICAgICAgICBpZiAodGhpcy5zdG9wUXVldWUgJiYgdGhpcy5nZXRUaW1lKCkgPj0gdGhpcy5zdG9wUXVldWUpIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcFF1ZXVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgY2xhc3MuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5yYWYuZGlzcG9zZSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuVmlkZW9QbGF5ZXIgPSBWaWRlb1BsYXllcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZGVvLXBsYXllci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/dom/video-player.js\n");

/***/ }),

/***/ "./lib/dom/video-progress.js":
/*!***********************************!*\
  !*** ./lib/dom/video-progress.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VideoProgress = void 0;\nconst defer_1 = __webpack_require__(/*! ../func/defer */ \"./lib/func/defer.js\");\nconst func_1 = __webpack_require__(/*! ../func/func */ \"./lib/func/func.js\");\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\n/**\n * VideoProgress is a class that allows you to quick seek videos.\n * Note that this is a HIGHLY experimental class and it generally only works\n * well for small size mp4 on Chrome and Safari (desktop).  It totally janks on Firefox.\n * See /examples/playground video progress for a sample.\n *\n * @experimental\n * @unstable\n * @hidden\n */\nclass VideoProgress {\n    constructor(video) {\n        this.video = video;\n        // Ensure we don't run into autoplay issues.\n        this.video.muted = true;\n        this.video.playsInline = true;\n        this.video.autoplay = false;\n        this.videoReady = new defer_1.Defer();\n    }\n    /**\n     * Loads the video competely first.\n     * TODO (uxder): Look for a better way to check completely readyState of video\n     *     besides polling.\n     */\n    load() {\n        this.video.load();\n        if (this.video.readyState === 4) {\n            this.videoReady.resolve();\n        }\n        else {\n            func_1.func\n                .waitUntil(() => this.video.readyState === 4)\n                .then(() => {\n                this.videoReady.resolve();\n            });\n        }\n        return this.videoReady.getPromise();\n    }\n    setProgress(progress) {\n        const interpolatedTime = mathf_1.mathf.lerp(0, this.video.duration, progress);\n        // this.video.pause();\n        // if (this.video['fastSeek']) {\n        // this.video['fastSeek'](interpolatedTime);\n        // } else {\n        if (interpolatedTime) {\n            this.video.currentTime = interpolatedTime;\n        }\n        // }\n    }\n}\nexports.VideoProgress = VideoProgress;\n//# sourceMappingURL=video-progress.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL3ZpZGVvLXByb2dyZXNzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2RvbS92aWRlby1wcm9ncmVzcy5qcz8yYWZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WaWRlb1Byb2dyZXNzID0gdm9pZCAwO1xuY29uc3QgZGVmZXJfMSA9IHJlcXVpcmUoXCIuLi9mdW5jL2RlZmVyXCIpO1xuY29uc3QgZnVuY18xID0gcmVxdWlyZShcIi4uL2Z1bmMvZnVuY1wiKTtcbmNvbnN0IG1hdGhmXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvbWF0aGZcIik7XG4vKipcbiAqIFZpZGVvUHJvZ3Jlc3MgaXMgYSBjbGFzcyB0aGF0IGFsbG93cyB5b3UgdG8gcXVpY2sgc2VlayB2aWRlb3MuXG4gKiBOb3RlIHRoYXQgdGhpcyBpcyBhIEhJR0hMWSBleHBlcmltZW50YWwgY2xhc3MgYW5kIGl0IGdlbmVyYWxseSBvbmx5IHdvcmtzXG4gKiB3ZWxsIGZvciBzbWFsbCBzaXplIG1wNCBvbiBDaHJvbWUgYW5kIFNhZmFyaSAoZGVza3RvcCkuICBJdCB0b3RhbGx5IGphbmtzIG9uIEZpcmVmb3guXG4gKiBTZWUgL2V4YW1wbGVzL3BsYXlncm91bmQgdmlkZW8gcHJvZ3Jlc3MgZm9yIGEgc2FtcGxlLlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqIEB1bnN0YWJsZVxuICogQGhpZGRlblxuICovXG5jbGFzcyBWaWRlb1Byb2dyZXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWRlbykge1xuICAgICAgICB0aGlzLnZpZGVvID0gdmlkZW87XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBydW4gaW50byBhdXRvcGxheSBpc3N1ZXMuXG4gICAgICAgIHRoaXMudmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnZpZGVvLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aWRlby5hdXRvcGxheSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpZGVvUmVhZHkgPSBuZXcgZGVmZXJfMS5EZWZlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgdmlkZW8gY29tcGV0ZWx5IGZpcnN0LlxuICAgICAqIFRPRE8gKHV4ZGVyKTogTG9vayBmb3IgYSBiZXR0ZXIgd2F5IHRvIGNoZWNrIGNvbXBsZXRlbHkgcmVhZHlTdGF0ZSBvZiB2aWRlb1xuICAgICAqICAgICBiZXNpZGVzIHBvbGxpbmcuXG4gICAgICovXG4gICAgbG9hZCgpIHtcbiAgICAgICAgdGhpcy52aWRlby5sb2FkKCk7XG4gICAgICAgIGlmICh0aGlzLnZpZGVvLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9SZWFkeS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmdW5jXzEuZnVuY1xuICAgICAgICAgICAgICAgIC53YWl0VW50aWwoKCkgPT4gdGhpcy52aWRlby5yZWFkeVN0YXRlID09PSA0KVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvUmVhZHkucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9SZWFkeS5nZXRQcm9taXNlKCk7XG4gICAgfVxuICAgIHNldFByb2dyZXNzKHByb2dyZXNzKSB7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRlZFRpbWUgPSBtYXRoZl8xLm1hdGhmLmxlcnAoMCwgdGhpcy52aWRlby5kdXJhdGlvbiwgcHJvZ3Jlc3MpO1xuICAgICAgICAvLyB0aGlzLnZpZGVvLnBhdXNlKCk7XG4gICAgICAgIC8vIGlmICh0aGlzLnZpZGVvWydmYXN0U2VlayddKSB7XG4gICAgICAgIC8vIHRoaXMudmlkZW9bJ2Zhc3RTZWVrJ10oaW50ZXJwb2xhdGVkVGltZSk7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZWRUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLnZpZGVvLmN1cnJlbnRUaW1lID0gaW50ZXJwb2xhdGVkVGltZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB9XG4gICAgfVxufVxuZXhwb3J0cy5WaWRlb1Byb2dyZXNzID0gVmlkZW9Qcm9ncmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZGVvLXByb2dyZXNzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/dom/video-progress.js\n");

/***/ }),

/***/ "./lib/dom/web-worker.js":
/*!*******************************!*\
  !*** ./lib/dom/web-worker.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebWorker = void 0;\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * A class that makes it really easy to work with web workers.\n *\n * This implementation limits your workers to just 1 parameter so it recommended\n * to use an object as your parameter.\n *\n * Your worker function should return some result (any type).\n *\n * You can create one time workers or work with the same worker.\n *\n * 1) One time workers\n *\n * Every time you call [[WebWorker.runOneTimeThrowAwayWorker]], it will create a\n * new ONE time worker that self terminates upon completion.\n *\n * This is very useful in spawning multiple processes that all work at once.\n * Each worker will run async and will resolve a promise when done.\n *\n * If you want to do many different calculations at once, a one time worker\n * might be the way.\n *\n * 2) Use the same worker.\n *\n * Calling [[WebWorker.run]] will run a webworker.\n * Calling it again, will run the same worker.  Note that if you make\n * make two calls to the same worker in sequence before the webworker can\n * resolve the first call, it will only response to the second call.\n *\n *\n *\n * There are some limitations / conventions in using this class.   Please\n * see the below.\n * ```ts\n *\n * // Create a web worker task function.\n * //\n * // Limitation 1:\n * // Note that task functon, actually ends up getting stringified\n * // (important), bundled and sent to a separate thread.  Trying to execute\n * // imported clases won't work. Consider the function being sandboxed in it's\n * // own world.\n * //\n * // Limitaton 2:\n * // It's a web worker function.  Workers have limitations like not being\n * // able to access the DOM.\n * // See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API#Web_Workers_concepts_and_usage for more.\n * //\n * // Limitation 3:\n * // The function should accept only 1 parameter AND it must be named \"params\"\n * // by convention.  You can send any parameters up as an object.  This is done\n * // as a convention and to make it easier to wrap up.  See [[WebWorker]] for\n * // more.\n * var task = (params)=> {\n *    return params.a + params.b;\n * }\n *\n *\n * // Now create an instance of WebWorker and set the task.\n * var worker = new WebWorker(task);\n *\n *\n * // Create two one time workers that run in parallel.\n * worker.runOneTimeThrowAwayWorker({a: 2, b: 3}).then((result)=> {\n *   console.log(result); // 5\n * })\n * worker.runOneTimeThrowAwayWorker({ a: 5, b: 5}).then((result)=> {\n *   console.log(result); // 10\n * })\n *\n *\n * // Reusing the same worker.\n * await worker.run({a: 6, b:10});\n * await worker.run({a:4, b:10});\n *\n * // Kill the worker\n * worker.terminate();\n * ```\n *\n * @unstable\n * @experimental\n */\nclass WebWorker {\n    constructor(workerTask) {\n        // Prepare the worker code as a string.\n        this.worker = null;\n        this.workerTask = workerTask;\n        this.workerTaskAsString = this.workerTask.toString();\n        this.workerTaskAsString = this.formatTask(this.workerTaskAsString);\n        this.codeToRun = `\n            self.addEventListener('message', function(event) {\n                let params = event.data;\n                let result = 'No result was generated.';\n                result = function(params) { ${this.workerTaskAsString} }(params);\n                self.postMessage({ result: result });\n                // close();\n            })\n         `;\n        // The raw string of the actual code this is going to run.\n        // console.log(this.codeToRun);\n    }\n    /**\n     * Strip out the start and end of the function string.  This formats\n     * a stringified function so it's ready to be a web worker.\n     * @param task\n     */\n    formatTask(task) {\n        return task.substring(task.indexOf('{') + 1, task.lastIndexOf('}'));\n    }\n    /**\n     * Create an instance of a Worker and sends out the message with the\n     * params. Resolves the promise when results come in.\n     *\n     * Note that each time you call this method, a new Worker is created.\n     * The Worker is terminated as soon as it resolves so it can be considered\n     * a one time worker..\n     * @param paramsToSend\n     * @param transfer.  An optional array of transferable objects.\n     *     https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage\n     *     for more.\n     */\n    runOneTimeThrowAwayWorker(paramsToSend, transfer) {\n        return new Promise((resolve, reject) => {\n            const blob = new Blob([this.codeToRun], { type: 'application/javascript' });\n            const blobUrl = URL.createObjectURL(blob);\n            const worker = new Worker(blobUrl);\n            URL.revokeObjectURL(blobUrl);\n            worker.postMessage(paramsToSend, transfer);\n            worker.onerror = (event) => {\n                reject(event);\n                worker.terminate();\n            };\n            worker.onmessage = (event) => {\n                resolve(event.data.result);\n                worker.terminate();\n            };\n        });\n    }\n    run(paramsToSend, transfer) {\n        return new Promise((resolve, reject) => {\n            if (!this.worker) {\n                const blob = new Blob([this.codeToRun], {\n                    type: 'application/javascript',\n                });\n                const blobUrl = URL.createObjectURL(blob);\n                this.worker = new Worker(blobUrl);\n            }\n            // URL.revokeObjectURL(blobUrl);\n            this.worker.postMessage(paramsToSend, transfer);\n            this.worker.onerror = (event) => {\n                reject(event);\n            };\n            this.worker.onmessage = (event) => {\n                resolve(event.data.result);\n            };\n        });\n    }\n    terminate() {\n        this.worker && this.worker.terminate();\n    }\n}\nexports.WebWorker = WebWorker;\n/* eslint-enable */\n//# sourceMappingURL=web-worker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL3dlYi13b3JrZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL3dlYi13b3JrZXIuanM/Y2Q5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViV29ya2VyID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gd29yayB3aXRoIHdlYiB3b3JrZXJzLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gbGltaXRzIHlvdXIgd29ya2VycyB0byBqdXN0IDEgcGFyYW1ldGVyIHNvIGl0IHJlY29tbWVuZGVkXG4gKiB0byB1c2UgYW4gb2JqZWN0IGFzIHlvdXIgcGFyYW1ldGVyLlxuICpcbiAqIFlvdXIgd29ya2VyIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gc29tZSByZXN1bHQgKGFueSB0eXBlKS5cbiAqXG4gKiBZb3UgY2FuIGNyZWF0ZSBvbmUgdGltZSB3b3JrZXJzIG9yIHdvcmsgd2l0aCB0aGUgc2FtZSB3b3JrZXIuXG4gKlxuICogMSkgT25lIHRpbWUgd29ya2Vyc1xuICpcbiAqIEV2ZXJ5IHRpbWUgeW91IGNhbGwgW1tXZWJXb3JrZXIucnVuT25lVGltZVRocm93QXdheVdvcmtlcl1dLCBpdCB3aWxsIGNyZWF0ZSBhXG4gKiBuZXcgT05FIHRpbWUgd29ya2VyIHRoYXQgc2VsZiB0ZXJtaW5hdGVzIHVwb24gY29tcGxldGlvbi5cbiAqXG4gKiBUaGlzIGlzIHZlcnkgdXNlZnVsIGluIHNwYXduaW5nIG11bHRpcGxlIHByb2Nlc3NlcyB0aGF0IGFsbCB3b3JrIGF0IG9uY2UuXG4gKiBFYWNoIHdvcmtlciB3aWxsIHJ1biBhc3luYyBhbmQgd2lsbCByZXNvbHZlIGEgcHJvbWlzZSB3aGVuIGRvbmUuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gZG8gbWFueSBkaWZmZXJlbnQgY2FsY3VsYXRpb25zIGF0IG9uY2UsIGEgb25lIHRpbWUgd29ya2VyXG4gKiBtaWdodCBiZSB0aGUgd2F5LlxuICpcbiAqIDIpIFVzZSB0aGUgc2FtZSB3b3JrZXIuXG4gKlxuICogQ2FsbGluZyBbW1dlYldvcmtlci5ydW5dXSB3aWxsIHJ1biBhIHdlYndvcmtlci5cbiAqIENhbGxpbmcgaXQgYWdhaW4sIHdpbGwgcnVuIHRoZSBzYW1lIHdvcmtlci4gIE5vdGUgdGhhdCBpZiB5b3UgbWFrZVxuICogbWFrZSB0d28gY2FsbHMgdG8gdGhlIHNhbWUgd29ya2VyIGluIHNlcXVlbmNlIGJlZm9yZSB0aGUgd2Vid29ya2VyIGNhblxuICogcmVzb2x2ZSB0aGUgZmlyc3QgY2FsbCwgaXQgd2lsbCBvbmx5IHJlc3BvbnNlIHRvIHRoZSBzZWNvbmQgY2FsbC5cbiAqXG4gKlxuICpcbiAqIFRoZXJlIGFyZSBzb21lIGxpbWl0YXRpb25zIC8gY29udmVudGlvbnMgaW4gdXNpbmcgdGhpcyBjbGFzcy4gICBQbGVhc2VcbiAqIHNlZSB0aGUgYmVsb3cuXG4gKiBgYGB0c1xuICpcbiAqIC8vIENyZWF0ZSBhIHdlYiB3b3JrZXIgdGFzayBmdW5jdGlvbi5cbiAqIC8vXG4gKiAvLyBMaW1pdGF0aW9uIDE6XG4gKiAvLyBOb3RlIHRoYXQgdGFzayBmdW5jdG9uLCBhY3R1YWxseSBlbmRzIHVwIGdldHRpbmcgc3RyaW5naWZpZWRcbiAqIC8vIChpbXBvcnRhbnQpLCBidW5kbGVkIGFuZCBzZW50IHRvIGEgc2VwYXJhdGUgdGhyZWFkLiAgVHJ5aW5nIHRvIGV4ZWN1dGVcbiAqIC8vIGltcG9ydGVkIGNsYXNlcyB3b24ndCB3b3JrLiBDb25zaWRlciB0aGUgZnVuY3Rpb24gYmVpbmcgc2FuZGJveGVkIGluIGl0J3NcbiAqIC8vIG93biB3b3JsZC5cbiAqIC8vXG4gKiAvLyBMaW1pdGF0b24gMjpcbiAqIC8vIEl0J3MgYSB3ZWIgd29ya2VyIGZ1bmN0aW9uLiAgV29ya2VycyBoYXZlIGxpbWl0YXRpb25zIGxpa2Ugbm90IGJlaW5nXG4gKiAvLyBhYmxlIHRvIGFjY2VzcyB0aGUgRE9NLlxuICogLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfV29ya2Vyc19BUEkjV2ViX1dvcmtlcnNfY29uY2VwdHNfYW5kX3VzYWdlIGZvciBtb3JlLlxuICogLy9cbiAqIC8vIExpbWl0YXRpb24gMzpcbiAqIC8vIFRoZSBmdW5jdGlvbiBzaG91bGQgYWNjZXB0IG9ubHkgMSBwYXJhbWV0ZXIgQU5EIGl0IG11c3QgYmUgbmFtZWQgXCJwYXJhbXNcIlxuICogLy8gYnkgY29udmVudGlvbi4gIFlvdSBjYW4gc2VuZCBhbnkgcGFyYW1ldGVycyB1cCBhcyBhbiBvYmplY3QuICBUaGlzIGlzIGRvbmVcbiAqIC8vIGFzIGEgY29udmVudGlvbiBhbmQgdG8gbWFrZSBpdCBlYXNpZXIgdG8gd3JhcCB1cC4gIFNlZSBbW1dlYldvcmtlcl1dIGZvclxuICogLy8gbW9yZS5cbiAqIHZhciB0YXNrID0gKHBhcmFtcyk9PiB7XG4gKiAgICByZXR1cm4gcGFyYW1zLmEgKyBwYXJhbXMuYjtcbiAqIH1cbiAqXG4gKlxuICogLy8gTm93IGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBXZWJXb3JrZXIgYW5kIHNldCB0aGUgdGFzay5cbiAqIHZhciB3b3JrZXIgPSBuZXcgV2ViV29ya2VyKHRhc2spO1xuICpcbiAqXG4gKiAvLyBDcmVhdGUgdHdvIG9uZSB0aW1lIHdvcmtlcnMgdGhhdCBydW4gaW4gcGFyYWxsZWwuXG4gKiB3b3JrZXIucnVuT25lVGltZVRocm93QXdheVdvcmtlcih7YTogMiwgYjogM30pLnRoZW4oKHJlc3VsdCk9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHJlc3VsdCk7IC8vIDVcbiAqIH0pXG4gKiB3b3JrZXIucnVuT25lVGltZVRocm93QXdheVdvcmtlcih7IGE6IDUsIGI6IDV9KS50aGVuKChyZXN1bHQpPT4ge1xuICogICBjb25zb2xlLmxvZyhyZXN1bHQpOyAvLyAxMFxuICogfSlcbiAqXG4gKlxuICogLy8gUmV1c2luZyB0aGUgc2FtZSB3b3JrZXIuXG4gKiBhd2FpdCB3b3JrZXIucnVuKHthOiA2LCBiOjEwfSk7XG4gKiBhd2FpdCB3b3JrZXIucnVuKHthOjQsIGI6MTB9KTtcbiAqXG4gKiAvLyBLaWxsIHRoZSB3b3JrZXJcbiAqIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAqIGBgYFxuICpcbiAqIEB1bnN0YWJsZVxuICogQGV4cGVyaW1lbnRhbFxuICovXG5jbGFzcyBXZWJXb3JrZXIge1xuICAgIGNvbnN0cnVjdG9yKHdvcmtlclRhc2spIHtcbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgd29ya2VyIGNvZGUgYXMgYSBzdHJpbmcuXG4gICAgICAgIHRoaXMud29ya2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy53b3JrZXJUYXNrID0gd29ya2VyVGFzaztcbiAgICAgICAgdGhpcy53b3JrZXJUYXNrQXNTdHJpbmcgPSB0aGlzLndvcmtlclRhc2sudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy53b3JrZXJUYXNrQXNTdHJpbmcgPSB0aGlzLmZvcm1hdFRhc2sodGhpcy53b3JrZXJUYXNrQXNTdHJpbmcpO1xuICAgICAgICB0aGlzLmNvZGVUb1J1biA9IGBcbiAgICAgICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICdObyByZXN1bHQgd2FzIGdlbmVyYXRlZC4nO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmN0aW9uKHBhcmFtcykgeyAke3RoaXMud29ya2VyVGFza0FzU3RyaW5nfSB9KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHJlc3VsdDogcmVzdWx0IH0pO1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgYDtcbiAgICAgICAgLy8gVGhlIHJhdyBzdHJpbmcgb2YgdGhlIGFjdHVhbCBjb2RlIHRoaXMgaXMgZ29pbmcgdG8gcnVuLlxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmNvZGVUb1J1bik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmlwIG91dCB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgZnVuY3Rpb24gc3RyaW5nLiAgVGhpcyBmb3JtYXRzXG4gICAgICogYSBzdHJpbmdpZmllZCBmdW5jdGlvbiBzbyBpdCdzIHJlYWR5IHRvIGJlIGEgd2ViIHdvcmtlci5cbiAgICAgKiBAcGFyYW0gdGFza1xuICAgICAqL1xuICAgIGZvcm1hdFRhc2sodGFzaykge1xuICAgICAgICByZXR1cm4gdGFzay5zdWJzdHJpbmcodGFzay5pbmRleE9mKCd7JykgKyAxLCB0YXNrLmxhc3RJbmRleE9mKCd9JykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYSBXb3JrZXIgYW5kIHNlbmRzIG91dCB0aGUgbWVzc2FnZSB3aXRoIHRoZVxuICAgICAqIHBhcmFtcy4gUmVzb2x2ZXMgdGhlIHByb21pc2Ugd2hlbiByZXN1bHRzIGNvbWUgaW4uXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgZWFjaCB0aW1lIHlvdSBjYWxsIHRoaXMgbWV0aG9kLCBhIG5ldyBXb3JrZXIgaXMgY3JlYXRlZC5cbiAgICAgKiBUaGUgV29ya2VyIGlzIHRlcm1pbmF0ZWQgYXMgc29vbiBhcyBpdCByZXNvbHZlcyBzbyBpdCBjYW4gYmUgY29uc2lkZXJlZFxuICAgICAqIGEgb25lIHRpbWUgd29ya2VyLi5cbiAgICAgKiBAcGFyYW0gcGFyYW1zVG9TZW5kXG4gICAgICogQHBhcmFtIHRyYW5zZmVyLiAgQW4gb3B0aW9uYWwgYXJyYXkgb2YgdHJhbnNmZXJhYmxlIG9iamVjdHMuXG4gICAgICogICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Xb3JrZXIvcG9zdE1lc3NhZ2VcbiAgICAgKiAgICAgZm9yIG1vcmUuXG4gICAgICovXG4gICAgcnVuT25lVGltZVRocm93QXdheVdvcmtlcihwYXJhbXNUb1NlbmQsIHRyYW5zZmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW3RoaXMuY29kZVRvUnVuXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSk7XG4gICAgICAgICAgICBjb25zdCBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVybCk7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVcmwpO1xuICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHBhcmFtc1RvU2VuZCwgdHJhbnNmZXIpO1xuICAgICAgICAgICAgd29ya2VyLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQpO1xuICAgICAgICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3b3JrZXIub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShldmVudC5kYXRhLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJ1bihwYXJhbXNUb1NlbmQsIHRyYW5zZmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFt0aGlzLmNvZGVUb1J1bl0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2JVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgICAgIHRoaXMud29ya2VyID0gbmV3IFdvcmtlcihibG9iVXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVybCk7XG4gICAgICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShwYXJhbXNUb1NlbmQsIHRyYW5zZmVyKTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQuZGF0YS5yZXN1bHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRlcm1pbmF0ZSgpIHtcbiAgICAgICAgdGhpcy53b3JrZXIgJiYgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJXb3JrZXIgPSBXZWJXb3JrZXI7XG4vKiBlc2xpbnQtZW5hYmxlICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWItd29ya2VyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/dom/web-worker.js\n");

/***/ }),

/***/ "./lib/dom/webgl-image-sequence.js":
/*!*****************************************!*\
  !*** ./lib/dom/webgl-image-sequence.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebGlImageSequence = exports.WebGlImageSequenceErrors = exports.vertShader = exports.fragShader = void 0;\nconst dom_1 = __webpack_require__(/*! ../dom/dom */ \"./lib/dom/dom.js\");\nconst is_1 = __webpack_require__(/*! ../is/is */ \"./lib/is/is.js\");\nconst func_1 = __webpack_require__(/*! ../func/func */ \"./lib/func/func.js\");\nconst defer_1 = __webpack_require__(/*! ../func/defer */ \"./lib/func/defer.js\");\nconst blob_loader_1 = __webpack_require__(/*! ../loader/blob-loader */ \"./lib/loader/blob-loader.js\");\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst dom_watcher_1 = __webpack_require__(/*! ../dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\nconst multi_interpolate_1 = __webpack_require__(/*! ../interpolate/multi-interpolate */ \"./lib/interpolate/multi-interpolate.js\");\nconst raf_timer_1 = __webpack_require__(/*! ../raf/raf-timer */ \"./lib/raf/raf-timer.js\");\nconst fps_1 = __webpack_require__(/*! ../time/fps */ \"./lib/time/fps.js\");\nconst webgl_1 = __webpack_require__(/*! ../dom/webgl */ \"./lib/dom/webgl.js\");\nexports.fragShader = `\n    precision mediump float;\n    uniform sampler2D u_image;\n    // texCoords passed in from the vertex shader.\n    varying vec2 v_texCoord;\n    void main() {\n      gl_FragColor = texture2D(u_image, v_texCoord);\n    }\n`;\nexports.vertShader = `\n    attribute vec2 a_position;\n    uniform mat3 u_matrix;\n    varying vec2 v_texCoord;\n    void main() {\n      gl_Position = vec4(u_matrix * vec3(a_position, 1), 1);\n      v_texCoord = a_position;\n    }\n`;\nexports.WebGlImageSequenceErrors = {\n    NO_ELEMENT: 'An element is required for webgl image sequence',\n    NO_IMAGE_SETS: 'Image sets are required for webgl image sequence',\n    NO_IMAGES: 'There are no images defined in your webgl image sequence image set',\n};\n/**\n * A class that allows you to play through an image sequence (sprite) based on\n * progress.  This class is similar to canvas-image-sequence but only implements\n * a subset of the features in preferences for better memory management.\n * Compared to canvas-image-sequence, this class has better VRAM management.\n *\n *\n * Usage:\n *\n * HTML / SASS\n * ```\n * <div class=\"my-element\"></div>\n *\n *\n * .my-element\n *   width: 100vw\n *   height: 100vh\n * ```\n *\n * Then in your JS:\n *\n * ```ts\n *\n * // All images are assumed to be the same dimensions.\n * let myImages = [\n *   'image-1.jpg',\n *   'image-2.jpg',\n *   'image-3.jpg',\n *   'image-4.jpg',\n *    ...\n *   'image-100.jpg',\n * ]\n *\n * let sequence = new WebGlImageSequence(\n *   document.querySelector('.my-element'),\n *   // Pass in your imageSet.  You can specific multiple (see below).\n *   [{images: myImages}],\n *    // Optional sizing.\n *   {\n *      cover: false, // Use cover mode.  Defaults to false.\n *      bottom: 0 // Align to the bottom.\n *      left: 0.2 // Align to the left\n *      leftNoClip: true // When aligning to left, use the no clip algo.\n *   },\n *   is.ipad() : 1 : undefined // Force dpr 1 on ipad that has less memory.\n * );\n *\n * // Loads the images.\n * sequence.load();\n *\n * // At a later time.  If images aren't loaded yet, render will get ignored.\n * sequence.renderByProgress(0);  // Renders frame at progress 0.\n * sequence.renderByProgress(0.5);  // Renders frame at progress 0.5\n * sequence.renderByProgress(1);  // Renders frame at progress 1\n *\n * // When done.\n * sequence.dispose();\n *\n * ```\n *\n * ### Sizing options.\n * WebGlImageSequence has two render modes, contain (default) and cover.\n * Contain will by default vertically center your image but you can offset this\n * by providing a bottom value.\n *\n *\n * ```ts\n * let sequence = new WebGlImageSequence(\n *   document.querySelector('.my-element'),\n *   [{images: myImages}],\n *   {\n *     cover: true\n *   }\n * );\n *\n * ```\n *\n *\n * ## MultiInterpolate capabilities.\n * WebGL Image Sequence has multiinterpolation built in to make it easier to\n * manage more complex sequences.\n * Normally, you may want to map an image sequence to just play from start to\n * end.  But what if you wanted more flexiblity?  You can do things like:\n *\n *\n * ```ts\n *\n * let progressPoints = [\n *       {\n *         from: 0, to: 0.5, start: 0, end: 1,\n *       },\n *       {\n *         from: 0.5, to: 1, start: 1, end: 0,\n *       },\n * ];\n * sequence.setMultiInterpolation(progressPoints);\n * sequence.load();\n *\n * ```\n * In the above, now the image sequence will play from start to end and back to\n * the start.  You can define your own progress points to have full control over\n * how you want your image sequence sprite to play out.\n *\n *\n * ## Playback capability\n * You can also play your canvas image sequence with a timer.\n * The playback also provides a completion promise.\n *\n * ```ts\n * // Create a complicated playback.\n * let progressPoints = [\n *       {\n *         from: 0, to: 0.5, start: 0, end: 1,\n *       },\n *       {\n *         from: 0.5, to: 1, start: 1, end: 0,\n *       },\n * ];\n * sequence.setMultiInterpolation(progressPoints);\n * // Now load the images.\n * sequence.load().then(()=> {\n *    // Now play the image sequence from progress 0 - 1 over a span of 3000 ms.\n *    sequence.play(0, 1, 3000).then(()=> {\n *       console.log('done');\n *    })\n * })\n *\n *\n * // Use stop if you need to stop the animation.\n * sequence.stop();\n *\n * ```\n *\n * ### Lerp Towards Capability\n * By setting a lerp value, webGlImageSequence will automatically \"lerp\" towards\n * frames if the delta between the currently rendered frame and the requested\n * progress is large.\n * * This is useful to \"smooth\" out movement between frames.\n *\n *\n * To use this feature, simply set the lerp value.\n *\n * As an exmaple we initially set the progress to 0 but immediately, change it to 1.\n * You will see that the progress value will lerp.   Internally, this happens\n * by running raf until the frame value delta is less than 1 and stable.\n *\n * ```ts\n *  sequence.lerpAmount = 0.12;\n *  sequence.renderByProgress(0);\n *  sequence.renderByProgress(1);\n * ```\n *\n *\n * Another usecase for setting lerp is to handle resolving state after playing\n * a sequence. See webgl-image-sequence4 for more on this.\n *\n *\n *\n * ## Selectively loading different sets of images.\n *\n * You can pass different sets of images to use.   Use the when condition\n * to modify your set.   Note that the when condition is only evaluated\n * upon resize.  If a new image set is matched, loading of that image\n * set will automatically happen in the background and render when complete.\n *\n * ```ts\n *\n * let myImages = [\n *   'image-1.jpg',\n *    ...\n *   'image-100.jpg',\n * ];\n *\n * let myMobileImages = [\n *   'image-mobile-1.jpg',\n *   'image-mobile-100.jpg',\n * ];\n *  let sequence = new WebGlImageSequence(\n *   document.querySelector('.my-element'),\n *   [{\n *     when: ()=> { return window.innerWidth >= 768},\n *     images: myImages\n *   },\n *   {\n *     when: ()=> { return window.innerWidth < 768},\n *     images: myMobileImages\n *   }]\n * );\n *\n * ```\n *\n * Can I have imageSets for only desktop or mobile?  Yes you can!\n *\n * ```ts\n *  let sequence = new WebGLImageSequence(\n *   document.querySelector('.my-element'),\n *   [\n *   {\n *     when: ()=> { return window.innerWidth < 768},\n *     images: myMobileImages\n *   }]\n * );\n *\n * ```\n * Here we specify WebGLImageSequence with an imageSet for only mobile.  This\n * means the images will only load on mobile and canvasImageSequence won't\n * do anything on desktop (nothing will show since there are no images).\n *\n *\n *\n * ############# Dev Notes ####################\n * Read the Dev Notes in canvas-image-sequence as this class has the same\n * foundation as canvas-image-sequence.  The primary difference is that\n * this class implements webGL instead of canvas2D as the renderer.\n *\n * In order to keep image-cache down, we still want to utilize the\n * cacheImage technique and generate objectURL and revoke them per drawCall.\n * You also want to avoid image.decode and imageBitmaps (for now).\n *\n * WebGL is primary is better over the canvas2d version because in the\n * canvas2D version, the VRAM (gpu memory) gets very large as it each image\n * gets composited.  The same thing happens in webGL but there is finer\n * control over the memory since we can destory textures.\n *\n * ```\n *   var texture = webgl.createTextureFromImage(gl, image);\n *   // Draw out\n *   ...\n *\n *   // Clear VRAM memory by deleting the texture after render.\n *   webgl.deleteTexture(gl, texture);\n *\n * ```\n *\n * TODO (uxder): Possibly upgrade to compressed textures.\n *           https://blog.playcanvas.com/webgl-texture-compression-made-easy/\n *\n * @unstable\n */\nclass WebGlImageSequence {\n    constructor(element, imageSets, options, dpr) {\n        /**\n         * The lerp amount when there is a delta between target and current frame\n         * greater than 1.  This defaults to 1 (meaning no lerp).  Change this value\n         * if you want canvasImageSequennce to smoothly interpolate between large\n         * deltas between the target and current frames.\n         */\n        this.lerpAmount = 1;\n        this.element = element;\n        if (!element) {\n            throw new Error(exports.WebGlImageSequenceErrors.NO_ELEMENT);\n        }\n        if (!imageSets) {\n            throw new Error(exports.WebGlImageSequenceErrors.NO_IMAGE_SETS);\n        }\n        this.imageSets = imageSets;\n        this.activeImageSet = null;\n        this.blobCache = {};\n        this.options = options;\n        this.isPlaying = false;\n        // this.useBitmapImageIfPossible = false;\n        // Create canvas.\n        this.canvasElement = document.createElement('canvas');\n        // Add aria label if available.\n        if (this.options && this.options.ariaLabel) {\n            this.canvasElement.setAttribute('aria-label', this.options.ariaLabel);\n            this.canvasElement.setAttribute('role', 'img');\n        }\n        else {\n            this.canvasElement.setAttribute('aria-hidden', 'true');\n        }\n        this.gl = this.canvasElement.getContext('webgl', {\n            antialias: false,\n            depth: false,\n        });\n        this.program = webgl_1.webgl.createProgram(this.gl, exports.vertShader, exports.fragShader);\n        this.dpr = func_1.func.setDefault(dpr, window.devicePixelRatio || 1);\n        this.canvasWidth = 0;\n        this.canvasHeight = 0;\n        this.imageNaturalHeight = 0;\n        this.imageNaturalWidth = 0;\n        this.currentFrame = 0;\n        this.lastDrawSource = null;\n        this.targetFrame = 0;\n        this.containScale = null;\n        this.disposed = false;\n        // Set FPS to 30 for Safari to limit computation.  Safari takes a lot\n        // more time to decode images so this prevents high CPU usage crashes\n        // in Safari.\n        this.fps = new fps_1.Fps(is_1.is.safari() ? 30 : 60);\n        this.cacheImage = new Image();\n        this.rafTimer = null;\n        this.multiInterpolate = null;\n        this.blobLoader = null;\n        this.progress = null;\n        this.playDefer = null;\n        this.domWatcher = new dom_watcher_1.DomWatcher();\n        this.domWatcher.add({\n            element: window,\n            // Ensure we use smart resize here because resizing canvas will make\n            // it flash (due to clearing the canvas).\n            on: 'smartResize',\n            callback: () => {\n                this.resize();\n                this.flush(); // Make a empty call to clear the memoize cache.\n                // Rerender the last known image.\n                this.lastDrawSource = null;\n                this.fps.lock(false);\n                this.lastRenderSource && this.draw(this.lastRenderSource);\n                this.fps.lock(true);\n            },\n            id: 'resize',\n            eventOptions: { passive: true },\n        });\n        this.domWatcher.run('resize');\n        // Another resize watcher dedicated to checking to checking if a new\n        // image set should be loaded.\n        this.domWatcher.add({\n            element: window,\n            on: 'smartResize',\n            callback: () => {\n                // Evaluate if we need to load a different image set.\n                const newSet = this.getSourceThatShouldLoad(this.imageSets);\n                if (newSet !== this.activeImageSet) {\n                    this.loadNewSet(this.imageSets);\n                    // Autoload the content.\n                    this.load().then(() => {\n                        // Set last frame to null to allow redrawing.\n                        this.lastDrawSource = null;\n                        this.fps.lock(false);\n                        this.renderByProgress(this.progress || 0);\n                        this.fps.lock(true);\n                    });\n                }\n            },\n            id: 'image-set-resize',\n            eventOptions: { passive: true },\n        });\n        this.element.appendChild(this.canvasElement);\n        this.readyPromise = new defer_1.Defer();\n        this.loadNewSet(imageSets);\n        // The previously rendered image source.\n        this.lastRenderSource = null;\n        this.lastDrawSource = null;\n        // Cull unncessary update\n        this.draw = func_1.func.runOnceOnChange(this.draw.bind(this));\n    }\n    /**\n     * Sets an optional multiinterpolations.  This allows you to define\n     * more complex play sequences on your image sequence.\n     *\n     * Here is an example of playing the image sequence from start to end\n     * and back to end.\n     *\n     * ```ts\n     * let progressPoints = [\n     *       {\n     *         from: 0, to: 0.5, start: 0, end: 1,\n     *       },\n     *       {\n     *         from: 0.5, to: 1, start: 1, end: 0,\n     *       },\n     * ];\n     * canvasImageSequence.setMultiInterpolation(progressPoints);\n     *\n     * ```\n     */\n    setMultiInterpolation(interpolations) {\n        this.multiInterpolate = new multi_interpolate_1.MultiInterpolate({\n            interpolations: [\n                {\n                    id: 'sequence',\n                    progress: interpolations,\n                },\n            ],\n        });\n    }\n    resize() {\n        this.canvasWidth = this.element.offsetWidth;\n        this.canvasHeight = this.element.offsetHeight;\n        this.canvasElement.width = this.element.offsetWidth * this.dpr;\n        this.canvasElement.height = this.element.offsetHeight * this.dpr;\n        this.canvasElement.style.width = this.canvasElement.width / this.dpr + 'px';\n        this.canvasElement.style.height =\n            this.canvasElement.height / this.dpr + 'px';\n    }\n    /**\n     * Starts loading the images.\n     */\n    load() {\n        // If there is no matching imageSet there is nothing to load.\n        if (!this.blobLoader || !this.activeImageSet) {\n            // Defer resolution.\n            window.setTimeout(() => {\n                this.readyPromise.resolve();\n            });\n            return this.readyPromise.getPromise();\n        }\n        const loadAllBlobs = () => {\n            this.blobLoader.load().then(results => {\n                this.blobCache = results;\n                this.setImageDimensions().then(() => {\n                    this.blobLoader.dispose();\n                    this.blobLoader = null;\n                    this.readyPromise.resolve(results);\n                });\n            });\n        };\n        loadAllBlobs();\n        return this.readyPromise.getPromise();\n    }\n    /**\n     * Allows you to set new imageSets.\n     *\n     * @param imageSource\n     */\n    loadNewSet(imageSets) {\n        // Release memory of current set.\n        this.blobLoader && this.blobLoader.dispose();\n        // Save the image sources.\n        this.imageSets = imageSets;\n        this.activeImageSet = this.getSourceThatShouldLoad(this.imageSets);\n        if (this.activeImageSet && !is_1.is.array(this.activeImageSet.images)) {\n            throw new Error(exports.WebGlImageSequenceErrors.NO_IMAGES);\n        }\n        // Set the active image set if one is available.\n        if (this.activeImageSet) {\n            this.blobLoader = new blob_loader_1.BlobLoader(this.activeImageSet.images);\n        }\n        else {\n            this.blobLoader = null;\n        }\n        this.blobCache = {};\n        this.flush();\n        this.lastRenderSource = null;\n        // Reset the readyPromise.\n        this.readyPromise = new defer_1.Defer();\n    }\n    /**\n     * Given a list of CanvasImageSequenceImageSets evaluates which set should\n     * be used to load into the canvas.  The criteria is that any\n     * imageSet without when is used or if when condition is specified the\n     * when condition is evaluated and if true, it is used.  If multiple imageSets\n     * are found, the the first one is used.\n     */\n    getSourceThatShouldLoad(sources) {\n        const matchingSouces = [];\n        sources.forEach(source => {\n            if (!source.when) {\n                matchingSouces.push(source);\n            }\n            else {\n                source.when() && matchingSouces.push(source);\n            }\n        });\n        return matchingSouces[0];\n    }\n    /**\n     * Makes a deletable image clone.\n     */\n    makeImage(source) {\n        return new Promise(resolve => {\n            if (!source || !this.blobCache[source]) {\n                resolve(null);\n                return;\n            }\n            // Remove the objectURL Blob from locale cache.\n            URL.revokeObjectURL(this.cacheImage.src);\n            this.cacheImage.onload = () => {\n                resolve(this.cacheImage);\n            };\n            // Create a new temporary ObjectURl to store.\n            this.cacheImage.src = URL.createObjectURL(this.blobCache[source]);\n        });\n    }\n    /**\n     * Sets the images dimensions used internally based on the first image.\n     * Assumes all images are uniform size.\n     */\n    setImageDimensions() {\n        return new Promise(resolve => {\n            const source = this.activeImageSet.images[0];\n            const blob = this.blobCache[source];\n            // Generate an image from teh first blob.\n            dom_1.dom.makeImageFromBlob(blob).then(image => {\n                const bitMapsLoaded = !image.naturalWidth;\n                this.imageNaturalHeight = bitMapsLoaded\n                    ? image.height\n                    : image.naturalHeight;\n                this.imageNaturalWidth = bitMapsLoaded\n                    ? image.width\n                    : image.naturalWidth;\n                // Release it from memory.\n                dom_1.dom.deleteImage(image);\n                resolve();\n            });\n        });\n    }\n    /**\n     * Gets internally used current image seet.\n     */\n    getActiveImages() {\n        return this.activeImageSet.images;\n    }\n    /**\n     * Renders by progress.  0 would mean the very first frame and the 1 would\n     * mean the last.\n     * @param {number} n A progress value between 0 and 1.\n     * @param {noMultiInterpolate} An option to force evaluation without\n     *   multiInterpolation.  This is useful in cases where you have\n     *   multiInterpolation enabled but you want to manually update the\n     *   position of the frame without it using multiInterpolation.  Simply,\n     *   being able to say, I want to render the image sequnce at 0.9 for example.\n     */\n    renderByProgress(n, noMultiInterpolate = false) {\n        this.progress = mathf_1.mathf.clamp01(n);\n        !this.isPlaying && this.renderProgress(n, noMultiInterpolate);\n    }\n    /**\n     * Internal render by progress value.\n     * @param {number} n A progress value between 0 and 1.\n     * @param {noMultiInterpolate} An option to force evaluation without\n     *   multiInterpolation.  This is useful in cases where you have\n     *   multiInterpolation enabled but you want to manually update the\n     *   position of the frame without it using multiInterpolation.  Simply,\n     *   being able to say, I want to render the image sequnce at 0.9 for example.\n     */\n    renderProgress(n, noMultiInterpolate = false) {\n        let progress = mathf_1.mathf.clamp01(n);\n        // If the optional multiinterpolate is set, then use multiInterpolate\n        // to figure out what the correct frame should be.\n        if (this.multiInterpolate && !noMultiInterpolate) {\n            const interpolateMap = this.multiInterpolate.calculate(progress);\n            progress = mathf_1.mathf.clamp01(interpolateMap['sequence']);\n        }\n        // Flush cache if progress is 0 or 1 to ensure final frame is always\n        // played.\n        if (progress >= 0.95 || progress <= 0.05) {\n            this.flush();\n        }\n        // Figure out the correct frame to render based on the number of\n        // frames in the sequence.\n        if (this.activeImageSet) {\n            const total = this.activeImageSet.images.length - 1;\n            const targetFrame = Math.ceil(mathf_1.mathf.lerp(0, total, progress));\n            this.renderFrame(targetFrame);\n        }\n    }\n    /**\n     * Renders a given frame on to the html element.\n     * @param i\n     */\n    renderFrame(i) {\n        // If images aren't loaded yet, skip drawing.\n        if (!this.readyPromise.complete) {\n            return;\n        }\n        this.targetFrame = i;\n        // If the delta between target and current frame is greater than\n        // 1 and there is a lerp value set, lerp towards the target frame.\n        // Otherwise, just set the currentFrame\n        // to the target for immediate updates.\n        // Note that by default, the lerp amount is set to 1 (meaning no lerp),\n        let diff = Math.abs(this.targetFrame - this.currentFrame);\n        if (diff > 1 && !this.isPlaying && this.lerpAmount < 1) {\n            this.currentFrame = mathf_1.mathf.lerp(this.currentFrame, this.targetFrame, this.lerpAmount);\n            // If there is a delta, keep updating with RAF until it gets resolved.\n            diff = Math.abs(this.targetFrame - this.currentFrame);\n            const precision = 0.001;\n            if (diff >= precision) {\n                window.requestAnimationFrame(() => {\n                    this.renderFrame(this.targetFrame);\n                });\n            }\n        }\n        else {\n            this.currentFrame = this.targetFrame;\n        }\n        const imageSource = this.activeImageSet.images[Math.round(this.currentFrame)];\n        this.draw(imageSource);\n    }\n    /**\n     * Flush the draw cache.\n     */\n    flush() {\n        this.draw(''); // Make a empty call to clear the memoize cache.\n        this.draw(null);\n    }\n    async draw(imageSource) {\n        // Prevent invalid draws\n        if (!imageSource || this.disposed) {\n            return;\n        }\n        if (imageSource === this.lastDrawSource) {\n            return;\n        }\n        // Can't draw on a 0 area canvas\n        if (!this.canvasWidth || !this.canvasHeight) {\n            return;\n        }\n        this.lastDrawSource = imageSource;\n        // If this was called at a rate exceeding the fps limit.\n        if (!this.fps.canRun()) {\n            this.fps.schedule(() => {\n                // Force a draw.  This ensures that even with FPS limiting,\n                // the very last draw call is always rendered.\n                this.lastDrawSource = null;\n                this.draw(imageSource);\n            });\n            return;\n        }\n        const image = await this.makeImage(imageSource);\n        // Decoding images in this way, we see a huge memory jump.  Avoid for now.\n        // await image.decode();\n        // If an image couldn't be generated for some reason.\n        if (!image) {\n            return;\n        }\n        const imageBox = {\n            width: this.imageNaturalWidth,\n            height: this.imageNaturalHeight,\n        };\n        const containerBox = {\n            width: this.canvasWidth,\n            height: this.canvasHeight,\n        };\n        let x;\n        let y;\n        let width;\n        let height;\n        // Background \"cover\" sizing.\n        // Defaults to center.\n        if (this.options && this.options.cover) {\n            const cover = mathf_1.mathf.calculateBackgroundCover(containerBox, imageBox);\n            if (this.options && is_1.is.number(this.options.left)) {\n                cover.xOffset =\n                    (containerBox.width - imageBox.width * cover.scalar) *\n                        -this.options.left;\n            }\n            if (this.options && is_1.is.number(this.options.right)) {\n                // Right align first.\n                cover.xOffset = -(containerBox.width - imageBox.width * cover.scalar);\n                cover.xOffset +=\n                    (containerBox.width - imageBox.width * cover.scalar) *\n                        this.options.right;\n            }\n            if (this.options && is_1.is.number(this.options.bottom)) {\n                // Set to bottom.\n                cover.yOffset = -(containerBox.height - imageBox.height * cover.scalar);\n                // Clipping Bottom algo.\n                // Add the percentage amount specified.\n                cover.yOffset +=\n                    (containerBox.height - imageBox.height * cover.scalar) *\n                        this.options.bottom;\n            }\n            if (this.options && is_1.is.number(this.options.top)) {\n                cover.yOffset =\n                    (containerBox.height - imageBox.height * cover.scalar) *\n                        -this.options.top;\n            }\n            x = -cover.xOffset >> 0;\n            y = -cover.yOffset >> 0;\n            width = (imageBox.width * cover.scalar) >> 0;\n            height = (imageBox.height * cover.scalar) >> 0;\n        }\n        else {\n            // Default to contain sizing algo.\n            this.containScale = mathf_1.mathf.calculateBackgroundContain(containerBox, imageBox);\n            // Default center algo.\n            let diffX = (containerBox.width - imageBox.width * this.containScale) / 2;\n            let diffY = (containerBox.height - imageBox.height * this.containScale) / 2;\n            // Sizing option logic.\n            if (this.options && is_1.is.number(this.options.bottom)) {\n                // Bottom align it.\n                diffY = containerBox.height - imageBox.height * this.containScale;\n                // Easy way to test this is to set bottom: 1 and\n                // bottomClipping: false which would top align the image.\n                if (this.options.bottomNoClip) {\n                    diffY -=\n                        (containerBox.height - imageBox.height * this.containScale) *\n                            this.options.bottom;\n                }\n                else {\n                    // Clipping Bottom algo.\n                    // Add the percentage amount specified.\n                    diffY -= containerBox.height * this.options.bottom;\n                }\n            }\n            if (this.options && is_1.is.number(this.options.right)) {\n                // Right align it.\n                diffX = containerBox.width - imageBox.width * this.containScale;\n                // Easy way to test this is to set right: 1 and\n                // rightClipping: false which would left align the image.\n                if (this.options.rightNoClip) {\n                    diffX -=\n                        (containerBox.width - imageBox.width * this.containScale) *\n                            this.options.right;\n                }\n                else {\n                    // Clipping right algo.\n                    // Add the percentage amount specified.\n                    diffX -= containerBox.width * this.options.right;\n                }\n            }\n            if (this.options && is_1.is.number(this.options.top)) {\n                // Top align it.\n                diffY = 0;\n                // Easy way to test this is to set top: 1 and\n                // topClipping: false which would bottom aligned the image.\n                if (this.options.topNoClip) {\n                    diffY =\n                        (containerBox.height - imageBox.height * this.containScale) *\n                            this.options.top;\n                }\n                else {\n                    // Clipping Top algo.\n                    // Add the percentage amount specified.\n                    diffY += this.options.top * containerBox.height;\n                }\n            }\n            if (this.options && is_1.is.number(this.options.left)) {\n                // Left align it.\n                diffX = 0;\n                // Easy way to test this is to set left: 1 and\n                // leftClipping: false which would right aligned the image.\n                if (this.options.leftNoClip) {\n                    diffX =\n                        (containerBox.width - imageBox.width * this.containScale) *\n                            this.options.left;\n                }\n                else {\n                    // Clipping left algo.\n                    // Add the percentage amount specified.\n                    diffX += this.options.left * containerBox.width;\n                }\n            }\n            x = diffX >> 0;\n            y = diffY >> 0;\n            width = (imageBox.width * this.containScale) >> 0;\n            height = (imageBox.height * this.containScale) >> 0;\n        }\n        // WebGL Draw.\n        const gl = this.gl;\n        const program = this.program;\n        const aPosition = gl.getAttribLocation(program, 'a_position');\n        const uMatrix = gl.getUniformLocation(program, 'u_matrix');\n        gl.useProgram(this.program);\n        gl.viewport(0, 0, this.canvasWidth * this.dpr, this.canvasHeight * this.dpr);\n        // gl.enable(gl.BLEND);\n        // gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        webgl_1.webgl.createVbo(gl, [\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            0.0,\n            1.0,\n            0.0,\n            1.0,\n            1.0,\n            0.0,\n            1.0,\n            1.0,\n        ]);\n        gl.enableVertexAttribArray(aPosition);\n        gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\n        const texture = webgl_1.webgl.createTextureFromImage(gl, image);\n        // Convert pixel coords to gl coords based on the x, y, width and height\n        // values calculated above.\n        const clipX = (x / this.canvasWidth) * 2 - 1;\n        const clipY = (y / this.canvasHeight) * -2 + 1;\n        const clipWidth = (width / this.canvasWidth) * 2;\n        const clipHeight = (height / this.canvasHeight) * -2;\n        // Stretch out unit quad.\n        gl.uniformMatrix3fv(uMatrix, false, [\n            clipWidth,\n            0,\n            0,\n            0,\n            clipHeight,\n            0,\n            clipX,\n            clipY,\n            1,\n        ]);\n        // Draw the rectangle.\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        // Clear VRAM memory by deleting the texture after render.\n        webgl_1.webgl.deleteTexture(gl, texture);\n        this.lastRenderSource = imageSource;\n    }\n    /**\n     * Updates the internal sizing options.\n     * @param options\n     */\n    setSizingOptions(options) {\n        this.options = options;\n    }\n    /**\n     * Plays the canvas image sequence with a timer. Playing will \"hijack\" the\n     * progress events while playing.   For example:\n     *\n     * ```ts\n     *    canvasImageSequence.play(0, 1, 3000).then(() => {\n     *       console.log('play complete');\n     *   });\n     * ```\n     *\n     * Here we tell the canvasImageSequence to play from start to end over\n     * a 3000ms period.  During this 3000ms period, any calls other to\n     * calls \"renderByProgress\" will get ignored since they can conflict with\n     * the playback.\n     *\n     *\n     * @param from A number between 0 - 1\n     * @param to A number between 0 - 1\n     * @param duration The duration in ms.\n     * @return Promise A promise that completes when done.\n     */\n    play(from, to, duration) {\n        this.stop();\n        this.rafTimer = new raf_timer_1.RafTimer((progress) => {\n            const interpolatedProgress = mathf_1.mathf.interpolateRange(progress, 0, 1, from, to);\n            this.renderProgress(interpolatedProgress);\n        });\n        this.rafTimer.setDuration(duration);\n        this.playDefer = new defer_1.Defer();\n        this.rafTimer.onComplete(() => {\n            this.isPlaying = false;\n            this.playDefer.resolve();\n            this.rafTimer.dispose();\n        });\n        this.rafTimer.play();\n        this.isPlaying = true;\n        return this.playDefer.getPromise();\n    }\n    /**\n     * Immediately stops the canvas animation playing.\n     * (that happens with play method).\n     */\n    stop() {\n        this.rafTimer && this.rafTimer.pause();\n        this.rafTimer && this.rafTimer.dispose();\n        this.playDefer && this.playDefer.resolve();\n    }\n    /**\n     * Returns the image dimension that were fetched.  This is based\n     * on the \"first\" image in the sequence.\n     * The sizes will be null if called prior to loading images.\n     */\n    getImageSize() {\n        return {\n            width: this.imageNaturalWidth,\n            height: this.imageNaturalHeight,\n        };\n    }\n    dispose() {\n        this.disposed = true;\n        this.stop();\n        this.domWatcher.dispose();\n        this.rafTimer && this.rafTimer.dispose();\n        this.blobLoader && this.blobLoader.dispose();\n        // this.element = null;\n        // this.blobCache = null;\n        // this.canvasElement = null;\n        dom_1.dom.deleteImage(this.cacheImage);\n        // this.cacheImage = null;\n        this.gl = null;\n    }\n}\nexports.WebGlImageSequence = WebGlImageSequence;\n//# sourceMappingURL=webgl-image-sequence.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL3dlYmdsLWltYWdlLXNlcXVlbmNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2RvbS93ZWJnbC1pbWFnZS1zZXF1ZW5jZS5qcz9jNTg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWJHbEltYWdlU2VxdWVuY2UgPSBleHBvcnRzLldlYkdsSW1hZ2VTZXF1ZW5jZUVycm9ycyA9IGV4cG9ydHMudmVydFNoYWRlciA9IGV4cG9ydHMuZnJhZ1NoYWRlciA9IHZvaWQgMDtcbmNvbnN0IGRvbV8xID0gcmVxdWlyZShcIi4uL2RvbS9kb21cIik7XG5jb25zdCBpc18xID0gcmVxdWlyZShcIi4uL2lzL2lzXCIpO1xuY29uc3QgZnVuY18xID0gcmVxdWlyZShcIi4uL2Z1bmMvZnVuY1wiKTtcbmNvbnN0IGRlZmVyXzEgPSByZXF1aXJlKFwiLi4vZnVuYy9kZWZlclwiKTtcbmNvbnN0IGJsb2JfbG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vbG9hZGVyL2Jsb2ItbG9hZGVyXCIpO1xuY29uc3QgbWF0aGZfMSA9IHJlcXVpcmUoXCIuLi9tYXRoZi9tYXRoZlwiKTtcbmNvbnN0IGRvbV93YXRjaGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbS13YXRjaGVyXCIpO1xuY29uc3QgbXVsdGlfaW50ZXJwb2xhdGVfMSA9IHJlcXVpcmUoXCIuLi9pbnRlcnBvbGF0ZS9tdWx0aS1pbnRlcnBvbGF0ZVwiKTtcbmNvbnN0IHJhZl90aW1lcl8xID0gcmVxdWlyZShcIi4uL3JhZi9yYWYtdGltZXJcIik7XG5jb25zdCBmcHNfMSA9IHJlcXVpcmUoXCIuLi90aW1lL2Zwc1wiKTtcbmNvbnN0IHdlYmdsXzEgPSByZXF1aXJlKFwiLi4vZG9tL3dlYmdsXCIpO1xuZXhwb3J0cy5mcmFnU2hhZGVyID0gYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XG4gICAgLy8gdGV4Q29vcmRzIHBhc3NlZCBpbiBmcm9tIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcbiAgICB9XG5gO1xuZXhwb3J0cy52ZXJ0U2hhZGVyID0gYFxuICAgIGF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XG4gICAgdW5pZm9ybSBtYXQzIHVfbWF0cml4O1xuICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSksIDEpO1xuICAgICAgdl90ZXhDb29yZCA9IGFfcG9zaXRpb247XG4gICAgfVxuYDtcbmV4cG9ydHMuV2ViR2xJbWFnZVNlcXVlbmNlRXJyb3JzID0ge1xuICAgIE5PX0VMRU1FTlQ6ICdBbiBlbGVtZW50IGlzIHJlcXVpcmVkIGZvciB3ZWJnbCBpbWFnZSBzZXF1ZW5jZScsXG4gICAgTk9fSU1BR0VfU0VUUzogJ0ltYWdlIHNldHMgYXJlIHJlcXVpcmVkIGZvciB3ZWJnbCBpbWFnZSBzZXF1ZW5jZScsXG4gICAgTk9fSU1BR0VTOiAnVGhlcmUgYXJlIG5vIGltYWdlcyBkZWZpbmVkIGluIHlvdXIgd2ViZ2wgaW1hZ2Ugc2VxdWVuY2UgaW1hZ2Ugc2V0Jyxcbn07XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBhbGxvd3MgeW91IHRvIHBsYXkgdGhyb3VnaCBhbiBpbWFnZSBzZXF1ZW5jZSAoc3ByaXRlKSBiYXNlZCBvblxuICogcHJvZ3Jlc3MuICBUaGlzIGNsYXNzIGlzIHNpbWlsYXIgdG8gY2FudmFzLWltYWdlLXNlcXVlbmNlIGJ1dCBvbmx5IGltcGxlbWVudHNcbiAqIGEgc3Vic2V0IG9mIHRoZSBmZWF0dXJlcyBpbiBwcmVmZXJlbmNlcyBmb3IgYmV0dGVyIG1lbW9yeSBtYW5hZ2VtZW50LlxuICogQ29tcGFyZWQgdG8gY2FudmFzLWltYWdlLXNlcXVlbmNlLCB0aGlzIGNsYXNzIGhhcyBiZXR0ZXIgVlJBTSBtYW5hZ2VtZW50LlxuICpcbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiBIVE1MIC8gU0FTU1xuICogYGBgXG4gKiA8ZGl2IGNsYXNzPVwibXktZWxlbWVudFwiPjwvZGl2PlxuICpcbiAqXG4gKiAubXktZWxlbWVudFxuICogICB3aWR0aDogMTAwdndcbiAqICAgaGVpZ2h0OiAxMDB2aFxuICogYGBgXG4gKlxuICogVGhlbiBpbiB5b3VyIEpTOlxuICpcbiAqIGBgYHRzXG4gKlxuICogLy8gQWxsIGltYWdlcyBhcmUgYXNzdW1lZCB0byBiZSB0aGUgc2FtZSBkaW1lbnNpb25zLlxuICogbGV0IG15SW1hZ2VzID0gW1xuICogICAnaW1hZ2UtMS5qcGcnLFxuICogICAnaW1hZ2UtMi5qcGcnLFxuICogICAnaW1hZ2UtMy5qcGcnLFxuICogICAnaW1hZ2UtNC5qcGcnLFxuICogICAgLi4uXG4gKiAgICdpbWFnZS0xMDAuanBnJyxcbiAqIF1cbiAqXG4gKiBsZXQgc2VxdWVuY2UgPSBuZXcgV2ViR2xJbWFnZVNlcXVlbmNlKFxuICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubXktZWxlbWVudCcpLFxuICogICAvLyBQYXNzIGluIHlvdXIgaW1hZ2VTZXQuICBZb3UgY2FuIHNwZWNpZmljIG11bHRpcGxlIChzZWUgYmVsb3cpLlxuICogICBbe2ltYWdlczogbXlJbWFnZXN9XSxcbiAqICAgIC8vIE9wdGlvbmFsIHNpemluZy5cbiAqICAge1xuICogICAgICBjb3ZlcjogZmFsc2UsIC8vIFVzZSBjb3ZlciBtb2RlLiAgRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiAgICAgIGJvdHRvbTogMCAvLyBBbGlnbiB0byB0aGUgYm90dG9tLlxuICogICAgICBsZWZ0OiAwLjIgLy8gQWxpZ24gdG8gdGhlIGxlZnRcbiAqICAgICAgbGVmdE5vQ2xpcDogdHJ1ZSAvLyBXaGVuIGFsaWduaW5nIHRvIGxlZnQsIHVzZSB0aGUgbm8gY2xpcCBhbGdvLlxuICogICB9LFxuICogICBpcy5pcGFkKCkgOiAxIDogdW5kZWZpbmVkIC8vIEZvcmNlIGRwciAxIG9uIGlwYWQgdGhhdCBoYXMgbGVzcyBtZW1vcnkuXG4gKiApO1xuICpcbiAqIC8vIExvYWRzIHRoZSBpbWFnZXMuXG4gKiBzZXF1ZW5jZS5sb2FkKCk7XG4gKlxuICogLy8gQXQgYSBsYXRlciB0aW1lLiAgSWYgaW1hZ2VzIGFyZW4ndCBsb2FkZWQgeWV0LCByZW5kZXIgd2lsbCBnZXQgaWdub3JlZC5cbiAqIHNlcXVlbmNlLnJlbmRlckJ5UHJvZ3Jlc3MoMCk7ICAvLyBSZW5kZXJzIGZyYW1lIGF0IHByb2dyZXNzIDAuXG4gKiBzZXF1ZW5jZS5yZW5kZXJCeVByb2dyZXNzKDAuNSk7ICAvLyBSZW5kZXJzIGZyYW1lIGF0IHByb2dyZXNzIDAuNVxuICogc2VxdWVuY2UucmVuZGVyQnlQcm9ncmVzcygxKTsgIC8vIFJlbmRlcnMgZnJhbWUgYXQgcHJvZ3Jlc3MgMVxuICpcbiAqIC8vIFdoZW4gZG9uZS5cbiAqIHNlcXVlbmNlLmRpc3Bvc2UoKTtcbiAqXG4gKiBgYGBcbiAqXG4gKiAjIyMgU2l6aW5nIG9wdGlvbnMuXG4gKiBXZWJHbEltYWdlU2VxdWVuY2UgaGFzIHR3byByZW5kZXIgbW9kZXMsIGNvbnRhaW4gKGRlZmF1bHQpIGFuZCBjb3Zlci5cbiAqIENvbnRhaW4gd2lsbCBieSBkZWZhdWx0IHZlcnRpY2FsbHkgY2VudGVyIHlvdXIgaW1hZ2UgYnV0IHlvdSBjYW4gb2Zmc2V0IHRoaXNcbiAqIGJ5IHByb3ZpZGluZyBhIGJvdHRvbSB2YWx1ZS5cbiAqXG4gKlxuICogYGBgdHNcbiAqIGxldCBzZXF1ZW5jZSA9IG5ldyBXZWJHbEltYWdlU2VxdWVuY2UoXG4gKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5teS1lbGVtZW50JyksXG4gKiAgIFt7aW1hZ2VzOiBteUltYWdlc31dLFxuICogICB7XG4gKiAgICAgY292ZXI6IHRydWVcbiAqICAgfVxuICogKTtcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICogIyMgTXVsdGlJbnRlcnBvbGF0ZSBjYXBhYmlsaXRpZXMuXG4gKiBXZWJHTCBJbWFnZSBTZXF1ZW5jZSBoYXMgbXVsdGlpbnRlcnBvbGF0aW9uIGJ1aWx0IGluIHRvIG1ha2UgaXQgZWFzaWVyIHRvXG4gKiBtYW5hZ2UgbW9yZSBjb21wbGV4IHNlcXVlbmNlcy5cbiAqIE5vcm1hbGx5LCB5b3UgbWF5IHdhbnQgdG8gbWFwIGFuIGltYWdlIHNlcXVlbmNlIHRvIGp1c3QgcGxheSBmcm9tIHN0YXJ0IHRvXG4gKiBlbmQuICBCdXQgd2hhdCBpZiB5b3Ugd2FudGVkIG1vcmUgZmxleGlibGl0eT8gIFlvdSBjYW4gZG8gdGhpbmdzIGxpa2U6XG4gKlxuICpcbiAqIGBgYHRzXG4gKlxuICogbGV0IHByb2dyZXNzUG9pbnRzID0gW1xuICogICAgICAge1xuICogICAgICAgICBmcm9tOiAwLCB0bzogMC41LCBzdGFydDogMCwgZW5kOiAxLFxuICogICAgICAgfSxcbiAqICAgICAgIHtcbiAqICAgICAgICAgZnJvbTogMC41LCB0bzogMSwgc3RhcnQ6IDEsIGVuZDogMCxcbiAqICAgICAgIH0sXG4gKiBdO1xuICogc2VxdWVuY2Uuc2V0TXVsdGlJbnRlcnBvbGF0aW9uKHByb2dyZXNzUG9pbnRzKTtcbiAqIHNlcXVlbmNlLmxvYWQoKTtcbiAqXG4gKiBgYGBcbiAqIEluIHRoZSBhYm92ZSwgbm93IHRoZSBpbWFnZSBzZXF1ZW5jZSB3aWxsIHBsYXkgZnJvbSBzdGFydCB0byBlbmQgYW5kIGJhY2sgdG9cbiAqIHRoZSBzdGFydC4gIFlvdSBjYW4gZGVmaW5lIHlvdXIgb3duIHByb2dyZXNzIHBvaW50cyB0byBoYXZlIGZ1bGwgY29udHJvbCBvdmVyXG4gKiBob3cgeW91IHdhbnQgeW91ciBpbWFnZSBzZXF1ZW5jZSBzcHJpdGUgdG8gcGxheSBvdXQuXG4gKlxuICpcbiAqICMjIFBsYXliYWNrIGNhcGFiaWxpdHlcbiAqIFlvdSBjYW4gYWxzbyBwbGF5IHlvdXIgY2FudmFzIGltYWdlIHNlcXVlbmNlIHdpdGggYSB0aW1lci5cbiAqIFRoZSBwbGF5YmFjayBhbHNvIHByb3ZpZGVzIGEgY29tcGxldGlvbiBwcm9taXNlLlxuICpcbiAqIGBgYHRzXG4gKiAvLyBDcmVhdGUgYSBjb21wbGljYXRlZCBwbGF5YmFjay5cbiAqIGxldCBwcm9ncmVzc1BvaW50cyA9IFtcbiAqICAgICAgIHtcbiAqICAgICAgICAgZnJvbTogMCwgdG86IDAuNSwgc3RhcnQ6IDAsIGVuZDogMSxcbiAqICAgICAgIH0sXG4gKiAgICAgICB7XG4gKiAgICAgICAgIGZyb206IDAuNSwgdG86IDEsIHN0YXJ0OiAxLCBlbmQ6IDAsXG4gKiAgICAgICB9LFxuICogXTtcbiAqIHNlcXVlbmNlLnNldE11bHRpSW50ZXJwb2xhdGlvbihwcm9ncmVzc1BvaW50cyk7XG4gKiAvLyBOb3cgbG9hZCB0aGUgaW1hZ2VzLlxuICogc2VxdWVuY2UubG9hZCgpLnRoZW4oKCk9PiB7XG4gKiAgICAvLyBOb3cgcGxheSB0aGUgaW1hZ2Ugc2VxdWVuY2UgZnJvbSBwcm9ncmVzcyAwIC0gMSBvdmVyIGEgc3BhbiBvZiAzMDAwIG1zLlxuICogICAgc2VxdWVuY2UucGxheSgwLCAxLCAzMDAwKS50aGVuKCgpPT4ge1xuICogICAgICAgY29uc29sZS5sb2coJ2RvbmUnKTtcbiAqICAgIH0pXG4gKiB9KVxuICpcbiAqXG4gKiAvLyBVc2Ugc3RvcCBpZiB5b3UgbmVlZCB0byBzdG9wIHRoZSBhbmltYXRpb24uXG4gKiBzZXF1ZW5jZS5zdG9wKCk7XG4gKlxuICogYGBgXG4gKlxuICogIyMjIExlcnAgVG93YXJkcyBDYXBhYmlsaXR5XG4gKiBCeSBzZXR0aW5nIGEgbGVycCB2YWx1ZSwgd2ViR2xJbWFnZVNlcXVlbmNlIHdpbGwgYXV0b21hdGljYWxseSBcImxlcnBcIiB0b3dhcmRzXG4gKiBmcmFtZXMgaWYgdGhlIGRlbHRhIGJldHdlZW4gdGhlIGN1cnJlbnRseSByZW5kZXJlZCBmcmFtZSBhbmQgdGhlIHJlcXVlc3RlZFxuICogcHJvZ3Jlc3MgaXMgbGFyZ2UuXG4gKiAqIFRoaXMgaXMgdXNlZnVsIHRvIFwic21vb3RoXCIgb3V0IG1vdmVtZW50IGJldHdlZW4gZnJhbWVzLlxuICpcbiAqXG4gKiBUbyB1c2UgdGhpcyBmZWF0dXJlLCBzaW1wbHkgc2V0IHRoZSBsZXJwIHZhbHVlLlxuICpcbiAqIEFzIGFuIGV4bWFwbGUgd2UgaW5pdGlhbGx5IHNldCB0aGUgcHJvZ3Jlc3MgdG8gMCBidXQgaW1tZWRpYXRlbHksIGNoYW5nZSBpdCB0byAxLlxuICogWW91IHdpbGwgc2VlIHRoYXQgdGhlIHByb2dyZXNzIHZhbHVlIHdpbGwgbGVycC4gICBJbnRlcm5hbGx5LCB0aGlzIGhhcHBlbnNcbiAqIGJ5IHJ1bm5pbmcgcmFmIHVudGlsIHRoZSBmcmFtZSB2YWx1ZSBkZWx0YSBpcyBsZXNzIHRoYW4gMSBhbmQgc3RhYmxlLlxuICpcbiAqIGBgYHRzXG4gKiAgc2VxdWVuY2UubGVycEFtb3VudCA9IDAuMTI7XG4gKiAgc2VxdWVuY2UucmVuZGVyQnlQcm9ncmVzcygwKTtcbiAqICBzZXF1ZW5jZS5yZW5kZXJCeVByb2dyZXNzKDEpO1xuICogYGBgXG4gKlxuICpcbiAqIEFub3RoZXIgdXNlY2FzZSBmb3Igc2V0dGluZyBsZXJwIGlzIHRvIGhhbmRsZSByZXNvbHZpbmcgc3RhdGUgYWZ0ZXIgcGxheWluZ1xuICogYSBzZXF1ZW5jZS4gU2VlIHdlYmdsLWltYWdlLXNlcXVlbmNlNCBmb3IgbW9yZSBvbiB0aGlzLlxuICpcbiAqXG4gKlxuICogIyMgU2VsZWN0aXZlbHkgbG9hZGluZyBkaWZmZXJlbnQgc2V0cyBvZiBpbWFnZXMuXG4gKlxuICogWW91IGNhbiBwYXNzIGRpZmZlcmVudCBzZXRzIG9mIGltYWdlcyB0byB1c2UuICAgVXNlIHRoZSB3aGVuIGNvbmRpdGlvblxuICogdG8gbW9kaWZ5IHlvdXIgc2V0LiAgIE5vdGUgdGhhdCB0aGUgd2hlbiBjb25kaXRpb24gaXMgb25seSBldmFsdWF0ZWRcbiAqIHVwb24gcmVzaXplLiAgSWYgYSBuZXcgaW1hZ2Ugc2V0IGlzIG1hdGNoZWQsIGxvYWRpbmcgb2YgdGhhdCBpbWFnZVxuICogc2V0IHdpbGwgYXV0b21hdGljYWxseSBoYXBwZW4gaW4gdGhlIGJhY2tncm91bmQgYW5kIHJlbmRlciB3aGVuIGNvbXBsZXRlLlxuICpcbiAqIGBgYHRzXG4gKlxuICogbGV0IG15SW1hZ2VzID0gW1xuICogICAnaW1hZ2UtMS5qcGcnLFxuICogICAgLi4uXG4gKiAgICdpbWFnZS0xMDAuanBnJyxcbiAqIF07XG4gKlxuICogbGV0IG15TW9iaWxlSW1hZ2VzID0gW1xuICogICAnaW1hZ2UtbW9iaWxlLTEuanBnJyxcbiAqICAgJ2ltYWdlLW1vYmlsZS0xMDAuanBnJyxcbiAqIF07XG4gKiAgbGV0IHNlcXVlbmNlID0gbmV3IFdlYkdsSW1hZ2VTZXF1ZW5jZShcbiAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm15LWVsZW1lbnQnKSxcbiAqICAgW3tcbiAqICAgICB3aGVuOiAoKT0+IHsgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoID49IDc2OH0sXG4gKiAgICAgaW1hZ2VzOiBteUltYWdlc1xuICogICB9LFxuICogICB7XG4gKiAgICAgd2hlbjogKCk9PiB7IHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OH0sXG4gKiAgICAgaW1hZ2VzOiBteU1vYmlsZUltYWdlc1xuICogICB9XVxuICogKTtcbiAqXG4gKiBgYGBcbiAqXG4gKiBDYW4gSSBoYXZlIGltYWdlU2V0cyBmb3Igb25seSBkZXNrdG9wIG9yIG1vYmlsZT8gIFllcyB5b3UgY2FuIVxuICpcbiAqIGBgYHRzXG4gKiAgbGV0IHNlcXVlbmNlID0gbmV3IFdlYkdMSW1hZ2VTZXF1ZW5jZShcbiAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm15LWVsZW1lbnQnKSxcbiAqICAgW1xuICogICB7XG4gKiAgICAgd2hlbjogKCk9PiB7IHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OH0sXG4gKiAgICAgaW1hZ2VzOiBteU1vYmlsZUltYWdlc1xuICogICB9XVxuICogKTtcbiAqXG4gKiBgYGBcbiAqIEhlcmUgd2Ugc3BlY2lmeSBXZWJHTEltYWdlU2VxdWVuY2Ugd2l0aCBhbiBpbWFnZVNldCBmb3Igb25seSBtb2JpbGUuICBUaGlzXG4gKiBtZWFucyB0aGUgaW1hZ2VzIHdpbGwgb25seSBsb2FkIG9uIG1vYmlsZSBhbmQgY2FudmFzSW1hZ2VTZXF1ZW5jZSB3b24ndFxuICogZG8gYW55dGhpbmcgb24gZGVza3RvcCAobm90aGluZyB3aWxsIHNob3cgc2luY2UgdGhlcmUgYXJlIG5vIGltYWdlcykuXG4gKlxuICpcbiAqXG4gKiAjIyMjIyMjIyMjIyMjIERldiBOb3RlcyAjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICogUmVhZCB0aGUgRGV2IE5vdGVzIGluIGNhbnZhcy1pbWFnZS1zZXF1ZW5jZSBhcyB0aGlzIGNsYXNzIGhhcyB0aGUgc2FtZVxuICogZm91bmRhdGlvbiBhcyBjYW52YXMtaW1hZ2Utc2VxdWVuY2UuICBUaGUgcHJpbWFyeSBkaWZmZXJlbmNlIGlzIHRoYXRcbiAqIHRoaXMgY2xhc3MgaW1wbGVtZW50cyB3ZWJHTCBpbnN0ZWFkIG9mIGNhbnZhczJEIGFzIHRoZSByZW5kZXJlci5cbiAqXG4gKiBJbiBvcmRlciB0byBrZWVwIGltYWdlLWNhY2hlIGRvd24sIHdlIHN0aWxsIHdhbnQgdG8gdXRpbGl6ZSB0aGVcbiAqIGNhY2hlSW1hZ2UgdGVjaG5pcXVlIGFuZCBnZW5lcmF0ZSBvYmplY3RVUkwgYW5kIHJldm9rZSB0aGVtIHBlciBkcmF3Q2FsbC5cbiAqIFlvdSBhbHNvIHdhbnQgdG8gYXZvaWQgaW1hZ2UuZGVjb2RlIGFuZCBpbWFnZUJpdG1hcHMgKGZvciBub3cpLlxuICpcbiAqIFdlYkdMIGlzIHByaW1hcnkgaXMgYmV0dGVyIG92ZXIgdGhlIGNhbnZhczJkIHZlcnNpb24gYmVjYXVzZSBpbiB0aGVcbiAqIGNhbnZhczJEIHZlcnNpb24sIHRoZSBWUkFNIChncHUgbWVtb3J5KSBnZXRzIHZlcnkgbGFyZ2UgYXMgaXQgZWFjaCBpbWFnZVxuICogZ2V0cyBjb21wb3NpdGVkLiAgVGhlIHNhbWUgdGhpbmcgaGFwcGVucyBpbiB3ZWJHTCBidXQgdGhlcmUgaXMgZmluZXJcbiAqIGNvbnRyb2wgb3ZlciB0aGUgbWVtb3J5IHNpbmNlIHdlIGNhbiBkZXN0b3J5IHRleHR1cmVzLlxuICpcbiAqIGBgYFxuICogICB2YXIgdGV4dHVyZSA9IHdlYmdsLmNyZWF0ZVRleHR1cmVGcm9tSW1hZ2UoZ2wsIGltYWdlKTtcbiAqICAgLy8gRHJhdyBvdXRcbiAqICAgLi4uXG4gKlxuICogICAvLyBDbGVhciBWUkFNIG1lbW9yeSBieSBkZWxldGluZyB0aGUgdGV4dHVyZSBhZnRlciByZW5kZXIuXG4gKiAgIHdlYmdsLmRlbGV0ZVRleHR1cmUoZ2wsIHRleHR1cmUpO1xuICpcbiAqIGBgYFxuICpcbiAqIFRPRE8gKHV4ZGVyKTogUG9zc2libHkgdXBncmFkZSB0byBjb21wcmVzc2VkIHRleHR1cmVzLlxuICogICAgICAgICAgIGh0dHBzOi8vYmxvZy5wbGF5Y2FudmFzLmNvbS93ZWJnbC10ZXh0dXJlLWNvbXByZXNzaW9uLW1hZGUtZWFzeS9cbiAqXG4gKiBAdW5zdGFibGVcbiAqL1xuY2xhc3MgV2ViR2xJbWFnZVNlcXVlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBpbWFnZVNldHMsIG9wdGlvbnMsIGRwcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxlcnAgYW1vdW50IHdoZW4gdGhlcmUgaXMgYSBkZWx0YSBiZXR3ZWVuIHRhcmdldCBhbmQgY3VycmVudCBmcmFtZVxuICAgICAgICAgKiBncmVhdGVyIHRoYW4gMS4gIFRoaXMgZGVmYXVsdHMgdG8gMSAobWVhbmluZyBubyBsZXJwKS4gIENoYW5nZSB0aGlzIHZhbHVlXG4gICAgICAgICAqIGlmIHlvdSB3YW50IGNhbnZhc0ltYWdlU2VxdWVubmNlIHRvIHNtb290aGx5IGludGVycG9sYXRlIGJldHdlZW4gbGFyZ2VcbiAgICAgICAgICogZGVsdGFzIGJldHdlZW4gdGhlIHRhcmdldCBhbmQgY3VycmVudCBmcmFtZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlcnBBbW91bnQgPSAxO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLldlYkdsSW1hZ2VTZXF1ZW5jZUVycm9ycy5OT19FTEVNRU5UKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWltYWdlU2V0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGV4cG9ydHMuV2ViR2xJbWFnZVNlcXVlbmNlRXJyb3JzLk5PX0lNQUdFX1NFVFMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1hZ2VTZXRzID0gaW1hZ2VTZXRzO1xuICAgICAgICB0aGlzLmFjdGl2ZUltYWdlU2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5ibG9iQ2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gdGhpcy51c2VCaXRtYXBJbWFnZUlmUG9zc2libGUgPSBmYWxzZTtcbiAgICAgICAgLy8gQ3JlYXRlIGNhbnZhcy5cbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIC8vIEFkZCBhcmlhIGxhYmVsIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuYXJpYUxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGhpcy5vcHRpb25zLmFyaWFMYWJlbCk7XG4gICAgICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2ltZycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2wgPSB0aGlzLmNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnd2ViZ2wnLCB7XG4gICAgICAgICAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgICAgICAgICAgZGVwdGg6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gd2ViZ2xfMS53ZWJnbC5jcmVhdGVQcm9ncmFtKHRoaXMuZ2wsIGV4cG9ydHMudmVydFNoYWRlciwgZXhwb3J0cy5mcmFnU2hhZGVyKTtcbiAgICAgICAgdGhpcy5kcHIgPSBmdW5jXzEuZnVuYy5zZXREZWZhdWx0KGRwciwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgIHRoaXMuY2FudmFzV2lkdGggPSAwO1xuICAgICAgICB0aGlzLmNhbnZhc0hlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuaW1hZ2VOYXR1cmFsSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5pbWFnZU5hdHVyYWxXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0RHJhd1NvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0RnJhbWUgPSAwO1xuICAgICAgICB0aGlzLmNvbnRhaW5TY2FsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gU2V0IEZQUyB0byAzMCBmb3IgU2FmYXJpIHRvIGxpbWl0IGNvbXB1dGF0aW9uLiAgU2FmYXJpIHRha2VzIGEgbG90XG4gICAgICAgIC8vIG1vcmUgdGltZSB0byBkZWNvZGUgaW1hZ2VzIHNvIHRoaXMgcHJldmVudHMgaGlnaCBDUFUgdXNhZ2UgY3Jhc2hlc1xuICAgICAgICAvLyBpbiBTYWZhcmkuXG4gICAgICAgIHRoaXMuZnBzID0gbmV3IGZwc18xLkZwcyhpc18xLmlzLnNhZmFyaSgpID8gMzAgOiA2MCk7XG4gICAgICAgIHRoaXMuY2FjaGVJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICB0aGlzLnJhZlRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5tdWx0aUludGVycG9sYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5ibG9iTG9hZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIHRoaXMucGxheURlZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb21XYXRjaGVyID0gbmV3IGRvbV93YXRjaGVyXzEuRG9tV2F0Y2hlcigpO1xuICAgICAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSB1c2Ugc21hcnQgcmVzaXplIGhlcmUgYmVjYXVzZSByZXNpemluZyBjYW52YXMgd2lsbCBtYWtlXG4gICAgICAgICAgICAvLyBpdCBmbGFzaCAoZHVlIHRvIGNsZWFyaW5nIHRoZSBjYW52YXMpLlxuICAgICAgICAgICAgb246ICdzbWFydFJlc2l6ZScsXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpOyAvLyBNYWtlIGEgZW1wdHkgY2FsbCB0byBjbGVhciB0aGUgbWVtb2l6ZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAvLyBSZXJlbmRlciB0aGUgbGFzdCBrbm93biBpbWFnZS5cbiAgICAgICAgICAgICAgICB0aGlzLmxhc3REcmF3U291cmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmZwcy5sb2NrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZW5kZXJTb3VyY2UgJiYgdGhpcy5kcmF3KHRoaXMubGFzdFJlbmRlclNvdXJjZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mcHMubG9jayh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZDogJ3Jlc2l6ZScsXG4gICAgICAgICAgICBldmVudE9wdGlvbnM6IHsgcGFzc2l2ZTogdHJ1ZSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kb21XYXRjaGVyLnJ1bigncmVzaXplJyk7XG4gICAgICAgIC8vIEFub3RoZXIgcmVzaXplIHdhdGNoZXIgZGVkaWNhdGVkIHRvIGNoZWNraW5nIHRvIGNoZWNraW5nIGlmIGEgbmV3XG4gICAgICAgIC8vIGltYWdlIHNldCBzaG91bGQgYmUgbG9hZGVkLlxuICAgICAgICB0aGlzLmRvbVdhdGNoZXIuYWRkKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgICAgICAgIG9uOiAnc21hcnRSZXNpemUnLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSBpZiB3ZSBuZWVkIHRvIGxvYWQgYSBkaWZmZXJlbnQgaW1hZ2Ugc2V0LlxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NldCA9IHRoaXMuZ2V0U291cmNlVGhhdFNob3VsZExvYWQodGhpcy5pbWFnZVNldHMpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdTZXQgIT09IHRoaXMuYWN0aXZlSW1hZ2VTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkTmV3U2V0KHRoaXMuaW1hZ2VTZXRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXV0b2xvYWQgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGxhc3QgZnJhbWUgdG8gbnVsbCB0byBhbGxvdyByZWRyYXdpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3REcmF3U291cmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnBzLmxvY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJCeVByb2dyZXNzKHRoaXMucHJvZ3Jlc3MgfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZwcy5sb2NrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWQ6ICdpbWFnZS1zZXQtcmVzaXplJyxcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uczogeyBwYXNzaXZlOiB0cnVlIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgdGhpcy5yZWFkeVByb21pc2UgPSBuZXcgZGVmZXJfMS5EZWZlcigpO1xuICAgICAgICB0aGlzLmxvYWROZXdTZXQoaW1hZ2VTZXRzKTtcbiAgICAgICAgLy8gVGhlIHByZXZpb3VzbHkgcmVuZGVyZWQgaW1hZ2Ugc291cmNlLlxuICAgICAgICB0aGlzLmxhc3RSZW5kZXJTb3VyY2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3REcmF3U291cmNlID0gbnVsbDtcbiAgICAgICAgLy8gQ3VsbCB1bm5jZXNzYXJ5IHVwZGF0ZVxuICAgICAgICB0aGlzLmRyYXcgPSBmdW5jXzEuZnVuYy5ydW5PbmNlT25DaGFuZ2UodGhpcy5kcmF3LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGFuIG9wdGlvbmFsIG11bHRpaW50ZXJwb2xhdGlvbnMuICBUaGlzIGFsbG93cyB5b3UgdG8gZGVmaW5lXG4gICAgICogbW9yZSBjb21wbGV4IHBsYXkgc2VxdWVuY2VzIG9uIHlvdXIgaW1hZ2Ugc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgb2YgcGxheWluZyB0aGUgaW1hZ2Ugc2VxdWVuY2UgZnJvbSBzdGFydCB0byBlbmRcbiAgICAgKiBhbmQgYmFjayB0byBlbmQuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGxldCBwcm9ncmVzc1BvaW50cyA9IFtcbiAgICAgKiAgICAgICB7XG4gICAgICogICAgICAgICBmcm9tOiAwLCB0bzogMC41LCBzdGFydDogMCwgZW5kOiAxLFxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgZnJvbTogMC41LCB0bzogMSwgc3RhcnQ6IDEsIGVuZDogMCxcbiAgICAgKiAgICAgICB9LFxuICAgICAqIF07XG4gICAgICogY2FudmFzSW1hZ2VTZXF1ZW5jZS5zZXRNdWx0aUludGVycG9sYXRpb24ocHJvZ3Jlc3NQb2ludHMpO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0TXVsdGlJbnRlcnBvbGF0aW9uKGludGVycG9sYXRpb25zKSB7XG4gICAgICAgIHRoaXMubXVsdGlJbnRlcnBvbGF0ZSA9IG5ldyBtdWx0aV9pbnRlcnBvbGF0ZV8xLk11bHRpSW50ZXJwb2xhdGUoe1xuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnc2VxdWVuY2UnLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogaW50ZXJwb2xhdGlvbnMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNpemUoKSB7XG4gICAgICAgIHRoaXMuY2FudmFzV2lkdGggPSB0aGlzLmVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzSGVpZ2h0ID0gdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LndpZHRoID0gdGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoICogdGhpcy5kcHI7XG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudC5oZWlnaHQgPSB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0ICogdGhpcy5kcHI7XG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudC5zdHlsZS53aWR0aCA9IHRoaXMuY2FudmFzRWxlbWVudC53aWR0aCAvIHRoaXMuZHByICsgJ3B4JztcbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LnN0eWxlLmhlaWdodCA9XG4gICAgICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQuaGVpZ2h0IC8gdGhpcy5kcHIgKyAncHgnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgbG9hZGluZyB0aGUgaW1hZ2VzLlxuICAgICAqL1xuICAgIGxvYWQoKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIGltYWdlU2V0IHRoZXJlIGlzIG5vdGhpbmcgdG8gbG9hZC5cbiAgICAgICAgaWYgKCF0aGlzLmJsb2JMb2FkZXIgfHwgIXRoaXMuYWN0aXZlSW1hZ2VTZXQpIHtcbiAgICAgICAgICAgIC8vIERlZmVyIHJlc29sdXRpb24uXG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkeVByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkeVByb21pc2UuZ2V0UHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvYWRBbGxCbG9icyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmxvYkxvYWRlci5sb2FkKCkudGhlbihyZXN1bHRzID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2JDYWNoZSA9IHJlc3VsdHM7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbWFnZURpbWVuc2lvbnMoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ibG9iTG9hZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ibG9iTG9hZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkeVByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBsb2FkQWxsQmxvYnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZHlQcm9taXNlLmdldFByb21pc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHlvdSB0byBzZXQgbmV3IGltYWdlU2V0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbWFnZVNvdXJjZVxuICAgICAqL1xuICAgIGxvYWROZXdTZXQoaW1hZ2VTZXRzKSB7XG4gICAgICAgIC8vIFJlbGVhc2UgbWVtb3J5IG9mIGN1cnJlbnQgc2V0LlxuICAgICAgICB0aGlzLmJsb2JMb2FkZXIgJiYgdGhpcy5ibG9iTG9hZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgLy8gU2F2ZSB0aGUgaW1hZ2Ugc291cmNlcy5cbiAgICAgICAgdGhpcy5pbWFnZVNldHMgPSBpbWFnZVNldHM7XG4gICAgICAgIHRoaXMuYWN0aXZlSW1hZ2VTZXQgPSB0aGlzLmdldFNvdXJjZVRoYXRTaG91bGRMb2FkKHRoaXMuaW1hZ2VTZXRzKTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlSW1hZ2VTZXQgJiYgIWlzXzEuaXMuYXJyYXkodGhpcy5hY3RpdmVJbWFnZVNldC5pbWFnZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5XZWJHbEltYWdlU2VxdWVuY2VFcnJvcnMuTk9fSU1BR0VTKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIGFjdGl2ZSBpbWFnZSBzZXQgaWYgb25lIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlSW1hZ2VTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuYmxvYkxvYWRlciA9IG5ldyBibG9iX2xvYWRlcl8xLkJsb2JMb2FkZXIodGhpcy5hY3RpdmVJbWFnZVNldC5pbWFnZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ibG9iTG9hZGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJsb2JDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHRoaXMubGFzdFJlbmRlclNvdXJjZSA9IG51bGw7XG4gICAgICAgIC8vIFJlc2V0IHRoZSByZWFkeVByb21pc2UuXG4gICAgICAgIHRoaXMucmVhZHlQcm9taXNlID0gbmV3IGRlZmVyXzEuRGVmZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBsaXN0IG9mIENhbnZhc0ltYWdlU2VxdWVuY2VJbWFnZVNldHMgZXZhbHVhdGVzIHdoaWNoIHNldCBzaG91bGRcbiAgICAgKiBiZSB1c2VkIHRvIGxvYWQgaW50byB0aGUgY2FudmFzLiAgVGhlIGNyaXRlcmlhIGlzIHRoYXQgYW55XG4gICAgICogaW1hZ2VTZXQgd2l0aG91dCB3aGVuIGlzIHVzZWQgb3IgaWYgd2hlbiBjb25kaXRpb24gaXMgc3BlY2lmaWVkIHRoZVxuICAgICAqIHdoZW4gY29uZGl0aW9uIGlzIGV2YWx1YXRlZCBhbmQgaWYgdHJ1ZSwgaXQgaXMgdXNlZC4gIElmIG11bHRpcGxlIGltYWdlU2V0c1xuICAgICAqIGFyZSBmb3VuZCwgdGhlIHRoZSBmaXJzdCBvbmUgaXMgdXNlZC5cbiAgICAgKi9cbiAgICBnZXRTb3VyY2VUaGF0U2hvdWxkTG9hZChzb3VyY2VzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nU291Y2VzID0gW107XG4gICAgICAgIHNvdXJjZXMuZm9yRWFjaChzb3VyY2UgPT4ge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2Uud2hlbikge1xuICAgICAgICAgICAgICAgIG1hdGNoaW5nU291Y2VzLnB1c2goc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZS53aGVuKCkgJiYgbWF0Y2hpbmdTb3VjZXMucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nU291Y2VzWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGRlbGV0YWJsZSBpbWFnZSBjbG9uZS5cbiAgICAgKi9cbiAgICBtYWtlSW1hZ2Uoc291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGlmICghc291cmNlIHx8ICF0aGlzLmJsb2JDYWNoZVtzb3VyY2VdKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdFVSTCBCbG9iIGZyb20gbG9jYWxlIGNhY2hlLlxuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLmNhY2hlSW1hZ2Uuc3JjKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmNhY2hlSW1hZ2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyB0ZW1wb3JhcnkgT2JqZWN0VVJsIHRvIHN0b3JlLlxuICAgICAgICAgICAgdGhpcy5jYWNoZUltYWdlLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy5ibG9iQ2FjaGVbc291cmNlXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbWFnZXMgZGltZW5zaW9ucyB1c2VkIGludGVybmFsbHkgYmFzZWQgb24gdGhlIGZpcnN0IGltYWdlLlxuICAgICAqIEFzc3VtZXMgYWxsIGltYWdlcyBhcmUgdW5pZm9ybSBzaXplLlxuICAgICAqL1xuICAgIHNldEltYWdlRGltZW5zaW9ucygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5hY3RpdmVJbWFnZVNldC5pbWFnZXNbMF07XG4gICAgICAgICAgICBjb25zdCBibG9iID0gdGhpcy5ibG9iQ2FjaGVbc291cmNlXTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGFuIGltYWdlIGZyb20gdGVoIGZpcnN0IGJsb2IuXG4gICAgICAgICAgICBkb21fMS5kb20ubWFrZUltYWdlRnJvbUJsb2IoYmxvYikudGhlbihpbWFnZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYml0TWFwc0xvYWRlZCA9ICFpbWFnZS5uYXR1cmFsV2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZU5hdHVyYWxIZWlnaHQgPSBiaXRNYXBzTG9hZGVkXG4gICAgICAgICAgICAgICAgICAgID8gaW1hZ2UuaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIDogaW1hZ2UubmF0dXJhbEhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlTmF0dXJhbFdpZHRoID0gYml0TWFwc0xvYWRlZFxuICAgICAgICAgICAgICAgICAgICA/IGltYWdlLndpZHRoXG4gICAgICAgICAgICAgICAgICAgIDogaW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICAgICAgICAgIC8vIFJlbGVhc2UgaXQgZnJvbSBtZW1vcnkuXG4gICAgICAgICAgICAgICAgZG9tXzEuZG9tLmRlbGV0ZUltYWdlKGltYWdlKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgaW50ZXJuYWxseSB1c2VkIGN1cnJlbnQgaW1hZ2Ugc2VldC5cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVJbWFnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZUltYWdlU2V0LmltYWdlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVycyBieSBwcm9ncmVzcy4gIDAgd291bGQgbWVhbiB0aGUgdmVyeSBmaXJzdCBmcmFtZSBhbmQgdGhlIDEgd291bGRcbiAgICAgKiBtZWFuIHRoZSBsYXN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIEEgcHJvZ3Jlc3MgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7bm9NdWx0aUludGVycG9sYXRlfSBBbiBvcHRpb24gdG8gZm9yY2UgZXZhbHVhdGlvbiB3aXRob3V0XG4gICAgICogICBtdWx0aUludGVycG9sYXRpb24uICBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlcyB3aGVyZSB5b3UgaGF2ZVxuICAgICAqICAgbXVsdGlJbnRlcnBvbGF0aW9uIGVuYWJsZWQgYnV0IHlvdSB3YW50IHRvIG1hbnVhbGx5IHVwZGF0ZSB0aGVcbiAgICAgKiAgIHBvc2l0aW9uIG9mIHRoZSBmcmFtZSB3aXRob3V0IGl0IHVzaW5nIG11bHRpSW50ZXJwb2xhdGlvbi4gIFNpbXBseSxcbiAgICAgKiAgIGJlaW5nIGFibGUgdG8gc2F5LCBJIHdhbnQgdG8gcmVuZGVyIHRoZSBpbWFnZSBzZXF1bmNlIGF0IDAuOSBmb3IgZXhhbXBsZS5cbiAgICAgKi9cbiAgICByZW5kZXJCeVByb2dyZXNzKG4sIG5vTXVsdGlJbnRlcnBvbGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBtYXRoZl8xLm1hdGhmLmNsYW1wMDEobik7XG4gICAgICAgICF0aGlzLmlzUGxheWluZyAmJiB0aGlzLnJlbmRlclByb2dyZXNzKG4sIG5vTXVsdGlJbnRlcnBvbGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIHJlbmRlciBieSBwcm9ncmVzcyB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBBIHByb2dyZXNzIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcGFyYW0ge25vTXVsdGlJbnRlcnBvbGF0ZX0gQW4gb3B0aW9uIHRvIGZvcmNlIGV2YWx1YXRpb24gd2l0aG91dFxuICAgICAqICAgbXVsdGlJbnRlcnBvbGF0aW9uLiAgVGhpcyBpcyB1c2VmdWwgaW4gY2FzZXMgd2hlcmUgeW91IGhhdmVcbiAgICAgKiAgIG11bHRpSW50ZXJwb2xhdGlvbiBlbmFibGVkIGJ1dCB5b3Ugd2FudCB0byBtYW51YWxseSB1cGRhdGUgdGhlXG4gICAgICogICBwb3NpdGlvbiBvZiB0aGUgZnJhbWUgd2l0aG91dCBpdCB1c2luZyBtdWx0aUludGVycG9sYXRpb24uICBTaW1wbHksXG4gICAgICogICBiZWluZyBhYmxlIHRvIHNheSwgSSB3YW50IHRvIHJlbmRlciB0aGUgaW1hZ2Ugc2VxdW5jZSBhdCAwLjkgZm9yIGV4YW1wbGUuXG4gICAgICovXG4gICAgcmVuZGVyUHJvZ3Jlc3Mobiwgbm9NdWx0aUludGVycG9sYXRlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHByb2dyZXNzID0gbWF0aGZfMS5tYXRoZi5jbGFtcDAxKG4pO1xuICAgICAgICAvLyBJZiB0aGUgb3B0aW9uYWwgbXVsdGlpbnRlcnBvbGF0ZSBpcyBzZXQsIHRoZW4gdXNlIG11bHRpSW50ZXJwb2xhdGVcbiAgICAgICAgLy8gdG8gZmlndXJlIG91dCB3aGF0IHRoZSBjb3JyZWN0IGZyYW1lIHNob3VsZCBiZS5cbiAgICAgICAgaWYgKHRoaXMubXVsdGlJbnRlcnBvbGF0ZSAmJiAhbm9NdWx0aUludGVycG9sYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZU1hcCA9IHRoaXMubXVsdGlJbnRlcnBvbGF0ZS5jYWxjdWxhdGUocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcHJvZ3Jlc3MgPSBtYXRoZl8xLm1hdGhmLmNsYW1wMDEoaW50ZXJwb2xhdGVNYXBbJ3NlcXVlbmNlJ10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZsdXNoIGNhY2hlIGlmIHByb2dyZXNzIGlzIDAgb3IgMSB0byBlbnN1cmUgZmluYWwgZnJhbWUgaXMgYWx3YXlzXG4gICAgICAgIC8vIHBsYXllZC5cbiAgICAgICAgaWYgKHByb2dyZXNzID49IDAuOTUgfHwgcHJvZ3Jlc3MgPD0gMC4wNSkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgZnJhbWUgdG8gcmVuZGVyIGJhc2VkIG9uIHRoZSBudW1iZXIgb2ZcbiAgICAgICAgLy8gZnJhbWVzIGluIHRoZSBzZXF1ZW5jZS5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlSW1hZ2VTZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gdGhpcy5hY3RpdmVJbWFnZVNldC5pbWFnZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEZyYW1lID0gTWF0aC5jZWlsKG1hdGhmXzEubWF0aGYubGVycCgwLCB0b3RhbCwgcHJvZ3Jlc3MpKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRnJhbWUodGFyZ2V0RnJhbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBnaXZlbiBmcmFtZSBvbiB0byB0aGUgaHRtbCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBpXG4gICAgICovXG4gICAgcmVuZGVyRnJhbWUoaSkge1xuICAgICAgICAvLyBJZiBpbWFnZXMgYXJlbid0IGxvYWRlZCB5ZXQsIHNraXAgZHJhd2luZy5cbiAgICAgICAgaWYgKCF0aGlzLnJlYWR5UHJvbWlzZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFyZ2V0RnJhbWUgPSBpO1xuICAgICAgICAvLyBJZiB0aGUgZGVsdGEgYmV0d2VlbiB0YXJnZXQgYW5kIGN1cnJlbnQgZnJhbWUgaXMgZ3JlYXRlciB0aGFuXG4gICAgICAgIC8vIDEgYW5kIHRoZXJlIGlzIGEgbGVycCB2YWx1ZSBzZXQsIGxlcnAgdG93YXJkcyB0aGUgdGFyZ2V0IGZyYW1lLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGp1c3Qgc2V0IHRoZSBjdXJyZW50RnJhbWVcbiAgICAgICAgLy8gdG8gdGhlIHRhcmdldCBmb3IgaW1tZWRpYXRlIHVwZGF0ZXMuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBieSBkZWZhdWx0LCB0aGUgbGVycCBhbW91bnQgaXMgc2V0IHRvIDEgKG1lYW5pbmcgbm8gbGVycCksXG4gICAgICAgIGxldCBkaWZmID0gTWF0aC5hYnModGhpcy50YXJnZXRGcmFtZSAtIHRoaXMuY3VycmVudEZyYW1lKTtcbiAgICAgICAgaWYgKGRpZmYgPiAxICYmICF0aGlzLmlzUGxheWluZyAmJiB0aGlzLmxlcnBBbW91bnQgPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IG1hdGhmXzEubWF0aGYubGVycCh0aGlzLmN1cnJlbnRGcmFtZSwgdGhpcy50YXJnZXRGcmFtZSwgdGhpcy5sZXJwQW1vdW50KTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgZGVsdGEsIGtlZXAgdXBkYXRpbmcgd2l0aCBSQUYgdW50aWwgaXQgZ2V0cyByZXNvbHZlZC5cbiAgICAgICAgICAgIGRpZmYgPSBNYXRoLmFicyh0aGlzLnRhcmdldEZyYW1lIC0gdGhpcy5jdXJyZW50RnJhbWUpO1xuICAgICAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gMC4wMDE7XG4gICAgICAgICAgICBpZiAoZGlmZiA+PSBwcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGcmFtZSh0aGlzLnRhcmdldEZyYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gdGhpcy50YXJnZXRGcmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbWFnZVNvdXJjZSA9IHRoaXMuYWN0aXZlSW1hZ2VTZXQuaW1hZ2VzW01hdGgucm91bmQodGhpcy5jdXJyZW50RnJhbWUpXTtcbiAgICAgICAgdGhpcy5kcmF3KGltYWdlU291cmNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmx1c2ggdGhlIGRyYXcgY2FjaGUuXG4gICAgICovXG4gICAgZmx1c2goKSB7XG4gICAgICAgIHRoaXMuZHJhdygnJyk7IC8vIE1ha2UgYSBlbXB0eSBjYWxsIHRvIGNsZWFyIHRoZSBtZW1vaXplIGNhY2hlLlxuICAgICAgICB0aGlzLmRyYXcobnVsbCk7XG4gICAgfVxuICAgIGFzeW5jIGRyYXcoaW1hZ2VTb3VyY2UpIHtcbiAgICAgICAgLy8gUHJldmVudCBpbnZhbGlkIGRyYXdzXG4gICAgICAgIGlmICghaW1hZ2VTb3VyY2UgfHwgdGhpcy5kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbWFnZVNvdXJjZSA9PT0gdGhpcy5sYXN0RHJhd1NvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbid0IGRyYXcgb24gYSAwIGFyZWEgY2FudmFzXG4gICAgICAgIGlmICghdGhpcy5jYW52YXNXaWR0aCB8fCAhdGhpcy5jYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3REcmF3U291cmNlID0gaW1hZ2VTb3VyY2U7XG4gICAgICAgIC8vIElmIHRoaXMgd2FzIGNhbGxlZCBhdCBhIHJhdGUgZXhjZWVkaW5nIHRoZSBmcHMgbGltaXQuXG4gICAgICAgIGlmICghdGhpcy5mcHMuY2FuUnVuKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZnBzLnNjaGVkdWxlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBhIGRyYXcuICBUaGlzIGVuc3VyZXMgdGhhdCBldmVuIHdpdGggRlBTIGxpbWl0aW5nLFxuICAgICAgICAgICAgICAgIC8vIHRoZSB2ZXJ5IGxhc3QgZHJhdyBjYWxsIGlzIGFsd2F5cyByZW5kZXJlZC5cbiAgICAgICAgICAgICAgICB0aGlzLmxhc3REcmF3U291cmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXcoaW1hZ2VTb3VyY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1hZ2UgPSBhd2FpdCB0aGlzLm1ha2VJbWFnZShpbWFnZVNvdXJjZSk7XG4gICAgICAgIC8vIERlY29kaW5nIGltYWdlcyBpbiB0aGlzIHdheSwgd2Ugc2VlIGEgaHVnZSBtZW1vcnkganVtcC4gIEF2b2lkIGZvciBub3cuXG4gICAgICAgIC8vIGF3YWl0IGltYWdlLmRlY29kZSgpO1xuICAgICAgICAvLyBJZiBhbiBpbWFnZSBjb3VsZG4ndCBiZSBnZW5lcmF0ZWQgZm9yIHNvbWUgcmVhc29uLlxuICAgICAgICBpZiAoIWltYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW1hZ2VCb3ggPSB7XG4gICAgICAgICAgICB3aWR0aDogdGhpcy5pbWFnZU5hdHVyYWxXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5pbWFnZU5hdHVyYWxIZWlnaHQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckJveCA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLmNhbnZhc1dpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmNhbnZhc0hlaWdodCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBsZXQgd2lkdGg7XG4gICAgICAgIGxldCBoZWlnaHQ7XG4gICAgICAgIC8vIEJhY2tncm91bmQgXCJjb3ZlclwiIHNpemluZy5cbiAgICAgICAgLy8gRGVmYXVsdHMgdG8gY2VudGVyLlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5jb3Zlcikge1xuICAgICAgICAgICAgY29uc3QgY292ZXIgPSBtYXRoZl8xLm1hdGhmLmNhbGN1bGF0ZUJhY2tncm91bmRDb3Zlcihjb250YWluZXJCb3gsIGltYWdlQm94KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgaXNfMS5pcy5udW1iZXIodGhpcy5vcHRpb25zLmxlZnQpKSB7XG4gICAgICAgICAgICAgICAgY292ZXIueE9mZnNldCA9XG4gICAgICAgICAgICAgICAgICAgIChjb250YWluZXJCb3gud2lkdGggLSBpbWFnZUJveC53aWR0aCAqIGNvdmVyLnNjYWxhcikgKlxuICAgICAgICAgICAgICAgICAgICAgICAgLXRoaXMub3B0aW9ucy5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiBpc18xLmlzLm51bWJlcih0aGlzLm9wdGlvbnMucmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gUmlnaHQgYWxpZ24gZmlyc3QuXG4gICAgICAgICAgICAgICAgY292ZXIueE9mZnNldCA9IC0oY29udGFpbmVyQm94LndpZHRoIC0gaW1hZ2VCb3gud2lkdGggKiBjb3Zlci5zY2FsYXIpO1xuICAgICAgICAgICAgICAgIGNvdmVyLnhPZmZzZXQgKz1cbiAgICAgICAgICAgICAgICAgICAgKGNvbnRhaW5lckJveC53aWR0aCAtIGltYWdlQm94LndpZHRoICogY292ZXIuc2NhbGFyKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIGlzXzEuaXMubnVtYmVyKHRoaXMub3B0aW9ucy5ib3R0b20pKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHRvIGJvdHRvbS5cbiAgICAgICAgICAgICAgICBjb3Zlci55T2Zmc2V0ID0gLShjb250YWluZXJCb3guaGVpZ2h0IC0gaW1hZ2VCb3guaGVpZ2h0ICogY292ZXIuc2NhbGFyKTtcbiAgICAgICAgICAgICAgICAvLyBDbGlwcGluZyBCb3R0b20gYWxnby5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHBlcmNlbnRhZ2UgYW1vdW50IHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBjb3Zlci55T2Zmc2V0ICs9XG4gICAgICAgICAgICAgICAgICAgIChjb250YWluZXJCb3guaGVpZ2h0IC0gaW1hZ2VCb3guaGVpZ2h0ICogY292ZXIuc2NhbGFyKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYm90dG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiBpc18xLmlzLm51bWJlcih0aGlzLm9wdGlvbnMudG9wKSkge1xuICAgICAgICAgICAgICAgIGNvdmVyLnlPZmZzZXQgPVxuICAgICAgICAgICAgICAgICAgICAoY29udGFpbmVyQm94LmhlaWdodCAtIGltYWdlQm94LmhlaWdodCAqIGNvdmVyLnNjYWxhcikgKlxuICAgICAgICAgICAgICAgICAgICAgICAgLXRoaXMub3B0aW9ucy50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ID0gLWNvdmVyLnhPZmZzZXQgPj4gMDtcbiAgICAgICAgICAgIHkgPSAtY292ZXIueU9mZnNldCA+PiAwO1xuICAgICAgICAgICAgd2lkdGggPSAoaW1hZ2VCb3gud2lkdGggKiBjb3Zlci5zY2FsYXIpID4+IDA7XG4gICAgICAgICAgICBoZWlnaHQgPSAoaW1hZ2VCb3guaGVpZ2h0ICogY292ZXIuc2NhbGFyKSA+PiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjb250YWluIHNpemluZyBhbGdvLlxuICAgICAgICAgICAgdGhpcy5jb250YWluU2NhbGUgPSBtYXRoZl8xLm1hdGhmLmNhbGN1bGF0ZUJhY2tncm91bmRDb250YWluKGNvbnRhaW5lckJveCwgaW1hZ2VCb3gpO1xuICAgICAgICAgICAgLy8gRGVmYXVsdCBjZW50ZXIgYWxnby5cbiAgICAgICAgICAgIGxldCBkaWZmWCA9IChjb250YWluZXJCb3gud2lkdGggLSBpbWFnZUJveC53aWR0aCAqIHRoaXMuY29udGFpblNjYWxlKSAvIDI7XG4gICAgICAgICAgICBsZXQgZGlmZlkgPSAoY29udGFpbmVyQm94LmhlaWdodCAtIGltYWdlQm94LmhlaWdodCAqIHRoaXMuY29udGFpblNjYWxlKSAvIDI7XG4gICAgICAgICAgICAvLyBTaXppbmcgb3B0aW9uIGxvZ2ljLlxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiBpc18xLmlzLm51bWJlcih0aGlzLm9wdGlvbnMuYm90dG9tKSkge1xuICAgICAgICAgICAgICAgIC8vIEJvdHRvbSBhbGlnbiBpdC5cbiAgICAgICAgICAgICAgICBkaWZmWSA9IGNvbnRhaW5lckJveC5oZWlnaHQgLSBpbWFnZUJveC5oZWlnaHQgKiB0aGlzLmNvbnRhaW5TY2FsZTtcbiAgICAgICAgICAgICAgICAvLyBFYXN5IHdheSB0byB0ZXN0IHRoaXMgaXMgdG8gc2V0IGJvdHRvbTogMSBhbmRcbiAgICAgICAgICAgICAgICAvLyBib3R0b21DbGlwcGluZzogZmFsc2Ugd2hpY2ggd291bGQgdG9wIGFsaWduIHRoZSBpbWFnZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJvdHRvbU5vQ2xpcCkge1xuICAgICAgICAgICAgICAgICAgICBkaWZmWSAtPVxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnRhaW5lckJveC5oZWlnaHQgLSBpbWFnZUJveC5oZWlnaHQgKiB0aGlzLmNvbnRhaW5TY2FsZSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5ib3R0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGlwcGluZyBCb3R0b20gYWxnby5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBwZXJjZW50YWdlIGFtb3VudCBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGRpZmZZIC09IGNvbnRhaW5lckJveC5oZWlnaHQgKiB0aGlzLm9wdGlvbnMuYm90dG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgaXNfMS5pcy5udW1iZXIodGhpcy5vcHRpb25zLnJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIC8vIFJpZ2h0IGFsaWduIGl0LlxuICAgICAgICAgICAgICAgIGRpZmZYID0gY29udGFpbmVyQm94LndpZHRoIC0gaW1hZ2VCb3gud2lkdGggKiB0aGlzLmNvbnRhaW5TY2FsZTtcbiAgICAgICAgICAgICAgICAvLyBFYXN5IHdheSB0byB0ZXN0IHRoaXMgaXMgdG8gc2V0IHJpZ2h0OiAxIGFuZFxuICAgICAgICAgICAgICAgIC8vIHJpZ2h0Q2xpcHBpbmc6IGZhbHNlIHdoaWNoIHdvdWxkIGxlZnQgYWxpZ24gdGhlIGltYWdlLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmlnaHROb0NsaXApIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZlggLT1cbiAgICAgICAgICAgICAgICAgICAgICAgIChjb250YWluZXJCb3gud2lkdGggLSBpbWFnZUJveC53aWR0aCAqIHRoaXMuY29udGFpblNjYWxlKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xpcHBpbmcgcmlnaHQgYWxnby5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBwZXJjZW50YWdlIGFtb3VudCBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGRpZmZYIC09IGNvbnRhaW5lckJveC53aWR0aCAqIHRoaXMub3B0aW9ucy5yaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIGlzXzEuaXMubnVtYmVyKHRoaXMub3B0aW9ucy50b3ApKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9wIGFsaWduIGl0LlxuICAgICAgICAgICAgICAgIGRpZmZZID0gMDtcbiAgICAgICAgICAgICAgICAvLyBFYXN5IHdheSB0byB0ZXN0IHRoaXMgaXMgdG8gc2V0IHRvcDogMSBhbmRcbiAgICAgICAgICAgICAgICAvLyB0b3BDbGlwcGluZzogZmFsc2Ugd2hpY2ggd291bGQgYm90dG9tIGFsaWduZWQgdGhlIGltYWdlLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG9wTm9DbGlwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZmZZID1cbiAgICAgICAgICAgICAgICAgICAgICAgIChjb250YWluZXJCb3guaGVpZ2h0IC0gaW1hZ2VCb3guaGVpZ2h0ICogdGhpcy5jb250YWluU2NhbGUpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xpcHBpbmcgVG9wIGFsZ28uXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcGVyY2VudGFnZSBhbW91bnQgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBkaWZmWSArPSB0aGlzLm9wdGlvbnMudG9wICogY29udGFpbmVyQm94LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIGlzXzEuaXMubnVtYmVyKHRoaXMub3B0aW9ucy5sZWZ0KSkge1xuICAgICAgICAgICAgICAgIC8vIExlZnQgYWxpZ24gaXQuXG4gICAgICAgICAgICAgICAgZGlmZlggPSAwO1xuICAgICAgICAgICAgICAgIC8vIEVhc3kgd2F5IHRvIHRlc3QgdGhpcyBpcyB0byBzZXQgbGVmdDogMSBhbmRcbiAgICAgICAgICAgICAgICAvLyBsZWZ0Q2xpcHBpbmc6IGZhbHNlIHdoaWNoIHdvdWxkIHJpZ2h0IGFsaWduZWQgdGhlIGltYWdlLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGVmdE5vQ2xpcCkge1xuICAgICAgICAgICAgICAgICAgICBkaWZmWCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAoY29udGFpbmVyQm94LndpZHRoIC0gaW1hZ2VCb3gud2lkdGggKiB0aGlzLmNvbnRhaW5TY2FsZSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xpcHBpbmcgbGVmdCBhbGdvLlxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHBlcmNlbnRhZ2UgYW1vdW50IHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgZGlmZlggKz0gdGhpcy5vcHRpb25zLmxlZnQgKiBjb250YWluZXJCb3gud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCA9IGRpZmZYID4+IDA7XG4gICAgICAgICAgICB5ID0gZGlmZlkgPj4gMDtcbiAgICAgICAgICAgIHdpZHRoID0gKGltYWdlQm94LndpZHRoICogdGhpcy5jb250YWluU2NhbGUpID4+IDA7XG4gICAgICAgICAgICBoZWlnaHQgPSAoaW1hZ2VCb3guaGVpZ2h0ICogdGhpcy5jb250YWluU2NhbGUpID4+IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2ViR0wgRHJhdy5cbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5wcm9ncmFtO1xuICAgICAgICBjb25zdCBhUG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYV9wb3NpdGlvbicpO1xuICAgICAgICBjb25zdCB1TWF0cml4ID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1X21hdHJpeCcpO1xuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuY2FudmFzV2lkdGggKiB0aGlzLmRwciwgdGhpcy5jYW52YXNIZWlnaHQgKiB0aGlzLmRwcik7XG4gICAgICAgIC8vIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgIC8vIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICB3ZWJnbF8xLndlYmdsLmNyZWF0ZVZibyhnbCwgW1xuICAgICAgICAgICAgMC4wLFxuICAgICAgICAgICAgMC4wLFxuICAgICAgICAgICAgMS4wLFxuICAgICAgICAgICAgMC4wLFxuICAgICAgICAgICAgMC4wLFxuICAgICAgICAgICAgMS4wLFxuICAgICAgICAgICAgMC4wLFxuICAgICAgICAgICAgMS4wLFxuICAgICAgICAgICAgMS4wLFxuICAgICAgICAgICAgMC4wLFxuICAgICAgICAgICAgMS4wLFxuICAgICAgICAgICAgMS4wLFxuICAgICAgICBdKTtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYVBvc2l0aW9uKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhUG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB3ZWJnbF8xLndlYmdsLmNyZWF0ZVRleHR1cmVGcm9tSW1hZ2UoZ2wsIGltYWdlKTtcbiAgICAgICAgLy8gQ29udmVydCBwaXhlbCBjb29yZHMgdG8gZ2wgY29vcmRzIGJhc2VkIG9uIHRoZSB4LCB5LCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIC8vIHZhbHVlcyBjYWxjdWxhdGVkIGFib3ZlLlxuICAgICAgICBjb25zdCBjbGlwWCA9ICh4IC8gdGhpcy5jYW52YXNXaWR0aCkgKiAyIC0gMTtcbiAgICAgICAgY29uc3QgY2xpcFkgPSAoeSAvIHRoaXMuY2FudmFzSGVpZ2h0KSAqIC0yICsgMTtcbiAgICAgICAgY29uc3QgY2xpcFdpZHRoID0gKHdpZHRoIC8gdGhpcy5jYW52YXNXaWR0aCkgKiAyO1xuICAgICAgICBjb25zdCBjbGlwSGVpZ2h0ID0gKGhlaWdodCAvIHRoaXMuY2FudmFzSGVpZ2h0KSAqIC0yO1xuICAgICAgICAvLyBTdHJldGNoIG91dCB1bml0IHF1YWQuXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodU1hdHJpeCwgZmFsc2UsIFtcbiAgICAgICAgICAgIGNsaXBXaWR0aCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGNsaXBIZWlnaHQsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgY2xpcFgsXG4gICAgICAgICAgICBjbGlwWSxcbiAgICAgICAgICAgIDEsXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBEcmF3IHRoZSByZWN0YW5nbGUuXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcbiAgICAgICAgLy8gQ2xlYXIgVlJBTSBtZW1vcnkgYnkgZGVsZXRpbmcgdGhlIHRleHR1cmUgYWZ0ZXIgcmVuZGVyLlxuICAgICAgICB3ZWJnbF8xLndlYmdsLmRlbGV0ZVRleHR1cmUoZ2wsIHRleHR1cmUpO1xuICAgICAgICB0aGlzLmxhc3RSZW5kZXJTb3VyY2UgPSBpbWFnZVNvdXJjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgc2l6aW5nIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBzZXRTaXppbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxheXMgdGhlIGNhbnZhcyBpbWFnZSBzZXF1ZW5jZSB3aXRoIGEgdGltZXIuIFBsYXlpbmcgd2lsbCBcImhpamFja1wiIHRoZVxuICAgICAqIHByb2dyZXNzIGV2ZW50cyB3aGlsZSBwbGF5aW5nLiAgIEZvciBleGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiAgICBjYW52YXNJbWFnZVNlcXVlbmNlLnBsYXkoMCwgMSwgMzAwMCkudGhlbigoKSA9PiB7XG4gICAgICogICAgICAgY29uc29sZS5sb2coJ3BsYXkgY29tcGxldGUnKTtcbiAgICAgKiAgIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogSGVyZSB3ZSB0ZWxsIHRoZSBjYW52YXNJbWFnZVNlcXVlbmNlIHRvIHBsYXkgZnJvbSBzdGFydCB0byBlbmQgb3ZlclxuICAgICAqIGEgMzAwMG1zIHBlcmlvZC4gIER1cmluZyB0aGlzIDMwMDBtcyBwZXJpb2QsIGFueSBjYWxscyBvdGhlciB0b1xuICAgICAqIGNhbGxzIFwicmVuZGVyQnlQcm9ncmVzc1wiIHdpbGwgZ2V0IGlnbm9yZWQgc2luY2UgdGhleSBjYW4gY29uZmxpY3Qgd2l0aFxuICAgICAqIHRoZSBwbGF5YmFjay5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb20gQSBudW1iZXIgYmV0d2VlbiAwIC0gMVxuICAgICAqIEBwYXJhbSB0byBBIG51bWJlciBiZXR3ZWVuIDAgLSAxXG4gICAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBpbiBtcy5cbiAgICAgKiBAcmV0dXJuIFByb21pc2UgQSBwcm9taXNlIHRoYXQgY29tcGxldGVzIHdoZW4gZG9uZS5cbiAgICAgKi9cbiAgICBwbGF5KGZyb20sIHRvLCBkdXJhdGlvbikge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5yYWZUaW1lciA9IG5ldyByYWZfdGltZXJfMS5SYWZUaW1lcigocHJvZ3Jlc3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRlZFByb2dyZXNzID0gbWF0aGZfMS5tYXRoZi5pbnRlcnBvbGF0ZVJhbmdlKHByb2dyZXNzLCAwLCAxLCBmcm9tLCB0byk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclByb2dyZXNzKGludGVycG9sYXRlZFByb2dyZXNzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmFmVGltZXIuc2V0RHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICB0aGlzLnBsYXlEZWZlciA9IG5ldyBkZWZlcl8xLkRlZmVyKCk7XG4gICAgICAgIHRoaXMucmFmVGltZXIub25Db21wbGV0ZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wbGF5RGVmZXIucmVzb2x2ZSgpO1xuICAgICAgICAgICAgdGhpcy5yYWZUaW1lci5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJhZlRpbWVyLnBsYXkoKTtcbiAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5wbGF5RGVmZXIuZ2V0UHJvbWlzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbW1lZGlhdGVseSBzdG9wcyB0aGUgY2FudmFzIGFuaW1hdGlvbiBwbGF5aW5nLlxuICAgICAqICh0aGF0IGhhcHBlbnMgd2l0aCBwbGF5IG1ldGhvZCkuXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5yYWZUaW1lciAmJiB0aGlzLnJhZlRpbWVyLnBhdXNlKCk7XG4gICAgICAgIHRoaXMucmFmVGltZXIgJiYgdGhpcy5yYWZUaW1lci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMucGxheURlZmVyICYmIHRoaXMucGxheURlZmVyLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW1hZ2UgZGltZW5zaW9uIHRoYXQgd2VyZSBmZXRjaGVkLiAgVGhpcyBpcyBiYXNlZFxuICAgICAqIG9uIHRoZSBcImZpcnN0XCIgaW1hZ2UgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAqIFRoZSBzaXplcyB3aWxsIGJlIG51bGwgaWYgY2FsbGVkIHByaW9yIHRvIGxvYWRpbmcgaW1hZ2VzLlxuICAgICAqL1xuICAgIGdldEltYWdlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLmltYWdlTmF0dXJhbFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmltYWdlTmF0dXJhbEhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB0aGlzLmRvbVdhdGNoZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnJhZlRpbWVyICYmIHRoaXMucmFmVGltZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmJsb2JMb2FkZXIgJiYgdGhpcy5ibG9iTG9hZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgLy8gdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgLy8gdGhpcy5ibG9iQ2FjaGUgPSBudWxsO1xuICAgICAgICAvLyB0aGlzLmNhbnZhc0VsZW1lbnQgPSBudWxsO1xuICAgICAgICBkb21fMS5kb20uZGVsZXRlSW1hZ2UodGhpcy5jYWNoZUltYWdlKTtcbiAgICAgICAgLy8gdGhpcy5jYWNoZUltYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJHbEltYWdlU2VxdWVuY2UgPSBXZWJHbEltYWdlU2VxdWVuY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJnbC1pbWFnZS1zZXF1ZW5jZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/dom/webgl-image-sequence.js\n");

/***/ }),

/***/ "./lib/dom/webgl.js":
/*!**************************!*\
  !*** ./lib/dom/webgl.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.webgl = void 0;\n/**\n * Set of webGl helper methods.\n */\nclass webgl {\n    /**\n     * @param gl WebGlRenderingContext\n     * @param vs  Vertex shader\n     * @param fr  Frag shader\n     */\n    static createProgram(gl, vs, fr) {\n        // Create program\n        const program = gl.createProgram();\n        // Compile vertex shader\n        const vShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vShader, vs);\n        gl.compileShader(vShader);\n        // Compile frag shader\n        const fShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fShader, fr);\n        gl.compileShader(fShader);\n        gl.attachShader(program, vShader);\n        gl.deleteShader(vShader);\n        gl.attachShader(program, fShader);\n        gl.deleteShader(fShader);\n        gl.linkProgram(program);\n        return program;\n    }\n    /**\n     * Create VBO.\n     * @param gl\n     * @param data\n     */\n    static createVbo(gl, data) {\n        const vbo = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);\n        return vbo;\n    }\n    /**\n     * Creates a text from image.  Requires that the image is already loaded.\n     * @param source\n     */\n    static createTextureFromImage(gl, image) {\n        const texture = gl.createTexture();\n        // https://stackoverflow.com/questions/39341564/webgl-how-to-correctly-blend-alpha-channel-png\n        // Set correct transparency to support pngs.\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        // Set the parameters so we can render any size image.\n        // We assume the image is NOT power of 2.\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        // Use linear to get best quality.\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n        return texture;\n    }\n    /**\n     * Deletes texture from GPU memory.\n     * @param gl\n     * @param texture\n     */\n    static deleteTexture(gl, texture) {\n        gl.deleteTexture(texture);\n    }\n}\nexports.webgl = webgl;\n//# sourceMappingURL=webgl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZG9tL3dlYmdsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2RvbS93ZWJnbC5qcz9mZGRiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53ZWJnbCA9IHZvaWQgMDtcbi8qKlxuICogU2V0IG9mIHdlYkdsIGhlbHBlciBtZXRob2RzLlxuICovXG5jbGFzcyB3ZWJnbCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGdsIFdlYkdsUmVuZGVyaW5nQ29udGV4dFxuICAgICAqIEBwYXJhbSB2cyAgVmVydGV4IHNoYWRlclxuICAgICAqIEBwYXJhbSBmciAgRnJhZyBzaGFkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUHJvZ3JhbShnbCwgdnMsIGZyKSB7XG4gICAgICAgIC8vIENyZWF0ZSBwcm9ncmFtXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgIC8vIENvbXBpbGUgdmVydGV4IHNoYWRlclxuICAgICAgICBjb25zdCB2U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICAgICAgICBnbC5zaGFkZXJTb3VyY2UodlNoYWRlciwgdnMpO1xuICAgICAgICBnbC5jb21waWxlU2hhZGVyKHZTaGFkZXIpO1xuICAgICAgICAvLyBDb21waWxlIGZyYWcgc2hhZGVyXG4gICAgICAgIGNvbnN0IGZTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKGZTaGFkZXIsIGZyKTtcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihmU2hhZGVyKTtcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZTaGFkZXIpO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIodlNoYWRlcik7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmU2hhZGVyKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZTaGFkZXIpO1xuICAgICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBWQk8uXG4gICAgICogQHBhcmFtIGdsXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlVmJvKGdsLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHZibyA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdmJvKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoZGF0YSksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgcmV0dXJuIHZibztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRleHQgZnJvbSBpbWFnZS4gIFJlcXVpcmVzIHRoYXQgdGhlIGltYWdlIGlzIGFscmVhZHkgbG9hZGVkLlxuICAgICAqIEBwYXJhbSBzb3VyY2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlVGV4dHVyZUZyb21JbWFnZShnbCwgaW1hZ2UpIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzkzNDE1NjQvd2ViZ2wtaG93LXRvLWNvcnJlY3RseS1ibGVuZC1hbHBoYS1jaGFubmVsLXBuZ1xuICAgICAgICAvLyBTZXQgY29ycmVjdCB0cmFuc3BhcmVuY3kgdG8gc3VwcG9ydCBwbmdzLlxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRydWUpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgLy8gU2V0IHRoZSBwYXJhbWV0ZXJzIHNvIHdlIGNhbiByZW5kZXIgYW55IHNpemUgaW1hZ2UuXG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGUgaW1hZ2UgaXMgTk9UIHBvd2VyIG9mIDIuXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgLy8gVXNlIGxpbmVhciB0byBnZXQgYmVzdCBxdWFsaXR5LlxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0ZXh0dXJlIGZyb20gR1BVIG1lbW9yeS5cbiAgICAgKiBAcGFyYW0gZ2xcbiAgICAgKiBAcGFyYW0gdGV4dHVyZVxuICAgICAqL1xuICAgIHN0YXRpYyBkZWxldGVUZXh0dXJlKGdsLCB0ZXh0dXJlKSB7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgfVxufVxuZXhwb3J0cy53ZWJnbCA9IHdlYmdsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViZ2wuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/dom/webgl.js\n");

/***/ }),

/***/ "./lib/ease/ease.js":
/*!**************************!*\
  !*** ./lib/ease/ease.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EASE = void 0;\n/**\n * Basis easing functions.\n * @see https://easings.net/en for nice visualization of each.\n *\n */\nclass EASE {\n    /**\n     * Eases the value in with a Sine curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    static easeInSine(t) {\n        return t === 0 || t === 1 ? t : 1 - Math.cos(t * (Math.PI / 2));\n    }\n    /**\n     * Eases the value out with a Sine curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    static easeOutSine(t) {\n        return t === 0 || t === 1 ? t : Math.sin(t * (Math.PI / 2));\n    }\n    /**\n     * Eases the value in and out with a Sine curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    static easeInOutSine(t) {\n        return t === 0 || t === 1 ? t : -0.5 * (Math.cos(Math.PI * t) - 1);\n    }\n    /**\n     * Eases the value in with a quadratic curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    static easeInQuad(t) {\n        return t === 0 || t === 1 ? t : t * t;\n    }\n    /**\n     * Eases the value out with a quadratic curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    static easeOutQuad(t) {\n        return t === 0 || t === 1 ? t : t * (2 - t);\n    }\n    /**\n     * Eases the value in with a cubic curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInCubic(t) {\n        return t === 0 || t === 1 ? t : t * t * t;\n    }\n    /**\n     * Eases the value in and out with a quadratic curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    static easeInOutQuad(t) {\n        if (t === 0 || t === 1) {\n            return t;\n        }\n        else if (t < 0.5) {\n            return 2 * t * t;\n        }\n        else {\n            return -1 + (4 - 2 * t) * t;\n        }\n    }\n    /**\n     * Eases the value out with a cubic curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeOutCubic(t) {\n        return t === 0 || t === 1 ? t : --t * t * t + 1;\n    }\n    /**\n     * Eases the value in and out with a cubic curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     */\n    static easeInOutCubic(t) {\n        if (t === 0 || t === 1) {\n            return t;\n        }\n        else if (t < 0.5) {\n            return 4 * t * t * t;\n        }\n        else {\n            return (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n        }\n    }\n    /**\n     * Eases the value in with a quartic curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInQuart(t) {\n        return t === 0 || t === 1 ? t : t * t * t * t;\n    }\n    /**\n     * Eases the value out with a quartic curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeOutQuart(t) {\n        return t === 0 || t === 1 ? t : 1 - --t * t * t * t;\n    }\n    /**\n     * Eases the value in and out with a quartic curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInOutQuart(t) {\n        if (t === 0 || t === 1) {\n            return t;\n        }\n        else if (t < 0.5) {\n            return 8 * t * t * t * t;\n        }\n        else {\n            return 1 - 8 * --t * t * t * t;\n        }\n    }\n    /**\n     * Eases the value in with a quintic curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInQuint(t) {\n        return t === 0 || t === 1 ? t : t * t * t * t * t;\n    }\n    /**\n     * Eases the value out with a quintic curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeOutQuint(t) {\n        return t === 0 || t === 1 ? t : 1 + --t * t * t * t * t;\n    }\n    /**\n     * Eases the value in and out with a quintic curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInOutQuint(t) {\n        return t === 0 || t === 1\n            ? t\n            : t < 0.5\n                ? 16 * t * t * t * t * t\n                : 1 + 16 * --t * t * t * t * t;\n    }\n    /**\n     * Eases the value in with an exponential curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInExpo(t) {\n        return t === 0 || t === 1 ? t : Math.pow(2, 10 * (t - 1));\n    }\n    /**\n     * Eases the value out with an exponential curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeOutExpo(t) {\n        return t === 0 || t === 1 ? t : 1 - Math.pow(2, -10 * t);\n    }\n    /**\n     * Eases the value in and out with an exponential curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInOutExpo(t) {\n        if (t === 0 || t === 1) {\n            return t;\n        }\n        else if (t < 0.5) {\n            return 0.5 * Math.pow(2, 10 * (t * 2 - 1));\n        }\n        else {\n            return 0.5 * (2 - Math.pow(2, -10 * (t * 2 - 1)));\n        }\n    }\n    /**\n     * Eases the value in with a circular curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInCirc(t) {\n        return t === 0 || t === 1 ? t : 1 - Math.sqrt(1 - t * t);\n    }\n    /**\n     * Eases the value out with a circular curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeOutCirc(t) {\n        return t === 0 || t === 1 ? t : Math.sqrt(1 - (t - 1) * (t - 1));\n    }\n    /**\n     * Eases the value in and out with a circular curve.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInOutCirc(t) {\n        if (t === 0 || t === 1) {\n            return t;\n        }\n        else if (t < 0.5) {\n            return -0.5 * (Math.sqrt(1 - t * t * 4) - 1);\n        }\n        else {\n            return 0.5 * (Math.sqrt(1 - 4 * (t - 1) * (t - 1)) + 1);\n        }\n    }\n    /**\n     * Eases the value in after bounding backwards at the beginning.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInBack(t) {\n        return t === 0 || t === 1 ? t : t * t * (2.70158 * t - 1.70158);\n    }\n    /**\n     * Eases the value out after bounding past the end point and back.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeOutBack(t) {\n        return t === 0 || t === 1\n            ? t\n            : (t - 1) * (t - 1) * (2.70158 * (t - 1) + 1.70158) + 1;\n    }\n    /**\n     * Eases the value in and out with an initial and ending movement beyond the\n     * full range.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInOutBack(t) {\n        if (t === 0 || t === 1) {\n            return t;\n        }\n        else if (t < 0.5) {\n            return 0.5 * (t * 2) * (t * 2) * (3.5949095 * (t * 2) - 2.5949095);\n        }\n        else {\n            return (0.5 *\n                ((t * 2 - 2) * (t * 2 - 2) * (3.5949095 * (t * 2 - 2) + 2.5949095) + 2));\n        }\n    }\n    /**\n     * Eases the value in with an elastic springy motion.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInElastic(t) {\n        if (t === 0 || t === 1) {\n            return t;\n        }\n        else {\n            return (-1 *\n                (Math.pow(2, 10 * (t - 1)) *\n                    Math.sin(((t - 1.075) * (2 * Math.PI)) / 0.3)));\n        }\n    }\n    /**\n     * Eases the value out with an elastic springy motion.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeOutElastic(t) {\n        return t === 0 || t === 1\n            ? t\n            : Math.pow(2, -10 * t) * Math.sin(((t - 0.075) * (2 * Math.PI)) / 0.3) +\n                1;\n    }\n    /**\n     * Eases the value in and out with an elastic springy motion.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInOutElastic(t) {\n        if (t === 0 || t === 1) {\n            return t;\n        }\n        else if (t < 0.5) {\n            return (-0.5 *\n                (Math.pow(2, 10 * (t * 2 - 1)) *\n                    Math.sin(((t * 2 - 1.1125) * 2 * Math.PI) / 0.45)));\n        }\n        else {\n            return (0.5 *\n                Math.pow(2, -10 * (t * 2 - 1)) *\n                Math.sin(((t * 2 - 1.1125) * 2 * Math.PI) / 0.45) +\n                1);\n        }\n    }\n    /**\n     * Eases the value in with a simple physics bounce.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInBounce(t) {\n        return t === 0 || t === 1 ? t : 1 - EASE.easeOutBounce(1 - t);\n    }\n    /**\n     * Eases the value out with a simple physics bounce.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeOutBounce(t) {\n        if (t === 0 || t === 1) {\n            return t;\n        }\n        else if (t < 1 / 2.75) {\n            return 7.5625 * t * t;\n        }\n        else if (t < 2 / 2.75) {\n            return 7.5625 * (t - 1.5 / 2.75) * (t - 1.5 / 2.75) + 0.75;\n        }\n        else if (t < 2.5 / 2.75) {\n            return 7.5625 * (t - 2.25 / 2.75) * (t - 2.25 / 2.75) + 0.9375;\n        }\n        else {\n            return 7.5625 * (t - 2.625 / 2.75) * (t - 2.625 / 2.75) + 0.984375;\n        }\n    }\n    /**\n     * Eases the value in and out with starting and ending bounces.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static easeInOutBounce(t) {\n        if (t === 0 || t === 1) {\n            return t;\n        }\n        else if (t < 0.5) {\n            return EASE.easeInBounce(t * 2) * 0.5;\n        }\n        else {\n            return EASE.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n        }\n    }\n    /**\n     * Returns the value without any easing. This is only useful if a script is\n     * expecting an easing method, but one isn't needed in that instance.\n     * @param {number} t Input between 0 and 1.\n     * @return {number} Output between 0 and 1.\n     *\n     */\n    static linear(t) {\n        return t;\n    }\n}\nexports.EASE = EASE;\n//# sourceMappingURL=ease.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZWFzZS9lYXNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2Vhc2UvZWFzZS5qcz84N2FhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FQVNFID0gdm9pZCAwO1xuLyoqXG4gKiBCYXNpcyBlYXNpbmcgZnVuY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Vhc2luZ3MubmV0L2VuIGZvciBuaWNlIHZpc3VhbGl6YXRpb24gb2YgZWFjaC5cbiAqXG4gKi9cbmNsYXNzIEVBU0Uge1xuICAgIC8qKlxuICAgICAqIEVhc2VzIHRoZSB2YWx1ZSBpbiB3aXRoIGEgU2luZSBjdXJ2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqL1xuICAgIHN0YXRpYyBlYXNlSW5TaW5lKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiAxIC0gTWF0aC5jb3ModCAqIChNYXRoLlBJIC8gMikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYXNlcyB0aGUgdmFsdWUgb3V0IHdpdGggYSBTaW5lIGN1cnZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICovXG4gICAgc3RhdGljIGVhc2VPdXRTaW5lKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiBNYXRoLnNpbih0ICogKE1hdGguUEkgLyAyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVhc2VzIHRoZSB2YWx1ZSBpbiBhbmQgb3V0IHdpdGggYSBTaW5lIGN1cnZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICovXG4gICAgc3RhdGljIGVhc2VJbk91dFNpbmUodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gMCB8fCB0ID09PSAxID8gdCA6IC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQpIC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVhc2VzIHRoZSB2YWx1ZSBpbiB3aXRoIGEgcXVhZHJhdGljIGN1cnZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICovXG4gICAgc3RhdGljIGVhc2VJblF1YWQodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gMCB8fCB0ID09PSAxID8gdCA6IHQgKiB0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYXNlcyB0aGUgdmFsdWUgb3V0IHdpdGggYSBxdWFkcmF0aWMgY3VydmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZWFzZU91dFF1YWQodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gMCB8fCB0ID09PSAxID8gdCA6IHQgKiAoMiAtIHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYXNlcyB0aGUgdmFsdWUgaW4gd2l0aCBhIGN1YmljIGN1cnZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZWFzZUluQ3ViaWModCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gMCB8fCB0ID09PSAxID8gdCA6IHQgKiB0ICogdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRWFzZXMgdGhlIHZhbHVlIGluIGFuZCBvdXQgd2l0aCBhIHF1YWRyYXRpYyBjdXJ2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqL1xuICAgIHN0YXRpYyBlYXNlSW5PdXRRdWFkKHQpIHtcbiAgICAgICAgaWYgKHQgPT09IDAgfHwgdCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodCA8IDAuNSkge1xuICAgICAgICAgICAgcmV0dXJuIDIgKiB0ICogdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMSArICg0IC0gMiAqIHQpICogdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYXNlcyB0aGUgdmFsdWUgb3V0IHdpdGggYSBjdWJpYyBjdXJ2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGVhc2VPdXRDdWJpYyh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAwIHx8IHQgPT09IDEgPyB0IDogLS10ICogdCAqIHQgKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYXNlcyB0aGUgdmFsdWUgaW4gYW5kIG91dCB3aXRoIGEgY3ViaWMgY3VydmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZWFzZUluT3V0Q3ViaWModCkge1xuICAgICAgICBpZiAodCA9PT0gMCB8fCB0ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0IDwgMC41KSB7XG4gICAgICAgICAgICByZXR1cm4gNCAqIHQgKiB0ICogdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRWFzZXMgdGhlIHZhbHVlIGluIHdpdGggYSBxdWFydGljIGN1cnZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZWFzZUluUXVhcnQodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gMCB8fCB0ID09PSAxID8gdCA6IHQgKiB0ICogdCAqIHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVhc2VzIHRoZSB2YWx1ZSBvdXQgd2l0aCBhIHF1YXJ0aWMgY3VydmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBlYXNlT3V0UXVhcnQodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gMCB8fCB0ID09PSAxID8gdCA6IDEgLSAtLXQgKiB0ICogdCAqIHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVhc2VzIHRoZSB2YWx1ZSBpbiBhbmQgb3V0IHdpdGggYSBxdWFydGljIGN1cnZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZWFzZUluT3V0UXVhcnQodCkge1xuICAgICAgICBpZiAodCA9PT0gMCB8fCB0ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0IDwgMC41KSB7XG4gICAgICAgICAgICByZXR1cm4gOCAqIHQgKiB0ICogdCAqIHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIDggKiAtLXQgKiB0ICogdCAqIHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRWFzZXMgdGhlIHZhbHVlIGluIHdpdGggYSBxdWludGljIGN1cnZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZWFzZUluUXVpbnQodCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gMCB8fCB0ID09PSAxID8gdCA6IHQgKiB0ICogdCAqIHQgKiB0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYXNlcyB0aGUgdmFsdWUgb3V0IHdpdGggYSBxdWludGljIGN1cnZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZWFzZU91dFF1aW50KHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiAxICsgLS10ICogdCAqIHQgKiB0ICogdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRWFzZXMgdGhlIHZhbHVlIGluIGFuZCBvdXQgd2l0aCBhIHF1aW50aWMgY3VydmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBlYXNlSW5PdXRRdWludCh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAwIHx8IHQgPT09IDFcbiAgICAgICAgICAgID8gdFxuICAgICAgICAgICAgOiB0IDwgMC41XG4gICAgICAgICAgICAgICAgPyAxNiAqIHQgKiB0ICogdCAqIHQgKiB0XG4gICAgICAgICAgICAgICAgOiAxICsgMTYgKiAtLXQgKiB0ICogdCAqIHQgKiB0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYXNlcyB0aGUgdmFsdWUgaW4gd2l0aCBhbiBleHBvbmVudGlhbCBjdXJ2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGVhc2VJbkV4cG8odCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gMCB8fCB0ID09PSAxID8gdCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVhc2VzIHRoZSB2YWx1ZSBvdXQgd2l0aCBhbiBleHBvbmVudGlhbCBjdXJ2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGVhc2VPdXRFeHBvKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVhc2VzIHRoZSB2YWx1ZSBpbiBhbmQgb3V0IHdpdGggYW4gZXhwb25lbnRpYWwgY3VydmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBlYXNlSW5PdXRFeHBvKHQpIHtcbiAgICAgICAgaWYgKHQgPT09IDAgfHwgdCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodCA8IDAuNSkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDIsIDEwICogKHQgKiAyIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgyIC0gTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYXNlcyB0aGUgdmFsdWUgaW4gd2l0aCBhIGNpcmN1bGFyIGN1cnZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZWFzZUluQ2lyYyh0KSB7XG4gICAgICAgIHJldHVybiB0ID09PSAwIHx8IHQgPT09IDEgPyB0IDogMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYXNlcyB0aGUgdmFsdWUgb3V0IHdpdGggYSBjaXJjdWxhciBjdXJ2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGVhc2VPdXRDaXJjKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiBNYXRoLnNxcnQoMSAtICh0IC0gMSkgKiAodCAtIDEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRWFzZXMgdGhlIHZhbHVlIGluIGFuZCBvdXQgd2l0aCBhIGNpcmN1bGFyIGN1cnZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZWFzZUluT3V0Q2lyYyh0KSB7XG4gICAgICAgIGlmICh0ID09PSAwIHx8IHQgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHQgPCAwLjUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQgKiA0KSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIDQgKiAodCAtIDEpICogKHQgLSAxKSkgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYXNlcyB0aGUgdmFsdWUgaW4gYWZ0ZXIgYm91bmRpbmcgYmFja3dhcmRzIGF0IHRoZSBiZWdpbm5pbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBlYXNlSW5CYWNrKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiB0ICogdCAqICgyLjcwMTU4ICogdCAtIDEuNzAxNTgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYXNlcyB0aGUgdmFsdWUgb3V0IGFmdGVyIGJvdW5kaW5nIHBhc3QgdGhlIGVuZCBwb2ludCBhbmQgYmFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGVhc2VPdXRCYWNrKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09IDAgfHwgdCA9PT0gMVxuICAgICAgICAgICAgPyB0XG4gICAgICAgICAgICA6ICh0IC0gMSkgKiAodCAtIDEpICogKDIuNzAxNTggKiAodCAtIDEpICsgMS43MDE1OCkgKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYXNlcyB0aGUgdmFsdWUgaW4gYW5kIG91dCB3aXRoIGFuIGluaXRpYWwgYW5kIGVuZGluZyBtb3ZlbWVudCBiZXlvbmQgdGhlXG4gICAgICogZnVsbCByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGVhc2VJbk91dEJhY2sodCkge1xuICAgICAgICBpZiAodCA9PT0gMCB8fCB0ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0IDwgMC41KSB7XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKHQgKiAyKSAqICh0ICogMikgKiAoMy41OTQ5MDk1ICogKHQgKiAyKSAtIDIuNTk0OTA5NSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKDAuNSAqXG4gICAgICAgICAgICAgICAgKCh0ICogMiAtIDIpICogKHQgKiAyIC0gMikgKiAoMy41OTQ5MDk1ICogKHQgKiAyIC0gMikgKyAyLjU5NDkwOTUpICsgMikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVhc2VzIHRoZSB2YWx1ZSBpbiB3aXRoIGFuIGVsYXN0aWMgc3ByaW5neSBtb3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBlYXNlSW5FbGFzdGljKHQpIHtcbiAgICAgICAgaWYgKHQgPT09IDAgfHwgdCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKC0xICpcbiAgICAgICAgICAgICAgICAoTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc2luKCgodCAtIDEuMDc1KSAqICgyICogTWF0aC5QSSkpIC8gMC4zKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVhc2VzIHRoZSB2YWx1ZSBvdXQgd2l0aCBhbiBlbGFzdGljIHNwcmluZ3kgbW90aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZWFzZU91dEVsYXN0aWModCkge1xuICAgICAgICByZXR1cm4gdCA9PT0gMCB8fCB0ID09PSAxXG4gICAgICAgICAgICA/IHRcbiAgICAgICAgICAgIDogTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigoKHQgLSAwLjA3NSkgKiAoMiAqIE1hdGguUEkpKSAvIDAuMykgK1xuICAgICAgICAgICAgICAgIDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVhc2VzIHRoZSB2YWx1ZSBpbiBhbmQgb3V0IHdpdGggYW4gZWxhc3RpYyBzcHJpbmd5IG1vdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGVhc2VJbk91dEVsYXN0aWModCkge1xuICAgICAgICBpZiAodCA9PT0gMCB8fCB0ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0IDwgMC41KSB7XG4gICAgICAgICAgICByZXR1cm4gKC0wLjUgKlxuICAgICAgICAgICAgICAgIChNYXRoLnBvdygyLCAxMCAqICh0ICogMiAtIDEpKSAqXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc2luKCgodCAqIDIgLSAxLjExMjUpICogMiAqIE1hdGguUEkpIC8gMC40NSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoMC41ICpcbiAgICAgICAgICAgICAgICBNYXRoLnBvdygyLCAtMTAgKiAodCAqIDIgLSAxKSkgKlxuICAgICAgICAgICAgICAgIE1hdGguc2luKCgodCAqIDIgLSAxLjExMjUpICogMiAqIE1hdGguUEkpIC8gMC40NSkgK1xuICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVhc2VzIHRoZSB2YWx1ZSBpbiB3aXRoIGEgc2ltcGxlIHBoeXNpY3MgYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZWFzZUluQm91bmNlKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiAxIC0gRUFTRS5lYXNlT3V0Qm91bmNlKDEgLSB0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRWFzZXMgdGhlIHZhbHVlIG91dCB3aXRoIGEgc2ltcGxlIHBoeXNpY3MgYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgZWFzZU91dEJvdW5jZSh0KSB7XG4gICAgICAgIGlmICh0ID09PSAwIHx8IHQgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHQgPCAxIC8gMi43NSkge1xuICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIHQgKiB0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHQgPCAyIC8gMi43NSkge1xuICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqICh0IC0gMS41IC8gMi43NSkgKiAodCAtIDEuNSAvIDIuNzUpICsgMC43NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0IDwgMi41IC8gMi43NSkge1xuICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqICh0IC0gMi4yNSAvIDIuNzUpICogKHQgLSAyLjI1IC8gMi43NSkgKyAwLjkzNzU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKHQgLSAyLjYyNSAvIDIuNzUpICogKHQgLSAyLjYyNSAvIDIuNzUpICsgMC45ODQzNzU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRWFzZXMgdGhlIHZhbHVlIGluIGFuZCBvdXQgd2l0aCBzdGFydGluZyBhbmQgZW5kaW5nIGJvdW5jZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBlYXNlSW5PdXRCb3VuY2UodCkge1xuICAgICAgICBpZiAodCA9PT0gMCB8fCB0ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0IDwgMC41KSB7XG4gICAgICAgICAgICByZXR1cm4gRUFTRS5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEVBU0UuZWFzZU91dEJvdW5jZSh0ICogMiAtIDEpICogMC41ICsgMC41O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIHdpdGhvdXQgYW55IGVhc2luZy4gVGhpcyBpcyBvbmx5IHVzZWZ1bCBpZiBhIHNjcmlwdCBpc1xuICAgICAqIGV4cGVjdGluZyBhbiBlYXNpbmcgbWV0aG9kLCBidXQgb25lIGlzbid0IG5lZWRlZCBpbiB0aGF0IGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgbGluZWFyKHQpIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxufVxuZXhwb3J0cy5FQVNFID0gRUFTRTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVhc2UuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/ease/ease.js\n");

/***/ }),

/***/ "./lib/ease/easer.js":
/*!***************************!*\
  !*** ./lib/ease/easer.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Easer = void 0;\nconst time_1 = __webpack_require__(/*! ../time/time */ \"./lib/time/time.js\");\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst ease_1 = __webpack_require__(/*! ./ease */ \"./lib/ease/ease.js\");\nconst raf_1 = __webpack_require__(/*! ../raf/raf */ \"./lib/raf/raf.js\");\n/**\n * A very simple time based tween implementation.\n * TODO (uxder); Possibly refactor this to use raf-timer instead.\n *\n * ```ts\n * import { Raf, Easer} from '@blinkk/degu';\n *\n * // Simple example.\n * let easer = new Easer({\n *   duration: 200,\n *   delay: 100,\n *   easeFunction: EASE.linear\n * });\n * easer.onUpdate((easeValue, complete)=> {\n *   // Called on each raf cycle.\n *   // element.style.left = 100 * easeValue + 'px';\n * })\n *\n * // Start and listen to completion.\n * easer.start().then(()=> {\n *   console.log('easing is complete');\n * })\n *\n *\n * // Example where you want to handle raf updates on your own.\n * // Here we tell easer that we will be calling the easer.calculate method\n * // on raf.\n * let easer = new Easer({\n *   duration: 200,\n *   easeFunction: EASE.easeInOutExpo,\n *   disableRaf: true // Note that this option is set to true.\n * });\n * easer.onComplete(()=> {\n *   console.log('this gets called on completion');\n * })\n *\n * easer.onUpdate((easeValue, complete)=> {\n *   console.log('this gets called on each update');\n *   // Do something\n *   // element.style.left = 100 * easeValue + 'px';\n * })\n *\n * // Since we told easer to not internall update on raf, we need to\n * // call calculate and tell easer to calculate.\n * var raf = new Raf(()=> {\n *   easer.calculate();\n * });\n *\n * // As an example, we throttle our raf instance to 10 FPS so easer will\n * // only update at 10 frames per second.\n * raf.setFps(10);\n *\n * easer.start(); // Start easer\n * raf.start(); // Start raf so easer calculate is called.\n *\n * ```\n *\n *\n */\nclass Easer {\n    /**\n     * @param {easerConfig} The easing configuration\n     * @constructor\n     */\n    constructor(easerConfig) {\n        this.easerConfig = easerConfig;\n        // The current ms since Jan 1, 1970.\n        this.startTime_ = 0;\n        // The end time.\n        this.endTime_ = 0;\n        // The duration of the ease.\n        this.duration_ = easerConfig.duration || 0;\n        // The delay.\n        this.delay_ = easerConfig.delay || 0;\n        // The easing function.\n        this.easeFunction_ = easerConfig.easeFunction || ease_1.EASE.linear;\n        // A flag to test whether the easer has started.\n        this.started_ = false;\n        // A single complete callback.\n        this.completeCallback_ = null;\n        // A single update callback.\n        this.updateCallback_ = null;\n        // The resolving function for the complete promise (if used).\n        this.completePromiseResolve_ = null;\n        // Internal instance of raf.\n        this.raf_ = new raf_1.Raf(() => {\n            this.calculate();\n        });\n        // Whether raf is disabled.  When this option is true, easer will\n        // no longer interally call Raf and instead expects easer.calculate()\n        // to be called on each Raf.  Disabling raf within easer might be\n        // a more advanced usercase in which an application wants to\n        // have control over easer and it's calculate timings.\n        this.rafDisabled_ = easerConfig.disableRaf || false;\n    }\n    reset(easerConfig) {\n        if (easerConfig) {\n            // The duration of the ease.\n            this.duration_ = easerConfig.duration || this.duration_;\n            // The delay.\n            this.delay_ = easerConfig.delay || this.delay_;\n            // The easing function.\n            this.easeFunction_ = easerConfig.easeFunction || this.easeFunction_;\n        }\n        // Set started to false to stop progression.\n        this.started_ = false;\n        this.startTime_ = 0;\n        this.endTime_ = 0;\n        this.raf_ && this.raf_.stop();\n    }\n    /**\n     * Returns the internal instance of raf.\n     * @return The internal instance of raf.\n     */\n    getRaf() {\n        return this.raf_;\n    }\n    /**\n     * Starts the easing.\n     * @return Returns a promise that resolved when the animation completes.\n     */\n    start() {\n        this.startTime_ = time_1.time.now() + this.delay_;\n        this.endTime_ = this.startTime_ + this.duration_;\n        this.started_ = true;\n        if (!this.rafDisabled_) {\n            this.raf_ && this.raf_.start();\n        }\n        return new Promise(resolve => {\n            this.completePromiseResolve_ = resolve;\n        });\n    }\n    /**\n     * Adds a complete callback.\n     */\n    onComplete(callback) {\n        this.completeCallback_ = callback;\n    }\n    /**\n     * Adds a complete callback.\n     */\n    onUpdate(callback) {\n        this.updateCallback_ = callback;\n    }\n    /**\n     * Calculates the current ease.  This method should generally be\n     * called at 60FPS by Raf.\n     */\n    calculate() {\n        if (!this.started_) {\n            return;\n        }\n        const currentTime = time_1.time.now();\n        // Check to see if we are more than our start time.\n        if (currentTime < this.startTime_) {\n            return;\n        }\n        // The time passed since the ease started.\n        const timePassed = currentTime - (this.startTime_ || 0);\n        const percent = timePassed / this.duration_;\n        // A value between 0 and 1 representing the current state of progression.\n        const progression = this.easeFunction_(mathf_1.mathf.clamp(0, 1, percent));\n        let complete = false;\n        if (percent > 1) {\n            // Ensure the ease amount ends on 1.\n            this.updateCallback_ && this.updateCallback_(1, complete);\n            this.completeCallback_ && this.completeCallback_(1, complete);\n            this.completePromiseResolve_ && this.completePromiseResolve_(1, complete);\n            complete = true;\n            this.started_ = false;\n        }\n        else {\n            this.updateCallback_ && this.updateCallback_(progression, complete);\n        }\n    }\n    dispose() {\n        this.raf_ && this.raf_.stop();\n    }\n}\nexports.Easer = Easer;\n//# sourceMappingURL=easer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZWFzZS9lYXNlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9lYXNlL2Vhc2VyLmpzPzZiMDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVhc2VyID0gdm9pZCAwO1xuY29uc3QgdGltZV8xID0gcmVxdWlyZShcIi4uL3RpbWUvdGltZVwiKTtcbmNvbnN0IG1hdGhmXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvbWF0aGZcIik7XG5jb25zdCBlYXNlXzEgPSByZXF1aXJlKFwiLi9lYXNlXCIpO1xuY29uc3QgcmFmXzEgPSByZXF1aXJlKFwiLi4vcmFmL3JhZlwiKTtcbi8qKlxuICogQSB2ZXJ5IHNpbXBsZSB0aW1lIGJhc2VkIHR3ZWVuIGltcGxlbWVudGF0aW9uLlxuICogVE9ETyAodXhkZXIpOyBQb3NzaWJseSByZWZhY3RvciB0aGlzIHRvIHVzZSByYWYtdGltZXIgaW5zdGVhZC5cbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgUmFmLCBFYXNlcn0gZnJvbSAnQGJsaW5ray9kZWd1JztcbiAqXG4gKiAvLyBTaW1wbGUgZXhhbXBsZS5cbiAqIGxldCBlYXNlciA9IG5ldyBFYXNlcih7XG4gKiAgIGR1cmF0aW9uOiAyMDAsXG4gKiAgIGRlbGF5OiAxMDAsXG4gKiAgIGVhc2VGdW5jdGlvbjogRUFTRS5saW5lYXJcbiAqIH0pO1xuICogZWFzZXIub25VcGRhdGUoKGVhc2VWYWx1ZSwgY29tcGxldGUpPT4ge1xuICogICAvLyBDYWxsZWQgb24gZWFjaCByYWYgY3ljbGUuXG4gKiAgIC8vIGVsZW1lbnQuc3R5bGUubGVmdCA9IDEwMCAqIGVhc2VWYWx1ZSArICdweCc7XG4gKiB9KVxuICpcbiAqIC8vIFN0YXJ0IGFuZCBsaXN0ZW4gdG8gY29tcGxldGlvbi5cbiAqIGVhc2VyLnN0YXJ0KCkudGhlbigoKT0+IHtcbiAqICAgY29uc29sZS5sb2coJ2Vhc2luZyBpcyBjb21wbGV0ZScpO1xuICogfSlcbiAqXG4gKlxuICogLy8gRXhhbXBsZSB3aGVyZSB5b3Ugd2FudCB0byBoYW5kbGUgcmFmIHVwZGF0ZXMgb24geW91ciBvd24uXG4gKiAvLyBIZXJlIHdlIHRlbGwgZWFzZXIgdGhhdCB3ZSB3aWxsIGJlIGNhbGxpbmcgdGhlIGVhc2VyLmNhbGN1bGF0ZSBtZXRob2RcbiAqIC8vIG9uIHJhZi5cbiAqIGxldCBlYXNlciA9IG5ldyBFYXNlcih7XG4gKiAgIGR1cmF0aW9uOiAyMDAsXG4gKiAgIGVhc2VGdW5jdGlvbjogRUFTRS5lYXNlSW5PdXRFeHBvLFxuICogICBkaXNhYmxlUmFmOiB0cnVlIC8vIE5vdGUgdGhhdCB0aGlzIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZS5cbiAqIH0pO1xuICogZWFzZXIub25Db21wbGV0ZSgoKT0+IHtcbiAqICAgY29uc29sZS5sb2coJ3RoaXMgZ2V0cyBjYWxsZWQgb24gY29tcGxldGlvbicpO1xuICogfSlcbiAqXG4gKiBlYXNlci5vblVwZGF0ZSgoZWFzZVZhbHVlLCBjb21wbGV0ZSk9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCd0aGlzIGdldHMgY2FsbGVkIG9uIGVhY2ggdXBkYXRlJyk7XG4gKiAgIC8vIERvIHNvbWV0aGluZ1xuICogICAvLyBlbGVtZW50LnN0eWxlLmxlZnQgPSAxMDAgKiBlYXNlVmFsdWUgKyAncHgnO1xuICogfSlcbiAqXG4gKiAvLyBTaW5jZSB3ZSB0b2xkIGVhc2VyIHRvIG5vdCBpbnRlcm5hbGwgdXBkYXRlIG9uIHJhZiwgd2UgbmVlZCB0b1xuICogLy8gY2FsbCBjYWxjdWxhdGUgYW5kIHRlbGwgZWFzZXIgdG8gY2FsY3VsYXRlLlxuICogdmFyIHJhZiA9IG5ldyBSYWYoKCk9PiB7XG4gKiAgIGVhc2VyLmNhbGN1bGF0ZSgpO1xuICogfSk7XG4gKlxuICogLy8gQXMgYW4gZXhhbXBsZSwgd2UgdGhyb3R0bGUgb3VyIHJhZiBpbnN0YW5jZSB0byAxMCBGUFMgc28gZWFzZXIgd2lsbFxuICogLy8gb25seSB1cGRhdGUgYXQgMTAgZnJhbWVzIHBlciBzZWNvbmQuXG4gKiByYWYuc2V0RnBzKDEwKTtcbiAqXG4gKiBlYXNlci5zdGFydCgpOyAvLyBTdGFydCBlYXNlclxuICogcmFmLnN0YXJ0KCk7IC8vIFN0YXJ0IHJhZiBzbyBlYXNlciBjYWxjdWxhdGUgaXMgY2FsbGVkLlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKi9cbmNsYXNzIEVhc2VyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Vhc2VyQ29uZmlnfSBUaGUgZWFzaW5nIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlYXNlckNvbmZpZykge1xuICAgICAgICB0aGlzLmVhc2VyQ29uZmlnID0gZWFzZXJDb25maWc7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IG1zIHNpbmNlIEphbiAxLCAxOTcwLlxuICAgICAgICB0aGlzLnN0YXJ0VGltZV8gPSAwO1xuICAgICAgICAvLyBUaGUgZW5kIHRpbWUuXG4gICAgICAgIHRoaXMuZW5kVGltZV8gPSAwO1xuICAgICAgICAvLyBUaGUgZHVyYXRpb24gb2YgdGhlIGVhc2UuXG4gICAgICAgIHRoaXMuZHVyYXRpb25fID0gZWFzZXJDb25maWcuZHVyYXRpb24gfHwgMDtcbiAgICAgICAgLy8gVGhlIGRlbGF5LlxuICAgICAgICB0aGlzLmRlbGF5XyA9IGVhc2VyQ29uZmlnLmRlbGF5IHx8IDA7XG4gICAgICAgIC8vIFRoZSBlYXNpbmcgZnVuY3Rpb24uXG4gICAgICAgIHRoaXMuZWFzZUZ1bmN0aW9uXyA9IGVhc2VyQ29uZmlnLmVhc2VGdW5jdGlvbiB8fCBlYXNlXzEuRUFTRS5saW5lYXI7XG4gICAgICAgIC8vIEEgZmxhZyB0byB0ZXN0IHdoZXRoZXIgdGhlIGVhc2VyIGhhcyBzdGFydGVkLlxuICAgICAgICB0aGlzLnN0YXJ0ZWRfID0gZmFsc2U7XG4gICAgICAgIC8vIEEgc2luZ2xlIGNvbXBsZXRlIGNhbGxiYWNrLlxuICAgICAgICB0aGlzLmNvbXBsZXRlQ2FsbGJhY2tfID0gbnVsbDtcbiAgICAgICAgLy8gQSBzaW5nbGUgdXBkYXRlIGNhbGxiYWNrLlxuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrXyA9IG51bGw7XG4gICAgICAgIC8vIFRoZSByZXNvbHZpbmcgZnVuY3Rpb24gZm9yIHRoZSBjb21wbGV0ZSBwcm9taXNlIChpZiB1c2VkKS5cbiAgICAgICAgdGhpcy5jb21wbGV0ZVByb21pc2VSZXNvbHZlXyA9IG51bGw7XG4gICAgICAgIC8vIEludGVybmFsIGluc3RhbmNlIG9mIHJhZi5cbiAgICAgICAgdGhpcy5yYWZfID0gbmV3IHJhZl8xLlJhZigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2hldGhlciByYWYgaXMgZGlzYWJsZWQuICBXaGVuIHRoaXMgb3B0aW9uIGlzIHRydWUsIGVhc2VyIHdpbGxcbiAgICAgICAgLy8gbm8gbG9uZ2VyIGludGVyYWxseSBjYWxsIFJhZiBhbmQgaW5zdGVhZCBleHBlY3RzIGVhc2VyLmNhbGN1bGF0ZSgpXG4gICAgICAgIC8vIHRvIGJlIGNhbGxlZCBvbiBlYWNoIFJhZi4gIERpc2FibGluZyByYWYgd2l0aGluIGVhc2VyIG1pZ2h0IGJlXG4gICAgICAgIC8vIGEgbW9yZSBhZHZhbmNlZCB1c2VyY2FzZSBpbiB3aGljaCBhbiBhcHBsaWNhdGlvbiB3YW50cyB0b1xuICAgICAgICAvLyBoYXZlIGNvbnRyb2wgb3ZlciBlYXNlciBhbmQgaXQncyBjYWxjdWxhdGUgdGltaW5ncy5cbiAgICAgICAgdGhpcy5yYWZEaXNhYmxlZF8gPSBlYXNlckNvbmZpZy5kaXNhYmxlUmFmIHx8IGZhbHNlO1xuICAgIH1cbiAgICByZXNldChlYXNlckNvbmZpZykge1xuICAgICAgICBpZiAoZWFzZXJDb25maWcpIHtcbiAgICAgICAgICAgIC8vIFRoZSBkdXJhdGlvbiBvZiB0aGUgZWFzZS5cbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb25fID0gZWFzZXJDb25maWcuZHVyYXRpb24gfHwgdGhpcy5kdXJhdGlvbl87XG4gICAgICAgICAgICAvLyBUaGUgZGVsYXkuXG4gICAgICAgICAgICB0aGlzLmRlbGF5XyA9IGVhc2VyQ29uZmlnLmRlbGF5IHx8IHRoaXMuZGVsYXlfO1xuICAgICAgICAgICAgLy8gVGhlIGVhc2luZyBmdW5jdGlvbi5cbiAgICAgICAgICAgIHRoaXMuZWFzZUZ1bmN0aW9uXyA9IGVhc2VyQ29uZmlnLmVhc2VGdW5jdGlvbiB8fCB0aGlzLmVhc2VGdW5jdGlvbl87XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHN0YXJ0ZWQgdG8gZmFsc2UgdG8gc3RvcCBwcm9ncmVzc2lvbi5cbiAgICAgICAgdGhpcy5zdGFydGVkXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZV8gPSAwO1xuICAgICAgICB0aGlzLmVuZFRpbWVfID0gMDtcbiAgICAgICAgdGhpcy5yYWZfICYmIHRoaXMucmFmXy5zdG9wKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGludGVybmFsIGluc3RhbmNlIG9mIHJhZi5cbiAgICAgKiBAcmV0dXJuIFRoZSBpbnRlcm5hbCBpbnN0YW5jZSBvZiByYWYuXG4gICAgICovXG4gICAgZ2V0UmFmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYWZfO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIGVhc2luZy5cbiAgICAgKiBAcmV0dXJuIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlcy5cbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdGFydFRpbWVfID0gdGltZV8xLnRpbWUubm93KCkgKyB0aGlzLmRlbGF5XztcbiAgICAgICAgdGhpcy5lbmRUaW1lXyA9IHRoaXMuc3RhcnRUaW1lXyArIHRoaXMuZHVyYXRpb25fO1xuICAgICAgICB0aGlzLnN0YXJ0ZWRfID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLnJhZkRpc2FibGVkXykge1xuICAgICAgICAgICAgdGhpcy5yYWZfICYmIHRoaXMucmFmXy5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVQcm9taXNlUmVzb2x2ZV8gPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvbXBsZXRlIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIG9uQ29tcGxldGUoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZUNhbGxiYWNrXyA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29tcGxldGUgY2FsbGJhY2suXG4gICAgICovXG4gICAgb25VcGRhdGUoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFja18gPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgY3VycmVudCBlYXNlLiAgVGhpcyBtZXRob2Qgc2hvdWxkIGdlbmVyYWxseSBiZVxuICAgICAqIGNhbGxlZCBhdCA2MEZQUyBieSBSYWYuXG4gICAgICovXG4gICAgY2FsY3VsYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZF8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IHRpbWVfMS50aW1lLm5vdygpO1xuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgYXJlIG1vcmUgdGhhbiBvdXIgc3RhcnQgdGltZS5cbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgdGhpcy5zdGFydFRpbWVfKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHRpbWUgcGFzc2VkIHNpbmNlIHRoZSBlYXNlIHN0YXJ0ZWQuXG4gICAgICAgIGNvbnN0IHRpbWVQYXNzZWQgPSBjdXJyZW50VGltZSAtICh0aGlzLnN0YXJ0VGltZV8gfHwgMCk7XG4gICAgICAgIGNvbnN0IHBlcmNlbnQgPSB0aW1lUGFzc2VkIC8gdGhpcy5kdXJhdGlvbl87XG4gICAgICAgIC8vIEEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdGF0ZSBvZiBwcm9ncmVzc2lvbi5cbiAgICAgICAgY29uc3QgcHJvZ3Jlc3Npb24gPSB0aGlzLmVhc2VGdW5jdGlvbl8obWF0aGZfMS5tYXRoZi5jbGFtcCgwLCAxLCBwZXJjZW50KSk7XG4gICAgICAgIGxldCBjb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAocGVyY2VudCA+IDEpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZWFzZSBhbW91bnQgZW5kcyBvbiAxLlxuICAgICAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFja18gJiYgdGhpcy51cGRhdGVDYWxsYmFja18oMSwgY29tcGxldGUpO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUNhbGxiYWNrXyAmJiB0aGlzLmNvbXBsZXRlQ2FsbGJhY2tfKDEsIGNvbXBsZXRlKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVQcm9taXNlUmVzb2x2ZV8gJiYgdGhpcy5jb21wbGV0ZVByb21pc2VSZXNvbHZlXygxLCBjb21wbGV0ZSk7XG4gICAgICAgICAgICBjb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWRfID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrXyAmJiB0aGlzLnVwZGF0ZUNhbGxiYWNrXyhwcm9ncmVzc2lvbiwgY29tcGxldGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMucmFmXyAmJiB0aGlzLnJhZl8uc3RvcCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuRWFzZXIgPSBFYXNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVhc2VyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/ease/easer.js\n");

/***/ }),

/***/ "./lib/func/defer.js":
/*!***************************!*\
  !*** ./lib/func/defer.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n//https://gist.github.com/uxder/b9bd3811e0508fae42c1df64155b9c8b\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Defer = void 0;\n/**\n * A basic deferred promise.  Allows you to resolve/reject a promise at a later\n * time.\n *\n *\n * ```ts\n *\n * let defer = new Defer();\n *\n * // Resolve the defer at a later time.\n * let hello = ()=> {\n *   defer.resolve({ message : 'you said hello'});\n *\n *   // If you need to reject.\n *   // defer.reject();\n * }\n *\n *\n * // Get the promise and handle it.\n * defer.getPromise().then((data)=> {\n *   console.log(data.message); // you said hello\n * })\n *\n * window.setTimeout(()=> {\n *   hello();\n * }, 200)\n *\n *\n *\n * ```\n *\n * @tested\n */\nclass Defer {\n    constructor() {\n        this.resolve = () => { };\n        this.reject = () => { };\n        this.complete = false;\n        this.promise = new Promise((resolve, reject) => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.resolve = (data) => {\n                this.complete = true;\n                return resolve(data);\n            };\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.reject = (data) => {\n                this.complete = true;\n                return reject(data);\n            };\n        });\n    }\n    /**\n     * Returns the deferred promise.  If the defer was already completed for\n     * some reason, will return a promise that is immediately resolved.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    getPromise() {\n        if (this.complete) {\n            return new Promise((resolve) => {\n                resolve();\n            });\n        }\n        else {\n            return this.promise;\n        }\n    }\n}\nexports.Defer = Defer;\n//# sourceMappingURL=defer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZnVuYy9kZWZlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9mdW5jL2RlZmVyLmpzPzI5Y2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vL2h0dHBzOi8vZ2lzdC5naXRodWIuY29tL3V4ZGVyL2I5YmQzODExZTA1MDhmYWU0MmMxZGY2NDE1NWI5YzhiXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlZmVyID0gdm9pZCAwO1xuLyoqXG4gKiBBIGJhc2ljIGRlZmVycmVkIHByb21pc2UuICBBbGxvd3MgeW91IHRvIHJlc29sdmUvcmVqZWN0IGEgcHJvbWlzZSBhdCBhIGxhdGVyXG4gKiB0aW1lLlxuICpcbiAqXG4gKiBgYGB0c1xuICpcbiAqIGxldCBkZWZlciA9IG5ldyBEZWZlcigpO1xuICpcbiAqIC8vIFJlc29sdmUgdGhlIGRlZmVyIGF0IGEgbGF0ZXIgdGltZS5cbiAqIGxldCBoZWxsbyA9ICgpPT4ge1xuICogICBkZWZlci5yZXNvbHZlKHsgbWVzc2FnZSA6ICd5b3Ugc2FpZCBoZWxsbyd9KTtcbiAqXG4gKiAgIC8vIElmIHlvdSBuZWVkIHRvIHJlamVjdC5cbiAqICAgLy8gZGVmZXIucmVqZWN0KCk7XG4gKiB9XG4gKlxuICpcbiAqIC8vIEdldCB0aGUgcHJvbWlzZSBhbmQgaGFuZGxlIGl0LlxuICogZGVmZXIuZ2V0UHJvbWlzZSgpLnRoZW4oKGRhdGEpPT4ge1xuICogICBjb25zb2xlLmxvZyhkYXRhLm1lc3NhZ2UpOyAvLyB5b3Ugc2FpZCBoZWxsb1xuICogfSlcbiAqXG4gKiB3aW5kb3cuc2V0VGltZW91dCgoKT0+IHtcbiAqICAgaGVsbG8oKTtcbiAqIH0sIDIwMClcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEB0ZXN0ZWRcbiAqL1xuY2xhc3MgRGVmZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlc29sdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMucmVqZWN0ID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLmNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChkYXRhKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZlcnJlZCBwcm9taXNlLiAgSWYgdGhlIGRlZmVyIHdhcyBhbHJlYWR5IGNvbXBsZXRlZCBmb3JcbiAgICAgKiBzb21lIHJlYXNvbiwgd2lsbCByZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgaW1tZWRpYXRlbHkgcmVzb2x2ZWQuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBnZXRQcm9taXNlKCkge1xuICAgICAgICBpZiAodGhpcy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5EZWZlciA9IERlZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/func/defer.js\n");

/***/ }),

/***/ "./lib/func/func.js":
/*!**************************!*\
  !*** ./lib/func/func.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.func = void 0;\nconst time_1 = __webpack_require__(/*! ../time/time */ \"./lib/time/time.js\");\n/**\n * A class that helps with functions.\n */\nclass func {\n    /**\n     *  A basic debounce implementation.  Debounce will basically wait X amount\n     * of seconds to execute AFTER it's last call.\n     *\n     * ```ts\n     *\n     * const debouncer = func.debounce((windowEvent)=> {\n     *   console.log(wiindowEvent);\n     * }, 500);\n     *\n     * // Now when you resize, it will wait 500 ms until the last resize call.\n     * window.addEventListener('resize', debounce);\n     *\n     * Or\n     *\n     * window.addEventListener('resize', func.debounce(()=> {\n     *   console.log('throttled');\n     * }, 500))\n     *\n     * ```\n     *\n     * @param callback The function to call.\n     * @param wait The ms to delay.\n     * @param immediate Optional, whether to immediately run (changes this to throttle)\n     * @return A debounced function\n     * @tested\n     */\n    static debounce(callback, wait, immediate) {\n        let timeOutId;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return function (...args) {\n            // eslint-disable-next-line\n            const ctx = this;\n            const runLater = () => {\n                timeOutId = undefined;\n                callback.apply(ctx, args);\n            };\n            const throttler = () => {\n                timeOutId = undefined;\n            };\n            // For debouncing.\n            if (!immediate && timeOutId === undefined) {\n                timeOutId = +setTimeout(runLater, wait);\n            }\n            // For throttling where we call on leading trail (immediate).\n            if (immediate && timeOutId === undefined) {\n                callback.apply(ctx, args);\n                timeOutId = +setTimeout(throttler, wait);\n            }\n        };\n    }\n    /**\n     * Throttles a function.  Throttle will run a function immediately when it's\n     * called and wait X amount of seconds before it can be called again.\n     *\n     * ```ts\n     *\n     * const throttler = func.throttle((windowEvent)=> {\n     *   console.log(wiindowEvent);\n     * }, 500);\n     *\n     * // Now when you resize, it will immediately call the throttle function\n     * // and wait 500 ms before it can be called again.\n     * window.addEventListener('resize', throttler);\n     *\n     * Or just:\n     *\n     * window.addEventListener('resize', func.throttle(()=> {\n     *   console.log('throttled');\n     * }, 500))\n     *\n     * ```\n     *\n     * @param callback The callback function\n     * @param wait The amount to wait in ms.\n     * @tested\n     */\n    static throttle(callback, wait) {\n        return func.debounce(callback, wait, true);\n    }\n    /**\n     * A simple function that resolves after a specific amoutn of time.\n     * This is useful to create a delay with await.\n     * ```ts\n     * console.log('hohoho');\n     * await func.wait(500);\n     * console.log('hohoho after 500ms');\n     * ```\n     * @param time\n     * @tested\n     */\n    static async wait(time) {\n        return new Promise(resolve => setTimeout(resolve, time));\n    }\n    /**\n     * Wait until a condition becomes truthy.   This under the hood implements\n     * polling to evaluate the condition so use wisely.\n     *\n     * ```ts\n     *\n     * let someValue = 0;\n     * func.waitUntil(()=> someValue === 5).then(()=> {\n     *   console.log('some value is 5!!!');\n     * })\n     *\n     * setTimeout(()=> {\n     *   someValue = 5;\n     * }, 1000);\n     *\n     * ```\n     *\n     *\n     * @param {Function} A condition that returns a boolean.\n     * @param {number} The amount of time that can elapse before rejecting the\n     *     returning promise. Defaults to 0, which is evaluated as forever.\n     * @param {number} The polling interval amount.\n     * @tested\n     */\n    static waitUntil(condition, timeout = 0, interval = 100) {\n        const startTime = time_1.time.now();\n        let resolvePromise;\n        let rejectPromise;\n        const returnPromise = new Promise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const evaluateCondition = () => {\n            const elapsed = time_1.time.timeDiffMs(startTime, time_1.time.now());\n            // If the condition resolves.\n            if (condition()) {\n                resolvePromise();\n            }\n            else if (timeout && elapsed > timeout) {\n                rejectPromise('Wait until timed out');\n            }\n            else {\n                setTimeout(evaluateCondition, interval);\n            }\n        };\n        // Start it up.\n        evaluateCondition();\n        return returnPromise;\n    }\n    /**\n     * Similar to waitUntil but will repeatedly perform an\n     * action until a condition is met.\n     * @param condition\n     * @param action\n     * @param timeout\n     * @param interval\n     *\n     *\n     * ```\n     * let someValue = 0;\n     * func.repeatUntil(\n     *  ()=> {return someValue === 5},\n     *  ()=> { somevalue++; }\n     * ).then(()=> {\n     *   console.log('some value is 5!!!');\n     * })\n     * ```\n     */\n    static repeatUntil(condition, \n    // The action that should be performed\n    action, timeout = 0, interval = 100) {\n        const startTime = time_1.time.now();\n        let resolvePromise;\n        let rejectPromise;\n        const returnPromise = new Promise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const evaluateCondition = () => {\n            const elapsed = time_1.time.timeDiffMs(startTime, time_1.time.now());\n            // If the condition resolves.\n            if (condition()) {\n                resolvePromise();\n            }\n            else if (timeout && elapsed > timeout) {\n                rejectPromise('Wait until timed out');\n            }\n            else {\n                action();\n                setTimeout(evaluateCondition, interval);\n            }\n        };\n        // Start it up.\n        evaluateCondition();\n        return returnPromise;\n    }\n    /**\n     * Memoizes a function with just a one time memory.   This memoize\n     * conserves RAM (probably :))\n     *\n     * If the same parameter is passed as the last execution, the results are\n     * pulled from the cache.  When paramers change, the callback is reevaluated\n     * for new results.\n     *\n     * The key difference between [[func.memoize]] is that this memoize stores\n     * just the last results as opposed to a dictionary of all previous results.\n     *\n     * If running a lot of executions, this can save memory.\n     *\n     * Consider the following example.  The calculations are done only when\n     * a mutation occurs in the parameters.  Otherwise, the results are\n     * pull from the single cache.\n     *\n     * ```ts\n     * let expensiveCalculation = func.memoizeSimple((a,b,c)=> {\n     *   return a + b + c;\n     * })\n     *\n     * expensiveCalculation(1, 1, 1); // 3, callback executed and results cached.\n     * expensiveCalculation(1, 1, 1); // 3 from cache\n     * expensiveCalculation(1, 1, 1); // 3 from cache\n     * expensiveCalculation(1, 1, 1); // 3 from cache\n     *\n     * expensiveCalculation(2, 2, 2); // 6, callback executed and results cached.\n     * expensiveCalculation(2, 2, 2); // 6 from cache\n     *\n     * // Now in a classic memozize the below would not be reexecuted. But since\n     * // this memoize only has a simple memory, it will be reexecuted.\n     * expensiveCalculation(1, 1, 1); // 3, callback executed and results cached.\n     * expensiveCalculation(1, 1, 1); // 3 from cache\n     *\n     * ```\n     * @param {Function} callback The function to wrap the memoize mechanism.\n     *     It's expect that this function returns something.  Can't be void.\n     * @return {Function}\n     * @tested\n     */\n    static memoizeSimple(callback) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let cachedResults = null;\n        let cachedArgs = null;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (...args) => {\n            const stringifiedArgs = JSON.stringify(args);\n            if (stringifiedArgs === cachedArgs) {\n                return cachedResults;\n            }\n            else {\n                cachedArgs = stringifiedArgs;\n                return (cachedResults = callback(...args));\n            }\n        };\n    }\n    /**\n     * Memoizes a function.  If the params passed to the function are the same\n     * as a previous call, then the cached results are returned, saving an\n     * unncessary excecution.\n     *\n     *\n     * Consider the follwing example\n     * ```ts\n     * let expensiveCalculation = func.memoize((a,b,c)=> {\n     *   return a + b + c;\n     * })\n     *\n     * expensiveCalculation(1, 1, 1); // 3, callback executed and results cached.\n     * expensiveCalculation(1, 1, 1); // 3 from cache\n     * expensiveCalculation(1, 1, 1); // 3 from cache\n     *\n     * expensiveCalculation(2, 2, 2); // 6, callback executed and results cached.\n     * expensiveCalculation(2, 2, 2); // 6 from cache\n     *\n     * expensiveCalculation(1, 1, 1); // 3 from cache\n     * expensiveCalculation(2, 2, 2); // 6 from cache\n     * ```\n     *\n     * A common case for memoize might be to use it in a class method.\n     * You can implement that with this pattern.\n     *\n     * ```ts\n     * class MyClass {\n     *\n     *     constructor() {\n     *        this.calculate = func.memoize(this.calculate.bind(this)) as any;\n     *     }\n     *\n     *     calculate(a, b) {\n     *       return a + b;\n     *     }\n     * }\n     *\n     * ```\n     *\n     * @param {Function} callback The function to wrap the memoize mechanism.\n     *     It's expect that this function returns something.  Can't be void.\n     * @return {Function}\n     * @tested\n     */\n    static memoize(callback) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const cachedResults = {};\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (...args) => {\n            const stringifiedArgs = JSON.stringify(args);\n            if (cachedResults[stringifiedArgs]) {\n                return cachedResults[stringifiedArgs];\n            }\n            const result = callback(...args);\n            cachedResults[stringifiedArgs] = result;\n            return result;\n        };\n    }\n    /**\n     * Runs a function ONLY when the parameters have changed.\n     *\n     *\n     * Running the below, you will see only four console.logs executed, each\n     * when the params have changed.\n     * ```ts\n     *\n     *   let expensiveOperation = func.runOnceOnChange(\n     *       (name) => {\n     *           // Do expensive stuff here.\n     *           console.log(name);\n     *       }\n     *   );\n     *\n     *   expensiveOperation('Scott');  // Scott\n     *   expensiveOperation('Scott');\n     *   expensiveOperation('Scott');\n     *   expensiveOperation('Scott');\n     *   expensiveOperation('Scott');\n     *   expensiveOperation('John');   // John\n     *   expensiveOperation('John');\n     *   expensiveOperation('Aya');    // Aya\n     *   expensiveOperation('Aya');\n     *   expensiveOperation('John');   // John\n     *   expensiveOperation('John');\n     * ```\n     *\n     * More in practice.  Here we want to do mutate only when the window.innerWidth\n     * or windowHeight has changed.\n     * ```ts\n     * let updateCanvasSize = func.runOnceOnChange(\n     *    (windowWidth, windowHeight)=> {\n     *       // Do something expensive.\n     *       console.log('Change the canvas size');\n     * })\n     *\n     * new Raf(()=> {\n     *   updateCanvasSize(window.innnerWidth, window.innerHeight);\n     * });\n     * ```\n     *\n     * You can implement this for a class method as follows\n     * ```ts\n     * class MyClass {\n     *\n     *     constructor() {\n     *        this.element = document.getElementById('hello');\n     *        this.render = func.runOnceOnChange(this.render.bind(this));\n     *\n     *        this.render(800);\n     *        this.render(800); // Won't be called a second time.\n     *     }\n     *\n     *     render(height) {\n     *       this.element.style.height = height + 'px';\n     *     }\n     * }\n     *\n     * ```\n     * @param {Function} callback The callback to execute.  Doesn't require\n     *     the callback to return a value.\n     * @tested\n     */\n    static runOnceOnChange(callback) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let cachedResults = null;\n        let cachedArgs = null;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (...args) => {\n            const stringifiedArgs = JSON.stringify(args);\n            // Only excute if arguments are different.\n            if (stringifiedArgs !== cachedArgs) {\n                cachedArgs = stringifiedArgs;\n                // eslint-disable-next-line\n                return (cachedResults = callback(...args));\n            }\n        };\n    }\n    /**\n     * A method that sets the default value if undefined.\n     * Useful in setting explicit default values.\n     *\n     * ```ts\n     *\n     * func.setDefault(10, 20); // 10\n     * func.setDefault(undefined, 20); // 20\n     * func.setDefault(undefined, false); // false\n     * ```\n     * @tested\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static setDefault(value, defaultValue) {\n        return Object.is(value, undefined) ? defaultValue : value;\n    }\n    /**\n     * Run the callback a specific number of times.\n     *\n     * ```ts\n     *\n     *  // Runs 5 times.\n     *  func.times(5, (i) => {\n     *       console.log('times', i);\n     *  });\n     *\n     * ```\n     * @param count\n     * @param callback\n     */\n    static times(count, callback) {\n        [...Array(count)].forEach((x, i) => {\n            callback(i);\n        });\n    }\n}\nexports.func = func;\n//# sourceMappingURL=func.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZnVuYy9mdW5jLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2Z1bmMvZnVuYy5qcz9mMmRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mdW5jID0gdm9pZCAwO1xuY29uc3QgdGltZV8xID0gcmVxdWlyZShcIi4uL3RpbWUvdGltZVwiKTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGhlbHBzIHdpdGggZnVuY3Rpb25zLlxuICovXG5jbGFzcyBmdW5jIHtcbiAgICAvKipcbiAgICAgKiAgQSBiYXNpYyBkZWJvdW5jZSBpbXBsZW1lbnRhdGlvbi4gIERlYm91bmNlIHdpbGwgYmFzaWNhbGx5IHdhaXQgWCBhbW91bnRcbiAgICAgKiBvZiBzZWNvbmRzIHRvIGV4ZWN1dGUgQUZURVIgaXQncyBsYXN0IGNhbGwuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqXG4gICAgICogY29uc3QgZGVib3VuY2VyID0gZnVuYy5kZWJvdW5jZSgod2luZG93RXZlbnQpPT4ge1xuICAgICAqICAgY29uc29sZS5sb2cod2lpbmRvd0V2ZW50KTtcbiAgICAgKiB9LCA1MDApO1xuICAgICAqXG4gICAgICogLy8gTm93IHdoZW4geW91IHJlc2l6ZSwgaXQgd2lsbCB3YWl0IDUwMCBtcyB1bnRpbCB0aGUgbGFzdCByZXNpemUgY2FsbC5cbiAgICAgKiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZGVib3VuY2UpO1xuICAgICAqXG4gICAgICogT3JcbiAgICAgKlxuICAgICAqIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jLmRlYm91bmNlKCgpPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coJ3Rocm90dGxlZCcpO1xuICAgICAqIH0sIDUwMCkpXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKiBAcGFyYW0gd2FpdCBUaGUgbXMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIGltbWVkaWF0ZSBPcHRpb25hbCwgd2hldGhlciB0byBpbW1lZGlhdGVseSBydW4gKGNoYW5nZXMgdGhpcyB0byB0aHJvdHRsZSlcbiAgICAgKiBAcmV0dXJuIEEgZGVib3VuY2VkIGZ1bmN0aW9uXG4gICAgICogQHRlc3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBkZWJvdW5jZShjYWxsYmFjaywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgICAgIGxldCB0aW1lT3V0SWQ7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgcnVuTGF0ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGltZU91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdGhyb3R0bGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRpbWVPdXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBGb3IgZGVib3VuY2luZy5cbiAgICAgICAgICAgIGlmICghaW1tZWRpYXRlICYmIHRpbWVPdXRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGltZU91dElkID0gK3NldFRpbWVvdXQocnVuTGF0ZXIsIHdhaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yIHRocm90dGxpbmcgd2hlcmUgd2UgY2FsbCBvbiBsZWFkaW5nIHRyYWlsIChpbW1lZGlhdGUpLlxuICAgICAgICAgICAgaWYgKGltbWVkaWF0ZSAmJiB0aW1lT3V0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgICAgICAgICAgICAgdGltZU91dElkID0gK3NldFRpbWVvdXQodGhyb3R0bGVyLCB3YWl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhyb3R0bGVzIGEgZnVuY3Rpb24uICBUaHJvdHRsZSB3aWxsIHJ1biBhIGZ1bmN0aW9uIGltbWVkaWF0ZWx5IHdoZW4gaXQnc1xuICAgICAqIGNhbGxlZCBhbmQgd2FpdCBYIGFtb3VudCBvZiBzZWNvbmRzIGJlZm9yZSBpdCBjYW4gYmUgY2FsbGVkIGFnYWluLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIGNvbnN0IHRocm90dGxlciA9IGZ1bmMudGhyb3R0bGUoKHdpbmRvd0V2ZW50KT0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHdpaW5kb3dFdmVudCk7XG4gICAgICogfSwgNTAwKTtcbiAgICAgKlxuICAgICAqIC8vIE5vdyB3aGVuIHlvdSByZXNpemUsIGl0IHdpbGwgaW1tZWRpYXRlbHkgY2FsbCB0aGUgdGhyb3R0bGUgZnVuY3Rpb25cbiAgICAgKiAvLyBhbmQgd2FpdCA1MDAgbXMgYmVmb3JlIGl0IGNhbiBiZSBjYWxsZWQgYWdhaW4uXG4gICAgICogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRocm90dGxlcik7XG4gICAgICpcbiAgICAgKiBPciBqdXN0OlxuICAgICAqXG4gICAgICogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmMudGhyb3R0bGUoKCk9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygndGhyb3R0bGVkJyk7XG4gICAgICogfSwgNTAwKSlcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB3YWl0IFRoZSBhbW91bnQgdG8gd2FpdCBpbiBtcy5cbiAgICAgKiBAdGVzdGVkXG4gICAgICovXG4gICAgc3RhdGljIHRocm90dGxlKGNhbGxiYWNrLCB3YWl0KSB7XG4gICAgICAgIHJldHVybiBmdW5jLmRlYm91bmNlKGNhbGxiYWNrLCB3YWl0LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyBhZnRlciBhIHNwZWNpZmljIGFtb3V0biBvZiB0aW1lLlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIHRvIGNyZWF0ZSBhIGRlbGF5IHdpdGggYXdhaXQuXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zb2xlLmxvZygnaG9ob2hvJyk7XG4gICAgICogYXdhaXQgZnVuYy53YWl0KDUwMCk7XG4gICAgICogY29uc29sZS5sb2coJ2hvaG9obyBhZnRlciA1MDBtcycpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB0aW1lXG4gICAgICogQHRlc3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyB3YWl0KHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXQgdW50aWwgYSBjb25kaXRpb24gYmVjb21lcyB0cnV0aHkuICAgVGhpcyB1bmRlciB0aGUgaG9vZCBpbXBsZW1lbnRzXG4gICAgICogcG9sbGluZyB0byBldmFsdWF0ZSB0aGUgY29uZGl0aW9uIHNvIHVzZSB3aXNlbHkuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqXG4gICAgICogbGV0IHNvbWVWYWx1ZSA9IDA7XG4gICAgICogZnVuYy53YWl0VW50aWwoKCk9PiBzb21lVmFsdWUgPT09IDUpLnRoZW4oKCk9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygnc29tZSB2YWx1ZSBpcyA1ISEhJyk7XG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIHNldFRpbWVvdXQoKCk9PiB7XG4gICAgICogICBzb21lVmFsdWUgPSA1O1xuICAgICAqIH0sIDEwMDApO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEEgY29uZGl0aW9uIHRoYXQgcmV0dXJucyBhIGJvb2xlYW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGNhbiBlbGFwc2UgYmVmb3JlIHJlamVjdGluZyB0aGVcbiAgICAgKiAgICAgcmV0dXJuaW5nIHByb21pc2UuIERlZmF1bHRzIHRvIDAsIHdoaWNoIGlzIGV2YWx1YXRlZCBhcyBmb3JldmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBUaGUgcG9sbGluZyBpbnRlcnZhbCBhbW91bnQuXG4gICAgICogQHRlc3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyB3YWl0VW50aWwoY29uZGl0aW9uLCB0aW1lb3V0ID0gMCwgaW50ZXJ2YWwgPSAxMDApIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gdGltZV8xLnRpbWUubm93KCk7XG4gICAgICAgIGxldCByZXNvbHZlUHJvbWlzZTtcbiAgICAgICAgbGV0IHJlamVjdFByb21pc2U7XG4gICAgICAgIGNvbnN0IHJldHVyblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZXZhbHVhdGVDb25kaXRpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gdGltZV8xLnRpbWUudGltZURpZmZNcyhzdGFydFRpbWUsIHRpbWVfMS50aW1lLm5vdygpKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb25kaXRpb24gcmVzb2x2ZXMuXG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGltZW91dCAmJiBlbGFwc2VkID4gdGltZW91dCkge1xuICAgICAgICAgICAgICAgIHJlamVjdFByb21pc2UoJ1dhaXQgdW50aWwgdGltZWQgb3V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGV2YWx1YXRlQ29uZGl0aW9uLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFN0YXJ0IGl0IHVwLlxuICAgICAgICBldmFsdWF0ZUNvbmRpdGlvbigpO1xuICAgICAgICByZXR1cm4gcmV0dXJuUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byB3YWl0VW50aWwgYnV0IHdpbGwgcmVwZWF0ZWRseSBwZXJmb3JtIGFuXG4gICAgICogYWN0aW9uIHVudGlsIGEgY29uZGl0aW9uIGlzIG1ldC5cbiAgICAgKiBAcGFyYW0gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIGFjdGlvblxuICAgICAqIEBwYXJhbSB0aW1lb3V0XG4gICAgICogQHBhcmFtIGludGVydmFsXG4gICAgICpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGxldCBzb21lVmFsdWUgPSAwO1xuICAgICAqIGZ1bmMucmVwZWF0VW50aWwoXG4gICAgICogICgpPT4ge3JldHVybiBzb21lVmFsdWUgPT09IDV9LFxuICAgICAqICAoKT0+IHsgc29tZXZhbHVlKys7IH1cbiAgICAgKiApLnRoZW4oKCk9PiB7XG4gICAgICogICBjb25zb2xlLmxvZygnc29tZSB2YWx1ZSBpcyA1ISEhJyk7XG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVwZWF0VW50aWwoY29uZGl0aW9uLCBcbiAgICAvLyBUaGUgYWN0aW9uIHRoYXQgc2hvdWxkIGJlIHBlcmZvcm1lZFxuICAgIGFjdGlvbiwgdGltZW91dCA9IDAsIGludGVydmFsID0gMTAwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHRpbWVfMS50aW1lLm5vdygpO1xuICAgICAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG4gICAgICAgIGxldCByZWplY3RQcm9taXNlO1xuICAgICAgICBjb25zdCByZXR1cm5Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGV2YWx1YXRlQ29uZGl0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IHRpbWVfMS50aW1lLnRpbWVEaWZmTXMoc3RhcnRUaW1lLCB0aW1lXzEudGltZS5ub3coKSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29uZGl0aW9uIHJlc29sdmVzLlxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVvdXQgJiYgZWxhcHNlZCA+IHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlKCdXYWl0IHVudGlsIHRpbWVkIG91dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChldmFsdWF0ZUNvbmRpdGlvbiwgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBTdGFydCBpdCB1cC5cbiAgICAgICAgZXZhbHVhdGVDb25kaXRpb24oKTtcbiAgICAgICAgcmV0dXJuIHJldHVyblByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lbW9pemVzIGEgZnVuY3Rpb24gd2l0aCBqdXN0IGEgb25lIHRpbWUgbWVtb3J5LiAgIFRoaXMgbWVtb2l6ZVxuICAgICAqIGNvbnNlcnZlcyBSQU0gKHByb2JhYmx5IDopKVxuICAgICAqXG4gICAgICogSWYgdGhlIHNhbWUgcGFyYW1ldGVyIGlzIHBhc3NlZCBhcyB0aGUgbGFzdCBleGVjdXRpb24sIHRoZSByZXN1bHRzIGFyZVxuICAgICAqIHB1bGxlZCBmcm9tIHRoZSBjYWNoZS4gIFdoZW4gcGFyYW1lcnMgY2hhbmdlLCB0aGUgY2FsbGJhY2sgaXMgcmVldmFsdWF0ZWRcbiAgICAgKiBmb3IgbmV3IHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBUaGUga2V5IGRpZmZlcmVuY2UgYmV0d2VlbiBbW2Z1bmMubWVtb2l6ZV1dIGlzIHRoYXQgdGhpcyBtZW1vaXplIHN0b3Jlc1xuICAgICAqIGp1c3QgdGhlIGxhc3QgcmVzdWx0cyBhcyBvcHBvc2VkIHRvIGEgZGljdGlvbmFyeSBvZiBhbGwgcHJldmlvdXMgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIElmIHJ1bm5pbmcgYSBsb3Qgb2YgZXhlY3V0aW9ucywgdGhpcyBjYW4gc2F2ZSBtZW1vcnkuXG4gICAgICpcbiAgICAgKiBDb25zaWRlciB0aGUgZm9sbG93aW5nIGV4YW1wbGUuICBUaGUgY2FsY3VsYXRpb25zIGFyZSBkb25lIG9ubHkgd2hlblxuICAgICAqIGEgbXV0YXRpb24gb2NjdXJzIGluIHRoZSBwYXJhbWV0ZXJzLiAgT3RoZXJ3aXNlLCB0aGUgcmVzdWx0cyBhcmVcbiAgICAgKiBwdWxsIGZyb20gdGhlIHNpbmdsZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbGV0IGV4cGVuc2l2ZUNhbGN1bGF0aW9uID0gZnVuYy5tZW1vaXplU2ltcGxlKChhLGIsYyk9PiB7XG4gICAgICogICByZXR1cm4gYSArIGIgKyBjO1xuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBleHBlbnNpdmVDYWxjdWxhdGlvbigxLCAxLCAxKTsgLy8gMywgY2FsbGJhY2sgZXhlY3V0ZWQgYW5kIHJlc3VsdHMgY2FjaGVkLlxuICAgICAqIGV4cGVuc2l2ZUNhbGN1bGF0aW9uKDEsIDEsIDEpOyAvLyAzIGZyb20gY2FjaGVcbiAgICAgKiBleHBlbnNpdmVDYWxjdWxhdGlvbigxLCAxLCAxKTsgLy8gMyBmcm9tIGNhY2hlXG4gICAgICogZXhwZW5zaXZlQ2FsY3VsYXRpb24oMSwgMSwgMSk7IC8vIDMgZnJvbSBjYWNoZVxuICAgICAqXG4gICAgICogZXhwZW5zaXZlQ2FsY3VsYXRpb24oMiwgMiwgMik7IC8vIDYsIGNhbGxiYWNrIGV4ZWN1dGVkIGFuZCByZXN1bHRzIGNhY2hlZC5cbiAgICAgKiBleHBlbnNpdmVDYWxjdWxhdGlvbigyLCAyLCAyKTsgLy8gNiBmcm9tIGNhY2hlXG4gICAgICpcbiAgICAgKiAvLyBOb3cgaW4gYSBjbGFzc2ljIG1lbW96aXplIHRoZSBiZWxvdyB3b3VsZCBub3QgYmUgcmVleGVjdXRlZC4gQnV0IHNpbmNlXG4gICAgICogLy8gdGhpcyBtZW1vaXplIG9ubHkgaGFzIGEgc2ltcGxlIG1lbW9yeSwgaXQgd2lsbCBiZSByZWV4ZWN1dGVkLlxuICAgICAqIGV4cGVuc2l2ZUNhbGN1bGF0aW9uKDEsIDEsIDEpOyAvLyAzLCBjYWxsYmFjayBleGVjdXRlZCBhbmQgcmVzdWx0cyBjYWNoZWQuXG4gICAgICogZXhwZW5zaXZlQ2FsY3VsYXRpb24oMSwgMSwgMSk7IC8vIDMgZnJvbSBjYWNoZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIHdyYXAgdGhlIG1lbW9pemUgbWVjaGFuaXNtLlxuICAgICAqICAgICBJdCdzIGV4cGVjdCB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBzb21ldGhpbmcuICBDYW4ndCBiZSB2b2lkLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEB0ZXN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgbWVtb2l6ZVNpbXBsZShjYWxsYmFjaykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgY2FjaGVkUmVzdWx0cyA9IG51bGw7XG4gICAgICAgIGxldCBjYWNoZWRBcmdzID0gbnVsbDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZEFyZ3MgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdpZmllZEFyZ3MgPT09IGNhY2hlZEFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhY2hlZEFyZ3MgPSBzdHJpbmdpZmllZEFyZ3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjYWNoZWRSZXN1bHRzID0gY2FsbGJhY2soLi4uYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZW1vaXplcyBhIGZ1bmN0aW9uLiAgSWYgdGhlIHBhcmFtcyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSB0aGUgc2FtZVxuICAgICAqIGFzIGEgcHJldmlvdXMgY2FsbCwgdGhlbiB0aGUgY2FjaGVkIHJlc3VsdHMgYXJlIHJldHVybmVkLCBzYXZpbmcgYW5cbiAgICAgKiB1bm5jZXNzYXJ5IGV4Y2VjdXRpb24uXG4gICAgICpcbiAgICAgKlxuICAgICAqIENvbnNpZGVyIHRoZSBmb2xsd2luZyBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBsZXQgZXhwZW5zaXZlQ2FsY3VsYXRpb24gPSBmdW5jLm1lbW9pemUoKGEsYixjKT0+IHtcbiAgICAgKiAgIHJldHVybiBhICsgYiArIGM7XG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIGV4cGVuc2l2ZUNhbGN1bGF0aW9uKDEsIDEsIDEpOyAvLyAzLCBjYWxsYmFjayBleGVjdXRlZCBhbmQgcmVzdWx0cyBjYWNoZWQuXG4gICAgICogZXhwZW5zaXZlQ2FsY3VsYXRpb24oMSwgMSwgMSk7IC8vIDMgZnJvbSBjYWNoZVxuICAgICAqIGV4cGVuc2l2ZUNhbGN1bGF0aW9uKDEsIDEsIDEpOyAvLyAzIGZyb20gY2FjaGVcbiAgICAgKlxuICAgICAqIGV4cGVuc2l2ZUNhbGN1bGF0aW9uKDIsIDIsIDIpOyAvLyA2LCBjYWxsYmFjayBleGVjdXRlZCBhbmQgcmVzdWx0cyBjYWNoZWQuXG4gICAgICogZXhwZW5zaXZlQ2FsY3VsYXRpb24oMiwgMiwgMik7IC8vIDYgZnJvbSBjYWNoZVxuICAgICAqXG4gICAgICogZXhwZW5zaXZlQ2FsY3VsYXRpb24oMSwgMSwgMSk7IC8vIDMgZnJvbSBjYWNoZVxuICAgICAqIGV4cGVuc2l2ZUNhbGN1bGF0aW9uKDIsIDIsIDIpOyAvLyA2IGZyb20gY2FjaGVcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEEgY29tbW9uIGNhc2UgZm9yIG1lbW9pemUgbWlnaHQgYmUgdG8gdXNlIGl0IGluIGEgY2xhc3MgbWV0aG9kLlxuICAgICAqIFlvdSBjYW4gaW1wbGVtZW50IHRoYXQgd2l0aCB0aGlzIHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNsYXNzIE15Q2xhc3Mge1xuICAgICAqXG4gICAgICogICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAqICAgICAgICB0aGlzLmNhbGN1bGF0ZSA9IGZ1bmMubWVtb2l6ZSh0aGlzLmNhbGN1bGF0ZS5iaW5kKHRoaXMpKSBhcyBhbnk7XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqICAgICBjYWxjdWxhdGUoYSwgYikge1xuICAgICAqICAgICAgIHJldHVybiBhICsgYjtcbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIHdyYXAgdGhlIG1lbW9pemUgbWVjaGFuaXNtLlxuICAgICAqICAgICBJdCdzIGV4cGVjdCB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBzb21ldGhpbmcuICBDYW4ndCBiZSB2b2lkLlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqIEB0ZXN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgbWVtb2l6ZShjYWxsYmFjaykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBjYWNoZWRSZXN1bHRzID0ge307XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRBcmdzID0gSlNPTi5zdHJpbmdpZnkoYXJncyk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0c1tzdHJpbmdpZmllZEFyZ3NdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdHNbc3RyaW5naWZpZWRBcmdzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgICAgICAgICAgY2FjaGVkUmVzdWx0c1tzdHJpbmdpZmllZEFyZ3NdID0gcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyBhIGZ1bmN0aW9uIE9OTFkgd2hlbiB0aGUgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKlxuICAgICAqIFJ1bm5pbmcgdGhlIGJlbG93LCB5b3Ugd2lsbCBzZWUgb25seSBmb3VyIGNvbnNvbGUubG9ncyBleGVjdXRlZCwgZWFjaFxuICAgICAqIHdoZW4gdGhlIHBhcmFtcyBoYXZlIGNoYW5nZWQuXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqICAgbGV0IGV4cGVuc2l2ZU9wZXJhdGlvbiA9IGZ1bmMucnVuT25jZU9uQ2hhbmdlKFxuICAgICAqICAgICAgIChuYW1lKSA9PiB7XG4gICAgICogICAgICAgICAgIC8vIERvIGV4cGVuc2l2ZSBzdHVmZiBoZXJlLlxuICAgICAqICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lKTtcbiAgICAgKiAgICAgICB9XG4gICAgICogICApO1xuICAgICAqXG4gICAgICogICBleHBlbnNpdmVPcGVyYXRpb24oJ1Njb3R0Jyk7ICAvLyBTY290dFxuICAgICAqICAgZXhwZW5zaXZlT3BlcmF0aW9uKCdTY290dCcpO1xuICAgICAqICAgZXhwZW5zaXZlT3BlcmF0aW9uKCdTY290dCcpO1xuICAgICAqICAgZXhwZW5zaXZlT3BlcmF0aW9uKCdTY290dCcpO1xuICAgICAqICAgZXhwZW5zaXZlT3BlcmF0aW9uKCdTY290dCcpO1xuICAgICAqICAgZXhwZW5zaXZlT3BlcmF0aW9uKCdKb2huJyk7ICAgLy8gSm9oblxuICAgICAqICAgZXhwZW5zaXZlT3BlcmF0aW9uKCdKb2huJyk7XG4gICAgICogICBleHBlbnNpdmVPcGVyYXRpb24oJ0F5YScpOyAgICAvLyBBeWFcbiAgICAgKiAgIGV4cGVuc2l2ZU9wZXJhdGlvbignQXlhJyk7XG4gICAgICogICBleHBlbnNpdmVPcGVyYXRpb24oJ0pvaG4nKTsgICAvLyBKb2huXG4gICAgICogICBleHBlbnNpdmVPcGVyYXRpb24oJ0pvaG4nKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE1vcmUgaW4gcHJhY3RpY2UuICBIZXJlIHdlIHdhbnQgdG8gZG8gbXV0YXRlIG9ubHkgd2hlbiB0aGUgd2luZG93LmlubmVyV2lkdGhcbiAgICAgKiBvciB3aW5kb3dIZWlnaHQgaGFzIGNoYW5nZWQuXG4gICAgICogYGBgdHNcbiAgICAgKiBsZXQgdXBkYXRlQ2FudmFzU2l6ZSA9IGZ1bmMucnVuT25jZU9uQ2hhbmdlKFxuICAgICAqICAgICh3aW5kb3dXaWR0aCwgd2luZG93SGVpZ2h0KT0+IHtcbiAgICAgKiAgICAgICAvLyBEbyBzb21ldGhpbmcgZXhwZW5zaXZlLlxuICAgICAqICAgICAgIGNvbnNvbGUubG9nKCdDaGFuZ2UgdGhlIGNhbnZhcyBzaXplJyk7XG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIG5ldyBSYWYoKCk9PiB7XG4gICAgICogICB1cGRhdGVDYW52YXNTaXplKHdpbmRvdy5pbm5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gaW1wbGVtZW50IHRoaXMgZm9yIGEgY2xhc3MgbWV0aG9kIGFzIGZvbGxvd3NcbiAgICAgKiBgYGB0c1xuICAgICAqIGNsYXNzIE15Q2xhc3Mge1xuICAgICAqXG4gICAgICogICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAqICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGVsbG8nKTtcbiAgICAgKiAgICAgICAgdGhpcy5yZW5kZXIgPSBmdW5jLnJ1bk9uY2VPbkNoYW5nZSh0aGlzLnJlbmRlci5iaW5kKHRoaXMpKTtcbiAgICAgKlxuICAgICAqICAgICAgICB0aGlzLnJlbmRlcig4MDApO1xuICAgICAqICAgICAgICB0aGlzLnJlbmRlcig4MDApOyAvLyBXb24ndCBiZSBjYWxsZWQgYSBzZWNvbmQgdGltZS5cbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogICAgIHJlbmRlcihoZWlnaHQpIHtcbiAgICAgKiAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBleGVjdXRlLiAgRG9lc24ndCByZXF1aXJlXG4gICAgICogICAgIHRoZSBjYWxsYmFjayB0byByZXR1cm4gYSB2YWx1ZS5cbiAgICAgKiBAdGVzdGVkXG4gICAgICovXG4gICAgc3RhdGljIHJ1bk9uY2VPbkNoYW5nZShjYWxsYmFjaykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgY2FjaGVkUmVzdWx0cyA9IG51bGw7XG4gICAgICAgIGxldCBjYWNoZWRBcmdzID0gbnVsbDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZEFyZ3MgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgICAgICAgICAgIC8vIE9ubHkgZXhjdXRlIGlmIGFyZ3VtZW50cyBhcmUgZGlmZmVyZW50LlxuICAgICAgICAgICAgaWYgKHN0cmluZ2lmaWVkQXJncyAhPT0gY2FjaGVkQXJncykge1xuICAgICAgICAgICAgICAgIGNhY2hlZEFyZ3MgPSBzdHJpbmdpZmllZEFyZ3M7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgcmV0dXJuIChjYWNoZWRSZXN1bHRzID0gY2FsbGJhY2soLi4uYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1ldGhvZCB0aGF0IHNldHMgdGhlIGRlZmF1bHQgdmFsdWUgaWYgdW5kZWZpbmVkLlxuICAgICAqIFVzZWZ1bCBpbiBzZXR0aW5nIGV4cGxpY2l0IGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIGZ1bmMuc2V0RGVmYXVsdCgxMCwgMjApOyAvLyAxMFxuICAgICAqIGZ1bmMuc2V0RGVmYXVsdCh1bmRlZmluZWQsIDIwKTsgLy8gMjBcbiAgICAgKiBmdW5jLnNldERlZmF1bHQodW5kZWZpbmVkLCBmYWxzZSk7IC8vIGZhbHNlXG4gICAgICogYGBgXG4gICAgICogQHRlc3RlZFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIHNldERlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmlzKHZhbHVlLCB1bmRlZmluZWQpID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biB0aGUgY2FsbGJhY2sgYSBzcGVjaWZpYyBudW1iZXIgb2YgdGltZXMuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqXG4gICAgICogIC8vIFJ1bnMgNSB0aW1lcy5cbiAgICAgKiAgZnVuYy50aW1lcyg1LCAoaSkgPT4ge1xuICAgICAqICAgICAgIGNvbnNvbGUubG9nKCd0aW1lcycsIGkpO1xuICAgICAqICB9KTtcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBjb3VudFxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqL1xuICAgIHN0YXRpYyB0aW1lcyhjb3VudCwgY2FsbGJhY2spIHtcbiAgICAgICAgWy4uLkFycmF5KGNvdW50KV0uZm9yRWFjaCgoeCwgaSkgPT4ge1xuICAgICAgICAgICAgY2FsbGJhY2soaSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuZnVuYyA9IGZ1bmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/func/func.js\n");

/***/ }),

/***/ "./lib/func/noop.js":
/*!**************************!*\
  !*** ./lib/func/noop.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.noop = void 0;\n/**\n * Does nothing. Use when you need to do nothing and want to make it clear that\n * you fully understood you were doing nothing and really truly intended to do\n * nothing.\n *\n * It does nothing, but on purpose and doesn't look like a bug or error.\n * It exists solely for readability.\n */\n// eslint-disable-next-line\nfunction noop(...args) {\n    // Purposefully empty.\n}\nexports.noop = noop;\n//# sourceMappingURL=noop.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvZnVuYy9ub29wLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2Z1bmMvbm9vcC5qcz9mZjAzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub29wID0gdm9pZCAwO1xuLyoqXG4gKiBEb2VzIG5vdGhpbmcuIFVzZSB3aGVuIHlvdSBuZWVkIHRvIGRvIG5vdGhpbmcgYW5kIHdhbnQgdG8gbWFrZSBpdCBjbGVhciB0aGF0XG4gKiB5b3UgZnVsbHkgdW5kZXJzdG9vZCB5b3Ugd2VyZSBkb2luZyBub3RoaW5nIGFuZCByZWFsbHkgdHJ1bHkgaW50ZW5kZWQgdG8gZG9cbiAqIG5vdGhpbmcuXG4gKlxuICogSXQgZG9lcyBub3RoaW5nLCBidXQgb24gcHVycG9zZSBhbmQgZG9lc24ndCBsb29rIGxpa2UgYSBidWcgb3IgZXJyb3IuXG4gKiBJdCBleGlzdHMgc29sZWx5IGZvciByZWFkYWJpbGl0eS5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5mdW5jdGlvbiBub29wKC4uLmFyZ3MpIHtcbiAgICAvLyBQdXJwb3NlZnVsbHkgZW1wdHkuXG59XG5leHBvcnRzLm5vb3AgPSBub29wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9vcC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/func/noop.js\n");

/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mathf = exports.bom = exports.DomWatcher = exports.dom = exports.RafTimer = exports.RafProgress = exports.Raf = exports.func = exports.time = exports.is = exports.MultiInterpolate = exports.CssVarInterpolate = exports.Interpolate = exports.EASE = void 0;\nconst dom_1 = __webpack_require__(/*! ./dom/dom */ \"./lib/dom/dom.js\");\nObject.defineProperty(exports, \"dom\", { enumerable: true, get: function () { return dom_1.dom; } });\nconst dom_watcher_1 = __webpack_require__(/*! ./dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\nObject.defineProperty(exports, \"DomWatcher\", { enumerable: true, get: function () { return dom_watcher_1.DomWatcher; } });\nconst bom_1 = __webpack_require__(/*! ./dom/bom */ \"./lib/dom/bom.js\");\nObject.defineProperty(exports, \"bom\", { enumerable: true, get: function () { return bom_1.bom; } });\nconst mathf_1 = __webpack_require__(/*! ./mathf/mathf */ \"./lib/mathf/mathf.js\");\nObject.defineProperty(exports, \"mathf\", { enumerable: true, get: function () { return mathf_1.mathf; } });\nconst is_1 = __webpack_require__(/*! ./is/is */ \"./lib/is/is.js\");\nObject.defineProperty(exports, \"is\", { enumerable: true, get: function () { return is_1.is; } });\nconst func_1 = __webpack_require__(/*! ./func/func */ \"./lib/func/func.js\");\nObject.defineProperty(exports, \"func\", { enumerable: true, get: function () { return func_1.func; } });\nconst time_1 = __webpack_require__(/*! ./time/time */ \"./lib/time/time.js\");\nObject.defineProperty(exports, \"time\", { enumerable: true, get: function () { return time_1.time; } });\nconst raf_1 = __webpack_require__(/*! ./raf/raf */ \"./lib/raf/raf.js\");\nObject.defineProperty(exports, \"Raf\", { enumerable: true, get: function () { return raf_1.Raf; } });\nconst raf_progress_1 = __webpack_require__(/*! ./raf/raf-progress */ \"./lib/raf/raf-progress.js\");\nObject.defineProperty(exports, \"RafProgress\", { enumerable: true, get: function () { return raf_progress_1.RafProgress; } });\nconst raf_timer_1 = __webpack_require__(/*! ./raf/raf-timer */ \"./lib/raf/raf-timer.js\");\nObject.defineProperty(exports, \"RafTimer\", { enumerable: true, get: function () { return raf_timer_1.RafTimer; } });\nconst interpolate_1 = __webpack_require__(/*! ./interpolate/interpolate */ \"./lib/interpolate/interpolate.js\");\nObject.defineProperty(exports, \"Interpolate\", { enumerable: true, get: function () { return interpolate_1.Interpolate; } });\nconst css_var_interpolate_1 = __webpack_require__(/*! ./interpolate/css-var-interpolate */ \"./lib/interpolate/css-var-interpolate.js\");\nObject.defineProperty(exports, \"CssVarInterpolate\", { enumerable: true, get: function () { return css_var_interpolate_1.CssVarInterpolate; } });\nconst multi_interpolate_1 = __webpack_require__(/*! ./interpolate/multi-interpolate */ \"./lib/interpolate/multi-interpolate.js\");\nObject.defineProperty(exports, \"MultiInterpolate\", { enumerable: true, get: function () { return multi_interpolate_1.MultiInterpolate; } });\nconst ease_1 = __webpack_require__(/*! ./ease/ease */ \"./lib/ease/ease.js\");\nObject.defineProperty(exports, \"EASE\", { enumerable: true, get: function () { return ease_1.EASE; } });\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvaW5kZXguanM/OWIwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWF0aGYgPSBleHBvcnRzLmJvbSA9IGV4cG9ydHMuRG9tV2F0Y2hlciA9IGV4cG9ydHMuZG9tID0gZXhwb3J0cy5SYWZUaW1lciA9IGV4cG9ydHMuUmFmUHJvZ3Jlc3MgPSBleHBvcnRzLlJhZiA9IGV4cG9ydHMuZnVuYyA9IGV4cG9ydHMudGltZSA9IGV4cG9ydHMuaXMgPSBleHBvcnRzLk11bHRpSW50ZXJwb2xhdGUgPSBleHBvcnRzLkNzc1ZhckludGVycG9sYXRlID0gZXhwb3J0cy5JbnRlcnBvbGF0ZSA9IGV4cG9ydHMuRUFTRSA9IHZvaWQgMDtcbmNvbnN0IGRvbV8xID0gcmVxdWlyZShcIi4vZG9tL2RvbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRvbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9tXzEuZG9tOyB9IH0pO1xuY29uc3QgZG9tX3dhdGNoZXJfMSA9IHJlcXVpcmUoXCIuL2RvbS9kb20td2F0Y2hlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvbVdhdGNoZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvbV93YXRjaGVyXzEuRG9tV2F0Y2hlcjsgfSB9KTtcbmNvbnN0IGJvbV8xID0gcmVxdWlyZShcIi4vZG9tL2JvbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJvbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYm9tXzEuYm9tOyB9IH0pO1xuY29uc3QgbWF0aGZfMSA9IHJlcXVpcmUoXCIuL21hdGhmL21hdGhmXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWF0aGZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmXzEubWF0aGY7IH0gfSk7XG5jb25zdCBpc18xID0gcmVxdWlyZShcIi4vaXMvaXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNfMS5pczsgfSB9KTtcbmNvbnN0IGZ1bmNfMSA9IHJlcXVpcmUoXCIuL2Z1bmMvZnVuY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZ1bmNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmNfMS5mdW5jOyB9IH0pO1xuY29uc3QgdGltZV8xID0gcmVxdWlyZShcIi4vdGltZS90aW1lXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidGltZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGltZV8xLnRpbWU7IH0gfSk7XG5jb25zdCByYWZfMSA9IHJlcXVpcmUoXCIuL3JhZi9yYWZcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSYWZcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJhZl8xLlJhZjsgfSB9KTtcbmNvbnN0IHJhZl9wcm9ncmVzc18xID0gcmVxdWlyZShcIi4vcmFmL3JhZi1wcm9ncmVzc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJhZlByb2dyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByYWZfcHJvZ3Jlc3NfMS5SYWZQcm9ncmVzczsgfSB9KTtcbmNvbnN0IHJhZl90aW1lcl8xID0gcmVxdWlyZShcIi4vcmFmL3JhZi10aW1lclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJhZlRpbWVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByYWZfdGltZXJfMS5SYWZUaW1lcjsgfSB9KTtcbmNvbnN0IGludGVycG9sYXRlXzEgPSByZXF1aXJlKFwiLi9pbnRlcnBvbGF0ZS9pbnRlcnBvbGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVycG9sYXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcnBvbGF0ZV8xLkludGVycG9sYXRlOyB9IH0pO1xuY29uc3QgY3NzX3Zhcl9pbnRlcnBvbGF0ZV8xID0gcmVxdWlyZShcIi4vaW50ZXJwb2xhdGUvY3NzLXZhci1pbnRlcnBvbGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNzc1ZhckludGVycG9sYXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjc3NfdmFyX2ludGVycG9sYXRlXzEuQ3NzVmFySW50ZXJwb2xhdGU7IH0gfSk7XG5jb25zdCBtdWx0aV9pbnRlcnBvbGF0ZV8xID0gcmVxdWlyZShcIi4vaW50ZXJwb2xhdGUvbXVsdGktaW50ZXJwb2xhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNdWx0aUludGVycG9sYXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtdWx0aV9pbnRlcnBvbGF0ZV8xLk11bHRpSW50ZXJwb2xhdGU7IH0gfSk7XG5jb25zdCBlYXNlXzEgPSByZXF1aXJlKFwiLi9lYXNlL2Vhc2VcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFQVNFXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlYXNlXzEuRUFTRTsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/index.js\n");

/***/ }),

/***/ "./lib/interpolate/css-var-interpolate.js":
/*!************************************************!*\
  !*** ./lib/interpolate/css-var-interpolate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CssVarInterpolate = void 0;\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst multi_interpolate_1 = __webpack_require__(/*! ./multi-interpolate */ \"./lib/interpolate/multi-interpolate.js\");\nconst element_visibility_1 = __webpack_require__(/*! ../dom/element-visibility */ \"./lib/dom/element-visibility.js\");\nconst dom_1 = __webpack_require__(/*! ../dom/dom */ \"./lib/dom/dom.js\");\nconst css_unit_1 = __webpack_require__(/*! ../string/css-unit */ \"./lib/string/css-unit.js\");\nconst objectf_1 = __webpack_require__(/*! ../objectf/objectf */ \"./lib/objectf/objectf.js\");\n/**\n * A class that allows you to multiInterpolate css variables.\n *\n * ```\n *\n * HTML\n * <div class=\"ball\"></div>\n * <input id=\"range\" type=\"range\" name=\"points\" step=\"0.01\" min=\"0\" max=\"1\" style=\"width: 500px;\">\n *\n * Sass\n *   You can apply the interpolated value as a css variable. If you specify\n *   numerical values in your from and to values, add the unit in css by\n *   multiplying it.\n *   Example of using vh:\n *      top: calc(var(--x) * 1vh)\n *   Example of using px:\n *      top: calc(var(--x) * 1px)\n *   Example of a complex variable setup:\n *   .ball\n *      transform: translateX(calc(var(--x) * 1px)) translateY(calc(var(--y) * 1px));\n *\n * ```\n *\n *\n *\n * JS\n * ```ts\n *\n *  this.ball = document.getElementById('ball');\n *  this.range = document.getElementById('range');\n *\n *  this.cssVarInterpolate = new CssVarInterpolate(\n *    this.ball,\n *    {\n *      interpolations: [\n *          {\n *            progress: [\n *              { from: 0, to: 1, start: 0, end: 500 },\n *            ],\n *            id: '--x'\n *          },\n *          {\n *            progress: [\n *               { from: 0, to: 0.2, start: 0, end: 100, easingFunction: EASE.easeOutSine },\n *               { from: 0.2, to: 0.3, start: 100, end: 300, easingFunction: EASE.easeOutSine },\n *               { from: 0.3, to: 0.5, start: 300, end: 0, easingFunction: EASE.easeOutSine },\n *               { from: 0.5, to: 1, start: 0, end: 500, easingFunction: EASE.easeInQuad },\n *            ],\n *            id: '--y'\n *          },\n *          // You can use simple unit values.  See interpolate for more.\n *          {\n *            progress: [\n *              { from: 0, to: 0.3, start: '10px', end: '30px' },\n *            ],\n *            id: '--z'\n *          },\n *\n *         // You can also use a special noInteperlate mode.\n *         // This is useful if you want to just apply non-interpolating values\n *         // at specific ranges.  It requires a default value.\n *         {\n *            progress: [\n *              { from: 0.2, to: 0.3, start: 'block', end: 'block' },\n *            ],\n *            id: '--display-settings',\n *            noInterpolation: true,\n *            noInterpolationDefault: 'none'\n *         }\n *\n *\n *        // Visibility id\n *        // It's common to associate visibility: hidden with opacity: 0\n *        // in order to boost rendering performance.\n *        // This can be done by creating a non-interpolation (see above)\n *        // but since it's a common take, it is available as a special\n *        // parameter.\n *        // Pass the visibilityId and it will create a css variable\n *        // tied to the opacity that sets the value to hidden when\n *        // the opacity value is <= 0.\n *          {\n *            progress: [\n *              { from: 0, to: 0.3, start: 0, end: 1 },\n *            ],\n *            id: '--my-opacity',\n *            visibilityId: '--my-visibility\n *          },\n *\n *\n *       // Staggers allows to create multi entries of the same property with an\n *       // offset.  For example, here 4 staggers would be created.\n *       // hero-y-0, hero-y-1, hero-y-2, hero-y-3 and the from and end points\n *       // would each be shifted by the progressOffset (0.008).\n *       // You can then use those css variables to target your elements.\n *       //\n *       // An easy way might be to add [row=\"0\"], [row=\"1\"]\n *       // your elements and add a sass mixin like the following.\n *       //\n *       //\n *       //  =effect-stagger($stagger, $offset)\n *       //   @for $i from 0 through $stagger\n *       //       [row=\"#{$i}\"]\n *       //       transform: translateY(var(--hero2-y-#{$i + $offset}))\n *       //\n *       // .my-chapter\n *       //     +effect-stagger(4,0)\n *       //\n *       // You could use this effect with https://github.com/blinkkcode/degu/blob/master/src/angular/directive-text-split.ts\n *       // or https://github.com/blinkkcode/degu/blob/master/src/dom/text-split2.ts\n *       //\n *       {\n *         progress: [{ from: 0, to: 0.3, start: '0px', end: '100px' }]\n *         id: 'hero-y',\n *         stagger: {\n *             count: 4,\n *             progressOffset: 0.008\n *         }\n *        }\n *\n *\n *\n *      ]}\n *  )\n *\n * // For perf boost\n * this.interpolator.useSubPixelRendering(false);\n *\n *  // Set the progress to the range value.\n *  this.progress = +this.range.value;\n *\n *\n *  // Note that cssVarInterpolate, will cull uncessary calls to\n *  // avoid layout updates/thrashing.  If the value of progress is the\n *  // same, won't make any uncessary calls but allow the animations\n *  // to complete.\n *  //\n *  //\n *  // Note that it is recommended to use [[RafProgress]] to manage progress\n *  // easing but here to keep the demo simple, we are using a simplified\n *  // model. See the css-var-interpolate example in /examples folder for this\n *  // same implemetnation using RafProgress.\n *  //\n *  const raf = new Raf(() => {\n *     let progress = +this.range.value;\n *\n *    // Add some ease to the progress to smooth it out.\n *    this.progress = mathf.ease(this.progress, progress, 0.25, EASE.easeInOutQuad);\n *\n *   // Reduce the precision of progress.  We dont need to report progress differences\n *   // of 0.0000001.\n *   this.progress = mathf.round(this.progress, 3);\n *\n *    this.cssVarInterpolate.update(this.progress);\n *  }).start();\n *\n *\n * ```\n *\n * Ranged Progress Interpolations\n * You can also set the progress range.  This will tell cssVarInterpolate\n * to internally generate a [[mathf.childProgress]] and scope the interpolations\n * to a scoped range instead of 0-1.\n * ```ts\n *  this.cssVarInterpolate.setProgressRange(0.2, 0.6);\n * ```\n *\n *\n * Element Visibility\n * CssVarInterpolate by default will only update css variables when the\n * root element is inview to performance reasons.\n *\n * If you want to turn this off, do the following:\n *\n * ```ts\n * this.cssVarInterpolate.renderOutview(true);\n * ```\n *\n *\n * // No write mode.\n * There are times you may just want to use the css-var-interpolate to just\n * calculate values for you.\n *\n * You can prevent css-var-interpolate from writing to the dom with:\n *\n * ```ts\n * this.cssVarInterpolate.useNoWrite(true);\n * ```\n *\n * then you can do something like this to get the values.\n *\n * ```\n * // Update\n *    this.cssVarInterpolate.update(this.progress);\n *\n * // Get the calculated values.\n *    const values = this.cssVarInterpolate.getValues();\n *\n *\n * // Now apply them or use them however you want.\n *    dom.setCssVariables(myElement, values);\n *\n * ```\n */\nclass CssVarInterpolate {\n    /**\n     * @param element The element to update the css variable to.\n     *     This can be the body element if you want a \"global\" css\n     *     variable or you can specific a more speicific element to\n     *     scope the results of your css variables.\n     * @param config\n     */\n    constructor(element, config) {\n        this.element = element;\n        this.config = config;\n        /**\n         * Set this to initially null so that when update is first called\n         * we are guanranteed that it will be processed.\n         */\n        this.mainProgress = null;\n        this.currentValues = {};\n        this.renderSubPixels = true;\n        if (config) {\n            this.multiInterpolate = new multi_interpolate_1.MultiInterpolate(config);\n        }\n        else {\n            this.multiInterpolate = null;\n        }\n        // Add element visibility to the VectorDom.\n        this.elementVisibility = element_visibility_1.elementVisibility.inview(this.element);\n        this.runOnceAfterOutView = true;\n        this.renderOnlyWhenInview = true;\n        this.ranOutViewUpdate = false;\n        this.precision = 4;\n        this.noWrite = false;\n        this.startProgress = 0;\n        this.endProgress = 1;\n    }\n    /**\n     * Updates the internal interpolations.   Use this to update your\n     * interpolations.\n     *\n     * ```ts\n     *\n     * let ci = new CssVarInterpolate(element);\n     * ci.setInterpolations({\n     *   interpolations: [\n     *       {\n     *           progress: [\n     *               { from: 0, to: 1, start: 0, end: 500 },\n     *           ],\n     *           id: '--x'\n     *\n     *       }\n     *   ]\n     * });\n     *\n     *\n     * ```\n     *\n     * @param config\n     */\n    setInterpolations(config) {\n        if (config) {\n            this.multiInterpolate = new multi_interpolate_1.MultiInterpolate(config);\n        }\n    }\n    /**\n     * Sets the internal precision.  Precision is used to evaluate how many\n     * decimals should be valuated on progress.  Lower precision means, 0.8888\n     * and 0.88888 would be same.    Enter the number of decimals you want to\n     * account for.  Lower precision will have slight performance benefits.\n     */\n    setPrecision(numberOfDecimals) {\n        this.precision = numberOfDecimals;\n    }\n    /**\n     * Flushes the update cache.  By default, two consecutive calls to\n     * update with the same progress values will cull the second call\n     * for performance booosts.  However, there are rare cases where\n     * you may want to update with the same progress values and force\n     * an update to the variable.  Calling flush will flush the internal\n     * cache.\n     *\n     * ```ts\n     *\n     * cssVarInterpolate.update(0.2);\n     * cssVarInterpolate.update(0.2); // Normally gets ignored\n     *\n     * cssVarInterpolate.update(0.2);\n     * cssVarInterpolate.flush(); // Flush cache\n     * cssVarInterpolate.update(0.2); // Will update.\n     * ```\n     */\n    flush() {\n        this.mainProgress = null;\n    }\n    /**\n     * Toggles subpixel rendering. When subpixel rendering is turned off,\n     * 'px' value interpolations will be turned into whole\n     * numbers.  Subpixel rendering is turned on by default but can be\n     * turned off for performance boosts.\n     */\n    useSubPixelRendering(value) {\n        this.renderSubPixels = value;\n    }\n    /**\n     * Sets css-var-interpolate to no write mode in which it will only calculate\n     * values but not write them to the dom.  This is used for cases in which\n     * you want use the class to calculate values but take control of when\n     * and where writing happens.\n     * @param value\n     */\n    useNoWrite(value) {\n        this.noWrite = value;\n    }\n    /**\n     * Allows batch update of css variables.  Recommend for improved\n     * performance.\n     */\n    // eslint-disable-next-line\n    useBatchUpdate(value) {\n        // This performance optimization is no longer needed, so setting this\n        // is a no-op.\n    }\n    /**\n     * Sets css var interpolate to render even when out of view.\n     */\n    renderOutview(value) {\n        this.renderOnlyWhenInview = !value;\n    }\n    /**\n     * Updates the progress and updates the css variable values.\n     * @param {number} progress\n     * @param {boolean} force Allows you to bypass the cache.  By default\n     *   two consecutive calls to update WITH the same progress values will\n     *   cull the second call.  Force allows you to force it to render again.\n     */\n    update(progress, force = false) {\n        if (!this.multiInterpolate) {\n            return;\n        }\n        // Only make updates when progress value was updated to avoid layout\n        // thrashing.\n        if (!force && progress === this.mainProgress) {\n            return;\n        }\n        /**\n         * Render this element only when it is inview for performance boost.\n         */\n        if (this.renderOnlyWhenInview &&\n            this.elementVisibility.state().ready &&\n            !this.elementVisibility.state().inview) {\n            // If we go out of view run interpolations atleast once so that\n            // when the element comes back into view, it correctly sits in\n            // the starting position.\n            if (this.runOnceAfterOutView && !this.ranOutViewUpdate) {\n                this.ranOutViewUpdate = true;\n                // Make a guestimation of 0 or 1 and round to 0 or 1 state.\n                // This helps fight cases in which progress might be tied to\n                // an eased scroll and user quickly scrolls out of view in which\n                // the progress is not fully resolve to the start or end state.\n                this.updateValues(progress >= 0.5 ? 1 : 0);\n            }\n            return;\n        }\n        // We are inview so run update normally.\n        this.ranOutViewUpdate = false;\n        this.updateValues(progress);\n    }\n    /**\n     * Updates and calculates interpolation values.\n     */\n    updateValues(progress) {\n        if (!this.multiInterpolate) {\n            return;\n        }\n        const roundedPrecision = mathf_1.mathf.toFixed(progress, this.precision);\n        // Cull if progress hasn't changed.\n        if (this.mainProgress === roundedPrecision) {\n            return;\n        }\n        // Create a child progress so that the range in which this interpolation\n        // reacts can be scoped.\n        // Use noClamp so that we can define negative progress if needed.\n        this.mainProgress = mathf_1.mathf.childProgress(roundedPrecision, this.startProgress, this.endProgress, true);\n        const previousValues = objectf_1.objectf.jsonCopy(this.currentValues);\n        this.currentValues = this.multiInterpolate.calculate(this.mainProgress);\n        // Check if the previous values and current values are exactly the same\n        // in which case we can avoid an unncessary update.\n        if (objectf_1.objectf.areEqual(previousValues, this.currentValues)) {\n            return;\n        }\n        // If we are in noWrite mode, skip.\n        if (this.noWrite) {\n            return;\n        }\n        for (const key in this.currentValues) {\n            let value = this.currentValues[key];\n            if (!this.renderSubPixels && typeof value === 'string') {\n                const cssUnitValue = css_unit_1.cssUnit.parse(value);\n                if (cssUnitValue.unit === 'px') {\n                    value = (cssUnitValue.value >> 0) + 'px';\n                    this.currentValues[key] = value;\n                }\n            }\n            dom_1.dom.setCssVariable(this.element, key, String(value));\n        }\n    }\n    /**\n     * Sets the start and end values of which interpolations begin.  This allows\n     * you to set something like, given the main progress that is updated from\n     * 0-1, I only want this to interpolate from 0.2-0.6.\n     * @param start\n     * @param end\n     */\n    setProgressRange(start, end) {\n        this.startProgress = start;\n        this.endProgress = end;\n    }\n    /**\n     * Gets the last set of calculated values.  This will return an empty\n     * object if no updates / calculations have been run.  If updates have\n     * been executed, it will return an object with each css-var property value.\n     */\n    getValues() {\n        return this.currentValues;\n    }\n}\nexports.CssVarInterpolate = CssVarInterpolate;\n//# sourceMappingURL=css-var-interpolate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvaW50ZXJwb2xhdGUvY3NzLXZhci1pbnRlcnBvbGF0ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9pbnRlcnBvbGF0ZS9jc3MtdmFyLWludGVycG9sYXRlLmpzP2RlODgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNzc1ZhckludGVycG9sYXRlID0gdm9pZCAwO1xuY29uc3QgbWF0aGZfMSA9IHJlcXVpcmUoXCIuLi9tYXRoZi9tYXRoZlwiKTtcbmNvbnN0IG11bHRpX2ludGVycG9sYXRlXzEgPSByZXF1aXJlKFwiLi9tdWx0aS1pbnRlcnBvbGF0ZVwiKTtcbmNvbnN0IGVsZW1lbnRfdmlzaWJpbGl0eV8xID0gcmVxdWlyZShcIi4uL2RvbS9lbGVtZW50LXZpc2liaWxpdHlcIik7XG5jb25zdCBkb21fMSA9IHJlcXVpcmUoXCIuLi9kb20vZG9tXCIpO1xuY29uc3QgY3NzX3VuaXRfMSA9IHJlcXVpcmUoXCIuLi9zdHJpbmcvY3NzLXVuaXRcIik7XG5jb25zdCBvYmplY3RmXzEgPSByZXF1aXJlKFwiLi4vb2JqZWN0Zi9vYmplY3RmXCIpO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgYWxsb3dzIHlvdSB0byBtdWx0aUludGVycG9sYXRlIGNzcyB2YXJpYWJsZXMuXG4gKlxuICogYGBgXG4gKlxuICogSFRNTFxuICogPGRpdiBjbGFzcz1cImJhbGxcIj48L2Rpdj5cbiAqIDxpbnB1dCBpZD1cInJhbmdlXCIgdHlwZT1cInJhbmdlXCIgbmFtZT1cInBvaW50c1wiIHN0ZXA9XCIwLjAxXCIgbWluPVwiMFwiIG1heD1cIjFcIiBzdHlsZT1cIndpZHRoOiA1MDBweDtcIj5cbiAqXG4gKiBTYXNzXG4gKiAgIFlvdSBjYW4gYXBwbHkgdGhlIGludGVycG9sYXRlZCB2YWx1ZSBhcyBhIGNzcyB2YXJpYWJsZS4gSWYgeW91IHNwZWNpZnlcbiAqICAgbnVtZXJpY2FsIHZhbHVlcyBpbiB5b3VyIGZyb20gYW5kIHRvIHZhbHVlcywgYWRkIHRoZSB1bml0IGluIGNzcyBieVxuICogICBtdWx0aXBseWluZyBpdC5cbiAqICAgRXhhbXBsZSBvZiB1c2luZyB2aDpcbiAqICAgICAgdG9wOiBjYWxjKHZhcigtLXgpICogMXZoKVxuICogICBFeGFtcGxlIG9mIHVzaW5nIHB4OlxuICogICAgICB0b3A6IGNhbGModmFyKC0teCkgKiAxcHgpXG4gKiAgIEV4YW1wbGUgb2YgYSBjb21wbGV4IHZhcmlhYmxlIHNldHVwOlxuICogICAuYmFsbFxuICogICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoY2FsYyh2YXIoLS14KSAqIDFweCkpIHRyYW5zbGF0ZVkoY2FsYyh2YXIoLS15KSAqIDFweCkpO1xuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICogSlNcbiAqIGBgYHRzXG4gKlxuICogIHRoaXMuYmFsbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiYWxsJyk7XG4gKiAgdGhpcy5yYW5nZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyYW5nZScpO1xuICpcbiAqICB0aGlzLmNzc1ZhckludGVycG9sYXRlID0gbmV3IENzc1ZhckludGVycG9sYXRlKFxuICogICAgdGhpcy5iYWxsLFxuICogICAge1xuICogICAgICBpbnRlcnBvbGF0aW9uczogW1xuICogICAgICAgICAge1xuICogICAgICAgICAgICBwcm9ncmVzczogW1xuICogICAgICAgICAgICAgIHsgZnJvbTogMCwgdG86IDEsIHN0YXJ0OiAwLCBlbmQ6IDUwMCB9LFxuICogICAgICAgICAgICBdLFxuICogICAgICAgICAgICBpZDogJy0teCdcbiAqICAgICAgICAgIH0sXG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICAgIHByb2dyZXNzOiBbXG4gKiAgICAgICAgICAgICAgIHsgZnJvbTogMCwgdG86IDAuMiwgc3RhcnQ6IDAsIGVuZDogMTAwLCBlYXNpbmdGdW5jdGlvbjogRUFTRS5lYXNlT3V0U2luZSB9LFxuICogICAgICAgICAgICAgICB7IGZyb206IDAuMiwgdG86IDAuMywgc3RhcnQ6IDEwMCwgZW5kOiAzMDAsIGVhc2luZ0Z1bmN0aW9uOiBFQVNFLmVhc2VPdXRTaW5lIH0sXG4gKiAgICAgICAgICAgICAgIHsgZnJvbTogMC4zLCB0bzogMC41LCBzdGFydDogMzAwLCBlbmQ6IDAsIGVhc2luZ0Z1bmN0aW9uOiBFQVNFLmVhc2VPdXRTaW5lIH0sXG4gKiAgICAgICAgICAgICAgIHsgZnJvbTogMC41LCB0bzogMSwgc3RhcnQ6IDAsIGVuZDogNTAwLCBlYXNpbmdGdW5jdGlvbjogRUFTRS5lYXNlSW5RdWFkIH0sXG4gKiAgICAgICAgICAgIF0sXG4gKiAgICAgICAgICAgIGlkOiAnLS15J1xuICogICAgICAgICAgfSxcbiAqICAgICAgICAgIC8vIFlvdSBjYW4gdXNlIHNpbXBsZSB1bml0IHZhbHVlcy4gIFNlZSBpbnRlcnBvbGF0ZSBmb3IgbW9yZS5cbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgICAgcHJvZ3Jlc3M6IFtcbiAqICAgICAgICAgICAgICB7IGZyb206IDAsIHRvOiAwLjMsIHN0YXJ0OiAnMTBweCcsIGVuZDogJzMwcHgnIH0sXG4gKiAgICAgICAgICAgIF0sXG4gKiAgICAgICAgICAgIGlkOiAnLS16J1xuICogICAgICAgICAgfSxcbiAqXG4gKiAgICAgICAgIC8vIFlvdSBjYW4gYWxzbyB1c2UgYSBzcGVjaWFsIG5vSW50ZXBlcmxhdGUgbW9kZS5cbiAqICAgICAgICAgLy8gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8ganVzdCBhcHBseSBub24taW50ZXJwb2xhdGluZyB2YWx1ZXNcbiAqICAgICAgICAgLy8gYXQgc3BlY2lmaWMgcmFuZ2VzLiAgSXQgcmVxdWlyZXMgYSBkZWZhdWx0IHZhbHVlLlxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgIHByb2dyZXNzOiBbXG4gKiAgICAgICAgICAgICAgeyBmcm9tOiAwLjIsIHRvOiAwLjMsIHN0YXJ0OiAnYmxvY2snLCBlbmQ6ICdibG9jaycgfSxcbiAqICAgICAgICAgICAgXSxcbiAqICAgICAgICAgICAgaWQ6ICctLWRpc3BsYXktc2V0dGluZ3MnLFxuICogICAgICAgICAgICBub0ludGVycG9sYXRpb246IHRydWUsXG4gKiAgICAgICAgICAgIG5vSW50ZXJwb2xhdGlvbkRlZmF1bHQ6ICdub25lJ1xuICogICAgICAgICB9XG4gKlxuICpcbiAqICAgICAgICAvLyBWaXNpYmlsaXR5IGlkXG4gKiAgICAgICAgLy8gSXQncyBjb21tb24gdG8gYXNzb2NpYXRlIHZpc2liaWxpdHk6IGhpZGRlbiB3aXRoIG9wYWNpdHk6IDBcbiAqICAgICAgICAvLyBpbiBvcmRlciB0byBib29zdCByZW5kZXJpbmcgcGVyZm9ybWFuY2UuXG4gKiAgICAgICAgLy8gVGhpcyBjYW4gYmUgZG9uZSBieSBjcmVhdGluZyBhIG5vbi1pbnRlcnBvbGF0aW9uIChzZWUgYWJvdmUpXG4gKiAgICAgICAgLy8gYnV0IHNpbmNlIGl0J3MgYSBjb21tb24gdGFrZSwgaXQgaXMgYXZhaWxhYmxlIGFzIGEgc3BlY2lhbFxuICogICAgICAgIC8vIHBhcmFtZXRlci5cbiAqICAgICAgICAvLyBQYXNzIHRoZSB2aXNpYmlsaXR5SWQgYW5kIGl0IHdpbGwgY3JlYXRlIGEgY3NzIHZhcmlhYmxlXG4gKiAgICAgICAgLy8gdGllZCB0byB0aGUgb3BhY2l0eSB0aGF0IHNldHMgdGhlIHZhbHVlIHRvIGhpZGRlbiB3aGVuXG4gKiAgICAgICAgLy8gdGhlIG9wYWNpdHkgdmFsdWUgaXMgPD0gMC5cbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgICAgcHJvZ3Jlc3M6IFtcbiAqICAgICAgICAgICAgICB7IGZyb206IDAsIHRvOiAwLjMsIHN0YXJ0OiAwLCBlbmQ6IDEgfSxcbiAqICAgICAgICAgICAgXSxcbiAqICAgICAgICAgICAgaWQ6ICctLW15LW9wYWNpdHknLFxuICogICAgICAgICAgICB2aXNpYmlsaXR5SWQ6ICctLW15LXZpc2liaWxpdHlcbiAqICAgICAgICAgIH0sXG4gKlxuICpcbiAqICAgICAgIC8vIFN0YWdnZXJzIGFsbG93cyB0byBjcmVhdGUgbXVsdGkgZW50cmllcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSB3aXRoIGFuXG4gKiAgICAgICAvLyBvZmZzZXQuICBGb3IgZXhhbXBsZSwgaGVyZSA0IHN0YWdnZXJzIHdvdWxkIGJlIGNyZWF0ZWQuXG4gKiAgICAgICAvLyBoZXJvLXktMCwgaGVyby15LTEsIGhlcm8teS0yLCBoZXJvLXktMyBhbmQgdGhlIGZyb20gYW5kIGVuZCBwb2ludHNcbiAqICAgICAgIC8vIHdvdWxkIGVhY2ggYmUgc2hpZnRlZCBieSB0aGUgcHJvZ3Jlc3NPZmZzZXQgKDAuMDA4KS5cbiAqICAgICAgIC8vIFlvdSBjYW4gdGhlbiB1c2UgdGhvc2UgY3NzIHZhcmlhYmxlcyB0byB0YXJnZXQgeW91ciBlbGVtZW50cy5cbiAqICAgICAgIC8vXG4gKiAgICAgICAvLyBBbiBlYXN5IHdheSBtaWdodCBiZSB0byBhZGQgW3Jvdz1cIjBcIl0sIFtyb3c9XCIxXCJdXG4gKiAgICAgICAvLyB5b3VyIGVsZW1lbnRzIGFuZCBhZGQgYSBzYXNzIG1peGluIGxpa2UgdGhlIGZvbGxvd2luZy5cbiAqICAgICAgIC8vXG4gKiAgICAgICAvL1xuICogICAgICAgLy8gID1lZmZlY3Qtc3RhZ2dlcigkc3RhZ2dlciwgJG9mZnNldClcbiAqICAgICAgIC8vICAgQGZvciAkaSBmcm9tIDAgdGhyb3VnaCAkc3RhZ2dlclxuICogICAgICAgLy8gICAgICAgW3Jvdz1cIiN7JGl9XCJdXG4gKiAgICAgICAvLyAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkodmFyKC0taGVybzIteS0jeyRpICsgJG9mZnNldH0pKVxuICogICAgICAgLy9cbiAqICAgICAgIC8vIC5teS1jaGFwdGVyXG4gKiAgICAgICAvLyAgICAgK2VmZmVjdC1zdGFnZ2VyKDQsMClcbiAqICAgICAgIC8vXG4gKiAgICAgICAvLyBZb3UgY291bGQgdXNlIHRoaXMgZWZmZWN0IHdpdGggaHR0cHM6Ly9naXRodWIuY29tL2JsaW5ra2NvZGUvZGVndS9ibG9iL21hc3Rlci9zcmMvYW5ndWxhci9kaXJlY3RpdmUtdGV4dC1zcGxpdC50c1xuICogICAgICAgLy8gb3IgaHR0cHM6Ly9naXRodWIuY29tL2JsaW5ra2NvZGUvZGVndS9ibG9iL21hc3Rlci9zcmMvZG9tL3RleHQtc3BsaXQyLnRzXG4gKiAgICAgICAvL1xuICogICAgICAge1xuICogICAgICAgICBwcm9ncmVzczogW3sgZnJvbTogMCwgdG86IDAuMywgc3RhcnQ6ICcwcHgnLCBlbmQ6ICcxMDBweCcgfV1cbiAqICAgICAgICAgaWQ6ICdoZXJvLXknLFxuICogICAgICAgICBzdGFnZ2VyOiB7XG4gKiAgICAgICAgICAgICBjb3VudDogNCxcbiAqICAgICAgICAgICAgIHByb2dyZXNzT2Zmc2V0OiAwLjAwOFxuICogICAgICAgICB9XG4gKiAgICAgICAgfVxuICpcbiAqXG4gKlxuICogICAgICBdfVxuICogIClcbiAqXG4gKiAvLyBGb3IgcGVyZiBib29zdFxuICogdGhpcy5pbnRlcnBvbGF0b3IudXNlU3ViUGl4ZWxSZW5kZXJpbmcoZmFsc2UpO1xuICpcbiAqICAvLyBTZXQgdGhlIHByb2dyZXNzIHRvIHRoZSByYW5nZSB2YWx1ZS5cbiAqICB0aGlzLnByb2dyZXNzID0gK3RoaXMucmFuZ2UudmFsdWU7XG4gKlxuICpcbiAqICAvLyBOb3RlIHRoYXQgY3NzVmFySW50ZXJwb2xhdGUsIHdpbGwgY3VsbCB1bmNlc3NhcnkgY2FsbHMgdG9cbiAqICAvLyBhdm9pZCBsYXlvdXQgdXBkYXRlcy90aHJhc2hpbmcuICBJZiB0aGUgdmFsdWUgb2YgcHJvZ3Jlc3MgaXMgdGhlXG4gKiAgLy8gc2FtZSwgd29uJ3QgbWFrZSBhbnkgdW5jZXNzYXJ5IGNhbGxzIGJ1dCBhbGxvdyB0aGUgYW5pbWF0aW9uc1xuICogIC8vIHRvIGNvbXBsZXRlLlxuICogIC8vXG4gKiAgLy9cbiAqICAvLyBOb3RlIHRoYXQgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIFtbUmFmUHJvZ3Jlc3NdXSB0byBtYW5hZ2UgcHJvZ3Jlc3NcbiAqICAvLyBlYXNpbmcgYnV0IGhlcmUgdG8ga2VlcCB0aGUgZGVtbyBzaW1wbGUsIHdlIGFyZSB1c2luZyBhIHNpbXBsaWZpZWRcbiAqICAvLyBtb2RlbC4gU2VlIHRoZSBjc3MtdmFyLWludGVycG9sYXRlIGV4YW1wbGUgaW4gL2V4YW1wbGVzIGZvbGRlciBmb3IgdGhpc1xuICogIC8vIHNhbWUgaW1wbGVtZXRuYXRpb24gdXNpbmcgUmFmUHJvZ3Jlc3MuXG4gKiAgLy9cbiAqICBjb25zdCByYWYgPSBuZXcgUmFmKCgpID0+IHtcbiAqICAgICBsZXQgcHJvZ3Jlc3MgPSArdGhpcy5yYW5nZS52YWx1ZTtcbiAqXG4gKiAgICAvLyBBZGQgc29tZSBlYXNlIHRvIHRoZSBwcm9ncmVzcyB0byBzbW9vdGggaXQgb3V0LlxuICogICAgdGhpcy5wcm9ncmVzcyA9IG1hdGhmLmVhc2UodGhpcy5wcm9ncmVzcywgcHJvZ3Jlc3MsIDAuMjUsIEVBU0UuZWFzZUluT3V0UXVhZCk7XG4gKlxuICogICAvLyBSZWR1Y2UgdGhlIHByZWNpc2lvbiBvZiBwcm9ncmVzcy4gIFdlIGRvbnQgbmVlZCB0byByZXBvcnQgcHJvZ3Jlc3MgZGlmZmVyZW5jZXNcbiAqICAgLy8gb2YgMC4wMDAwMDAxLlxuICogICB0aGlzLnByb2dyZXNzID0gbWF0aGYucm91bmQodGhpcy5wcm9ncmVzcywgMyk7XG4gKlxuICogICAgdGhpcy5jc3NWYXJJbnRlcnBvbGF0ZS51cGRhdGUodGhpcy5wcm9ncmVzcyk7XG4gKiAgfSkuc3RhcnQoKTtcbiAqXG4gKlxuICogYGBgXG4gKlxuICogUmFuZ2VkIFByb2dyZXNzIEludGVycG9sYXRpb25zXG4gKiBZb3UgY2FuIGFsc28gc2V0IHRoZSBwcm9ncmVzcyByYW5nZS4gIFRoaXMgd2lsbCB0ZWxsIGNzc1ZhckludGVycG9sYXRlXG4gKiB0byBpbnRlcm5hbGx5IGdlbmVyYXRlIGEgW1ttYXRoZi5jaGlsZFByb2dyZXNzXV0gYW5kIHNjb3BlIHRoZSBpbnRlcnBvbGF0aW9uc1xuICogdG8gYSBzY29wZWQgcmFuZ2UgaW5zdGVhZCBvZiAwLTEuXG4gKiBgYGB0c1xuICogIHRoaXMuY3NzVmFySW50ZXJwb2xhdGUuc2V0UHJvZ3Jlc3NSYW5nZSgwLjIsIDAuNik7XG4gKiBgYGBcbiAqXG4gKlxuICogRWxlbWVudCBWaXNpYmlsaXR5XG4gKiBDc3NWYXJJbnRlcnBvbGF0ZSBieSBkZWZhdWx0IHdpbGwgb25seSB1cGRhdGUgY3NzIHZhcmlhYmxlcyB3aGVuIHRoZVxuICogcm9vdCBlbGVtZW50IGlzIGludmlldyB0byBwZXJmb3JtYW5jZSByZWFzb25zLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHR1cm4gdGhpcyBvZmYsIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogYGBgdHNcbiAqIHRoaXMuY3NzVmFySW50ZXJwb2xhdGUucmVuZGVyT3V0dmlldyh0cnVlKTtcbiAqIGBgYFxuICpcbiAqXG4gKiAvLyBObyB3cml0ZSBtb2RlLlxuICogVGhlcmUgYXJlIHRpbWVzIHlvdSBtYXkganVzdCB3YW50IHRvIHVzZSB0aGUgY3NzLXZhci1pbnRlcnBvbGF0ZSB0byBqdXN0XG4gKiBjYWxjdWxhdGUgdmFsdWVzIGZvciB5b3UuXG4gKlxuICogWW91IGNhbiBwcmV2ZW50IGNzcy12YXItaW50ZXJwb2xhdGUgZnJvbSB3cml0aW5nIHRvIHRoZSBkb20gd2l0aDpcbiAqXG4gKiBgYGB0c1xuICogdGhpcy5jc3NWYXJJbnRlcnBvbGF0ZS51c2VOb1dyaXRlKHRydWUpO1xuICogYGBgXG4gKlxuICogdGhlbiB5b3UgY2FuIGRvIHNvbWV0aGluZyBsaWtlIHRoaXMgdG8gZ2V0IHRoZSB2YWx1ZXMuXG4gKlxuICogYGBgXG4gKiAvLyBVcGRhdGVcbiAqICAgIHRoaXMuY3NzVmFySW50ZXJwb2xhdGUudXBkYXRlKHRoaXMucHJvZ3Jlc3MpO1xuICpcbiAqIC8vIEdldCB0aGUgY2FsY3VsYXRlZCB2YWx1ZXMuXG4gKiAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmNzc1ZhckludGVycG9sYXRlLmdldFZhbHVlcygpO1xuICpcbiAqXG4gKiAvLyBOb3cgYXBwbHkgdGhlbSBvciB1c2UgdGhlbSBob3dldmVyIHlvdSB3YW50LlxuICogICAgZG9tLnNldENzc1ZhcmlhYmxlcyhteUVsZW1lbnQsIHZhbHVlcyk7XG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIENzc1ZhckludGVycG9sYXRlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0byB1cGRhdGUgdGhlIGNzcyB2YXJpYWJsZSB0by5cbiAgICAgKiAgICAgVGhpcyBjYW4gYmUgdGhlIGJvZHkgZWxlbWVudCBpZiB5b3Ugd2FudCBhIFwiZ2xvYmFsXCIgY3NzXG4gICAgICogICAgIHZhcmlhYmxlIG9yIHlvdSBjYW4gc3BlY2lmaWMgYSBtb3JlIHNwZWljaWZpYyBlbGVtZW50IHRvXG4gICAgICogICAgIHNjb3BlIHRoZSByZXN1bHRzIG9mIHlvdXIgY3NzIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoaXMgdG8gaW5pdGlhbGx5IG51bGwgc28gdGhhdCB3aGVuIHVwZGF0ZSBpcyBmaXJzdCBjYWxsZWRcbiAgICAgICAgICogd2UgYXJlIGd1YW5yYW50ZWVkIHRoYXQgaXQgd2lsbCBiZSBwcm9jZXNzZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1haW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLnJlbmRlclN1YlBpeGVscyA9IHRydWU7XG4gICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMubXVsdGlJbnRlcnBvbGF0ZSA9IG5ldyBtdWx0aV9pbnRlcnBvbGF0ZV8xLk11bHRpSW50ZXJwb2xhdGUoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubXVsdGlJbnRlcnBvbGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGVsZW1lbnQgdmlzaWJpbGl0eSB0byB0aGUgVmVjdG9yRG9tLlxuICAgICAgICB0aGlzLmVsZW1lbnRWaXNpYmlsaXR5ID0gZWxlbWVudF92aXNpYmlsaXR5XzEuZWxlbWVudFZpc2liaWxpdHkuaW52aWV3KHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHRoaXMucnVuT25jZUFmdGVyT3V0VmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMucmVuZGVyT25seVdoZW5JbnZpZXcgPSB0cnVlO1xuICAgICAgICB0aGlzLnJhbk91dFZpZXdVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmVjaXNpb24gPSA0O1xuICAgICAgICB0aGlzLm5vV3JpdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFydFByb2dyZXNzID0gMDtcbiAgICAgICAgdGhpcy5lbmRQcm9ncmVzcyA9IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIGludGVycG9sYXRpb25zLiAgIFVzZSB0aGlzIHRvIHVwZGF0ZSB5b3VyXG4gICAgICogaW50ZXJwb2xhdGlvbnMuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqXG4gICAgICogbGV0IGNpID0gbmV3IENzc1ZhckludGVycG9sYXRlKGVsZW1lbnQpO1xuICAgICAqIGNpLnNldEludGVycG9sYXRpb25zKHtcbiAgICAgKiAgIGludGVycG9sYXRpb25zOiBbXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgICBwcm9ncmVzczogW1xuICAgICAqICAgICAgICAgICAgICAgeyBmcm9tOiAwLCB0bzogMSwgc3RhcnQ6IDAsIGVuZDogNTAwIH0sXG4gICAgICogICAgICAgICAgIF0sXG4gICAgICogICAgICAgICAgIGlkOiAnLS14J1xuICAgICAqXG4gICAgICogICAgICAgfVxuICAgICAqICAgXVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWdcbiAgICAgKi9cbiAgICBzZXRJbnRlcnBvbGF0aW9ucyhjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5tdWx0aUludGVycG9sYXRlID0gbmV3IG11bHRpX2ludGVycG9sYXRlXzEuTXVsdGlJbnRlcnBvbGF0ZShjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGludGVybmFsIHByZWNpc2lvbi4gIFByZWNpc2lvbiBpcyB1c2VkIHRvIGV2YWx1YXRlIGhvdyBtYW55XG4gICAgICogZGVjaW1hbHMgc2hvdWxkIGJlIHZhbHVhdGVkIG9uIHByb2dyZXNzLiAgTG93ZXIgcHJlY2lzaW9uIG1lYW5zLCAwLjg4ODhcbiAgICAgKiBhbmQgMC44ODg4OCB3b3VsZCBiZSBzYW1lLiAgICBFbnRlciB0aGUgbnVtYmVyIG9mIGRlY2ltYWxzIHlvdSB3YW50IHRvXG4gICAgICogYWNjb3VudCBmb3IuICBMb3dlciBwcmVjaXNpb24gd2lsbCBoYXZlIHNsaWdodCBwZXJmb3JtYW5jZSBiZW5lZml0cy5cbiAgICAgKi9cbiAgICBzZXRQcmVjaXNpb24obnVtYmVyT2ZEZWNpbWFscykge1xuICAgICAgICB0aGlzLnByZWNpc2lvbiA9IG51bWJlck9mRGVjaW1hbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoZXMgdGhlIHVwZGF0ZSBjYWNoZS4gIEJ5IGRlZmF1bHQsIHR3byBjb25zZWN1dGl2ZSBjYWxscyB0b1xuICAgICAqIHVwZGF0ZSB3aXRoIHRoZSBzYW1lIHByb2dyZXNzIHZhbHVlcyB3aWxsIGN1bGwgdGhlIHNlY29uZCBjYWxsXG4gICAgICogZm9yIHBlcmZvcm1hbmNlIGJvb29zdHMuICBIb3dldmVyLCB0aGVyZSBhcmUgcmFyZSBjYXNlcyB3aGVyZVxuICAgICAqIHlvdSBtYXkgd2FudCB0byB1cGRhdGUgd2l0aCB0aGUgc2FtZSBwcm9ncmVzcyB2YWx1ZXMgYW5kIGZvcmNlXG4gICAgICogYW4gdXBkYXRlIHRvIHRoZSB2YXJpYWJsZS4gIENhbGxpbmcgZmx1c2ggd2lsbCBmbHVzaCB0aGUgaW50ZXJuYWxcbiAgICAgKiBjYWNoZS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKiBjc3NWYXJJbnRlcnBvbGF0ZS51cGRhdGUoMC4yKTtcbiAgICAgKiBjc3NWYXJJbnRlcnBvbGF0ZS51cGRhdGUoMC4yKTsgLy8gTm9ybWFsbHkgZ2V0cyBpZ25vcmVkXG4gICAgICpcbiAgICAgKiBjc3NWYXJJbnRlcnBvbGF0ZS51cGRhdGUoMC4yKTtcbiAgICAgKiBjc3NWYXJJbnRlcnBvbGF0ZS5mbHVzaCgpOyAvLyBGbHVzaCBjYWNoZVxuICAgICAqIGNzc1ZhckludGVycG9sYXRlLnVwZGF0ZSgwLjIpOyAvLyBXaWxsIHVwZGF0ZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgdGhpcy5tYWluUHJvZ3Jlc3MgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHN1YnBpeGVsIHJlbmRlcmluZy4gV2hlbiBzdWJwaXhlbCByZW5kZXJpbmcgaXMgdHVybmVkIG9mZixcbiAgICAgKiAncHgnIHZhbHVlIGludGVycG9sYXRpb25zIHdpbGwgYmUgdHVybmVkIGludG8gd2hvbGVcbiAgICAgKiBudW1iZXJzLiAgU3VicGl4ZWwgcmVuZGVyaW5nIGlzIHR1cm5lZCBvbiBieSBkZWZhdWx0IGJ1dCBjYW4gYmVcbiAgICAgKiB0dXJuZWQgb2ZmIGZvciBwZXJmb3JtYW5jZSBib29zdHMuXG4gICAgICovXG4gICAgdXNlU3ViUGl4ZWxSZW5kZXJpbmcodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJTdWJQaXhlbHMgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBjc3MtdmFyLWludGVycG9sYXRlIHRvIG5vIHdyaXRlIG1vZGUgaW4gd2hpY2ggaXQgd2lsbCBvbmx5IGNhbGN1bGF0ZVxuICAgICAqIHZhbHVlcyBidXQgbm90IHdyaXRlIHRoZW0gdG8gdGhlIGRvbS4gIFRoaXMgaXMgdXNlZCBmb3IgY2FzZXMgaW4gd2hpY2hcbiAgICAgKiB5b3Ugd2FudCB1c2UgdGhlIGNsYXNzIHRvIGNhbGN1bGF0ZSB2YWx1ZXMgYnV0IHRha2UgY29udHJvbCBvZiB3aGVuXG4gICAgICogYW5kIHdoZXJlIHdyaXRpbmcgaGFwcGVucy5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICB1c2VOb1dyaXRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubm9Xcml0ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgYmF0Y2ggdXBkYXRlIG9mIGNzcyB2YXJpYWJsZXMuICBSZWNvbW1lbmQgZm9yIGltcHJvdmVkXG4gICAgICogcGVyZm9ybWFuY2UuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgdXNlQmF0Y2hVcGRhdGUodmFsdWUpIHtcbiAgICAgICAgLy8gVGhpcyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gaXMgbm8gbG9uZ2VyIG5lZWRlZCwgc28gc2V0dGluZyB0aGlzXG4gICAgICAgIC8vIGlzIGEgbm8tb3AuXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgY3NzIHZhciBpbnRlcnBvbGF0ZSB0byByZW5kZXIgZXZlbiB3aGVuIG91dCBvZiB2aWV3LlxuICAgICAqL1xuICAgIHJlbmRlck91dHZpZXcodmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJPbmx5V2hlbkludmlldyA9ICF2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcHJvZ3Jlc3MgYW5kIHVwZGF0ZXMgdGhlIGNzcyB2YXJpYWJsZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByb2dyZXNzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZSBBbGxvd3MgeW91IHRvIGJ5cGFzcyB0aGUgY2FjaGUuICBCeSBkZWZhdWx0XG4gICAgICogICB0d28gY29uc2VjdXRpdmUgY2FsbHMgdG8gdXBkYXRlIFdJVEggdGhlIHNhbWUgcHJvZ3Jlc3MgdmFsdWVzIHdpbGxcbiAgICAgKiAgIGN1bGwgdGhlIHNlY29uZCBjYWxsLiAgRm9yY2UgYWxsb3dzIHlvdSB0byBmb3JjZSBpdCB0byByZW5kZXIgYWdhaW4uXG4gICAgICovXG4gICAgdXBkYXRlKHByb2dyZXNzLCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5tdWx0aUludGVycG9sYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBtYWtlIHVwZGF0ZXMgd2hlbiBwcm9ncmVzcyB2YWx1ZSB3YXMgdXBkYXRlZCB0byBhdm9pZCBsYXlvdXRcbiAgICAgICAgLy8gdGhyYXNoaW5nLlxuICAgICAgICBpZiAoIWZvcmNlICYmIHByb2dyZXNzID09PSB0aGlzLm1haW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhpcyBlbGVtZW50IG9ubHkgd2hlbiBpdCBpcyBpbnZpZXcgZm9yIHBlcmZvcm1hbmNlIGJvb3N0LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMucmVuZGVyT25seVdoZW5JbnZpZXcgJiZcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudFZpc2liaWxpdHkuc3RhdGUoKS5yZWFkeSAmJlxuICAgICAgICAgICAgIXRoaXMuZWxlbWVudFZpc2liaWxpdHkuc3RhdGUoKS5pbnZpZXcpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGdvIG91dCBvZiB2aWV3IHJ1biBpbnRlcnBvbGF0aW9ucyBhdGxlYXN0IG9uY2Ugc28gdGhhdFxuICAgICAgICAgICAgLy8gd2hlbiB0aGUgZWxlbWVudCBjb21lcyBiYWNrIGludG8gdmlldywgaXQgY29ycmVjdGx5IHNpdHMgaW5cbiAgICAgICAgICAgIC8vIHRoZSBzdGFydGluZyBwb3NpdGlvbi5cbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bk9uY2VBZnRlck91dFZpZXcgJiYgIXRoaXMucmFuT3V0Vmlld1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmFuT3V0Vmlld1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBhIGd1ZXN0aW1hdGlvbiBvZiAwIG9yIDEgYW5kIHJvdW5kIHRvIDAgb3IgMSBzdGF0ZS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGhlbHBzIGZpZ2h0IGNhc2VzIGluIHdoaWNoIHByb2dyZXNzIG1pZ2h0IGJlIHRpZWQgdG9cbiAgICAgICAgICAgICAgICAvLyBhbiBlYXNlZCBzY3JvbGwgYW5kIHVzZXIgcXVpY2tseSBzY3JvbGxzIG91dCBvZiB2aWV3IGluIHdoaWNoXG4gICAgICAgICAgICAgICAgLy8gdGhlIHByb2dyZXNzIGlzIG5vdCBmdWxseSByZXNvbHZlIHRvIHRoZSBzdGFydCBvciBlbmQgc3RhdGUuXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZXMocHJvZ3Jlc3MgPj0gMC41ID8gMSA6IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGFyZSBpbnZpZXcgc28gcnVuIHVwZGF0ZSBub3JtYWxseS5cbiAgICAgICAgdGhpcy5yYW5PdXRWaWV3VXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKHByb2dyZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbmQgY2FsY3VsYXRlcyBpbnRlcnBvbGF0aW9uIHZhbHVlcy5cbiAgICAgKi9cbiAgICB1cGRhdGVWYWx1ZXMocHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLm11bHRpSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3VuZGVkUHJlY2lzaW9uID0gbWF0aGZfMS5tYXRoZi50b0ZpeGVkKHByb2dyZXNzLCB0aGlzLnByZWNpc2lvbik7XG4gICAgICAgIC8vIEN1bGwgaWYgcHJvZ3Jlc3MgaGFzbid0IGNoYW5nZWQuXG4gICAgICAgIGlmICh0aGlzLm1haW5Qcm9ncmVzcyA9PT0gcm91bmRlZFByZWNpc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIGNoaWxkIHByb2dyZXNzIHNvIHRoYXQgdGhlIHJhbmdlIGluIHdoaWNoIHRoaXMgaW50ZXJwb2xhdGlvblxuICAgICAgICAvLyByZWFjdHMgY2FuIGJlIHNjb3BlZC5cbiAgICAgICAgLy8gVXNlIG5vQ2xhbXAgc28gdGhhdCB3ZSBjYW4gZGVmaW5lIG5lZ2F0aXZlIHByb2dyZXNzIGlmIG5lZWRlZC5cbiAgICAgICAgdGhpcy5tYWluUHJvZ3Jlc3MgPSBtYXRoZl8xLm1hdGhmLmNoaWxkUHJvZ3Jlc3Mocm91bmRlZFByZWNpc2lvbiwgdGhpcy5zdGFydFByb2dyZXNzLCB0aGlzLmVuZFByb2dyZXNzLCB0cnVlKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZXMgPSBvYmplY3RmXzEub2JqZWN0Zi5qc29uQ29weSh0aGlzLmN1cnJlbnRWYWx1ZXMpO1xuICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZXMgPSB0aGlzLm11bHRpSW50ZXJwb2xhdGUuY2FsY3VsYXRlKHRoaXMubWFpblByb2dyZXNzKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHByZXZpb3VzIHZhbHVlcyBhbmQgY3VycmVudCB2YWx1ZXMgYXJlIGV4YWN0bHkgdGhlIHNhbWVcbiAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBjYW4gYXZvaWQgYW4gdW5uY2Vzc2FyeSB1cGRhdGUuXG4gICAgICAgIGlmIChvYmplY3RmXzEub2JqZWN0Zi5hcmVFcXVhbChwcmV2aW91c1ZhbHVlcywgdGhpcy5jdXJyZW50VmFsdWVzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFyZSBpbiBub1dyaXRlIG1vZGUsIHNraXAuXG4gICAgICAgIGlmICh0aGlzLm5vV3JpdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmN1cnJlbnRWYWx1ZXMpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuY3VycmVudFZhbHVlc1trZXldO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlbmRlclN1YlBpeGVscyAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3NzVW5pdFZhbHVlID0gY3NzX3VuaXRfMS5jc3NVbml0LnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY3NzVW5pdFZhbHVlLnVuaXQgPT09ICdweCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAoY3NzVW5pdFZhbHVlLnZhbHVlID4+IDApICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21fMS5kb20uc2V0Q3NzVmFyaWFibGUodGhpcy5lbGVtZW50LCBrZXksIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIG9mIHdoaWNoIGludGVycG9sYXRpb25zIGJlZ2luLiAgVGhpcyBhbGxvd3NcbiAgICAgKiB5b3UgdG8gc2V0IHNvbWV0aGluZyBsaWtlLCBnaXZlbiB0aGUgbWFpbiBwcm9ncmVzcyB0aGF0IGlzIHVwZGF0ZWQgZnJvbVxuICAgICAqIDAtMSwgSSBvbmx5IHdhbnQgdGhpcyB0byBpbnRlcnBvbGF0ZSBmcm9tIDAuMi0wLjYuXG4gICAgICogQHBhcmFtIHN0YXJ0XG4gICAgICogQHBhcmFtIGVuZFxuICAgICAqL1xuICAgIHNldFByb2dyZXNzUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnN0YXJ0UHJvZ3Jlc3MgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmRQcm9ncmVzcyA9IGVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBzZXQgb2YgY2FsY3VsYXRlZCB2YWx1ZXMuICBUaGlzIHdpbGwgcmV0dXJuIGFuIGVtcHR5XG4gICAgICogb2JqZWN0IGlmIG5vIHVwZGF0ZXMgLyBjYWxjdWxhdGlvbnMgaGF2ZSBiZWVuIHJ1bi4gIElmIHVwZGF0ZXMgaGF2ZVxuICAgICAqIGJlZW4gZXhlY3V0ZWQsIGl0IHdpbGwgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGVhY2ggY3NzLXZhciBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWYWx1ZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Dc3NWYXJJbnRlcnBvbGF0ZSA9IENzc1ZhckludGVycG9sYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3NzLXZhci1pbnRlcnBvbGF0ZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/interpolate/css-var-interpolate.js\n");

/***/ }),

/***/ "./lib/interpolate/interpolate.js":
/*!****************************************!*\
  !*** ./lib/interpolate/interpolate.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Interpolate = void 0;\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst is_1 = __webpack_require__(/*! ../is/is */ \"./lib/is/is.js\");\nconst color_1 = __webpack_require__(/*! ../mathf/color */ \"./lib/mathf/color.js\");\nconst css_unit_1 = __webpack_require__(/*! ../string/css-unit */ \"./lib/string/css-unit.js\");\n/**\n * A class that interperolate between values. Interperolate is really a\n * compositoin around mathf.ease.\n *\n * ```ts\n * import { EASE, Interpolate } from '@blinkk/degu'\n * let inter = new Interpolate({\n *   from: 0,\n *   to: 100,\n *   easeFunction: EASE.linear\n * });\n *\n * inter.calculate(0.3);  // return 30.\n *\n * inter.calculate(0.6); // return 60\n *\n * // Get the value from currentValue if needed.\n * console.log(inter.currentValue); // 60\n * ```\n *\n * This can be useful to create low level tweens.\n * Here for example, we can manually, tween the x and y positions\n * of a ball with separate easing.\n *\n * ```ts\n * import { Raf, EASE, Interpolate } from '@blinkk/degu'\n *\n * this.progress = 0;\n * let ballXInter = new Interpolate({\n *   from: 30,\n *   to: 100 ,\n *   easeFunction: EASE.easeOutSine\n * })\n * let ballYInter = new Interpolate({\n *   from: 30,\n *   to: 100 ,\n *   easeFunction: EASE.linear\n * })\n *\n * // See RafTimer for how this works.  Basically, here we are running raf for\n * // 300ms and the progress is a value between 0-1 which we used to passed to the\n * // interperolators.\n * new RafTimer((progress)=> {\n *   // Update the positions of ball.\n *   ball.x = ballXInter.calculate(this.progress);\n *   ball.y = ballYInter.calculate(this.progress);\n * }).start(300);\n *\n * See more examples in the /examples folder\n *\n * ```\n *\n *\n * Unit and Color support.\n *\n * Interpolate also uses [[cssUnit]] to interprete string values (as best as it\n * can).  You can pass basic css unit values such as '10px' or '10vw' as\n * from and to values.  Color values of rgba and hex are also supported.\n *\n *\n * It does NOT support cross unit interporalation at the moment such as\n * from: '0px', to: '10vw'.  (Here the units don't match.)\n *\n * ```ts\n * let inter = new Interpolate({\n *   from: '0px',\n *   to: '100px',\n *   easeFunction: EASE.linear\n * });\n * inter.calculate(0.3);  // return '30px'.\n *\n *\n *  inter = new Interpolate({\n *      from: 'rgba(255, 255, 255, 0)',\n *      to: 'rgba(0,0,0,1)',\n *      easeFunction: EASE.linear\n *  });\n *   inter.calculate(0.5) // 'rgba(127, 127, 127, 0.5)'\n * ```\n *\n *\n * @tested\n */\nclass Interpolate {\n    constructor(interpolateConfig) {\n        this.interpolateConfig = interpolateConfig;\n        this.currentValue = 0;\n        this.currentProgress = 0;\n        // Assume we start on preogress 0.\n        this.calculate(0);\n    }\n    /**\n     * Modify the interpolate settings.\n     * @param interpolateConfig\n     */\n    modify(interpolateConfig) {\n        return new Interpolate(interpolateConfig);\n    }\n    calculate(progress) {\n        this.currentProgress = progress;\n        // If we are just interpolating a number just calculate a straight ease.\n        if (is_1.is.number(this.interpolateConfig.from)) {\n            this.currentValue = mathf_1.mathf.ease(this.interpolateConfig.from, this.interpolateConfig.to, this.currentProgress, this.interpolateConfig.easeFunction);\n        }\n        else {\n            // If we are interpolating a string.\n            // Use the from value to determine the type of cssUnit this is.\n            const from = css_unit_1.cssUnit.parse(this.interpolateConfig.from);\n            const to = css_unit_1.cssUnit.parse(this.interpolateConfig.to);\n            // If unit type, interpolate the values and append a unit.\n            if (from.valueType === css_unit_1.CssUnitObjectTypes.number) {\n                this.currentValue = mathf_1.mathf.ease(from.value, to.value, this.currentProgress, this.interpolateConfig.easeFunction);\n                this.currentValue = `${this.currentValue}${from.unit}`;\n            }\n            // If it's an rgba type inteporalate it.\n            if (from.valueType === css_unit_1.CssUnitObjectTypes.rgba) {\n                const interpolatedRgba = color_1.color.rgbaEase(from.value, to.value, this.currentProgress, this.interpolateConfig.easeFunction);\n                this.currentValue = color_1.color.rgbaToCss(interpolatedRgba);\n            }\n        }\n        return this.currentValue;\n    }\n}\nexports.Interpolate = Interpolate;\n//# sourceMappingURL=interpolate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvaW50ZXJwb2xhdGUvaW50ZXJwb2xhdGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvaW50ZXJwb2xhdGUvaW50ZXJwb2xhdGUuanM/MGVhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW50ZXJwb2xhdGUgPSB2b2lkIDA7XG5jb25zdCBtYXRoZl8xID0gcmVxdWlyZShcIi4uL21hdGhmL21hdGhmXCIpO1xuY29uc3QgaXNfMSA9IHJlcXVpcmUoXCIuLi9pcy9pc1wiKTtcbmNvbnN0IGNvbG9yXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvY29sb3JcIik7XG5jb25zdCBjc3NfdW5pdF8xID0gcmVxdWlyZShcIi4uL3N0cmluZy9jc3MtdW5pdFwiKTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGludGVycGVyb2xhdGUgYmV0d2VlbiB2YWx1ZXMuIEludGVycGVyb2xhdGUgaXMgcmVhbGx5IGFcbiAqIGNvbXBvc2l0b2luIGFyb3VuZCBtYXRoZi5lYXNlLlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBFQVNFLCBJbnRlcnBvbGF0ZSB9IGZyb20gJ0BibGlua2svZGVndSdcbiAqIGxldCBpbnRlciA9IG5ldyBJbnRlcnBvbGF0ZSh7XG4gKiAgIGZyb206IDAsXG4gKiAgIHRvOiAxMDAsXG4gKiAgIGVhc2VGdW5jdGlvbjogRUFTRS5saW5lYXJcbiAqIH0pO1xuICpcbiAqIGludGVyLmNhbGN1bGF0ZSgwLjMpOyAgLy8gcmV0dXJuIDMwLlxuICpcbiAqIGludGVyLmNhbGN1bGF0ZSgwLjYpOyAvLyByZXR1cm4gNjBcbiAqXG4gKiAvLyBHZXQgdGhlIHZhbHVlIGZyb20gY3VycmVudFZhbHVlIGlmIG5lZWRlZC5cbiAqIGNvbnNvbGUubG9nKGludGVyLmN1cnJlbnRWYWx1ZSk7IC8vIDYwXG4gKiBgYGBcbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gY3JlYXRlIGxvdyBsZXZlbCB0d2VlbnMuXG4gKiBIZXJlIGZvciBleGFtcGxlLCB3ZSBjYW4gbWFudWFsbHksIHR3ZWVuIHRoZSB4IGFuZCB5IHBvc2l0aW9uc1xuICogb2YgYSBiYWxsIHdpdGggc2VwYXJhdGUgZWFzaW5nLlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBSYWYsIEVBU0UsIEludGVycG9sYXRlIH0gZnJvbSAnQGJsaW5ray9kZWd1J1xuICpcbiAqIHRoaXMucHJvZ3Jlc3MgPSAwO1xuICogbGV0IGJhbGxYSW50ZXIgPSBuZXcgSW50ZXJwb2xhdGUoe1xuICogICBmcm9tOiAzMCxcbiAqICAgdG86IDEwMCAsXG4gKiAgIGVhc2VGdW5jdGlvbjogRUFTRS5lYXNlT3V0U2luZVxuICogfSlcbiAqIGxldCBiYWxsWUludGVyID0gbmV3IEludGVycG9sYXRlKHtcbiAqICAgZnJvbTogMzAsXG4gKiAgIHRvOiAxMDAgLFxuICogICBlYXNlRnVuY3Rpb246IEVBU0UubGluZWFyXG4gKiB9KVxuICpcbiAqIC8vIFNlZSBSYWZUaW1lciBmb3IgaG93IHRoaXMgd29ya3MuICBCYXNpY2FsbHksIGhlcmUgd2UgYXJlIHJ1bm5pbmcgcmFmIGZvclxuICogLy8gMzAwbXMgYW5kIHRoZSBwcm9ncmVzcyBpcyBhIHZhbHVlIGJldHdlZW4gMC0xIHdoaWNoIHdlIHVzZWQgdG8gcGFzc2VkIHRvIHRoZVxuICogLy8gaW50ZXJwZXJvbGF0b3JzLlxuICogbmV3IFJhZlRpbWVyKChwcm9ncmVzcyk9PiB7XG4gKiAgIC8vIFVwZGF0ZSB0aGUgcG9zaXRpb25zIG9mIGJhbGwuXG4gKiAgIGJhbGwueCA9IGJhbGxYSW50ZXIuY2FsY3VsYXRlKHRoaXMucHJvZ3Jlc3MpO1xuICogICBiYWxsLnkgPSBiYWxsWUludGVyLmNhbGN1bGF0ZSh0aGlzLnByb2dyZXNzKTtcbiAqIH0pLnN0YXJ0KDMwMCk7XG4gKlxuICogU2VlIG1vcmUgZXhhbXBsZXMgaW4gdGhlIC9leGFtcGxlcyBmb2xkZXJcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICogVW5pdCBhbmQgQ29sb3Igc3VwcG9ydC5cbiAqXG4gKiBJbnRlcnBvbGF0ZSBhbHNvIHVzZXMgW1tjc3NVbml0XV0gdG8gaW50ZXJwcmV0ZSBzdHJpbmcgdmFsdWVzIChhcyBiZXN0IGFzIGl0XG4gKiBjYW4pLiAgWW91IGNhbiBwYXNzIGJhc2ljIGNzcyB1bml0IHZhbHVlcyBzdWNoIGFzICcxMHB4JyBvciAnMTB2dycgYXNcbiAqIGZyb20gYW5kIHRvIHZhbHVlcy4gIENvbG9yIHZhbHVlcyBvZiByZ2JhIGFuZCBoZXggYXJlIGFsc28gc3VwcG9ydGVkLlxuICpcbiAqXG4gKiBJdCBkb2VzIE5PVCBzdXBwb3J0IGNyb3NzIHVuaXQgaW50ZXJwb3JhbGF0aW9uIGF0IHRoZSBtb21lbnQgc3VjaCBhc1xuICogZnJvbTogJzBweCcsIHRvOiAnMTB2dycuICAoSGVyZSB0aGUgdW5pdHMgZG9uJ3QgbWF0Y2guKVxuICpcbiAqIGBgYHRzXG4gKiBsZXQgaW50ZXIgPSBuZXcgSW50ZXJwb2xhdGUoe1xuICogICBmcm9tOiAnMHB4JyxcbiAqICAgdG86ICcxMDBweCcsXG4gKiAgIGVhc2VGdW5jdGlvbjogRUFTRS5saW5lYXJcbiAqIH0pO1xuICogaW50ZXIuY2FsY3VsYXRlKDAuMyk7ICAvLyByZXR1cm4gJzMwcHgnLlxuICpcbiAqXG4gKiAgaW50ZXIgPSBuZXcgSW50ZXJwb2xhdGUoe1xuICogICAgICBmcm9tOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwKScsXG4gKiAgICAgIHRvOiAncmdiYSgwLDAsMCwxKScsXG4gKiAgICAgIGVhc2VGdW5jdGlvbjogRUFTRS5saW5lYXJcbiAqICB9KTtcbiAqICAgaW50ZXIuY2FsY3VsYXRlKDAuNSkgLy8gJ3JnYmEoMTI3LCAxMjcsIDEyNywgMC41KSdcbiAqIGBgYFxuICpcbiAqXG4gKiBAdGVzdGVkXG4gKi9cbmNsYXNzIEludGVycG9sYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihpbnRlcnBvbGF0ZUNvbmZpZykge1xuICAgICAgICB0aGlzLmludGVycG9sYXRlQ29uZmlnID0gaW50ZXJwb2xhdGVDb25maWc7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvZ3Jlc3MgPSAwO1xuICAgICAgICAvLyBBc3N1bWUgd2Ugc3RhcnQgb24gcHJlb2dyZXNzIDAuXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlKDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdGhlIGludGVycG9sYXRlIHNldHRpbmdzLlxuICAgICAqIEBwYXJhbSBpbnRlcnBvbGF0ZUNvbmZpZ1xuICAgICAqL1xuICAgIG1vZGlmeShpbnRlcnBvbGF0ZUNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYXRlKGludGVycG9sYXRlQ29uZmlnKTtcbiAgICB9XG4gICAgY2FsY3VsYXRlKHByb2dyZXNzKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgIC8vIElmIHdlIGFyZSBqdXN0IGludGVycG9sYXRpbmcgYSBudW1iZXIganVzdCBjYWxjdWxhdGUgYSBzdHJhaWdodCBlYXNlLlxuICAgICAgICBpZiAoaXNfMS5pcy5udW1iZXIodGhpcy5pbnRlcnBvbGF0ZUNvbmZpZy5mcm9tKSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSBtYXRoZl8xLm1hdGhmLmVhc2UodGhpcy5pbnRlcnBvbGF0ZUNvbmZpZy5mcm9tLCB0aGlzLmludGVycG9sYXRlQ29uZmlnLnRvLCB0aGlzLmN1cnJlbnRQcm9ncmVzcywgdGhpcy5pbnRlcnBvbGF0ZUNvbmZpZy5lYXNlRnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGludGVycG9sYXRpbmcgYSBzdHJpbmcuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGZyb20gdmFsdWUgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGNzc1VuaXQgdGhpcyBpcy5cbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBjc3NfdW5pdF8xLmNzc1VuaXQucGFyc2UodGhpcy5pbnRlcnBvbGF0ZUNvbmZpZy5mcm9tKTtcbiAgICAgICAgICAgIGNvbnN0IHRvID0gY3NzX3VuaXRfMS5jc3NVbml0LnBhcnNlKHRoaXMuaW50ZXJwb2xhdGVDb25maWcudG8pO1xuICAgICAgICAgICAgLy8gSWYgdW5pdCB0eXBlLCBpbnRlcnBvbGF0ZSB0aGUgdmFsdWVzIGFuZCBhcHBlbmQgYSB1bml0LlxuICAgICAgICAgICAgaWYgKGZyb20udmFsdWVUeXBlID09PSBjc3NfdW5pdF8xLkNzc1VuaXRPYmplY3RUeXBlcy5udW1iZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG1hdGhmXzEubWF0aGYuZWFzZShmcm9tLnZhbHVlLCB0by52YWx1ZSwgdGhpcy5jdXJyZW50UHJvZ3Jlc3MsIHRoaXMuaW50ZXJwb2xhdGVDb25maWcuZWFzZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGAke3RoaXMuY3VycmVudFZhbHVlfSR7ZnJvbS51bml0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBpdCdzIGFuIHJnYmEgdHlwZSBpbnRlcG9yYWxhdGUgaXQuXG4gICAgICAgICAgICBpZiAoZnJvbS52YWx1ZVR5cGUgPT09IGNzc191bml0XzEuQ3NzVW5pdE9iamVjdFR5cGVzLnJnYmEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRSZ2JhID0gY29sb3JfMS5jb2xvci5yZ2JhRWFzZShmcm9tLnZhbHVlLCB0by52YWx1ZSwgdGhpcy5jdXJyZW50UHJvZ3Jlc3MsIHRoaXMuaW50ZXJwb2xhdGVDb25maWcuZWFzZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGNvbG9yXzEuY29sb3IucmdiYVRvQ3NzKGludGVycG9sYXRlZFJnYmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWYWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLkludGVycG9sYXRlID0gSW50ZXJwb2xhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcnBvbGF0ZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/interpolate/interpolate.js\n");

/***/ }),

/***/ "./lib/interpolate/multi-interpolate.js":
/*!**********************************************!*\
  !*** ./lib/interpolate/multi-interpolate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MultiInterpolate = exports.multiInterpolateHelper = void 0;\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst ease_1 = __webpack_require__(/*! ../ease/ease */ \"./lib/ease/ease.js\");\nconst interpolate_1 = __webpack_require__(/*! ./interpolate */ \"./lib/interpolate/interpolate.js\");\nexports.multiInterpolateHelper = {\n    errors: {\n        FROM_TO_EQUAL: 'Range progress from and to values should not equal each other.',\n        FROM_GREATER: 'Range progress from greater than the value of to',\n    },\n    /**\n     * Checks for invalid progress specifications.\n     */\n    checkInvalidRangedProgresses: (progresses) => {\n        progresses.forEach(progress => {\n            if (progress.from === progress.to) {\n                console.error(progress);\n                throw new Error(exports.multiInterpolateHelper.errors.FROM_TO_EQUAL);\n            }\n            if (progress.from > progress.to) {\n                console.error(progress);\n                throw new Error(exports.multiInterpolateHelper.errors.FROM_GREATER);\n            }\n        });\n    },\n    /**\n     * Given the current progress, does a search withn the progresses, to\n     * find the best matching progress.\n     *\n     * The order of progresses DOES matter because this will do a search from\n     * top to bottom.\n     *\n     * @param {number} currentProgress A number between 0-1 representing progress.\n     * @param {Array<rangedProgress>} orderedProgress A list of ordered\n     *     progresses.  This algo assumed tha the progresses are ordered based\n     *     on from value.  Run your progress through\n     *     [[multiInterpolaterHelper.orderProgresses]].\n     *\n     * @return {rangedProgress} Returns the best matching ranged progress.\n     */\n    findBestMatchingRangedProgress(currentProgress, progress) {\n        // We assume that we always want to start with the first progress\n        // declaration.\n        let matchedProgress = progress[0];\n        progress.forEach(progress => {\n            const previousProgress = matchedProgress;\n            // If the current matchedProgress has come to an end.\n            // select the next progress.\n            if (matchedProgress.to <= currentProgress) {\n                matchedProgress = progress;\n            }\n            // If the current progress is still not in range, revert to the\n            // previous progress.\n            if (matchedProgress.from > currentProgress) {\n                matchedProgress = previousProgress;\n            }\n        });\n        return matchedProgress;\n    },\n};\n/**\n * MultiInterpolate allows you to interpolate multiple values at once against\n * a parent progress.\n *\n * ```ts\n *\n *\n * JS\n *  import { MultiInterpolate, EASE } from '@blinkk/degu';\n *  let multiInterpolate = new MultiInterpolate({\n *   interpolations: [\n *     // This declaration would create the following.\n *     // When progress is:\n *     // 0 - 0.29999 ---> x = 50.\n *     //    It uses applies the start value of the first progress.\n *     // 0.3 - 0.5   ---> x = 50 - 100.\n *     // 0.5 - 0.8   ---> x = 100 - 800\n *     // 0.8 - 1     ----> x = 800.  The last value is used.\n *     {\n *       progress: [\n *          { from: 0.3, to: 0.5, start: 50, end: 1000,\n *             easingFunction: EASE.easeInOutSine },\n *          { from: 0.5, to: 0.8, start: 1000, end: 8000,\n *             easingFunction: EASE.easeInOutBounce }\n *       ],\n *       id: 'x',\n *     },\n *\n *     // When the progress is from 0.5 - 1,\n *     // The value of y would go from 0 to 100.\n *     {\n *       progress: [{ from: 0, to: 0.5, start: 0, end: 100 }],\n *       id: 'y',\n *     },\n *     // When the progress is from 0.5 - 1,\n *     // The value of someOtherId would go from 0 to 100.\n *     {\n *       progress: [{ from: 0, to: 1, start: 0, end: 100 }]\n *       id: 'someOther',\n *     },\n *\n *     // Multi interpolate also supports simple units.  See interpolate for\n *     // unit and color support.\n *     {\n *       progress: [{ from: 0, to: 1, start: '0px', end: '100px' }]\n *       id: 'z',\n *     }\n *\n *\n *     // There is also no interpolation mode.  This doesn't interpolate\n *     // but rather just applies properties when specific ranges are matched.\n *     {\n *       progress: [\n *          { from: 0.3, to: 0.5, start: 'none', end: 'none'},\n *          { from: 0.5, to: 0.8, start: 'inline', end: 'inline }\n *       ],\n *       noInterpolation: true\n *       noInterpolationDefault: 'block'\n *       id: 'display-setting',\n *     },\n *\n *\n *     // Staggers allow to create multi entries of the same property with an\n *     // offset.  For example, here 4 staggers would be created.\n *     // hero-y-0, hero-y-1, hero-y-2, hero-y-3 and the from and end points\n *     // would each be shifted by the progressOffset (0.008).\n *     {\n *       progress: [{ from: 0, to: 0.3, start: '0px', end: '100px' }]\n *       id: 'hero-y',\n *       stagger: {\n *           count: 4,\n *           progressOffset: 0.008\n *       }\n *     }\n *\n *\n *     // onUpdate also provides you hooks when values up.\n *     {\n *       progress: [{ from: 0, to: 0.3, start: '0px', end: '100px' }]\n *       id: 'hero-y',\n *       onUpdate: (id:string, currentProgress:number, currentValue:string|number) => {\n *          ...\n *       }\n *     }\n *\n *  ]\n * });\n *\n * // What are the values at 0 progress.\n * let results = multiInterpolate.calculate(0);\n * console.log(results['x']); // 50\n * console.log(results['y']); // 0\n * console.log(results['someOther']); // 0\n *\n * // What are the values at 0.3 progress (30%)\n * results = multiInterpolate.calculate(0.3);\n * console.log(results['x']); // 50\n * console.log(results['y']); // ~60\n * console.log(results['someOther']); // 30\n *\n * // What are the values at 0.7 progress (70%)\n * results = multiInterpolate.calculate(0.7);\n * console.log(results['x']); //~7441\n * console.log(results['y']); // ~100\n * console.log(results['someOther']); // 30\n *\n * results = multiInterpolate.calculate(1);\n * console.log(results['x']); //~7441\n * console.log(results['y']); // ~100\n * console.log(results['someOther']); // 100\n *\n *\n * ```\n * @tested\n */\nclass MultiInterpolate {\n    constructor(multiInterpolaterConfig) {\n        this.parentProgress = 0;\n        this.currentValues = {};\n        this.config = multiInterpolaterConfig;\n        this.updateConfig(this.config);\n    }\n    /**\n     * Sets and updates the config.  Validates, reorders and set the config.\n     */\n    updateConfig(config) {\n        // Assign and create staggers.\n        this.config = this.createStaggers(config);\n        if (!this.config.interpolations) {\n            throw new Error('Multiinterpolation config is missing interpolations');\n        }\n        this.config.interpolations = this.config.interpolations.map((interpolateSettings) => {\n            // Valid progresses.\n            exports.multiInterpolateHelper.checkInvalidRangedProgresses(interpolateSettings.progress);\n            // TODO (uxder)\n            // I think we can add some from of checks to to warn\n            // users if their progresses are out of order.\n            //\n            //\n            // Example of case that isn't good.\n            //    { from: 0.3, to: 0.4, start: 0, end: 100 },\n            //    { from: 0, to: 0.2, start: 100, end: 800 }\n            //    { from: 0.4, to: 1, start: 100, end: 800 }\n            //\n            // Users should restructure the progress in order of\n            // from. Could easily reorder in code but it might be\n            // better keep as is and enforce cleaner organization and\n            // keep the logic top - down.\n            //\n            return interpolateSettings;\n        });\n    }\n    /**\n     * Goes through each multiInterpolation to check if stagger is set.\n     * If it is, create stagger entries.\n     * @param config\n     */\n    createStaggers(config) {\n        const itemsToAdd = [];\n        [...config.interpolations].forEach(item => {\n            // If stagger is set, we are going to add a specific stagger count.\n            if (item.stagger && !item.staggerItem) {\n                for (let i = 0; i < item.stagger.count; i++) {\n                    const newItem = Object.assign({}, item);\n                    newItem.progress = newItem.progress.map(progress => {\n                        progress = Object.assign({}, progress);\n                        progress.to += i * item.stagger.progressOffset;\n                        progress.from += i * item.stagger.progressOffset;\n                        newItem.id = item.id + '-' + i;\n                        // newItem.stagger = null;\n                        newItem.staggerItem = true;\n                        return progress;\n                    });\n                    // Add this stagger.\n                    itemsToAdd.push(newItem);\n                }\n            }\n        });\n        itemsToAdd.forEach(item => {\n            config.interpolations.push(item);\n        });\n        return config;\n    }\n    /**\n     * Returns the last know interpolations values.\n     * ```ts\n     * multiInterpolate.calculate(0.5);\n     *\n     * let results = multiInterpolate.getCalculations();\n     *\n     * ```\n     */\n    getCalculations() {\n        return this.currentValues;\n    }\n    /**\n     * Sets the current progress and returns all interpolations.\n     * @param {number} The current progress.\n     * @return {Object} An object with all interpolation ids as the keys and their\n     *     relative values.\n     */\n    calculate(progress) {\n        this.parentProgress = progress;\n        this.config.interpolations.forEach((config) => {\n            // Given the set of rangedProgress, find the best matching\n            // one based on the current progress.\n            const matchedRangeProgress = exports.multiInterpolateHelper.findBestMatchingRangedProgress(this.parentProgress, config.progress);\n            // Now that we have a best matched rangedProgress, create\n            // a \"Child progress' progress (@see mathf.childProgress) and\n            // then calculate the ease / interpolations.\n            const childProgress = mathf_1.mathf.childProgress(this.parentProgress, matchedRangeProgress.from, matchedRangeProgress.to);\n            /*\n             * There are very specific cases in which we want to specify\n             * non-interpolating values.\n             *\n             * This happens for the case\n             * in css-var-interpolate, where we might want to add\n             * non-interpolating css properties for specific ranges.\n             *\n             * An example is:\n             *    color: var(--myColor)\n             *\n             *   - id: '--myColor'\n             *     noInterpolation: true\n             *     noInterpolationDefault: 'orange'\n             *     progress:\n             *     -  from: 0.3\n             *        to: 0.5\n             *        start: 'blue'\n             *        end: 'blue'\n             *     - from: 0.6\n             *       to: 0.7\n             *       start: 'red'\n             *       end: 'red'\n             *\n             * Another example is:\n             *   display: var(--display-settings)\n             *   - id: '--display-settings'\n             *     noInterpolation: true\n             *     noInterpolationDefault: 'block'\n             *     progress:\n             *     - from: 0.3\n             *       to: 0.5\n             *       start: 'none'\n             *       end: 'none'\n             *     - from: 0.6\n             *       to: 0.7\n             *       start: 'inline-block'\n             *       end: 'inline-block'\n             *\n             * Since it is noInterpolation, the start and end values are expected\n             * to be identical, and when there is no matching setting, the\n             * value would return null so that the \"default\" css value\n             * gets used.\n             */\n            if (config.noInterpolation) {\n                if (!config.noInterpolationDefault) {\n                    throw new Error('You are using noInterpolation without a noInterpolation default');\n                }\n                if (mathf_1.mathf.isBetween(this.parentProgress, matchedRangeProgress.from, matchedRangeProgress.to, true)) {\n                    // By convention, the start and end should match\n                    // so we just pick end.\n                    this.currentValues[config.id] = matchedRangeProgress.end;\n                }\n                else {\n                    this.currentValues[config.id] = config.noInterpolationDefault;\n                }\n            }\n            else {\n                // Now calculate the interpolation based on the childProgress\n                // progress value.\n                const interpolatedValue = new interpolate_1.Interpolate({\n                    from: matchedRangeProgress.start,\n                    to: matchedRangeProgress.end,\n                    easeFunction: matchedRangeProgress.easingFunction || ease_1.EASE.linear,\n                }).calculate(childProgress);\n                // Finally cache this value to the current values list.\n                this.currentValues[config.id] = interpolatedValue;\n                /**\n                 * If visibilityId is declared, we want to create an extra\n                 * interpolation value that observes the current config and\n                 * set it value to 'hidden' when <0 and otherwise 'visible'\n                 *\n                 * The goal here is to be able to create a visibility css\n                 * variable associated with the opacity variable.\n                 *\n                 * When the opacity is 0, the visiblity should be hidden\n                 * to boost performance.\n                 *\n                 * ```\n                 *  {\n                 *   progress: [{ from: 0, to: 0.3, start: 0, end: 1 },],\n                 *   id: '--my-opacity'\n                 *   visibilityId: '--my-visibility'\n                 * },\n                 *\n                 *   .myvar\n                 *       opacity: var(--my-opacity)\n                 *       visibility: var(--my-visibility)\n                 * ```\n                 *\n                 * https://github.com/blinkkcode/degu/issues/65\n                 */\n                if (config.visibilityId) {\n                    // Add this to the current values list.\n                    this.currentValues[config.visibilityId] =\n                        interpolatedValue <= 0 ? 'hidden' : 'visible';\n                }\n            }\n            // Run update function.\n            if (config.onUpdate) {\n                config.onUpdate(config.id, this.parentProgress, this.currentValues[config.id]);\n            }\n        });\n        return this.currentValues;\n    }\n}\nexports.MultiInterpolate = MultiInterpolate;\n//# sourceMappingURL=multi-interpolate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvaW50ZXJwb2xhdGUvbXVsdGktaW50ZXJwb2xhdGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvaW50ZXJwb2xhdGUvbXVsdGktaW50ZXJwb2xhdGUuanM/Y2UwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXVsdGlJbnRlcnBvbGF0ZSA9IGV4cG9ydHMubXVsdGlJbnRlcnBvbGF0ZUhlbHBlciA9IHZvaWQgMDtcbmNvbnN0IG1hdGhmXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvbWF0aGZcIik7XG5jb25zdCBlYXNlXzEgPSByZXF1aXJlKFwiLi4vZWFzZS9lYXNlXCIpO1xuY29uc3QgaW50ZXJwb2xhdGVfMSA9IHJlcXVpcmUoXCIuL2ludGVycG9sYXRlXCIpO1xuZXhwb3J0cy5tdWx0aUludGVycG9sYXRlSGVscGVyID0ge1xuICAgIGVycm9yczoge1xuICAgICAgICBGUk9NX1RPX0VRVUFMOiAnUmFuZ2UgcHJvZ3Jlc3MgZnJvbSBhbmQgdG8gdmFsdWVzIHNob3VsZCBub3QgZXF1YWwgZWFjaCBvdGhlci4nLFxuICAgICAgICBGUk9NX0dSRUFURVI6ICdSYW5nZSBwcm9ncmVzcyBmcm9tIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgdG8nLFxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGZvciBpbnZhbGlkIHByb2dyZXNzIHNwZWNpZmljYXRpb25zLlxuICAgICAqL1xuICAgIGNoZWNrSW52YWxpZFJhbmdlZFByb2dyZXNzZXM6IChwcm9ncmVzc2VzKSA9PiB7XG4gICAgICAgIHByb2dyZXNzZXMuZm9yRWFjaChwcm9ncmVzcyA9PiB7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MuZnJvbSA9PT0gcHJvZ3Jlc3MudG8pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5tdWx0aUludGVycG9sYXRlSGVscGVyLmVycm9ycy5GUk9NX1RPX0VRVUFMKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9ncmVzcy5mcm9tID4gcHJvZ3Jlc3MudG8pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5tdWx0aUludGVycG9sYXRlSGVscGVyLmVycm9ycy5GUk9NX0dSRUFURVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdpdmVuIHRoZSBjdXJyZW50IHByb2dyZXNzLCBkb2VzIGEgc2VhcmNoIHdpdGhuIHRoZSBwcm9ncmVzc2VzLCB0b1xuICAgICAqIGZpbmQgdGhlIGJlc3QgbWF0Y2hpbmcgcHJvZ3Jlc3MuXG4gICAgICpcbiAgICAgKiBUaGUgb3JkZXIgb2YgcHJvZ3Jlc3NlcyBET0VTIG1hdHRlciBiZWNhdXNlIHRoaXMgd2lsbCBkbyBhIHNlYXJjaCBmcm9tXG4gICAgICogdG9wIHRvIGJvdHRvbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50UHJvZ3Jlc3MgQSBudW1iZXIgYmV0d2VlbiAwLTEgcmVwcmVzZW50aW5nIHByb2dyZXNzLlxuICAgICAqIEBwYXJhbSB7QXJyYXk8cmFuZ2VkUHJvZ3Jlc3M+fSBvcmRlcmVkUHJvZ3Jlc3MgQSBsaXN0IG9mIG9yZGVyZWRcbiAgICAgKiAgICAgcHJvZ3Jlc3Nlcy4gIFRoaXMgYWxnbyBhc3N1bWVkIHRoYSB0aGUgcHJvZ3Jlc3NlcyBhcmUgb3JkZXJlZCBiYXNlZFxuICAgICAqICAgICBvbiBmcm9tIHZhbHVlLiAgUnVuIHlvdXIgcHJvZ3Jlc3MgdGhyb3VnaFxuICAgICAqICAgICBbW211bHRpSW50ZXJwb2xhdGVySGVscGVyLm9yZGVyUHJvZ3Jlc3Nlc11dLlxuICAgICAqXG4gICAgICogQHJldHVybiB7cmFuZ2VkUHJvZ3Jlc3N9IFJldHVybnMgdGhlIGJlc3QgbWF0Y2hpbmcgcmFuZ2VkIHByb2dyZXNzLlxuICAgICAqL1xuICAgIGZpbmRCZXN0TWF0Y2hpbmdSYW5nZWRQcm9ncmVzcyhjdXJyZW50UHJvZ3Jlc3MsIHByb2dyZXNzKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHdlIGFsd2F5cyB3YW50IHRvIHN0YXJ0IHdpdGggdGhlIGZpcnN0IHByb2dyZXNzXG4gICAgICAgIC8vIGRlY2xhcmF0aW9uLlxuICAgICAgICBsZXQgbWF0Y2hlZFByb2dyZXNzID0gcHJvZ3Jlc3NbMF07XG4gICAgICAgIHByb2dyZXNzLmZvckVhY2gocHJvZ3Jlc3MgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNQcm9ncmVzcyA9IG1hdGNoZWRQcm9ncmVzcztcbiAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IG1hdGNoZWRQcm9ncmVzcyBoYXMgY29tZSB0byBhbiBlbmQuXG4gICAgICAgICAgICAvLyBzZWxlY3QgdGhlIG5leHQgcHJvZ3Jlc3MuXG4gICAgICAgICAgICBpZiAobWF0Y2hlZFByb2dyZXNzLnRvIDw9IGN1cnJlbnRQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MgaXMgc3RpbGwgbm90IGluIHJhbmdlLCByZXZlcnQgdG8gdGhlXG4gICAgICAgICAgICAvLyBwcmV2aW91cyBwcm9ncmVzcy5cbiAgICAgICAgICAgIGlmIChtYXRjaGVkUHJvZ3Jlc3MuZnJvbSA+IGN1cnJlbnRQcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRQcm9ncmVzcyA9IHByZXZpb3VzUHJvZ3Jlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWF0Y2hlZFByb2dyZXNzO1xuICAgIH0sXG59O1xuLyoqXG4gKiBNdWx0aUludGVycG9sYXRlIGFsbG93cyB5b3UgdG8gaW50ZXJwb2xhdGUgbXVsdGlwbGUgdmFsdWVzIGF0IG9uY2UgYWdhaW5zdFxuICogYSBwYXJlbnQgcHJvZ3Jlc3MuXG4gKlxuICogYGBgdHNcbiAqXG4gKlxuICogSlNcbiAqICBpbXBvcnQgeyBNdWx0aUludGVycG9sYXRlLCBFQVNFIH0gZnJvbSAnQGJsaW5ray9kZWd1JztcbiAqICBsZXQgbXVsdGlJbnRlcnBvbGF0ZSA9IG5ldyBNdWx0aUludGVycG9sYXRlKHtcbiAqICAgaW50ZXJwb2xhdGlvbnM6IFtcbiAqICAgICAvLyBUaGlzIGRlY2xhcmF0aW9uIHdvdWxkIGNyZWF0ZSB0aGUgZm9sbG93aW5nLlxuICogICAgIC8vIFdoZW4gcHJvZ3Jlc3MgaXM6XG4gKiAgICAgLy8gMCAtIDAuMjk5OTkgLS0tPiB4ID0gNTAuXG4gKiAgICAgLy8gICAgSXQgdXNlcyBhcHBsaWVzIHRoZSBzdGFydCB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvZ3Jlc3MuXG4gKiAgICAgLy8gMC4zIC0gMC41ICAgLS0tPiB4ID0gNTAgLSAxMDAuXG4gKiAgICAgLy8gMC41IC0gMC44ICAgLS0tPiB4ID0gMTAwIC0gODAwXG4gKiAgICAgLy8gMC44IC0gMSAgICAgLS0tLT4geCA9IDgwMC4gIFRoZSBsYXN0IHZhbHVlIGlzIHVzZWQuXG4gKiAgICAge1xuICogICAgICAgcHJvZ3Jlc3M6IFtcbiAqICAgICAgICAgIHsgZnJvbTogMC4zLCB0bzogMC41LCBzdGFydDogNTAsIGVuZDogMTAwMCxcbiAqICAgICAgICAgICAgIGVhc2luZ0Z1bmN0aW9uOiBFQVNFLmVhc2VJbk91dFNpbmUgfSxcbiAqICAgICAgICAgIHsgZnJvbTogMC41LCB0bzogMC44LCBzdGFydDogMTAwMCwgZW5kOiA4MDAwLFxuICogICAgICAgICAgICAgZWFzaW5nRnVuY3Rpb246IEVBU0UuZWFzZUluT3V0Qm91bmNlIH1cbiAqICAgICAgIF0sXG4gKiAgICAgICBpZDogJ3gnLFxuICogICAgIH0sXG4gKlxuICogICAgIC8vIFdoZW4gdGhlIHByb2dyZXNzIGlzIGZyb20gMC41IC0gMSxcbiAqICAgICAvLyBUaGUgdmFsdWUgb2YgeSB3b3VsZCBnbyBmcm9tIDAgdG8gMTAwLlxuICogICAgIHtcbiAqICAgICAgIHByb2dyZXNzOiBbeyBmcm9tOiAwLCB0bzogMC41LCBzdGFydDogMCwgZW5kOiAxMDAgfV0sXG4gKiAgICAgICBpZDogJ3knLFxuICogICAgIH0sXG4gKiAgICAgLy8gV2hlbiB0aGUgcHJvZ3Jlc3MgaXMgZnJvbSAwLjUgLSAxLFxuICogICAgIC8vIFRoZSB2YWx1ZSBvZiBzb21lT3RoZXJJZCB3b3VsZCBnbyBmcm9tIDAgdG8gMTAwLlxuICogICAgIHtcbiAqICAgICAgIHByb2dyZXNzOiBbeyBmcm9tOiAwLCB0bzogMSwgc3RhcnQ6IDAsIGVuZDogMTAwIH1dXG4gKiAgICAgICBpZDogJ3NvbWVPdGhlcicsXG4gKiAgICAgfSxcbiAqXG4gKiAgICAgLy8gTXVsdGkgaW50ZXJwb2xhdGUgYWxzbyBzdXBwb3J0cyBzaW1wbGUgdW5pdHMuICBTZWUgaW50ZXJwb2xhdGUgZm9yXG4gKiAgICAgLy8gdW5pdCBhbmQgY29sb3Igc3VwcG9ydC5cbiAqICAgICB7XG4gKiAgICAgICBwcm9ncmVzczogW3sgZnJvbTogMCwgdG86IDEsIHN0YXJ0OiAnMHB4JywgZW5kOiAnMTAwcHgnIH1dXG4gKiAgICAgICBpZDogJ3onLFxuICogICAgIH1cbiAqXG4gKlxuICogICAgIC8vIFRoZXJlIGlzIGFsc28gbm8gaW50ZXJwb2xhdGlvbiBtb2RlLiAgVGhpcyBkb2Vzbid0IGludGVycG9sYXRlXG4gKiAgICAgLy8gYnV0IHJhdGhlciBqdXN0IGFwcGxpZXMgcHJvcGVydGllcyB3aGVuIHNwZWNpZmljIHJhbmdlcyBhcmUgbWF0Y2hlZC5cbiAqICAgICB7XG4gKiAgICAgICBwcm9ncmVzczogW1xuICogICAgICAgICAgeyBmcm9tOiAwLjMsIHRvOiAwLjUsIHN0YXJ0OiAnbm9uZScsIGVuZDogJ25vbmUnfSxcbiAqICAgICAgICAgIHsgZnJvbTogMC41LCB0bzogMC44LCBzdGFydDogJ2lubGluZScsIGVuZDogJ2lubGluZSB9XG4gKiAgICAgICBdLFxuICogICAgICAgbm9JbnRlcnBvbGF0aW9uOiB0cnVlXG4gKiAgICAgICBub0ludGVycG9sYXRpb25EZWZhdWx0OiAnYmxvY2snXG4gKiAgICAgICBpZDogJ2Rpc3BsYXktc2V0dGluZycsXG4gKiAgICAgfSxcbiAqXG4gKlxuICogICAgIC8vIFN0YWdnZXJzIGFsbG93IHRvIGNyZWF0ZSBtdWx0aSBlbnRyaWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IHdpdGggYW5cbiAqICAgICAvLyBvZmZzZXQuICBGb3IgZXhhbXBsZSwgaGVyZSA0IHN0YWdnZXJzIHdvdWxkIGJlIGNyZWF0ZWQuXG4gKiAgICAgLy8gaGVyby15LTAsIGhlcm8teS0xLCBoZXJvLXktMiwgaGVyby15LTMgYW5kIHRoZSBmcm9tIGFuZCBlbmQgcG9pbnRzXG4gKiAgICAgLy8gd291bGQgZWFjaCBiZSBzaGlmdGVkIGJ5IHRoZSBwcm9ncmVzc09mZnNldCAoMC4wMDgpLlxuICogICAgIHtcbiAqICAgICAgIHByb2dyZXNzOiBbeyBmcm9tOiAwLCB0bzogMC4zLCBzdGFydDogJzBweCcsIGVuZDogJzEwMHB4JyB9XVxuICogICAgICAgaWQ6ICdoZXJvLXknLFxuICogICAgICAgc3RhZ2dlcjoge1xuICogICAgICAgICAgIGNvdW50OiA0LFxuICogICAgICAgICAgIHByb2dyZXNzT2Zmc2V0OiAwLjAwOFxuICogICAgICAgfVxuICogICAgIH1cbiAqXG4gKlxuICogICAgIC8vIG9uVXBkYXRlIGFsc28gcHJvdmlkZXMgeW91IGhvb2tzIHdoZW4gdmFsdWVzIHVwLlxuICogICAgIHtcbiAqICAgICAgIHByb2dyZXNzOiBbeyBmcm9tOiAwLCB0bzogMC4zLCBzdGFydDogJzBweCcsIGVuZDogJzEwMHB4JyB9XVxuICogICAgICAgaWQ6ICdoZXJvLXknLFxuICogICAgICAgb25VcGRhdGU6IChpZDpzdHJpbmcsIGN1cnJlbnRQcm9ncmVzczpudW1iZXIsIGN1cnJlbnRWYWx1ZTpzdHJpbmd8bnVtYmVyKSA9PiB7XG4gKiAgICAgICAgICAuLi5cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogIF1cbiAqIH0pO1xuICpcbiAqIC8vIFdoYXQgYXJlIHRoZSB2YWx1ZXMgYXQgMCBwcm9ncmVzcy5cbiAqIGxldCByZXN1bHRzID0gbXVsdGlJbnRlcnBvbGF0ZS5jYWxjdWxhdGUoMCk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHRzWyd4J10pOyAvLyA1MFxuICogY29uc29sZS5sb2cocmVzdWx0c1sneSddKTsgLy8gMFxuICogY29uc29sZS5sb2cocmVzdWx0c1snc29tZU90aGVyJ10pOyAvLyAwXG4gKlxuICogLy8gV2hhdCBhcmUgdGhlIHZhbHVlcyBhdCAwLjMgcHJvZ3Jlc3MgKDMwJSlcbiAqIHJlc3VsdHMgPSBtdWx0aUludGVycG9sYXRlLmNhbGN1bGF0ZSgwLjMpO1xuICogY29uc29sZS5sb2cocmVzdWx0c1sneCddKTsgLy8gNTBcbiAqIGNvbnNvbGUubG9nKHJlc3VsdHNbJ3knXSk7IC8vIH42MFxuICogY29uc29sZS5sb2cocmVzdWx0c1snc29tZU90aGVyJ10pOyAvLyAzMFxuICpcbiAqIC8vIFdoYXQgYXJlIHRoZSB2YWx1ZXMgYXQgMC43IHByb2dyZXNzICg3MCUpXG4gKiByZXN1bHRzID0gbXVsdGlJbnRlcnBvbGF0ZS5jYWxjdWxhdGUoMC43KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdHNbJ3gnXSk7IC8vfjc0NDFcbiAqIGNvbnNvbGUubG9nKHJlc3VsdHNbJ3knXSk7IC8vIH4xMDBcbiAqIGNvbnNvbGUubG9nKHJlc3VsdHNbJ3NvbWVPdGhlciddKTsgLy8gMzBcbiAqXG4gKiByZXN1bHRzID0gbXVsdGlJbnRlcnBvbGF0ZS5jYWxjdWxhdGUoMSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHRzWyd4J10pOyAvL343NDQxXG4gKiBjb25zb2xlLmxvZyhyZXN1bHRzWyd5J10pOyAvLyB+MTAwXG4gKiBjb25zb2xlLmxvZyhyZXN1bHRzWydzb21lT3RoZXInXSk7IC8vIDEwMFxuICpcbiAqXG4gKiBgYGBcbiAqIEB0ZXN0ZWRcbiAqL1xuY2xhc3MgTXVsdGlJbnRlcnBvbGF0ZSB7XG4gICAgY29uc3RydWN0b3IobXVsdGlJbnRlcnBvbGF0ZXJDb25maWcpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRQcm9ncmVzcyA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IG11bHRpSW50ZXJwb2xhdGVyQ29uZmlnO1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbmZpZyh0aGlzLmNvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYW5kIHVwZGF0ZXMgdGhlIGNvbmZpZy4gIFZhbGlkYXRlcywgcmVvcmRlcnMgYW5kIHNldCB0aGUgY29uZmlnLlxuICAgICAqL1xuICAgIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgLy8gQXNzaWduIGFuZCBjcmVhdGUgc3RhZ2dlcnMuXG4gICAgICAgIHRoaXMuY29uZmlnID0gdGhpcy5jcmVhdGVTdGFnZ2Vycyhjb25maWcpO1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmludGVycG9sYXRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpaW50ZXJwb2xhdGlvbiBjb25maWcgaXMgbWlzc2luZyBpbnRlcnBvbGF0aW9ucycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnLmludGVycG9sYXRpb25zID0gdGhpcy5jb25maWcuaW50ZXJwb2xhdGlvbnMubWFwKChpbnRlcnBvbGF0ZVNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgICAvLyBWYWxpZCBwcm9ncmVzc2VzLlxuICAgICAgICAgICAgZXhwb3J0cy5tdWx0aUludGVycG9sYXRlSGVscGVyLmNoZWNrSW52YWxpZFJhbmdlZFByb2dyZXNzZXMoaW50ZXJwb2xhdGVTZXR0aW5ncy5wcm9ncmVzcyk7XG4gICAgICAgICAgICAvLyBUT0RPICh1eGRlcilcbiAgICAgICAgICAgIC8vIEkgdGhpbmsgd2UgY2FuIGFkZCBzb21lIGZyb20gb2YgY2hlY2tzIHRvIHRvIHdhcm5cbiAgICAgICAgICAgIC8vIHVzZXJzIGlmIHRoZWlyIHByb2dyZXNzZXMgYXJlIG91dCBvZiBvcmRlci5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRXhhbXBsZSBvZiBjYXNlIHRoYXQgaXNuJ3QgZ29vZC5cbiAgICAgICAgICAgIC8vICAgIHsgZnJvbTogMC4zLCB0bzogMC40LCBzdGFydDogMCwgZW5kOiAxMDAgfSxcbiAgICAgICAgICAgIC8vICAgIHsgZnJvbTogMCwgdG86IDAuMiwgc3RhcnQ6IDEwMCwgZW5kOiA4MDAgfVxuICAgICAgICAgICAgLy8gICAgeyBmcm9tOiAwLjQsIHRvOiAxLCBzdGFydDogMTAwLCBlbmQ6IDgwMCB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVXNlcnMgc2hvdWxkIHJlc3RydWN0dXJlIHRoZSBwcm9ncmVzcyBpbiBvcmRlciBvZlxuICAgICAgICAgICAgLy8gZnJvbS4gQ291bGQgZWFzaWx5IHJlb3JkZXIgaW4gY29kZSBidXQgaXQgbWlnaHQgYmVcbiAgICAgICAgICAgIC8vIGJldHRlciBrZWVwIGFzIGlzIGFuZCBlbmZvcmNlIGNsZWFuZXIgb3JnYW5pemF0aW9uIGFuZFxuICAgICAgICAgICAgLy8ga2VlcCB0aGUgbG9naWMgdG9wIC0gZG93bi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTZXR0aW5ncztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdvZXMgdGhyb3VnaCBlYWNoIG11bHRpSW50ZXJwb2xhdGlvbiB0byBjaGVjayBpZiBzdGFnZ2VyIGlzIHNldC5cbiAgICAgKiBJZiBpdCBpcywgY3JlYXRlIHN0YWdnZXIgZW50cmllcy5cbiAgICAgKiBAcGFyYW0gY29uZmlnXG4gICAgICovXG4gICAgY3JlYXRlU3RhZ2dlcnMoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zVG9BZGQgPSBbXTtcbiAgICAgICAgWy4uLmNvbmZpZy5pbnRlcnBvbGF0aW9uc10uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIC8vIElmIHN0YWdnZXIgaXMgc2V0LCB3ZSBhcmUgZ29pbmcgdG8gYWRkIGEgc3BlY2lmaWMgc3RhZ2dlciBjb3VudC5cbiAgICAgICAgICAgIGlmIChpdGVtLnN0YWdnZXIgJiYgIWl0ZW0uc3RhZ2dlckl0ZW0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW0uc3RhZ2dlci5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3SXRlbS5wcm9ncmVzcyA9IG5ld0l0ZW0ucHJvZ3Jlc3MubWFwKHByb2dyZXNzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MudG8gKz0gaSAqIGl0ZW0uc3RhZ2dlci5wcm9ncmVzc09mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzLmZyb20gKz0gaSAqIGl0ZW0uc3RhZ2dlci5wcm9ncmVzc09mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0uaWQgPSBpdGVtLmlkICsgJy0nICsgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ld0l0ZW0uc3RhZ2dlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdJdGVtLnN0YWdnZXJJdGVtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGlzIHN0YWdnZXIuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zVG9BZGQucHVzaChuZXdJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpdGVtc1RvQWRkLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBjb25maWcuaW50ZXJwb2xhdGlvbnMucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhc3Qga25vdyBpbnRlcnBvbGF0aW9ucyB2YWx1ZXMuXG4gICAgICogYGBgdHNcbiAgICAgKiBtdWx0aUludGVycG9sYXRlLmNhbGN1bGF0ZSgwLjUpO1xuICAgICAqXG4gICAgICogbGV0IHJlc3VsdHMgPSBtdWx0aUludGVycG9sYXRlLmdldENhbGN1bGF0aW9ucygpO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0Q2FsY3VsYXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VmFsdWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHByb2dyZXNzIGFuZCByZXR1cm5zIGFsbCBpbnRlcnBvbGF0aW9ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gVGhlIGN1cnJlbnQgcHJvZ3Jlc3MuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhbGwgaW50ZXJwb2xhdGlvbiBpZHMgYXMgdGhlIGtleXMgYW5kIHRoZWlyXG4gICAgICogICAgIHJlbGF0aXZlIHZhbHVlcy5cbiAgICAgKi9cbiAgICBjYWxjdWxhdGUocHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICB0aGlzLmNvbmZpZy5pbnRlcnBvbGF0aW9ucy5mb3JFYWNoKChjb25maWcpID0+IHtcbiAgICAgICAgICAgIC8vIEdpdmVuIHRoZSBzZXQgb2YgcmFuZ2VkUHJvZ3Jlc3MsIGZpbmQgdGhlIGJlc3QgbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vIG9uZSBiYXNlZCBvbiB0aGUgY3VycmVudCBwcm9ncmVzcy5cbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRSYW5nZVByb2dyZXNzID0gZXhwb3J0cy5tdWx0aUludGVycG9sYXRlSGVscGVyLmZpbmRCZXN0TWF0Y2hpbmdSYW5nZWRQcm9ncmVzcyh0aGlzLnBhcmVudFByb2dyZXNzLCBjb25maWcucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgLy8gTm93IHRoYXQgd2UgaGF2ZSBhIGJlc3QgbWF0Y2hlZCByYW5nZWRQcm9ncmVzcywgY3JlYXRlXG4gICAgICAgICAgICAvLyBhIFwiQ2hpbGQgcHJvZ3Jlc3MnIHByb2dyZXNzIChAc2VlIG1hdGhmLmNoaWxkUHJvZ3Jlc3MpIGFuZFxuICAgICAgICAgICAgLy8gdGhlbiBjYWxjdWxhdGUgdGhlIGVhc2UgLyBpbnRlcnBvbGF0aW9ucy5cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkUHJvZ3Jlc3MgPSBtYXRoZl8xLm1hdGhmLmNoaWxkUHJvZ3Jlc3ModGhpcy5wYXJlbnRQcm9ncmVzcywgbWF0Y2hlZFJhbmdlUHJvZ3Jlc3MuZnJvbSwgbWF0Y2hlZFJhbmdlUHJvZ3Jlc3MudG8pO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRoZXJlIGFyZSB2ZXJ5IHNwZWNpZmljIGNhc2VzIGluIHdoaWNoIHdlIHdhbnQgdG8gc3BlY2lmeVxuICAgICAgICAgICAgICogbm9uLWludGVycG9sYXRpbmcgdmFsdWVzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoaXMgaGFwcGVucyBmb3IgdGhlIGNhc2VcbiAgICAgICAgICAgICAqIGluIGNzcy12YXItaW50ZXJwb2xhdGUsIHdoZXJlIHdlIG1pZ2h0IHdhbnQgdG8gYWRkXG4gICAgICAgICAgICAgKiBub24taW50ZXJwb2xhdGluZyBjc3MgcHJvcGVydGllcyBmb3Igc3BlY2lmaWMgcmFuZ2VzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEFuIGV4YW1wbGUgaXM6XG4gICAgICAgICAgICAgKiAgICBjb2xvcjogdmFyKC0tbXlDb2xvcilcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgIC0gaWQ6ICctLW15Q29sb3InXG4gICAgICAgICAgICAgKiAgICAgbm9JbnRlcnBvbGF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgKiAgICAgbm9JbnRlcnBvbGF0aW9uRGVmYXVsdDogJ29yYW5nZSdcbiAgICAgICAgICAgICAqICAgICBwcm9ncmVzczpcbiAgICAgICAgICAgICAqICAgICAtICBmcm9tOiAwLjNcbiAgICAgICAgICAgICAqICAgICAgICB0bzogMC41XG4gICAgICAgICAgICAgKiAgICAgICAgc3RhcnQ6ICdibHVlJ1xuICAgICAgICAgICAgICogICAgICAgIGVuZDogJ2JsdWUnXG4gICAgICAgICAgICAgKiAgICAgLSBmcm9tOiAwLjZcbiAgICAgICAgICAgICAqICAgICAgIHRvOiAwLjdcbiAgICAgICAgICAgICAqICAgICAgIHN0YXJ0OiAncmVkJ1xuICAgICAgICAgICAgICogICAgICAgZW5kOiAncmVkJ1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEFub3RoZXIgZXhhbXBsZSBpczpcbiAgICAgICAgICAgICAqICAgZGlzcGxheTogdmFyKC0tZGlzcGxheS1zZXR0aW5ncylcbiAgICAgICAgICAgICAqICAgLSBpZDogJy0tZGlzcGxheS1zZXR0aW5ncydcbiAgICAgICAgICAgICAqICAgICBub0ludGVycG9sYXRpb246IHRydWVcbiAgICAgICAgICAgICAqICAgICBub0ludGVycG9sYXRpb25EZWZhdWx0OiAnYmxvY2snXG4gICAgICAgICAgICAgKiAgICAgcHJvZ3Jlc3M6XG4gICAgICAgICAgICAgKiAgICAgLSBmcm9tOiAwLjNcbiAgICAgICAgICAgICAqICAgICAgIHRvOiAwLjVcbiAgICAgICAgICAgICAqICAgICAgIHN0YXJ0OiAnbm9uZSdcbiAgICAgICAgICAgICAqICAgICAgIGVuZDogJ25vbmUnXG4gICAgICAgICAgICAgKiAgICAgLSBmcm9tOiAwLjZcbiAgICAgICAgICAgICAqICAgICAgIHRvOiAwLjdcbiAgICAgICAgICAgICAqICAgICAgIHN0YXJ0OiAnaW5saW5lLWJsb2NrJ1xuICAgICAgICAgICAgICogICAgICAgZW5kOiAnaW5saW5lLWJsb2NrJ1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFNpbmNlIGl0IGlzIG5vSW50ZXJwb2xhdGlvbiwgdGhlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGFyZSBleHBlY3RlZFxuICAgICAgICAgICAgICogdG8gYmUgaWRlbnRpY2FsLCBhbmQgd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzZXR0aW5nLCB0aGVcbiAgICAgICAgICAgICAqIHZhbHVlIHdvdWxkIHJldHVybiBudWxsIHNvIHRoYXQgdGhlIFwiZGVmYXVsdFwiIGNzcyB2YWx1ZVxuICAgICAgICAgICAgICogZ2V0cyB1c2VkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoY29uZmlnLm5vSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICghY29uZmlnLm5vSW50ZXJwb2xhdGlvbkRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHVzaW5nIG5vSW50ZXJwb2xhdGlvbiB3aXRob3V0IGEgbm9JbnRlcnBvbGF0aW9uIGRlZmF1bHQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGhmXzEubWF0aGYuaXNCZXR3ZWVuKHRoaXMucGFyZW50UHJvZ3Jlc3MsIG1hdGNoZWRSYW5nZVByb2dyZXNzLmZyb20sIG1hdGNoZWRSYW5nZVByb2dyZXNzLnRvLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBjb252ZW50aW9uLCB0aGUgc3RhcnQgYW5kIGVuZCBzaG91bGQgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UganVzdCBwaWNrIGVuZC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWVzW2NvbmZpZy5pZF0gPSBtYXRjaGVkUmFuZ2VQcm9ncmVzcy5lbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZXNbY29uZmlnLmlkXSA9IGNvbmZpZy5ub0ludGVycG9sYXRpb25EZWZhdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vdyBjYWxjdWxhdGUgdGhlIGludGVycG9sYXRpb24gYmFzZWQgb24gdGhlIGNoaWxkUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAvLyBwcm9ncmVzcyB2YWx1ZS5cbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRWYWx1ZSA9IG5ldyBpbnRlcnBvbGF0ZV8xLkludGVycG9sYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogbWF0Y2hlZFJhbmdlUHJvZ3Jlc3Muc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHRvOiBtYXRjaGVkUmFuZ2VQcm9ncmVzcy5lbmQsXG4gICAgICAgICAgICAgICAgICAgIGVhc2VGdW5jdGlvbjogbWF0Y2hlZFJhbmdlUHJvZ3Jlc3MuZWFzaW5nRnVuY3Rpb24gfHwgZWFzZV8xLkVBU0UubGluZWFyLFxuICAgICAgICAgICAgICAgIH0pLmNhbGN1bGF0ZShjaGlsZFByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5IGNhY2hlIHRoaXMgdmFsdWUgdG8gdGhlIGN1cnJlbnQgdmFsdWVzIGxpc3QuXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWVzW2NvbmZpZy5pZF0gPSBpbnRlcnBvbGF0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB2aXNpYmlsaXR5SWQgaXMgZGVjbGFyZWQsIHdlIHdhbnQgdG8gY3JlYXRlIGFuIGV4dHJhXG4gICAgICAgICAgICAgICAgICogaW50ZXJwb2xhdGlvbiB2YWx1ZSB0aGF0IG9ic2VydmVzIHRoZSBjdXJyZW50IGNvbmZpZyBhbmRcbiAgICAgICAgICAgICAgICAgKiBzZXQgaXQgdmFsdWUgdG8gJ2hpZGRlbicgd2hlbiA8MCBhbmQgb3RoZXJ3aXNlICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogVGhlIGdvYWwgaGVyZSBpcyB0byBiZSBhYmxlIHRvIGNyZWF0ZSBhIHZpc2liaWxpdHkgY3NzXG4gICAgICAgICAgICAgICAgICogdmFyaWFibGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBvcGFjaXR5IHZhcmlhYmxlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogV2hlbiB0aGUgb3BhY2l0eSBpcyAwLCB0aGUgdmlzaWJsaXR5IHNob3VsZCBiZSBoaWRkZW5cbiAgICAgICAgICAgICAgICAgKiB0byBib29zdCBwZXJmb3JtYW5jZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAgICAgICAqICB7XG4gICAgICAgICAgICAgICAgICogICBwcm9ncmVzczogW3sgZnJvbTogMCwgdG86IDAuMywgc3RhcnQ6IDAsIGVuZDogMSB9LF0sXG4gICAgICAgICAgICAgICAgICogICBpZDogJy0tbXktb3BhY2l0eSdcbiAgICAgICAgICAgICAgICAgKiAgIHZpc2liaWxpdHlJZDogJy0tbXktdmlzaWJpbGl0eSdcbiAgICAgICAgICAgICAgICAgKiB9LFxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogICAubXl2YXJcbiAgICAgICAgICAgICAgICAgKiAgICAgICBvcGFjaXR5OiB2YXIoLS1teS1vcGFjaXR5KVxuICAgICAgICAgICAgICAgICAqICAgICAgIHZpc2liaWxpdHk6IHZhcigtLW15LXZpc2liaWxpdHkpXG4gICAgICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vYmxpbmtrY29kZS9kZWd1L2lzc3Vlcy82NVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcudmlzaWJpbGl0eUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGlzIHRvIHRoZSBjdXJyZW50IHZhbHVlcyBsaXN0LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZXNbY29uZmlnLnZpc2liaWxpdHlJZF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkVmFsdWUgPD0gMCA/ICdoaWRkZW4nIDogJ3Zpc2libGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJ1biB1cGRhdGUgZnVuY3Rpb24uXG4gICAgICAgICAgICBpZiAoY29uZmlnLm9uVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLm9uVXBkYXRlKGNvbmZpZy5pZCwgdGhpcy5wYXJlbnRQcm9ncmVzcywgdGhpcy5jdXJyZW50VmFsdWVzW2NvbmZpZy5pZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFZhbHVlcztcbiAgICB9XG59XG5leHBvcnRzLk11bHRpSW50ZXJwb2xhdGUgPSBNdWx0aUludGVycG9sYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGktaW50ZXJwb2xhdGUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/interpolate/multi-interpolate.js\n");

/***/ }),

/***/ "./lib/is/is.js":
/*!**********************!*\
  !*** ./lib/is/is.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.is = void 0;\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * A utility function that generally tests the state of things.\n */\nclass is {\n    /**\n     * Helper function to do true type checking.\n     * See https://gomakethings.com/true-type-checking-with-vanilla-js/\n     * @param value\n     * @param type\n     */\n    static type(value, type) {\n        const trueType = Object.prototype.toString\n            .call(value)\n            .slice(8, -1)\n            .toLowerCase();\n        return type === trueType;\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static boolean(value) {\n        return is.type(value, 'boolean');\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static array(value) {\n        return is.type(value, 'array');\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static string(value) {\n        return is.type(value, 'string');\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static date(value) {\n        return is.type(value, 'date');\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static number(value) {\n        return is.type(value, 'number');\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static function(value) {\n        return is.type(value, 'function');\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static null(value) {\n        return is.type(value, 'null');\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static undefined(value) {\n        return is.type(value, 'undefined');\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static defined(value) {\n        return !is.undefined(value);\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static regex(value) {\n        return is.type(value, 'regexp');\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static object(value) {\n        return is.type(value, 'object');\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static int(value) {\n        return is.number(value) && value % 1 === 0;\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static float(value) {\n        return is.number(value) && !is.int(value);\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static multipleOf(value, multiple) {\n        return is.number(value) && value % multiple === 0;\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static powerOf2(value) {\n        return value !== 0 && (value & (value - 1)) === 0;\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static even(value) {\n        return is.number(value) && is.multipleOf(value, 2);\n    }\n    /**\n     * @param value\n     * @tested\n     */\n    static odd(value) {\n        return is.number(value) && !is.even(value);\n    }\n    /**\n     * https://stackoverflow.com/questions/2652319/how-do-you-check-that-a-number-is-nan-in-javascript\n     * @param value\n     * @tested\n     */\n    static nan(value) {\n        return value !== value;\n    }\n    static mobile() {\n        return is.ios() || is.android();\n    }\n    static ios() {\n        return /iPhone|iPad|iPod/i.test(navigator.userAgent) || is.ipad();\n    }\n    static android() {\n        return /Android/i.test(navigator.userAgent);\n    }\n    static chrome() {\n        return navigator.userAgent.indexOf('Chrome') !== -1 && !is.edge();\n    }\n    static safari() {\n        return (!is.chrome() && navigator.userAgent.indexOf('Safari') !== -1 && !is.edge());\n    }\n    static ipad() {\n        return (navigator.userAgent.toLowerCase().indexOf('macintosh') !== -1 &&\n            Boolean(navigator.maxTouchPoints) &&\n            navigator.maxTouchPoints > 2);\n    }\n    static edge() {\n        return navigator.userAgent.indexOf('Edge') !== -1;\n    }\n    static firefox() {\n        return navigator.userAgent.indexOf('Firefox') !== -1;\n    }\n    static ie() {\n        return /MSIE\\/\\d+/.test(navigator.userAgent);\n    }\n    static ieOrEdge() {\n        return (/Edge\\/\\d+/.test(navigator.userAgent) ||\n            /MSIE\\/\\d+/.test(navigator.userAgent) ||\n            /Trident\\/\\d+/.test(navigator.userAgent));\n    }\n    static chromeOs() {\n        return /\\bCrOS\\b/.test(navigator.userAgent);\n    }\n    /**\n     * Detects support for offscreen canvas.\n     * https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas\n     */\n    static supportingOffScreenCanvas() {\n        return !!window['OffscreenCanvas'];\n    }\n    /**\n     * Detects support for webp images\n     */\n    static supportingWebp() {\n        const elem = document.createElement('canvas');\n        let canvasSupported = false;\n        if (elem.toDataURL('image/webp')) {\n            canvasSupported =\n                elem.toDataURL('image/webp').indexOf('data:image/webp') === 0;\n        }\n        // Test for firefox fails in the above but as of version 65 FF\n        // supports webp.\n        if (is.firefox() && +navigator.userAgent.match(/Firefox\\/(.*)/)[1] >= 65) {\n            canvasSupported = true;\n        }\n        // Test for Edge fails above but as of version 18, Edge supports\n        // webp.\n        if (is.edge() && +navigator.userAgent.match(/Edge\\/(.*)/)[1] >= 18) {\n            canvasSupported = true;\n        }\n        return canvasSupported;\n    }\n    /**\n     * The is.supportWebp has some performance costs due to the use of toDataUrl.\n     * This allows you to avoid that.\n     *\n     * Note that technically it is async but it is going to resolve almost\n     * instantly.\n     *\n     * ```\n     * is.supportingWebpAsync().then((supports)=> {\n     *    if(supports) {\n     *      ...supported\n     *    }\n     * });\n     *\n     * ```\n     */\n    static supportingWebpAsync() {\n        return new Promise(resolve => {\n            const img = new Image();\n            img.onload = function () {\n                const result = img.width > 0 && img.height > 0;\n                resolve(result);\n            };\n            img.onerror = () => {\n                resolve(false);\n            };\n            img.src =\n                'data:image/webp;base64,' +\n                    'UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==';\n        });\n    }\n    /**\n     * Whether the browser can handle more advanced css calc.\n     * @see https://css-tricks.com/making-custom-properties-css-variables-dynamic/\n     */\n    static supportingAdvancedCssCalc() {\n        document.body.style.transitionTimingFunction =\n            'cubic-bezier(calc(1 * 1),1,1,1)';\n        return getComputedStyle(document.body).transitionTimingFunction !== 'ease';\n    }\n    /**\n     * Whether touch is supported or not.\n     */\n    static supportingTouch() {\n        return ('ontouchstart' in window ||\n            navigator.maxTouchPoints > 0 ||\n            navigator.msMaxTouchPoints > 0);\n    }\n    /**\n     * Whether device orientation is supported\n     */\n    static supportingDeviceOrientation() {\n        return !!window['DeviceOrientationEvent'];\n    }\n    /**\n     * Whether FILE Apis are supported.\n     */\n    static supportingFileApis() {\n        return !!(window['File'] &&\n            window['FileReader'] &&\n            window['FileList'] &&\n            window['Blob']);\n    }\n    /**\n     * Whether createImageBitMap is supported or not.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/createImageBitmap;\n     */\n    static supportingCreateImageBitmap() {\n        return !!window['createImageBitmap'] && !is.firefox();\n    }\n    /**\n     * A string value that appears to be a css hex.\n     *\n     * ```\n     * is.cssHex('#FFFFFF') // true\n     * is.cssHex('#ffffff') // true\n     * is.cssHex('FFFFFF') // false\n     * is.cssHex(0) // false\n     *\n     * ```\n     */\n    static cssHex(value) {\n        return is.string(value) && value.startsWith('#');\n    }\n    /**\n     * A string value that appears to be a css rgba like.\n     *\n     * ```\n     * is.cssRgba(\"rgba(255, 255, 255, 0.3)\") // true\n     * is.cssRgba(\"rgba()\") // true\n     * is.cssRgba('rgb('255, 255, 255)') // false\n     *\n     * ```\n     */\n    static cssRgba(value) {\n        return is.string(value) && value.startsWith('rgba(');\n    }\n    /**\n     * A string value that appears to be a css rgb like.\n     *\n     * ```\n     * is.cssRgb(\"rgb(255, 255, 255)\") // true\n     * is.cssRgb(\"rgba(')\") // false\n     * is.cssRgb(90) // false\n     *\n     * ```\n     */\n    static cssRgb(value) {\n        return is.string(value) && value.startsWith('rgb(');\n    }\n    /**\n     * Tests whether this is a hex value.\n     * ```\n     * is.hex('#FFFFFF') // false -> starts with #.\n     * is.hex('FFFFFF') // true\n     * is.hex('ffffff') // true\n     * is.hex(0) // false\n     *\n     * ```\n     * @param value\n     */\n    static hex(value) {\n        const a = parseInt(value, 16);\n        return is.string(value) && a.toString(16) === value.toLowerCase();\n    }\n    /**\n     * Whether if the window load event has fired.\n     * @see https://stackoverflow.com/questions/13364613/how-to-know-if-window-load-event-was-fired-already\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming/loadEventEnd\n     */\n    static windowLoaded() {\n        return performance.timing.loadEventEnd !== 0;\n    }\n    /**\n     * Whether this URL looks like a google cloudish url.\n     * @param url\n     */\n    static isGoogleCloudLikeUrl(url) {\n        return url.includes('googleusercontent.com');\n    }\n    /**\n     * Whether the current viewport is landscape or not.   Includes 1x1 aspect.\n     */\n    static isLandscape() {\n        return window.innerWidth >= window.innerHeight;\n    }\n    // Alias\n    static landscape() {\n        return window.innerWidth < window.innerHeight;\n    }\n    /**\n     * Whether the current viewport is portrait or not.   Excludes 1x1 aspect.\n     */\n    static isPortrait() {\n        return window.innerWidth < window.innerHeight;\n    }\n    // Alias\n    static portrait() {\n        return window.innerWidth < window.innerHeight;\n    }\n    /**\n     * Whether this is one of the major search engine bots.\n     * https://stackoverflow.com/questions/20084513/detect-search-crawlers-via-javascript\n     */\n    static bot() {\n        const botPattern = '(googlebot/|bot|Googlebot-Mobile|Googlebot-Image|Google favicon|Mediapartners-Google|bingbot|slurp|java|wget|curl|Commons-HttpClient|Python-urllib|libwww|httpunit|nutch|phpcrawl|msnbot|jyxobot|FAST-WebCrawler|FAST Enterprise Crawler|biglotron|teoma|convera|seekbot|gigablast|exabot|ngbot|ia_archiver|GingerCrawler|webmon |httrack|webcrawler|grub.org|UsineNouvelleCrawler|antibot|netresearchserver|speedy|fluffy|bibnum.bnf|findlink|msrbot|panscient|yacybot|AISearchBot|IOI|ips-agent|tagoobot|MJ12bot|dotbot|woriobot|yanga|buzzbot|mlbot|yandexbot|purebot|Linguee Bot|Voyager|CyberPatrol|voilabot|baiduspider|citeseerxbot|spbot|twengabot|postrank|turnitinbot|scribdbot|page2rss|sitebot|linkdex|Adidxbot|blekkobot|ezooms|dotbot|Mail.RU_Bot|discobot|heritrix|findthatfile|europarchive.org|NerdByNature.Bot|sistrix crawler|ahrefsbot|Aboundex|domaincrawler|wbsearchbot|summify|ccbot|edisterbot|seznambot|ec2linkfinder|gslfbot|aihitbot|intelium_bot|facebookexternalhit|yeti|RetrevoPageAnalyzer|lb-spider|sogou|lssbot|careerbot|wotbox|wocbot|ichiro|DuckDuckBot|lssrocketcrawler|drupact|webcompanycrawler|acoonbot|openindexspider|gnam gnam spider|web-archive-net.com.bot|backlinkcrawler|coccoc|integromedb|content crawler spider|toplistbot|seokicks-robot|it2media-domain-crawler|ip-web-crawler.com|siteexplorer.info|elisabot|proximic|changedetection|blexbot|arabot|WeSEE:Search|niki-bot|CrystalSemanticsBot|rogerbot|360Spider|psbot|InterfaxScanBot|Lipperhey SEO Service|CC Metadata Scaper|g00g1e.net|GrapeshotCrawler|urlappendbot|brainobot|fr-crawler|binlar|SimpleCrawler|Livelapbot|Twitterbot|cXensebot|smtbot|bnf.fr_bot|A6-Indexer|ADmantX|Facebot|Twitterbot|OrangeBot|memorybot|AdvBot|MegaIndex|SemanticScholarBot|ltx71|nerdybot|xovibot|BUbiNG|Qwantify|archive.org_bot|Applebot|TweetmemeBot|crawler4j|findxbot|SemrushBot|yoozBot|lipperhey|y!j-asr|Domain Re-Animator Bot|AddThis)';\n        const re = new RegExp(botPattern, 'i');\n        return re.test(navigator.userAgent);\n    }\n}\nexports.is = is;\n/* eslint-enable */\n//# sourceMappingURL=is.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvaXMvaXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvaXMvaXMuanM/YzYzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXMgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IGdlbmVyYWxseSB0ZXN0cyB0aGUgc3RhdGUgb2YgdGhpbmdzLlxuICovXG5jbGFzcyBpcyB7XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGRvIHRydWUgdHlwZSBjaGVja2luZy5cbiAgICAgKiBTZWUgaHR0cHM6Ly9nb21ha2V0aGluZ3MuY29tL3RydWUtdHlwZS1jaGVja2luZy13aXRoLXZhbmlsbGEtanMvXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIHR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgdHlwZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBjb25zdCB0cnVlVHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgICAgIC5jYWxsKHZhbHVlKVxuICAgICAgICAgICAgLnNsaWNlKDgsIC0xKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB0eXBlID09PSB0cnVlVHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHRlc3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpcy50eXBlKHZhbHVlLCAnYm9vbGVhbicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAdGVzdGVkXG4gICAgICovXG4gICAgc3RhdGljIGFycmF5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpcy50eXBlKHZhbHVlLCAnYXJyYXknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHRlc3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzLnR5cGUodmFsdWUsICdzdHJpbmcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHRlc3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBkYXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpcy50eXBlKHZhbHVlLCAnZGF0ZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAdGVzdGVkXG4gICAgICovXG4gICAgc3RhdGljIG51bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXMudHlwZSh2YWx1ZSwgJ251bWJlcicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAdGVzdGVkXG4gICAgICovXG4gICAgc3RhdGljIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpcy50eXBlKHZhbHVlLCAnZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHRlc3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBudWxsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpcy50eXBlKHZhbHVlLCAnbnVsbCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAdGVzdGVkXG4gICAgICovXG4gICAgc3RhdGljIHVuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXMudHlwZSh2YWx1ZSwgJ3VuZGVmaW5lZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAdGVzdGVkXG4gICAgICovXG4gICAgc3RhdGljIGRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICFpcy51bmRlZmluZWQodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAdGVzdGVkXG4gICAgICovXG4gICAgc3RhdGljIHJlZ2V4KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpcy50eXBlKHZhbHVlLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEB0ZXN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgb2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpcy50eXBlKHZhbHVlLCAnb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEB0ZXN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgaW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpcy5udW1iZXIodmFsdWUpICYmIHZhbHVlICUgMSA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHRlc3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBmbG9hdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXMubnVtYmVyKHZhbHVlKSAmJiAhaXMuaW50KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHRlc3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBtdWx0aXBsZU9mKHZhbHVlLCBtdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gaXMubnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAlIG11bHRpcGxlID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAdGVzdGVkXG4gICAgICovXG4gICAgc3RhdGljIHBvd2VyT2YyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gMCAmJiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEB0ZXN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZXZlbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXMubnVtYmVyKHZhbHVlKSAmJiBpcy5tdWx0aXBsZU9mKHZhbHVlLCAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHRlc3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBvZGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzLm51bWJlcih2YWx1ZSkgJiYgIWlzLmV2ZW4odmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjUyMzE5L2hvdy1kby15b3UtY2hlY2stdGhhdC1hLW51bWJlci1pcy1uYW4taW4tamF2YXNjcmlwdFxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEB0ZXN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgbmFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gICAgfVxuICAgIHN0YXRpYyBtb2JpbGUoKSB7XG4gICAgICAgIHJldHVybiBpcy5pb3MoKSB8fCBpcy5hbmRyb2lkKCk7XG4gICAgfVxuICAgIHN0YXRpYyBpb3MoKSB7XG4gICAgICAgIHJldHVybiAvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgaXMuaXBhZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgYW5kcm9pZCgpIHtcbiAgICAgICAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gICAgc3RhdGljIGNocm9tZSgpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgIT09IC0xICYmICFpcy5lZGdlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBzYWZhcmkoKSB7XG4gICAgICAgIHJldHVybiAoIWlzLmNocm9tZSgpICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignU2FmYXJpJykgIT09IC0xICYmICFpcy5lZGdlKCkpO1xuICAgIH1cbiAgICBzdGF0aWMgaXBhZCgpIHtcbiAgICAgICAgcmV0dXJuIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignbWFjaW50b3NoJykgIT09IC0xICYmXG4gICAgICAgICAgICBCb29sZWFuKG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cykgJiZcbiAgICAgICAgICAgIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDIpO1xuICAgIH1cbiAgICBzdGF0aWMgZWRnZSgpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpICE9PSAtMTtcbiAgICB9XG4gICAgc3RhdGljIGZpcmVmb3goKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSAhPT0gLTE7XG4gICAgfVxuICAgIHN0YXRpYyBpZSgpIHtcbiAgICAgICAgcmV0dXJuIC9NU0lFXFwvXFxkKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gICAgc3RhdGljIGllT3JFZGdlKCkge1xuICAgICAgICByZXR1cm4gKC9FZGdlXFwvXFxkKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fFxuICAgICAgICAgICAgL01TSUVcXC9cXGQrLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIHx8XG4gICAgICAgICAgICAvVHJpZGVudFxcL1xcZCsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpO1xuICAgIH1cbiAgICBzdGF0aWMgY2hyb21lT3MoKSB7XG4gICAgICAgIHJldHVybiAvXFxiQ3JPU1xcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyBzdXBwb3J0IGZvciBvZmZzY3JlZW4gY2FudmFzLlxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9PZmZzY3JlZW5DYW52YXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3VwcG9ydGluZ09mZlNjcmVlbkNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuICEhd2luZG93WydPZmZzY3JlZW5DYW52YXMnXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyBzdXBwb3J0IGZvciB3ZWJwIGltYWdlc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdXBwb3J0aW5nV2VicCgpIHtcbiAgICAgICAgY29uc3QgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBsZXQgY2FudmFzU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChlbGVtLnRvRGF0YVVSTCgnaW1hZ2Uvd2VicCcpKSB7XG4gICAgICAgICAgICBjYW52YXNTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIGVsZW0udG9EYXRhVVJMKCdpbWFnZS93ZWJwJykuaW5kZXhPZignZGF0YTppbWFnZS93ZWJwJykgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBmb3IgZmlyZWZveCBmYWlscyBpbiB0aGUgYWJvdmUgYnV0IGFzIG9mIHZlcnNpb24gNjUgRkZcbiAgICAgICAgLy8gc3VwcG9ydHMgd2VicC5cbiAgICAgICAgaWYgKGlzLmZpcmVmb3goKSAmJiArbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLyguKikvKVsxXSA+PSA2NSkge1xuICAgICAgICAgICAgY2FudmFzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IGZvciBFZGdlIGZhaWxzIGFib3ZlIGJ1dCBhcyBvZiB2ZXJzaW9uIDE4LCBFZGdlIHN1cHBvcnRzXG4gICAgICAgIC8vIHdlYnAuXG4gICAgICAgIGlmIChpcy5lZGdlKCkgJiYgK25hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8oLiopLylbMV0gPj0gMTgpIHtcbiAgICAgICAgICAgIGNhbnZhc1N1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbnZhc1N1cHBvcnRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGlzLnN1cHBvcnRXZWJwIGhhcyBzb21lIHBlcmZvcm1hbmNlIGNvc3RzIGR1ZSB0byB0aGUgdXNlIG9mIHRvRGF0YVVybC5cbiAgICAgKiBUaGlzIGFsbG93cyB5b3UgdG8gYXZvaWQgdGhhdC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0ZWNobmljYWxseSBpdCBpcyBhc3luYyBidXQgaXQgaXMgZ29pbmcgdG8gcmVzb2x2ZSBhbG1vc3RcbiAgICAgKiBpbnN0YW50bHkuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBpcy5zdXBwb3J0aW5nV2VicEFzeW5jKCkudGhlbigoc3VwcG9ydHMpPT4ge1xuICAgICAqICAgIGlmKHN1cHBvcnRzKSB7XG4gICAgICogICAgICAuLi5zdXBwb3J0ZWRcbiAgICAgKiAgICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgc3VwcG9ydGluZ1dlYnBBc3luYygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGltZy53aWR0aCA+IDAgJiYgaW1nLmhlaWdodCA+IDA7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltZy5zcmMgPVxuICAgICAgICAgICAgICAgICdkYXRhOmltYWdlL3dlYnA7YmFzZTY0LCcgK1xuICAgICAgICAgICAgICAgICAgICAnVWtsR1Job0FBQUJYUlVKUVZsQTRUQTBBQUFBdkFBQUFFQWNRRVJHSWlQNEhBQT09JztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgY2FuIGhhbmRsZSBtb3JlIGFkdmFuY2VkIGNzcyBjYWxjLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9tYWtpbmctY3VzdG9tLXByb3BlcnRpZXMtY3NzLXZhcmlhYmxlcy1keW5hbWljL1xuICAgICAqL1xuICAgIHN0YXRpYyBzdXBwb3J0aW5nQWR2YW5jZWRDc3NDYWxjKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9XG4gICAgICAgICAgICAnY3ViaWMtYmV6aWVyKGNhbGMoMSAqIDEpLDEsMSwxKSc7XG4gICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiAhPT0gJ2Vhc2UnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvdWNoIGlzIHN1cHBvcnRlZCBvciBub3QuXG4gICAgICovXG4gICAgc3RhdGljIHN1cHBvcnRpbmdUb3VjaCgpIHtcbiAgICAgICAgcmV0dXJuICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHxcbiAgICAgICAgICAgIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAgfHxcbiAgICAgICAgICAgIG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzID4gMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZGV2aWNlIG9yaWVudGF0aW9uIGlzIHN1cHBvcnRlZFxuICAgICAqL1xuICAgIHN0YXRpYyBzdXBwb3J0aW5nRGV2aWNlT3JpZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXdpbmRvd1snRGV2aWNlT3JpZW50YXRpb25FdmVudCddO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIEZJTEUgQXBpcyBhcmUgc3VwcG9ydGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdXBwb3J0aW5nRmlsZUFwaXMoKSB7XG4gICAgICAgIHJldHVybiAhISh3aW5kb3dbJ0ZpbGUnXSAmJlxuICAgICAgICAgICAgd2luZG93WydGaWxlUmVhZGVyJ10gJiZcbiAgICAgICAgICAgIHdpbmRvd1snRmlsZUxpc3QnXSAmJlxuICAgICAgICAgICAgd2luZG93WydCbG9iJ10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGNyZWF0ZUltYWdlQml0TWFwIGlzIHN1cHBvcnRlZCBvciBub3QuXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93T3JXb3JrZXJHbG9iYWxTY29wZS9jcmVhdGVJbWFnZUJpdG1hcDtcbiAgICAgKi9cbiAgICBzdGF0aWMgc3VwcG9ydGluZ0NyZWF0ZUltYWdlQml0bWFwKCkge1xuICAgICAgICByZXR1cm4gISF3aW5kb3dbJ2NyZWF0ZUltYWdlQml0bWFwJ10gJiYgIWlzLmZpcmVmb3goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdHJpbmcgdmFsdWUgdGhhdCBhcHBlYXJzIHRvIGJlIGEgY3NzIGhleC5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGlzLmNzc0hleCgnI0ZGRkZGRicpIC8vIHRydWVcbiAgICAgKiBpcy5jc3NIZXgoJyNmZmZmZmYnKSAvLyB0cnVlXG4gICAgICogaXMuY3NzSGV4KCdGRkZGRkYnKSAvLyBmYWxzZVxuICAgICAqIGlzLmNzc0hleCgwKSAvLyBmYWxzZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGNzc0hleCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXMuc3RyaW5nKHZhbHVlKSAmJiB2YWx1ZS5zdGFydHNXaXRoKCcjJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc3RyaW5nIHZhbHVlIHRoYXQgYXBwZWFycyB0byBiZSBhIGNzcyByZ2JhIGxpa2UuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBpcy5jc3NSZ2JhKFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpXCIpIC8vIHRydWVcbiAgICAgKiBpcy5jc3NSZ2JhKFwicmdiYSgpXCIpIC8vIHRydWVcbiAgICAgKiBpcy5jc3NSZ2JhKCdyZ2IoJzI1NSwgMjU1LCAyNTUpJykgLy8gZmFsc2VcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBjc3NSZ2JhKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpcy5zdHJpbmcodmFsdWUpICYmIHZhbHVlLnN0YXJ0c1dpdGgoJ3JnYmEoJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc3RyaW5nIHZhbHVlIHRoYXQgYXBwZWFycyB0byBiZSBhIGNzcyByZ2IgbGlrZS5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGlzLmNzc1JnYihcInJnYigyNTUsIDI1NSwgMjU1KVwiKSAvLyB0cnVlXG4gICAgICogaXMuY3NzUmdiKFwicmdiYSgnKVwiKSAvLyBmYWxzZVxuICAgICAqIGlzLmNzc1JnYig5MCkgLy8gZmFsc2VcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBjc3NSZ2IodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzLnN0cmluZyh2YWx1ZSkgJiYgdmFsdWUuc3RhcnRzV2l0aCgncmdiKCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyB3aGV0aGVyIHRoaXMgaXMgYSBoZXggdmFsdWUuXG4gICAgICogYGBgXG4gICAgICogaXMuaGV4KCcjRkZGRkZGJykgLy8gZmFsc2UgLT4gc3RhcnRzIHdpdGggIy5cbiAgICAgKiBpcy5oZXgoJ0ZGRkZGRicpIC8vIHRydWVcbiAgICAgKiBpcy5oZXgoJ2ZmZmZmZicpIC8vIHRydWVcbiAgICAgKiBpcy5oZXgoMCkgLy8gZmFsc2VcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBoZXgodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYSA9IHBhcnNlSW50KHZhbHVlLCAxNik7XG4gICAgICAgIHJldHVybiBpcy5zdHJpbmcodmFsdWUpICYmIGEudG9TdHJpbmcoMTYpID09PSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGlmIHRoZSB3aW5kb3cgbG9hZCBldmVudCBoYXMgZmlyZWQuXG4gICAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM2NDYxMy9ob3ctdG8ta25vdy1pZi13aW5kb3ctbG9hZC1ldmVudC13YXMtZmlyZWQtYWxyZWFkeVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1BlcmZvcm1hbmNlVGltaW5nL2xvYWRFdmVudEVuZFxuICAgICAqL1xuICAgIHN0YXRpYyB3aW5kb3dMb2FkZWQoKSB7XG4gICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS50aW1pbmcubG9hZEV2ZW50RW5kICE9PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgVVJMIGxvb2tzIGxpa2UgYSBnb29nbGUgY2xvdWRpc2ggdXJsLlxuICAgICAqIEBwYXJhbSB1cmxcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNHb29nbGVDbG91ZExpa2VVcmwodXJsKSB7XG4gICAgICAgIHJldHVybiB1cmwuaW5jbHVkZXMoJ2dvb2dsZXVzZXJjb250ZW50LmNvbScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjdXJyZW50IHZpZXdwb3J0IGlzIGxhbmRzY2FwZSBvciBub3QuICAgSW5jbHVkZXMgMXgxIGFzcGVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNMYW5kc2NhcGUoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aCA+PSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuICAgIC8vIEFsaWFzXG4gICAgc3RhdGljIGxhbmRzY2FwZSgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoIDwgd2luZG93LmlubmVySGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjdXJyZW50IHZpZXdwb3J0IGlzIHBvcnRyYWl0IG9yIG5vdC4gICBFeGNsdWRlcyAxeDEgYXNwZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1BvcnRyYWl0KCkge1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggPCB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuICAgIC8vIEFsaWFzXG4gICAgc3RhdGljIHBvcnRyYWl0KCkge1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggPCB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBpcyBvbmUgb2YgdGhlIG1ham9yIHNlYXJjaCBlbmdpbmUgYm90cy5cbiAgICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDA4NDUxMy9kZXRlY3Qtc2VhcmNoLWNyYXdsZXJzLXZpYS1qYXZhc2NyaXB0XG4gICAgICovXG4gICAgc3RhdGljIGJvdCgpIHtcbiAgICAgICAgY29uc3QgYm90UGF0dGVybiA9ICcoZ29vZ2xlYm90L3xib3R8R29vZ2xlYm90LU1vYmlsZXxHb29nbGVib3QtSW1hZ2V8R29vZ2xlIGZhdmljb258TWVkaWFwYXJ0bmVycy1Hb29nbGV8YmluZ2JvdHxzbHVycHxqYXZhfHdnZXR8Y3VybHxDb21tb25zLUh0dHBDbGllbnR8UHl0aG9uLXVybGxpYnxsaWJ3d3d8aHR0cHVuaXR8bnV0Y2h8cGhwY3Jhd2x8bXNuYm90fGp5eG9ib3R8RkFTVC1XZWJDcmF3bGVyfEZBU1QgRW50ZXJwcmlzZSBDcmF3bGVyfGJpZ2xvdHJvbnx0ZW9tYXxjb252ZXJhfHNlZWtib3R8Z2lnYWJsYXN0fGV4YWJvdHxuZ2JvdHxpYV9hcmNoaXZlcnxHaW5nZXJDcmF3bGVyfHdlYm1vbiB8aHR0cmFja3x3ZWJjcmF3bGVyfGdydWIub3JnfFVzaW5lTm91dmVsbGVDcmF3bGVyfGFudGlib3R8bmV0cmVzZWFyY2hzZXJ2ZXJ8c3BlZWR5fGZsdWZmeXxiaWJudW0uYm5mfGZpbmRsaW5rfG1zcmJvdHxwYW5zY2llbnR8eWFjeWJvdHxBSVNlYXJjaEJvdHxJT0l8aXBzLWFnZW50fHRhZ29vYm90fE1KMTJib3R8ZG90Ym90fHdvcmlvYm90fHlhbmdhfGJ1enpib3R8bWxib3R8eWFuZGV4Ym90fHB1cmVib3R8TGluZ3VlZSBCb3R8Vm95YWdlcnxDeWJlclBhdHJvbHx2b2lsYWJvdHxiYWlkdXNwaWRlcnxjaXRlc2Vlcnhib3R8c3Bib3R8dHdlbmdhYm90fHBvc3RyYW5rfHR1cm5pdGluYm90fHNjcmliZGJvdHxwYWdlMnJzc3xzaXRlYm90fGxpbmtkZXh8QWRpZHhib3R8Ymxla2tvYm90fGV6b29tc3xkb3Rib3R8TWFpbC5SVV9Cb3R8ZGlzY29ib3R8aGVyaXRyaXh8ZmluZHRoYXRmaWxlfGV1cm9wYXJjaGl2ZS5vcmd8TmVyZEJ5TmF0dXJlLkJvdHxzaXN0cml4IGNyYXdsZXJ8YWhyZWZzYm90fEFib3VuZGV4fGRvbWFpbmNyYXdsZXJ8d2JzZWFyY2hib3R8c3VtbWlmeXxjY2JvdHxlZGlzdGVyYm90fHNlem5hbWJvdHxlYzJsaW5rZmluZGVyfGdzbGZib3R8YWloaXRib3R8aW50ZWxpdW1fYm90fGZhY2Vib29rZXh0ZXJuYWxoaXR8eWV0aXxSZXRyZXZvUGFnZUFuYWx5emVyfGxiLXNwaWRlcnxzb2dvdXxsc3Nib3R8Y2FyZWVyYm90fHdvdGJveHx3b2Nib3R8aWNoaXJvfER1Y2tEdWNrQm90fGxzc3JvY2tldGNyYXdsZXJ8ZHJ1cGFjdHx3ZWJjb21wYW55Y3Jhd2xlcnxhY29vbmJvdHxvcGVuaW5kZXhzcGlkZXJ8Z25hbSBnbmFtIHNwaWRlcnx3ZWItYXJjaGl2ZS1uZXQuY29tLmJvdHxiYWNrbGlua2NyYXdsZXJ8Y29jY29jfGludGVncm9tZWRifGNvbnRlbnQgY3Jhd2xlciBzcGlkZXJ8dG9wbGlzdGJvdHxzZW9raWNrcy1yb2JvdHxpdDJtZWRpYS1kb21haW4tY3Jhd2xlcnxpcC13ZWItY3Jhd2xlci5jb218c2l0ZWV4cGxvcmVyLmluZm98ZWxpc2Fib3R8cHJveGltaWN8Y2hhbmdlZGV0ZWN0aW9ufGJsZXhib3R8YXJhYm90fFdlU0VFOlNlYXJjaHxuaWtpLWJvdHxDcnlzdGFsU2VtYW50aWNzQm90fHJvZ2VyYm90fDM2MFNwaWRlcnxwc2JvdHxJbnRlcmZheFNjYW5Cb3R8TGlwcGVyaGV5IFNFTyBTZXJ2aWNlfENDIE1ldGFkYXRhIFNjYXBlcnxnMDBnMWUubmV0fEdyYXBlc2hvdENyYXdsZXJ8dXJsYXBwZW5kYm90fGJyYWlub2JvdHxmci1jcmF3bGVyfGJpbmxhcnxTaW1wbGVDcmF3bGVyfExpdmVsYXBib3R8VHdpdHRlcmJvdHxjWGVuc2Vib3R8c210Ym90fGJuZi5mcl9ib3R8QTYtSW5kZXhlcnxBRG1hbnRYfEZhY2Vib3R8VHdpdHRlcmJvdHxPcmFuZ2VCb3R8bWVtb3J5Ym90fEFkdkJvdHxNZWdhSW5kZXh8U2VtYW50aWNTY2hvbGFyQm90fGx0eDcxfG5lcmR5Ym90fHhvdmlib3R8QlViaU5HfFF3YW50aWZ5fGFyY2hpdmUub3JnX2JvdHxBcHBsZWJvdHxUd2VldG1lbWVCb3R8Y3Jhd2xlcjRqfGZpbmR4Ym90fFNlbXJ1c2hCb3R8eW9vekJvdHxsaXBwZXJoZXl8eSFqLWFzcnxEb21haW4gUmUtQW5pbWF0b3IgQm90fEFkZFRoaXMpJztcbiAgICAgICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKGJvdFBhdHRlcm4sICdpJyk7XG4gICAgICAgIHJldHVybiByZS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuaXMgPSBpcztcbi8qIGVzbGludC1lbmFibGUgKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/is/is.js\n");

/***/ }),

/***/ "./lib/loader/blob-loader.js":
/*!***********************************!*\
  !*** ./lib/loader/blob-loader.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlobLoader = void 0;\nconst __1 = __webpack_require__(/*! .. */ \"./lib/index.js\");\n/**\n * A class that fetches a bunch of blobs.\n *\n * Here is an example of using the blob loader to fetch images.\n * const myImages = [\n *  'http://mydomain.com/dog.png',\n *  'http://mydomain.com/cat.png'\n *  'http://mydomain.com/cow.jpg'\n * ];\n *\n * const blobLoader = new blobLoader();\n *\n * // Loads images.\n * await results = blobLoader.load();\n *\n * // The source of the image is the key.\n * results['http://mydomain.com/dog.png']; // DOG blob.\n * results['http://mydomain.com/cat.png']; // Cat blob.\n *\n * const image = dom.makeImageFromBlob(blob);\n *\n * // Use the image.\n * canvas.drawImage(image);\n *\n * // Now delete it from memory.\n * dom.deleteImage(image);\n *\n * // Later\n * blobLoader.dispose();\n *\n * ```\n */\nclass BlobLoader {\n    constructor(imageSources) {\n        this.imageSources = imageSources;\n        this.blobs = {};\n        this.images64 = {};\n        this.maxRetries = 3;\n    }\n    load() {\n        return new Promise(resolve => {\n            if (!this.imageSources) {\n                resolve(this.blobs);\n            }\n            const promises = this.imageSources.map(source => {\n                return this.loadBlob(source);\n            });\n            Promise.all(promises).then(() => {\n                resolve(this.blobs);\n            });\n        });\n    }\n    loadBlob(source, retryCount = 0) {\n        return new Promise(resolve => {\n            fetch(source)\n                .then(response => {\n                // If status was not okay retry.\n                if (!response.ok) {\n                    retryCount++;\n                    if (retryCount >= this.maxRetries) {\n                        throw new Error(`failed after ${retryCount} tries`);\n                    }\n                    else {\n                        return this.loadBlob(source, retryCount);\n                    }\n                }\n                else {\n                    return response.blob();\n                }\n            })\n                .then(response => {\n                if (this.blobs && response) {\n                    this.blobs[source] = response;\n                }\n                resolve(response);\n            });\n        });\n    }\n    /**\n     * Loads the requested images as Base64 images.\n     */\n    loadBase64Images() {\n        return new Promise(resolve => {\n            const promises = this.imageSources.map(source => {\n                return this.loadBlobAsBase64Image(source);\n            });\n            Promise.all(promises).then(() => {\n                resolve(this.images64);\n            });\n        });\n    }\n    loadBlobAsBase64Image(source, retryCount = 0) {\n        return new Promise((resolve, reject) => {\n            fetch(source)\n                .then(response => {\n                // If status was not okay retry.\n                if (!response.ok) {\n                    retryCount++;\n                    if (retryCount >= this.maxRetries) {\n                        reject(`failed after ${retryCount} tries`);\n                    }\n                    return this.loadBlobAsBase64Image(source, retryCount);\n                }\n                else {\n                    return response.blob();\n                }\n            })\n                .then(response => {\n                if (response) {\n                    __1.dom.makeBase64ImageFromBlob(response).then(image => {\n                        this.images64[source] = image;\n                        resolve(response);\n                    });\n                }\n            });\n        });\n    }\n    dispose() {\n        this.imageSources = [];\n        this.images64 = {};\n        this.blobs = {};\n    }\n}\nexports.BlobLoader = BlobLoader;\n//# sourceMappingURL=blob-loader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbG9hZGVyL2Jsb2ItbG9hZGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL2xvYWRlci9ibG9iLWxvYWRlci5qcz9jZmEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CbG9iTG9hZGVyID0gdm9pZCAwO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uXCIpO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgZmV0Y2hlcyBhIGJ1bmNoIG9mIGJsb2JzLlxuICpcbiAqIEhlcmUgaXMgYW4gZXhhbXBsZSBvZiB1c2luZyB0aGUgYmxvYiBsb2FkZXIgdG8gZmV0Y2ggaW1hZ2VzLlxuICogY29uc3QgbXlJbWFnZXMgPSBbXG4gKiAgJ2h0dHA6Ly9teWRvbWFpbi5jb20vZG9nLnBuZycsXG4gKiAgJ2h0dHA6Ly9teWRvbWFpbi5jb20vY2F0LnBuZydcbiAqICAnaHR0cDovL215ZG9tYWluLmNvbS9jb3cuanBnJ1xuICogXTtcbiAqXG4gKiBjb25zdCBibG9iTG9hZGVyID0gbmV3IGJsb2JMb2FkZXIoKTtcbiAqXG4gKiAvLyBMb2FkcyBpbWFnZXMuXG4gKiBhd2FpdCByZXN1bHRzID0gYmxvYkxvYWRlci5sb2FkKCk7XG4gKlxuICogLy8gVGhlIHNvdXJjZSBvZiB0aGUgaW1hZ2UgaXMgdGhlIGtleS5cbiAqIHJlc3VsdHNbJ2h0dHA6Ly9teWRvbWFpbi5jb20vZG9nLnBuZyddOyAvLyBET0cgYmxvYi5cbiAqIHJlc3VsdHNbJ2h0dHA6Ly9teWRvbWFpbi5jb20vY2F0LnBuZyddOyAvLyBDYXQgYmxvYi5cbiAqXG4gKiBjb25zdCBpbWFnZSA9IGRvbS5tYWtlSW1hZ2VGcm9tQmxvYihibG9iKTtcbiAqXG4gKiAvLyBVc2UgdGhlIGltYWdlLlxuICogY2FudmFzLmRyYXdJbWFnZShpbWFnZSk7XG4gKlxuICogLy8gTm93IGRlbGV0ZSBpdCBmcm9tIG1lbW9yeS5cbiAqIGRvbS5kZWxldGVJbWFnZShpbWFnZSk7XG4gKlxuICogLy8gTGF0ZXJcbiAqIGJsb2JMb2FkZXIuZGlzcG9zZSgpO1xuICpcbiAqIGBgYFxuICovXG5jbGFzcyBCbG9iTG9hZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbWFnZVNvdXJjZXMpIHtcbiAgICAgICAgdGhpcy5pbWFnZVNvdXJjZXMgPSBpbWFnZVNvdXJjZXM7XG4gICAgICAgIHRoaXMuYmxvYnMgPSB7fTtcbiAgICAgICAgdGhpcy5pbWFnZXM2NCA9IHt9O1xuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSAzO1xuICAgIH1cbiAgICBsb2FkKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW1hZ2VTb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmJsb2JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5pbWFnZVNvdXJjZXMubWFwKHNvdXJjZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEJsb2Ioc291cmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5ibG9icyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxvYWRCbG9iKHNvdXJjZSwgcmV0cnlDb3VudCA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgZmV0Y2goc291cmNlKVxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzdGF0dXMgd2FzIG5vdCBva2F5IHJldHJ5LlxuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0cnlDb3VudCA+PSB0aGlzLm1heFJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIGFmdGVyICR7cmV0cnlDb3VudH0gdHJpZXNgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRCbG9iKHNvdXJjZSwgcmV0cnlDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmxvYnMgJiYgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ibG9ic1tzb3VyY2VdID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgcmVxdWVzdGVkIGltYWdlcyBhcyBCYXNlNjQgaW1hZ2VzLlxuICAgICAqL1xuICAgIGxvYWRCYXNlNjRJbWFnZXMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5pbWFnZVNvdXJjZXMubWFwKHNvdXJjZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEJsb2JBc0Jhc2U2NEltYWdlKHNvdXJjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuaW1hZ2VzNjQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb2FkQmxvYkFzQmFzZTY0SW1hZ2Uoc291cmNlLCByZXRyeUNvdW50ID0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZmV0Y2goc291cmNlKVxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzdGF0dXMgd2FzIG5vdCBva2F5IHJldHJ5LlxuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0cnlDb3VudCA+PSB0aGlzLm1heFJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChgZmFpbGVkIGFmdGVyICR7cmV0cnlDb3VudH0gdHJpZXNgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkQmxvYkFzQmFzZTY0SW1hZ2Uoc291cmNlLCByZXRyeUNvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9fMS5kb20ubWFrZUJhc2U2NEltYWdlRnJvbUJsb2IocmVzcG9uc2UpLnRoZW4oaW1hZ2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZXM2NFtzb3VyY2VdID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmltYWdlU291cmNlcyA9IFtdO1xuICAgICAgICB0aGlzLmltYWdlczY0ID0ge307XG4gICAgICAgIHRoaXMuYmxvYnMgPSB7fTtcbiAgICB9XG59XG5leHBvcnRzLkJsb2JMb2FkZXIgPSBCbG9iTG9hZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvYi1sb2FkZXIuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/loader/blob-loader.js\n");

/***/ }),

/***/ "./lib/loader/image-loader.js":
/*!************************************!*\
  !*** ./lib/loader/image-loader.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageLoader = void 0;\nconst is_1 = __webpack_require__(/*! ../is/is */ \"./lib/is/is.js\");\nconst __1 = __webpack_require__(/*! .. */ \"./lib/index.js\");\n/**\n * A class the loads a given set of images.\n *\n *\n * TODO (uxder): Needs more work.  Needs error and fetch fail handling.\n *\n * ```ts\n *\n * const myImages = [\n *  'http://mydomain.com/dog.png',\n *  'http://mydomain.com/cat.png'\n *  'http://mydomain.com/cow.jpg'\n * ];\n * const myImageLoader = new ImageLoader(myImages);\n *\n * // Optional - decodes the image as well.\n * // However, this uses image.decode() which will move the image memory\n * // to native memory.  It is not recommended unless you know what you are\n * // doing.\n * // @see dom.fetchAndMakeImage for more on the issues around\n * // image.decode().\n * myImageLoader.setDecodeAfterFetch(true);\n *\n *\n * // Loads images.\n * await results = myImageLoader.load();\n *\n * // The source of the image is the key.\n * results['http://mydomain.com/dog.png']; // DOG HTML Image element.\n * results['http://mydomain.com/cat.png']; // Cat HTML Image element.\n *\n * ```\n *\n *\n * You can alternatively fetch for just blobs.\n * ```ts\n * const myImages = [\n *  'http://mydomain.com/dog.png',\n *  'http://mydomain.com/cat.png'\n *  'http://mydomain.com/cow.jpg'\n * ];\n * const myImageLoader = new ImageLoader(myImages);\n *\n * await results = myImageLoader.loadBlobs();\n * results['http://mydomain.com/dog.png']; // DOG image blob.\n * ```\n */\nclass ImageLoader {\n    constructor(imageSources) {\n        this.imageSources = imageSources;\n        this.images = {};\n        this.maxRetries = 3;\n        this.decodeAfterFetch = false;\n        this.onEachImageLoaded = null;\n    }\n    /**\n     * Allows you to hook into each load event of image.\n     * This should be called prior to calling load.\n     *\n     * ```\n     * const myImages = [\n     *  'http://mydomain.com/dog.png',\n     *  'http://mydomain.com/cat.png'\n     *  'http://mydomain.com/cow.jpg'\n     * ];\n     * const myImageLoader = new ImageLoader(myImages);\n     *\n     * myImageLoader.loadCallback((source, img)=> {\n     *   console.log(source) // The image url that was just loaded.\n     *   console.log(img); // The image itself.\n     * })\n     *\n     * // Loads images.\n     * await results = myImageLoader.load();\n     *\n     * ```\n     * @param value\n     */\n    setLoadCallback(callback) {\n        this.onEachImageLoaded = callback;\n    }\n    /**\n     * Gets the internal cached images.\n     */\n    getImages() {\n        return this.images;\n    }\n    /**\n     * Sets to decodeAfterFetching.  Setting true on firefox causes failures\n     * so we test for firefox.\n     * @param value\n     */\n    setDecodeAfterFetch(value) {\n        this.decodeAfterFetch = is_1.is.firefox() ? false : value;\n    }\n    /**\n     * Begins loading all images.\n     */\n    load() {\n        return new Promise(resolve => {\n            const promises = this.imageSources.map(source => {\n                return this.fetchImage(source);\n            });\n            Promise.all(promises).then(() => {\n                resolve(this.images);\n            });\n        });\n    }\n    /**\n     * Pings / Fetches all images.   This can be used as an alternative\n     * to load().  Unlike load that ends up storing ImageBitmap or images\n     * in memory (resulting in higher RAM usage),\n     * this will simply make an XHR request so the response is\n     * help in browser cache.\n     *\n     * Once cached, you can pair this with dom.fetchAndMakeImage and dom.deleteImage\n     * to give you better control of releasing image memory from RAM on a per image\n     * basis.\n     *\n     * ```\n     *  const myImages = [\n     *  'http://mydomain.com/dog.png',\n     *  'http://mydomain.com/cat.png'\n     *  'http://mydomain.com/cow.jpg'\n     * ];\n     *  const imageLoader = new ImageLoader();\n     *\n     *  // Ping images.\n     * await results = myImageLoader.ping();\n     *\n     * // Images have been fetched and are in browser memory.\n     * // You can construct it now.\n     * const image = dom.fetchAndMakeImage(results[0]);\n     *\n     * // Do something with the image.\n     * canvas.drawImage(image);\n     *\n     * // Now manually delete it when you don't need it.\n     * dom.deleteImage(image);\n     *\n     *\n     *\n     * ```\n     *\n     * @param source\n     * @param retryCount\n     */\n    ping() {\n        return new Promise(resolve => {\n            const promises = this.imageSources.map(source => {\n                return this.pingSource(source);\n            });\n            Promise.all(promises).then(() => {\n                resolve(this.imageSources);\n            });\n        });\n    }\n    /**\n     * Only fetches images without generating it.\n     * This is useful for cases in which you want to\n     * \"preload\" images into the browser cache but not hold the image data in\n     * memory.\n     */\n    pingSource(source, retryCount = 0) {\n        return new Promise((resolve, reject) => {\n            fetch(source).then(response => {\n                // If status was not okay retry.\n                if (!response.ok) {\n                    retryCount++;\n                    if (retryCount >= this.maxRetries) {\n                        reject(`failed after ${retryCount} tries`);\n                    }\n                    else {\n                        resolve(this.pingSource(source, retryCount));\n                    }\n                }\n                else {\n                    resolve(source);\n                }\n            });\n        });\n    }\n    /**\n     * Fetches and creates an image element when successful.\n     * @param source The image source\n     * @param retryCount The current retry count.\n     */\n    fetchImage(source, retryCount = 0) {\n        return new Promise(resolve => {\n            fetch(source)\n                .then(response => {\n                // If status was not okay retry.\n                if (!response.ok) {\n                    retryCount++;\n                    if (retryCount >= this.maxRetries) {\n                        resolve();\n                    }\n                    else {\n                        this.fetchImage(source, retryCount);\n                    }\n                }\n                return response.blob();\n            })\n                .then(response => {\n                const blob = response;\n                const img = document.createElement('img');\n                // Note watch out with using image.decode();\n                // image.decode() images are moved to native memory where\n                // it can't be flushed even with image = null;\n                if (this.decodeAfterFetch && 'decode' in img) {\n                    img.src = URL.createObjectURL(blob);\n                    img.decoding = 'async';\n                    img\n                        .decode()\n                        .then(() => {\n                        this.images[source] = img;\n                        this.onEachImageLoaded && this.onEachImageLoaded(source, img);\n                        resolve();\n                    })\n                        .catch(() => {\n                        // console.log('error', Error);, then later,\n                        // throw new Error(error);\n                        // Usually when there is an error thrown it's\n                        // because this image couldn't be decoded\n                        // in a regular manner so we fall back again\n                        // to loading it normally.\n                        img.onload = () => {\n                            this.images[source] = img;\n                            this.onEachImageLoaded && this.onEachImageLoaded(source, img);\n                            resolve();\n                        };\n                        img.src = URL.createObjectURL(blob);\n                    });\n                }\n                else {\n                    img.onload = () => {\n                        this.images[source] = img;\n                        this.onEachImageLoaded && this.onEachImageLoaded(source, img);\n                        resolve();\n                    };\n                    img.src = URL.createObjectURL(blob);\n                }\n            });\n        });\n    }\n    /**\n     * Begins loading imageBitMaps. Alternate to load method but ImageBitmap\n     * has only partial support at the moment.\n     */\n    loadImageBitmaps() {\n        return new Promise(resolve => {\n            const promises = this.imageSources.map(source => {\n                return this.fetchImageBitmap(source);\n            });\n            Promise.all(promises).then(() => {\n                resolve(this.images);\n            });\n        });\n    }\n    /**\n     * Fetches image bitmap.   Image bitmaps are faster in rendering images on\n     * canvas because they don't do image decoding on each draw.  However,\n     * they are not fully supported across all browsers so use wisely.\n     *\n     * Also note that at the current time usage of ImageBitmap seems to bloat the\n     * native memory that can't be released.\n     *\n     * @see https://aerotwist.com/blog/the-hack-is-back/\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap\n     */\n    fetchImageBitmap(source, retryCount = 0) {\n        return new Promise(resolve => {\n            fetch(source)\n                .then(response => {\n                // If status was not okay retry.\n                if (!response.ok) {\n                    retryCount++;\n                    if (retryCount >= this.maxRetries) {\n                        resolve();\n                    }\n                    else {\n                        this.fetchImageBitmap(source, retryCount);\n                    }\n                }\n                return response.blob();\n            })\n                .then(blobData => createImageBitmap(blobData))\n                .then(response => {\n                const blob = response;\n                this.images[source] = blob;\n                this.onEachImageLoaded && this.onEachImageLoaded(source, blob);\n                resolve();\n            });\n        });\n    }\n    /**\n     * Loads bitmap or image.   If browser supports bitmaps, it will\n     * load bitmaps instead of an image.\n     */\n    loadBitmapOrImage() {\n        return is_1.is.supportingCreateImageBitmap()\n            ? this.loadImageBitmaps()\n            : this.load();\n    }\n    dispose() {\n        for (const key in this.images) {\n            if (!this.images[key]) {\n                return;\n            }\n            // If we loaded bitmaps and we can dispose.\n            // https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap/close\n            const item = this.images[key];\n            if (item instanceof ImageBitmap) {\n                item.close();\n            }\n            else if (typeof item === 'string') {\n                URL.revokeObjectURL(item);\n            }\n            else if (item instanceof HTMLImageElement) {\n                __1.dom.deleteImage(item);\n            }\n        }\n        this.images = {};\n    }\n}\nexports.ImageLoader = ImageLoader;\n//# sourceMappingURL=image-loader.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbG9hZGVyL2ltYWdlLWxvYWRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9sb2FkZXIvaW1hZ2UtbG9hZGVyLmpzPzkxNjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkltYWdlTG9hZGVyID0gdm9pZCAwO1xuY29uc3QgaXNfMSA9IHJlcXVpcmUoXCIuLi9pcy9pc1wiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLlwiKTtcbi8qKlxuICogQSBjbGFzcyB0aGUgbG9hZHMgYSBnaXZlbiBzZXQgb2YgaW1hZ2VzLlxuICpcbiAqXG4gKiBUT0RPICh1eGRlcik6IE5lZWRzIG1vcmUgd29yay4gIE5lZWRzIGVycm9yIGFuZCBmZXRjaCBmYWlsIGhhbmRsaW5nLlxuICpcbiAqIGBgYHRzXG4gKlxuICogY29uc3QgbXlJbWFnZXMgPSBbXG4gKiAgJ2h0dHA6Ly9teWRvbWFpbi5jb20vZG9nLnBuZycsXG4gKiAgJ2h0dHA6Ly9teWRvbWFpbi5jb20vY2F0LnBuZydcbiAqICAnaHR0cDovL215ZG9tYWluLmNvbS9jb3cuanBnJ1xuICogXTtcbiAqIGNvbnN0IG15SW1hZ2VMb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIobXlJbWFnZXMpO1xuICpcbiAqIC8vIE9wdGlvbmFsIC0gZGVjb2RlcyB0aGUgaW1hZ2UgYXMgd2VsbC5cbiAqIC8vIEhvd2V2ZXIsIHRoaXMgdXNlcyBpbWFnZS5kZWNvZGUoKSB3aGljaCB3aWxsIG1vdmUgdGhlIGltYWdlIG1lbW9yeVxuICogLy8gdG8gbmF0aXZlIG1lbW9yeS4gIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlXG4gKiAvLyBkb2luZy5cbiAqIC8vIEBzZWUgZG9tLmZldGNoQW5kTWFrZUltYWdlIGZvciBtb3JlIG9uIHRoZSBpc3N1ZXMgYXJvdW5kXG4gKiAvLyBpbWFnZS5kZWNvZGUoKS5cbiAqIG15SW1hZ2VMb2FkZXIuc2V0RGVjb2RlQWZ0ZXJGZXRjaCh0cnVlKTtcbiAqXG4gKlxuICogLy8gTG9hZHMgaW1hZ2VzLlxuICogYXdhaXQgcmVzdWx0cyA9IG15SW1hZ2VMb2FkZXIubG9hZCgpO1xuICpcbiAqIC8vIFRoZSBzb3VyY2Ugb2YgdGhlIGltYWdlIGlzIHRoZSBrZXkuXG4gKiByZXN1bHRzWydodHRwOi8vbXlkb21haW4uY29tL2RvZy5wbmcnXTsgLy8gRE9HIEhUTUwgSW1hZ2UgZWxlbWVudC5cbiAqIHJlc3VsdHNbJ2h0dHA6Ly9teWRvbWFpbi5jb20vY2F0LnBuZyddOyAvLyBDYXQgSFRNTCBJbWFnZSBlbGVtZW50LlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKiBZb3UgY2FuIGFsdGVybmF0aXZlbHkgZmV0Y2ggZm9yIGp1c3QgYmxvYnMuXG4gKiBgYGB0c1xuICogY29uc3QgbXlJbWFnZXMgPSBbXG4gKiAgJ2h0dHA6Ly9teWRvbWFpbi5jb20vZG9nLnBuZycsXG4gKiAgJ2h0dHA6Ly9teWRvbWFpbi5jb20vY2F0LnBuZydcbiAqICAnaHR0cDovL215ZG9tYWluLmNvbS9jb3cuanBnJ1xuICogXTtcbiAqIGNvbnN0IG15SW1hZ2VMb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIobXlJbWFnZXMpO1xuICpcbiAqIGF3YWl0IHJlc3VsdHMgPSBteUltYWdlTG9hZGVyLmxvYWRCbG9icygpO1xuICogcmVzdWx0c1snaHR0cDovL215ZG9tYWluLmNvbS9kb2cucG5nJ107IC8vIERPRyBpbWFnZSBibG9iLlxuICogYGBgXG4gKi9cbmNsYXNzIEltYWdlTG9hZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbWFnZVNvdXJjZXMpIHtcbiAgICAgICAgdGhpcy5pbWFnZVNvdXJjZXMgPSBpbWFnZVNvdXJjZXM7XG4gICAgICAgIHRoaXMuaW1hZ2VzID0ge307XG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IDM7XG4gICAgICAgIHRoaXMuZGVjb2RlQWZ0ZXJGZXRjaCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uRWFjaEltYWdlTG9hZGVkID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHlvdSB0byBob29rIGludG8gZWFjaCBsb2FkIGV2ZW50IG9mIGltYWdlLlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBwcmlvciB0byBjYWxsaW5nIGxvYWQuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBteUltYWdlcyA9IFtcbiAgICAgKiAgJ2h0dHA6Ly9teWRvbWFpbi5jb20vZG9nLnBuZycsXG4gICAgICogICdodHRwOi8vbXlkb21haW4uY29tL2NhdC5wbmcnXG4gICAgICogICdodHRwOi8vbXlkb21haW4uY29tL2Nvdy5qcGcnXG4gICAgICogXTtcbiAgICAgKiBjb25zdCBteUltYWdlTG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKG15SW1hZ2VzKTtcbiAgICAgKlxuICAgICAqIG15SW1hZ2VMb2FkZXIubG9hZENhbGxiYWNrKChzb3VyY2UsIGltZyk9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhzb3VyY2UpIC8vIFRoZSBpbWFnZSB1cmwgdGhhdCB3YXMganVzdCBsb2FkZWQuXG4gICAgICogICBjb25zb2xlLmxvZyhpbWcpOyAvLyBUaGUgaW1hZ2UgaXRzZWxmLlxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiAvLyBMb2FkcyBpbWFnZXMuXG4gICAgICogYXdhaXQgcmVzdWx0cyA9IG15SW1hZ2VMb2FkZXIubG9hZCgpO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICovXG4gICAgc2V0TG9hZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub25FYWNoSW1hZ2VMb2FkZWQgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW50ZXJuYWwgY2FjaGVkIGltYWdlcy5cbiAgICAgKi9cbiAgICBnZXRJbWFnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0byBkZWNvZGVBZnRlckZldGNoaW5nLiAgU2V0dGluZyB0cnVlIG9uIGZpcmVmb3ggY2F1c2VzIGZhaWx1cmVzXG4gICAgICogc28gd2UgdGVzdCBmb3IgZmlyZWZveC5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXREZWNvZGVBZnRlckZldGNoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlQWZ0ZXJGZXRjaCA9IGlzXzEuaXMuZmlyZWZveCgpID8gZmFsc2UgOiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmVnaW5zIGxvYWRpbmcgYWxsIGltYWdlcy5cbiAgICAgKi9cbiAgICBsb2FkKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuaW1hZ2VTb3VyY2VzLm1hcChzb3VyY2UgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoSW1hZ2Uoc291cmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5pbWFnZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQaW5ncyAvIEZldGNoZXMgYWxsIGltYWdlcy4gICBUaGlzIGNhbiBiZSB1c2VkIGFzIGFuIGFsdGVybmF0aXZlXG4gICAgICogdG8gbG9hZCgpLiAgVW5saWtlIGxvYWQgdGhhdCBlbmRzIHVwIHN0b3JpbmcgSW1hZ2VCaXRtYXAgb3IgaW1hZ2VzXG4gICAgICogaW4gbWVtb3J5IChyZXN1bHRpbmcgaW4gaGlnaGVyIFJBTSB1c2FnZSksXG4gICAgICogdGhpcyB3aWxsIHNpbXBseSBtYWtlIGFuIFhIUiByZXF1ZXN0IHNvIHRoZSByZXNwb25zZSBpc1xuICAgICAqIGhlbHAgaW4gYnJvd3NlciBjYWNoZS5cbiAgICAgKlxuICAgICAqIE9uY2UgY2FjaGVkLCB5b3UgY2FuIHBhaXIgdGhpcyB3aXRoIGRvbS5mZXRjaEFuZE1ha2VJbWFnZSBhbmQgZG9tLmRlbGV0ZUltYWdlXG4gICAgICogdG8gZ2l2ZSB5b3UgYmV0dGVyIGNvbnRyb2wgb2YgcmVsZWFzaW5nIGltYWdlIG1lbW9yeSBmcm9tIFJBTSBvbiBhIHBlciBpbWFnZVxuICAgICAqIGJhc2lzLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogIGNvbnN0IG15SW1hZ2VzID0gW1xuICAgICAqICAnaHR0cDovL215ZG9tYWluLmNvbS9kb2cucG5nJyxcbiAgICAgKiAgJ2h0dHA6Ly9teWRvbWFpbi5jb20vY2F0LnBuZydcbiAgICAgKiAgJ2h0dHA6Ly9teWRvbWFpbi5jb20vY293LmpwZydcbiAgICAgKiBdO1xuICAgICAqICBjb25zdCBpbWFnZUxvYWRlciA9IG5ldyBJbWFnZUxvYWRlcigpO1xuICAgICAqXG4gICAgICogIC8vIFBpbmcgaW1hZ2VzLlxuICAgICAqIGF3YWl0IHJlc3VsdHMgPSBteUltYWdlTG9hZGVyLnBpbmcoKTtcbiAgICAgKlxuICAgICAqIC8vIEltYWdlcyBoYXZlIGJlZW4gZmV0Y2hlZCBhbmQgYXJlIGluIGJyb3dzZXIgbWVtb3J5LlxuICAgICAqIC8vIFlvdSBjYW4gY29uc3RydWN0IGl0IG5vdy5cbiAgICAgKiBjb25zdCBpbWFnZSA9IGRvbS5mZXRjaEFuZE1ha2VJbWFnZShyZXN1bHRzWzBdKTtcbiAgICAgKlxuICAgICAqIC8vIERvIHNvbWV0aGluZyB3aXRoIHRoZSBpbWFnZS5cbiAgICAgKiBjYW52YXMuZHJhd0ltYWdlKGltYWdlKTtcbiAgICAgKlxuICAgICAqIC8vIE5vdyBtYW51YWxseSBkZWxldGUgaXQgd2hlbiB5b3UgZG9uJ3QgbmVlZCBpdC5cbiAgICAgKiBkb20uZGVsZXRlSW1hZ2UoaW1hZ2UpO1xuICAgICAqXG4gICAgICpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHNvdXJjZVxuICAgICAqIEBwYXJhbSByZXRyeUNvdW50XG4gICAgICovXG4gICAgcGluZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLmltYWdlU291cmNlcy5tYXAoc291cmNlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5waW5nU291cmNlKHNvdXJjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuaW1hZ2VTb3VyY2VzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSBmZXRjaGVzIGltYWdlcyB3aXRob3V0IGdlbmVyYXRpbmcgaXQuXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzIGluIHdoaWNoIHlvdSB3YW50IHRvXG4gICAgICogXCJwcmVsb2FkXCIgaW1hZ2VzIGludG8gdGhlIGJyb3dzZXIgY2FjaGUgYnV0IG5vdCBob2xkIHRoZSBpbWFnZSBkYXRhIGluXG4gICAgICogbWVtb3J5LlxuICAgICAqL1xuICAgIHBpbmdTb3VyY2Uoc291cmNlLCByZXRyeUNvdW50ID0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZmV0Y2goc291cmNlKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzdGF0dXMgd2FzIG5vdCBva2F5IHJldHJ5LlxuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0cnlDb3VudCA+PSB0aGlzLm1heFJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChgZmFpbGVkIGFmdGVyICR7cmV0cnlDb3VudH0gdHJpZXNgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5waW5nU291cmNlKHNvdXJjZSwgcmV0cnlDb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGFuZCBjcmVhdGVzIGFuIGltYWdlIGVsZW1lbnQgd2hlbiBzdWNjZXNzZnVsLlxuICAgICAqIEBwYXJhbSBzb3VyY2UgVGhlIGltYWdlIHNvdXJjZVxuICAgICAqIEBwYXJhbSByZXRyeUNvdW50IFRoZSBjdXJyZW50IHJldHJ5IGNvdW50LlxuICAgICAqL1xuICAgIGZldGNoSW1hZ2Uoc291cmNlLCByZXRyeUNvdW50ID0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBmZXRjaChzb3VyY2UpXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIHN0YXR1cyB3YXMgbm90IG9rYXkgcmV0cnkuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICByZXRyeUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXRyeUNvdW50ID49IHRoaXMubWF4UmV0cmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mZXRjaEltYWdlKHNvdXJjZSwgcmV0cnlDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHdhdGNoIG91dCB3aXRoIHVzaW5nIGltYWdlLmRlY29kZSgpO1xuICAgICAgICAgICAgICAgIC8vIGltYWdlLmRlY29kZSgpIGltYWdlcyBhcmUgbW92ZWQgdG8gbmF0aXZlIG1lbW9yeSB3aGVyZVxuICAgICAgICAgICAgICAgIC8vIGl0IGNhbid0IGJlIGZsdXNoZWQgZXZlbiB3aXRoIGltYWdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWNvZGVBZnRlckZldGNoICYmICdkZWNvZGUnIGluIGltZykge1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgICAgICAgICAgaW1nLmRlY29kaW5nID0gJ2FzeW5jJztcbiAgICAgICAgICAgICAgICAgICAgaW1nXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVjb2RlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzW3NvdXJjZV0gPSBpbWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRWFjaEltYWdlTG9hZGVkICYmIHRoaXMub25FYWNoSW1hZ2VMb2FkZWQoc291cmNlLCBpbWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdlcnJvcicsIEVycm9yKTssIHRoZW4gbGF0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXN1YWxseSB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIHRocm93biBpdCdzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoaXMgaW1hZ2UgY291bGRuJ3QgYmUgZGVjb2RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gYSByZWd1bGFyIG1hbm5lciBzbyB3ZSBmYWxsIGJhY2sgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGxvYWRpbmcgaXQgbm9ybWFsbHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzW3NvdXJjZV0gPSBpbWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVhY2hJbWFnZUxvYWRlZCAmJiB0aGlzLm9uRWFjaEltYWdlTG9hZGVkKHNvdXJjZSwgaW1nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1nLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzW3NvdXJjZV0gPSBpbWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRWFjaEltYWdlTG9hZGVkICYmIHRoaXMub25FYWNoSW1hZ2VMb2FkZWQoc291cmNlLCBpbWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJlZ2lucyBsb2FkaW5nIGltYWdlQml0TWFwcy4gQWx0ZXJuYXRlIHRvIGxvYWQgbWV0aG9kIGJ1dCBJbWFnZUJpdG1hcFxuICAgICAqIGhhcyBvbmx5IHBhcnRpYWwgc3VwcG9ydCBhdCB0aGUgbW9tZW50LlxuICAgICAqL1xuICAgIGxvYWRJbWFnZUJpdG1hcHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5pbWFnZVNvdXJjZXMubWFwKHNvdXJjZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hJbWFnZUJpdG1hcChzb3VyY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmltYWdlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgaW1hZ2UgYml0bWFwLiAgIEltYWdlIGJpdG1hcHMgYXJlIGZhc3RlciBpbiByZW5kZXJpbmcgaW1hZ2VzIG9uXG4gICAgICogY2FudmFzIGJlY2F1c2UgdGhleSBkb24ndCBkbyBpbWFnZSBkZWNvZGluZyBvbiBlYWNoIGRyYXcuICBIb3dldmVyLFxuICAgICAqIHRoZXkgYXJlIG5vdCBmdWxseSBzdXBwb3J0ZWQgYWNyb3NzIGFsbCBicm93c2VycyBzbyB1c2Ugd2lzZWx5LlxuICAgICAqXG4gICAgICogQWxzbyBub3RlIHRoYXQgYXQgdGhlIGN1cnJlbnQgdGltZSB1c2FnZSBvZiBJbWFnZUJpdG1hcCBzZWVtcyB0byBibG9hdCB0aGVcbiAgICAgKiBuYXRpdmUgbWVtb3J5IHRoYXQgY2FuJ3QgYmUgcmVsZWFzZWQuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vYWVyb3R3aXN0LmNvbS9ibG9nL3RoZS1oYWNrLWlzLWJhY2svXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW1hZ2VCaXRtYXBcbiAgICAgKi9cbiAgICBmZXRjaEltYWdlQml0bWFwKHNvdXJjZSwgcmV0cnlDb3VudCA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgZmV0Y2goc291cmNlKVxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzdGF0dXMgd2FzIG5vdCBva2F5IHJldHJ5LlxuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0cnlDb3VudCA+PSB0aGlzLm1heFJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hJbWFnZUJpdG1hcChzb3VyY2UsIHJldHJ5Q291bnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGJsb2JEYXRhID0+IGNyZWF0ZUltYWdlQml0bWFwKGJsb2JEYXRhKSlcbiAgICAgICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzW3NvdXJjZV0gPSBibG9iO1xuICAgICAgICAgICAgICAgIHRoaXMub25FYWNoSW1hZ2VMb2FkZWQgJiYgdGhpcy5vbkVhY2hJbWFnZUxvYWRlZChzb3VyY2UsIGJsb2IpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYml0bWFwIG9yIGltYWdlLiAgIElmIGJyb3dzZXIgc3VwcG9ydHMgYml0bWFwcywgaXQgd2lsbFxuICAgICAqIGxvYWQgYml0bWFwcyBpbnN0ZWFkIG9mIGFuIGltYWdlLlxuICAgICAqL1xuICAgIGxvYWRCaXRtYXBPckltYWdlKCkge1xuICAgICAgICByZXR1cm4gaXNfMS5pcy5zdXBwb3J0aW5nQ3JlYXRlSW1hZ2VCaXRtYXAoKVxuICAgICAgICAgICAgPyB0aGlzLmxvYWRJbWFnZUJpdG1hcHMoKVxuICAgICAgICAgICAgOiB0aGlzLmxvYWQoKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5pbWFnZXMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbWFnZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGxvYWRlZCBiaXRtYXBzIGFuZCB3ZSBjYW4gZGlzcG9zZS5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JbWFnZUJpdG1hcC9jbG9zZVxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaW1hZ2VzW2tleV07XG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgX18xLmRvbS5kZWxldGVJbWFnZShpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmltYWdlcyA9IHt9O1xuICAgIH1cbn1cbmV4cG9ydHMuSW1hZ2VMb2FkZXIgPSBJbWFnZUxvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWxvYWRlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/loader/image-loader.js\n");

/***/ }),

/***/ "./lib/map/default-map.js":
/*!********************************!*\
  !*** ./lib/map/default-map.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultMap = void 0;\nconst noop_1 = __webpack_require__(/*! ../func/noop */ \"./lib/func/noop.js\");\n/**\n * Allows for returning generated defaults for unknown keys.\n * Useful as a quick and dirty way to cache results of functions.\n *\n * This is intended to behave similarly to the defaultdict structure in python.\n *\n * ```\n * const sqrRts =\n *     DefaultMap.usingFunction<number, number>((x) => Math.sqrt(x));\n * sqrRts.get(9); // Returns 3\n * ```\n */\nclass DefaultMap extends Map {\n    constructor(iterable = [], defaultFunction = noop_1.noop) {\n        super(iterable);\n        this.defaultFunction = defaultFunction;\n    }\n    static usingFunction(defaultFunction) {\n        return new this([], defaultFunction);\n    }\n    get(key) {\n        if (!this.has(key)) {\n            const defaultValue = this.defaultFunction(key);\n            this.set(key, defaultValue);\n            return defaultValue;\n        }\n        else {\n            return super.get(key);\n        }\n    }\n}\nexports.DefaultMap = DefaultMap;\n//# sourceMappingURL=default-map.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbWFwL2RlZmF1bHQtbWFwLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL21hcC9kZWZhdWx0LW1hcC5qcz81NGVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWZhdWx0TWFwID0gdm9pZCAwO1xuY29uc3Qgbm9vcF8xID0gcmVxdWlyZShcIi4uL2Z1bmMvbm9vcFwiKTtcbi8qKlxuICogQWxsb3dzIGZvciByZXR1cm5pbmcgZ2VuZXJhdGVkIGRlZmF1bHRzIGZvciB1bmtub3duIGtleXMuXG4gKiBVc2VmdWwgYXMgYSBxdWljayBhbmQgZGlydHkgd2F5IHRvIGNhY2hlIHJlc3VsdHMgb2YgZnVuY3Rpb25zLlxuICpcbiAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVoYXZlIHNpbWlsYXJseSB0byB0aGUgZGVmYXVsdGRpY3Qgc3RydWN0dXJlIGluIHB5dGhvbi5cbiAqXG4gKiBgYGBcbiAqIGNvbnN0IHNxclJ0cyA9XG4gKiAgICAgRGVmYXVsdE1hcC51c2luZ0Z1bmN0aW9uPG51bWJlciwgbnVtYmVyPigoeCkgPT4gTWF0aC5zcXJ0KHgpKTtcbiAqIHNxclJ0cy5nZXQoOSk7IC8vIFJldHVybnMgM1xuICogYGBgXG4gKi9cbmNsYXNzIERlZmF1bHRNYXAgZXh0ZW5kcyBNYXAge1xuICAgIGNvbnN0cnVjdG9yKGl0ZXJhYmxlID0gW10sIGRlZmF1bHRGdW5jdGlvbiA9IG5vb3BfMS5ub29wKSB7XG4gICAgICAgIHN1cGVyKGl0ZXJhYmxlKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0RnVuY3Rpb24gPSBkZWZhdWx0RnVuY3Rpb247XG4gICAgfVxuICAgIHN0YXRpYyB1c2luZ0Z1bmN0aW9uKGRlZmF1bHRGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoW10sIGRlZmF1bHRGdW5jdGlvbik7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRlZmF1bHRGdW5jdGlvbihrZXkpO1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGVmYXVsdE1hcCA9IERlZmF1bHRNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0LW1hcC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/map/default-map.js\n");

/***/ }),

/***/ "./lib/mathf/catmull-rom.js":
/*!**********************************!*\
  !*** ./lib/mathf/catmull-rom.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CatmullRom = void 0;\nconst mathf_1 = __webpack_require__(/*! ./mathf */ \"./lib/mathf/mathf.js\");\nconst vector_1 = __webpack_require__(/*! ./vector */ \"./lib/mathf/vector.js\");\nconst hermite_curve_1 = __webpack_require__(/*! ./hermite-curve */ \"./lib/mathf/hermite-curve.js\");\n/**\n * A basic catmull-rom class.  Useful for creating splines or catmull-rom\n * interpolations.  They are useful compared to other splines because they are\n * guaranteed to go through specified control points.\n *\n * This particular implementation uses hermite curves from point to point.\n * Given a set of points, we calculate the m0, m1 tangents between and\n * curve until we are out of points.\n *\n * TODO (uxder): Using interpolate, create a spline.\n * TDOO (uxder): Take on SVG spline interpolate.\n *\n * ```ts\n *    let catmullInterpolate = CatmullRom.interpolate(\n *        [\n *            new Vector(0, 0),\n *            new Vector(100, 100),\n *            new Vector(200, 200),\n *            new Vector(300, 400),\n *            ... // Can take any number of vectors.\n *        ],\n *        0.25,   // Optional m0 tension\n *        0.25    // Optional m1 tensions\n *    );\n *\n *   let progress = 0.5;\n *   let x = catmullInterplate(progress).x;  // Returns the x value at 0.5 progress.\n *   let y = catmullInterpolate(progress).y; // Returns the y value at 0.5 progress.\n * ```\n *\n * Or static method\n * ```ts\n *\n * let mypoints = [\n *           new Vector(0, 0),\n *           new Vector(100, 100),\n *           new Vector(200, 200),\n * ]\n * this.x = CatmullRom.getPoint(\n *    myPoints,\n *    0.5, // Progress\n * ).x;\n * this.y = CatmullRom.getPoint(\n *    myPoints,\n *    0.5, // Progress\n * ).y;\n *\n * ```\n *\n *\n * @see http://marina.sys.wakayama-u.ac.jp/~tokoi/?date=20150105\n * @see https://www.youtube.com/watch?v=w_uU_rPayoQ\n * @see https://en.wikibooks.org/wiki/Cg_Programming/Unity/Hermite_Curves\n * @see https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline\n * @see http://hadashia.hatenablog.com/entry/2017/12/30/150556\n */\nclass CatmullRom {\n    /**\n     * Create a function that can be called to apply camtull roll interpolations.\n     * @param points  A point of vectors.\n     * @param m0Tension\n     * @param m1Tension\n     */\n    static interpolate(points, m0Tension = 0.5, m1Tension = 0.5) {\n        return (progress) => {\n            return CatmullRom.getPoint(points, progress, m0Tension, m1Tension);\n        };\n    }\n    /**\n     * For the given set of vectors, finds the p0 and p1 (start and end)\n     * vectors that apply to the current progress range and then calculates\n     * the in-between m0 and m1 tangents and applies the hermite-curve\n     * and returns a vector of the current catmull-rom interpolation.\n     * @param points\n     * @param progress\n     */\n    static getPoint(points, progress, m0Tension = 0.5, m1Tension = 0.5) {\n        const pointCount = points.length - 1;\n        const percentPerVector = 100 / pointCount;\n        const i = mathf_1.mathf.clamp(Math.floor(mathf_1.mathf.lerp(0, pointCount, progress)), pointCount - 1, 0);\n        const p_1 = points[i - 1] && points[i - 1].clone();\n        const p0 = points[i] && points[i].clone();\n        const p1 = points[i + 1] && points[i + 1].clone();\n        const p2 = points[i + 2] && points[i + 2].clone();\n        // Calculate M0 tangent\n        //   M0 = p1 - p_1 / 2\n        let m0;\n        if (i > 0) {\n            m0 = vector_1.Vector.subtract(p1, p_1).scale(m0Tension);\n        }\n        else {\n            m0 = vector_1.Vector.subtract(p1, p0);\n        }\n        // Calculate M1 tangent\n        // M1 = p2 - p0 / 2\n        let m1;\n        if (i < pointCount - 2) {\n            m1 = vector_1.Vector.subtract(p2, p0).scale(m1Tension);\n        }\n        else {\n            m1 = vector_1.Vector.subtract(p1, p0);\n        }\n        // Calculate the child progress for this curve.\n        const startProgress = (percentPerVector * i) / 100;\n        const endProgress = (percentPerVector * (i + 1)) / 100;\n        const childProgress = mathf_1.mathf.childProgress(progress, startProgress, endProgress);\n        return hermite_curve_1.HermiteCurve.getPoint(childProgress, p0, m0, p1, m1);\n    }\n}\nexports.CatmullRom = CatmullRom;\n//# sourceMappingURL=catmull-rom.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbWF0aGYvY2F0bXVsbC1yb20uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvbWF0aGYvY2F0bXVsbC1yb20uanM/MjcyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2F0bXVsbFJvbSA9IHZvaWQgMDtcbmNvbnN0IG1hdGhmXzEgPSByZXF1aXJlKFwiLi9tYXRoZlwiKTtcbmNvbnN0IHZlY3Rvcl8xID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xuY29uc3QgaGVybWl0ZV9jdXJ2ZV8xID0gcmVxdWlyZShcIi4vaGVybWl0ZS1jdXJ2ZVwiKTtcbi8qKlxuICogQSBiYXNpYyBjYXRtdWxsLXJvbSBjbGFzcy4gIFVzZWZ1bCBmb3IgY3JlYXRpbmcgc3BsaW5lcyBvciBjYXRtdWxsLXJvbVxuICogaW50ZXJwb2xhdGlvbnMuICBUaGV5IGFyZSB1c2VmdWwgY29tcGFyZWQgdG8gb3RoZXIgc3BsaW5lcyBiZWNhdXNlIHRoZXkgYXJlXG4gKiBndWFyYW50ZWVkIHRvIGdvIHRocm91Z2ggc3BlY2lmaWVkIGNvbnRyb2wgcG9pbnRzLlxuICpcbiAqIFRoaXMgcGFydGljdWxhciBpbXBsZW1lbnRhdGlvbiB1c2VzIGhlcm1pdGUgY3VydmVzIGZyb20gcG9pbnQgdG8gcG9pbnQuXG4gKiBHaXZlbiBhIHNldCBvZiBwb2ludHMsIHdlIGNhbGN1bGF0ZSB0aGUgbTAsIG0xIHRhbmdlbnRzIGJldHdlZW4gYW5kXG4gKiBjdXJ2ZSB1bnRpbCB3ZSBhcmUgb3V0IG9mIHBvaW50cy5cbiAqXG4gKiBUT0RPICh1eGRlcik6IFVzaW5nIGludGVycG9sYXRlLCBjcmVhdGUgYSBzcGxpbmUuXG4gKiBURE9PICh1eGRlcik6IFRha2Ugb24gU1ZHIHNwbGluZSBpbnRlcnBvbGF0ZS5cbiAqXG4gKiBgYGB0c1xuICogICAgbGV0IGNhdG11bGxJbnRlcnBvbGF0ZSA9IENhdG11bGxSb20uaW50ZXJwb2xhdGUoXG4gKiAgICAgICAgW1xuICogICAgICAgICAgICBuZXcgVmVjdG9yKDAsIDApLFxuICogICAgICAgICAgICBuZXcgVmVjdG9yKDEwMCwgMTAwKSxcbiAqICAgICAgICAgICAgbmV3IFZlY3RvcigyMDAsIDIwMCksXG4gKiAgICAgICAgICAgIG5ldyBWZWN0b3IoMzAwLCA0MDApLFxuICogICAgICAgICAgICAuLi4gLy8gQ2FuIHRha2UgYW55IG51bWJlciBvZiB2ZWN0b3JzLlxuICogICAgICAgIF0sXG4gKiAgICAgICAgMC4yNSwgICAvLyBPcHRpb25hbCBtMCB0ZW5zaW9uXG4gKiAgICAgICAgMC4yNSAgICAvLyBPcHRpb25hbCBtMSB0ZW5zaW9uc1xuICogICAgKTtcbiAqXG4gKiAgIGxldCBwcm9ncmVzcyA9IDAuNTtcbiAqICAgbGV0IHggPSBjYXRtdWxsSW50ZXJwbGF0ZShwcm9ncmVzcykueDsgIC8vIFJldHVybnMgdGhlIHggdmFsdWUgYXQgMC41IHByb2dyZXNzLlxuICogICBsZXQgeSA9IGNhdG11bGxJbnRlcnBvbGF0ZShwcm9ncmVzcykueTsgLy8gUmV0dXJucyB0aGUgeSB2YWx1ZSBhdCAwLjUgcHJvZ3Jlc3MuXG4gKiBgYGBcbiAqXG4gKiBPciBzdGF0aWMgbWV0aG9kXG4gKiBgYGB0c1xuICpcbiAqIGxldCBteXBvaW50cyA9IFtcbiAqICAgICAgICAgICBuZXcgVmVjdG9yKDAsIDApLFxuICogICAgICAgICAgIG5ldyBWZWN0b3IoMTAwLCAxMDApLFxuICogICAgICAgICAgIG5ldyBWZWN0b3IoMjAwLCAyMDApLFxuICogXVxuICogdGhpcy54ID0gQ2F0bXVsbFJvbS5nZXRQb2ludChcbiAqICAgIG15UG9pbnRzLFxuICogICAgMC41LCAvLyBQcm9ncmVzc1xuICogKS54O1xuICogdGhpcy55ID0gQ2F0bXVsbFJvbS5nZXRQb2ludChcbiAqICAgIG15UG9pbnRzLFxuICogICAgMC41LCAvLyBQcm9ncmVzc1xuICogKS55O1xuICpcbiAqIGBgYFxuICpcbiAqXG4gKiBAc2VlIGh0dHA6Ly9tYXJpbmEuc3lzLndha2F5YW1hLXUuYWMuanAvfnRva29pLz9kYXRlPTIwMTUwMTA1XG4gKiBAc2VlIGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9d191VV9yUGF5b1FcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQ2dfUHJvZ3JhbW1pbmcvVW5pdHkvSGVybWl0ZV9DdXJ2ZXNcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2VudHJpcGV0YWxfQ2F0bXVsbCVFMiU4MCU5M1JvbV9zcGxpbmVcbiAqIEBzZWUgaHR0cDovL2hhZGFzaGlhLmhhdGVuYWJsb2cuY29tL2VudHJ5LzIwMTcvMTIvMzAvMTUwNTU2XG4gKi9cbmNsYXNzIENhdG11bGxSb20ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB0byBhcHBseSBjYW10dWxsIHJvbGwgaW50ZXJwb2xhdGlvbnMuXG4gICAgICogQHBhcmFtIHBvaW50cyAgQSBwb2ludCBvZiB2ZWN0b3JzLlxuICAgICAqIEBwYXJhbSBtMFRlbnNpb25cbiAgICAgKiBAcGFyYW0gbTFUZW5zaW9uXG4gICAgICovXG4gICAgc3RhdGljIGludGVycG9sYXRlKHBvaW50cywgbTBUZW5zaW9uID0gMC41LCBtMVRlbnNpb24gPSAwLjUpIHtcbiAgICAgICAgcmV0dXJuIChwcm9ncmVzcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIENhdG11bGxSb20uZ2V0UG9pbnQocG9pbnRzLCBwcm9ncmVzcywgbTBUZW5zaW9uLCBtMVRlbnNpb24pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIGdpdmVuIHNldCBvZiB2ZWN0b3JzLCBmaW5kcyB0aGUgcDAgYW5kIHAxIChzdGFydCBhbmQgZW5kKVxuICAgICAqIHZlY3RvcnMgdGhhdCBhcHBseSB0byB0aGUgY3VycmVudCBwcm9ncmVzcyByYW5nZSBhbmQgdGhlbiBjYWxjdWxhdGVzXG4gICAgICogdGhlIGluLWJldHdlZW4gbTAgYW5kIG0xIHRhbmdlbnRzIGFuZCBhcHBsaWVzIHRoZSBoZXJtaXRlLWN1cnZlXG4gICAgICogYW5kIHJldHVybnMgYSB2ZWN0b3Igb2YgdGhlIGN1cnJlbnQgY2F0bXVsbC1yb20gaW50ZXJwb2xhdGlvbi5cbiAgICAgKiBAcGFyYW0gcG9pbnRzXG4gICAgICogQHBhcmFtIHByb2dyZXNzXG4gICAgICovXG4gICAgc3RhdGljIGdldFBvaW50KHBvaW50cywgcHJvZ3Jlc3MsIG0wVGVuc2lvbiA9IDAuNSwgbTFUZW5zaW9uID0gMC41KSB7XG4gICAgICAgIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgcGVyY2VudFBlclZlY3RvciA9IDEwMCAvIHBvaW50Q291bnQ7XG4gICAgICAgIGNvbnN0IGkgPSBtYXRoZl8xLm1hdGhmLmNsYW1wKE1hdGguZmxvb3IobWF0aGZfMS5tYXRoZi5sZXJwKDAsIHBvaW50Q291bnQsIHByb2dyZXNzKSksIHBvaW50Q291bnQgLSAxLCAwKTtcbiAgICAgICAgY29uc3QgcF8xID0gcG9pbnRzW2kgLSAxXSAmJiBwb2ludHNbaSAtIDFdLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IHAwID0gcG9pbnRzW2ldICYmIHBvaW50c1tpXS5jbG9uZSgpO1xuICAgICAgICBjb25zdCBwMSA9IHBvaW50c1tpICsgMV0gJiYgcG9pbnRzW2kgKyAxXS5jbG9uZSgpO1xuICAgICAgICBjb25zdCBwMiA9IHBvaW50c1tpICsgMl0gJiYgcG9pbnRzW2kgKyAyXS5jbG9uZSgpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgTTAgdGFuZ2VudFxuICAgICAgICAvLyAgIE0wID0gcDEgLSBwXzEgLyAyXG4gICAgICAgIGxldCBtMDtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBtMCA9IHZlY3Rvcl8xLlZlY3Rvci5zdWJ0cmFjdChwMSwgcF8xKS5zY2FsZShtMFRlbnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbTAgPSB2ZWN0b3JfMS5WZWN0b3Iuc3VidHJhY3QocDEsIHAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgTTEgdGFuZ2VudFxuICAgICAgICAvLyBNMSA9IHAyIC0gcDAgLyAyXG4gICAgICAgIGxldCBtMTtcbiAgICAgICAgaWYgKGkgPCBwb2ludENvdW50IC0gMikge1xuICAgICAgICAgICAgbTEgPSB2ZWN0b3JfMS5WZWN0b3Iuc3VidHJhY3QocDIsIHAwKS5zY2FsZShtMVRlbnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbTEgPSB2ZWN0b3JfMS5WZWN0b3Iuc3VidHJhY3QocDEsIHAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGNoaWxkIHByb2dyZXNzIGZvciB0aGlzIGN1cnZlLlxuICAgICAgICBjb25zdCBzdGFydFByb2dyZXNzID0gKHBlcmNlbnRQZXJWZWN0b3IgKiBpKSAvIDEwMDtcbiAgICAgICAgY29uc3QgZW5kUHJvZ3Jlc3MgPSAocGVyY2VudFBlclZlY3RvciAqIChpICsgMSkpIC8gMTAwO1xuICAgICAgICBjb25zdCBjaGlsZFByb2dyZXNzID0gbWF0aGZfMS5tYXRoZi5jaGlsZFByb2dyZXNzKHByb2dyZXNzLCBzdGFydFByb2dyZXNzLCBlbmRQcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBoZXJtaXRlX2N1cnZlXzEuSGVybWl0ZUN1cnZlLmdldFBvaW50KGNoaWxkUHJvZ3Jlc3MsIHAwLCBtMCwgcDEsIG0xKTtcbiAgICB9XG59XG5leHBvcnRzLkNhdG11bGxSb20gPSBDYXRtdWxsUm9tO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2F0bXVsbC1yb20uanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/mathf/catmull-rom.js\n");

/***/ }),

/***/ "./lib/mathf/color.js":
/*!****************************!*\
  !*** ./lib/mathf/color.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.color = void 0;\nconst mathf_1 = __webpack_require__(/*! ./mathf */ \"./lib/mathf/mathf.js\");\nconst __1 = __webpack_require__(/*! .. */ \"./lib/index.js\");\n/**\n * A class that helps with color transformations.\n *\n * @see https://www.alanzucconi.com/2016/01/06/colour-interpolation/\n */\nclass color {\n    constructor() { }\n    /**\n     * Converts a hex value such as 0xffffff to normalized Rbg values.\n     *\n     * ```ts\n     * color.hexToRgbNormalized(0xffffff) // >> [1, 1, 1];\n     * ```\n     * @param hexValue\n     */\n    static hexToRgbNormalized(hexValue) {\n        const out = [];\n        out[0] = ((hexValue >> 16) & 0xff) / 255;\n        out[1] = ((hexValue >> 8) & 0xff) / 255;\n        out[2] = (hexValue & 0xff) / 255;\n        return out;\n    }\n    /**\n     * Converts a colorRGB to an rgb array.\n     */\n    static colorRgbToRgb(colorRgb) {\n        return [colorRgb.r, colorRgb.g, colorRgb.b];\n    }\n    /**\n     * Converts normalized rgb values back out to hex.\n     * ```ts\n     * color.normalizedRgbToHex([1,1,1]) // >> 0xFFFFFF\n     * ```\n     * @param rgb\n     */\n    static normalizedRgbToHex(rgb) {\n        return (((rgb[0] * 255) << 16) + ((rgb[1] * 255) << 8) + ((rgb[2] * 255) | 0));\n    }\n    /**\n     * Converts rgb to normalized rgb.\n     * ```ts\n     * color.rgbToNormalizedRgb([255,255,255]) // >> [1,1,1]\n     * color.rgbToNormalizedRgb([0,0,0]) // >> [0,0,0]\n     * ```\n     *\n     * @param rgb\n     */\n    static rgbToNormalizedRgb(rgb) {\n        return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255];\n    }\n    /**\n     * Converts normalized rgb to rgb.\n     * ```ts\n     * color.normalizedRgbToRgb([1,1,1]) // >> [255,255,255]\n     * color.normalizedRgbToRgb([0,0,0]) // >> [0,0,0]\n     * ```\n     *\n     * @param rgb\n     */\n    static normalizedRgbToRgb(rgb) {\n        return [(rgb[0] * 255) >> 0, (rgb[1] * 255) >> 0, (rgb[2] * 255) >> 0];\n    }\n    /**\n     * A stardard lerp between two rgba values.  This simple algo is a\n     * straight line interpolation and isn't always going to\n     * guarantee the right hue between values.  In short,\n     * it's not gonna be very colorful between values.\n     *\n     * ```ts\n     *\n     * let a = { r: 0, g: 0, b: 0, a: 0};\n     * let b = { r: 255, g: 255, b: 255, a: 1};\n     * let lerp = color.rgbaLerp(a, b, 0.5);\n     * ```\n     *\n     * @param start The starting rgba color.\n     * @param end The ending rgba color.\n     * @param t The current progress.j\n     */\n    static rgbaLerp(start, end, t) {\n        return {\n            r: mathf_1.mathf.lerp(start.r, end.r, t) >> 0,\n            g: mathf_1.mathf.lerp(start.g, end.g, t) >> 0,\n            b: mathf_1.mathf.lerp(start.b, end.b, t) >> 0,\n            a: mathf_1.mathf.lerp(start.a, end.a, t),\n        };\n    }\n    /**\n     * Similar to to [[color.rgbaLerp]] but uses ease.\n     * @param start\n     * @param end\n     * @param t\n     */\n    static rgbaEase(start, end, t, ease) {\n        return {\n            r: mathf_1.mathf.ease(start.r, end.r, t, ease) >> 0,\n            g: mathf_1.mathf.ease(start.g, end.g, t, ease) >> 0,\n            b: mathf_1.mathf.ease(start.b, end.b, t, ease) >> 0,\n            a: mathf_1.mathf.ease(start.a, end.a, t, ease),\n        };\n    }\n    /**\n     * Converts an rgb out to a standard hex value.\n     *\n     * Modified version of:\n     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\n     *\n     * ```ts\n     *\n     * color.rgbToHex({r: 255, g: 255, b: 255}); // #FFFFFF\n     * color.rgbToHex({r: 0, g: 0, b: 0}); // #000000\n     *\n     * // You can pass RGBA but it will simply get ignored.\n     * color.rgbToHex({r: 255, g: 255, b: 255, a: 1}); // #FFFFFF\n     * ```\n     * @param rgb\n     */\n    static rgbToHex(rgb) {\n        const r = rgb.r;\n        const g = rgb.g;\n        const b = rgb.b;\n        return ('#' +\n            ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase());\n    }\n    /**\n     * Converts a hex value to rgb.\n     * Modified version of:\n     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\n     */\n    static hexToRgba(hex, a = 1) {\n        const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n        hex = hex.replace(shorthandRegex, (m, r, g, b) => {\n            return r + r + g + g + b + b;\n        });\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        let rgba = null;\n        if (result) {\n            rgba = {\n                r: parseInt(result[1], 16),\n                g: parseInt(result[2], 16),\n                b: parseInt(result[3], 16),\n                a: a,\n            };\n        }\n        return rgba;\n    }\n    /**\n     * Converts a css like rgba string to an RGBA object.\n     *\n     * ```ts\n     *\n     * color.cssToRgba('#FFFFFF') // { r: 255, b: 255, g: 255, a: 1}\n     * color.cssToRgba('rgba(255, 255, 255, 0.3)') // { r: 255, b: 255, g: 255, a: 0.3}\n     * color.cssToRgb('rgb(255, 255, 255)') // { r: 255, b: 255, g: 255, a: 1}\n     *\n     * color.cssToRgba(20) // null\n     * color.cssToRgba('hello') // null\n     * ```\n     */\n    static cssToRgba(css) {\n        if (__1.is.cssHex(css)) {\n            return color.hexToRgba(css);\n        }\n        if (__1.is.cssRgb(css)) {\n            // We are just going to modify the rgb string to be rgba like\n            // and process it as a rgba type string.\n            css = css.replace(')', ',1)');\n            css = css.replace('rgb', 'rgba');\n        }\n        if (__1.is.cssRgba(css)) {\n            const match = css.match(/^rgba\\(\\s*?(\\d{1,3})\\s*?,\\s*?(\\d{1,3})\\s*?,\\s*?(\\d{1,3})\\s*?,\\s*?(\\d*(?:\\.\\d+)?)\\)$/);\n            if (match) {\n                const rgba = {\n                    r: +match[1],\n                    g: +match[2],\n                    b: +match[3],\n                    a: +match[4],\n                };\n                return rgba;\n            }\n            else {\n                return null;\n            }\n        }\n        return null;\n    }\n    /**\n     * Converts ColorRGBA to a css string.\n     *\n     * ```ts\n     *\n     * color.rgbaToCss({r: 255, g: 255, b: 255, a: 1}); // rgba(255, 255, 255, 1)\n     *\n     * ```\n     *\n     * @param rgba\n     */\n    static rgbaToCss(rgba) {\n        return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;\n    }\n}\nexports.color = color;\n//# sourceMappingURL=color.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbWF0aGYvY29sb3IuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvbWF0aGYvY29sb3IuanM/MmFlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29sb3IgPSB2b2lkIDA7XG5jb25zdCBtYXRoZl8xID0gcmVxdWlyZShcIi4vbWF0aGZcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi5cIik7XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBoZWxwcyB3aXRoIGNvbG9yIHRyYW5zZm9ybWF0aW9ucy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LmFsYW56dWNjb25pLmNvbS8yMDE2LzAxLzA2L2NvbG91ci1pbnRlcnBvbGF0aW9uL1xuICovXG5jbGFzcyBjb2xvciB7XG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGhleCB2YWx1ZSBzdWNoIGFzIDB4ZmZmZmZmIHRvIG5vcm1hbGl6ZWQgUmJnIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29sb3IuaGV4VG9SZ2JOb3JtYWxpemVkKDB4ZmZmZmZmKSAvLyA+PiBbMSwgMSwgMV07XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGhleFZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIGhleFRvUmdiTm9ybWFsaXplZChoZXhWYWx1ZSkge1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgb3V0WzBdID0gKChoZXhWYWx1ZSA+PiAxNikgJiAweGZmKSAvIDI1NTtcbiAgICAgICAgb3V0WzFdID0gKChoZXhWYWx1ZSA+PiA4KSAmIDB4ZmYpIC8gMjU1O1xuICAgICAgICBvdXRbMl0gPSAoaGV4VmFsdWUgJiAweGZmKSAvIDI1NTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBjb2xvclJHQiB0byBhbiByZ2IgYXJyYXkuXG4gICAgICovXG4gICAgc3RhdGljIGNvbG9yUmdiVG9SZ2IoY29sb3JSZ2IpIHtcbiAgICAgICAgcmV0dXJuIFtjb2xvclJnYi5yLCBjb2xvclJnYi5nLCBjb2xvclJnYi5iXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgbm9ybWFsaXplZCByZ2IgdmFsdWVzIGJhY2sgb3V0IHRvIGhleC5cbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbG9yLm5vcm1hbGl6ZWRSZ2JUb0hleChbMSwxLDFdKSAvLyA+PiAweEZGRkZGRlxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSByZ2JcbiAgICAgKi9cbiAgICBzdGF0aWMgbm9ybWFsaXplZFJnYlRvSGV4KHJnYikge1xuICAgICAgICByZXR1cm4gKCgocmdiWzBdICogMjU1KSA8PCAxNikgKyAoKHJnYlsxXSAqIDI1NSkgPDwgOCkgKyAoKHJnYlsyXSAqIDI1NSkgfCAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHJnYiB0byBub3JtYWxpemVkIHJnYi5cbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbG9yLnJnYlRvTm9ybWFsaXplZFJnYihbMjU1LDI1NSwyNTVdKSAvLyA+PiBbMSwxLDFdXG4gICAgICogY29sb3IucmdiVG9Ob3JtYWxpemVkUmdiKFswLDAsMF0pIC8vID4+IFswLDAsMF1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZ2JcbiAgICAgKi9cbiAgICBzdGF0aWMgcmdiVG9Ob3JtYWxpemVkUmdiKHJnYikge1xuICAgICAgICByZXR1cm4gW3JnYlswXSAvIDI1NSwgcmdiWzFdIC8gMjU1LCByZ2JbMl0gLyAyNTVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBub3JtYWxpemVkIHJnYiB0byByZ2IuXG4gICAgICogYGBgdHNcbiAgICAgKiBjb2xvci5ub3JtYWxpemVkUmdiVG9SZ2IoWzEsMSwxXSkgLy8gPj4gWzI1NSwyNTUsMjU1XVxuICAgICAqIGNvbG9yLm5vcm1hbGl6ZWRSZ2JUb1JnYihbMCwwLDBdKSAvLyA+PiBbMCwwLDBdXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmdiXG4gICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZWRSZ2JUb1JnYihyZ2IpIHtcbiAgICAgICAgcmV0dXJuIFsocmdiWzBdICogMjU1KSA+PiAwLCAocmdiWzFdICogMjU1KSA+PiAwLCAocmdiWzJdICogMjU1KSA+PiAwXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdGFyZGFyZCBsZXJwIGJldHdlZW4gdHdvIHJnYmEgdmFsdWVzLiAgVGhpcyBzaW1wbGUgYWxnbyBpcyBhXG4gICAgICogc3RyYWlnaHQgbGluZSBpbnRlcnBvbGF0aW9uIGFuZCBpc24ndCBhbHdheXMgZ29pbmcgdG9cbiAgICAgKiBndWFyYW50ZWUgdGhlIHJpZ2h0IGh1ZSBiZXR3ZWVuIHZhbHVlcy4gIEluIHNob3J0LFxuICAgICAqIGl0J3Mgbm90IGdvbm5hIGJlIHZlcnkgY29sb3JmdWwgYmV0d2VlbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqXG4gICAgICogbGV0IGEgPSB7IHI6IDAsIGc6IDAsIGI6IDAsIGE6IDB9O1xuICAgICAqIGxldCBiID0geyByOiAyNTUsIGc6IDI1NSwgYjogMjU1LCBhOiAxfTtcbiAgICAgKiBsZXQgbGVycCA9IGNvbG9yLnJnYmFMZXJwKGEsIGIsIDAuNSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgVGhlIHN0YXJ0aW5nIHJnYmEgY29sb3IuXG4gICAgICogQHBhcmFtIGVuZCBUaGUgZW5kaW5nIHJnYmEgY29sb3IuXG4gICAgICogQHBhcmFtIHQgVGhlIGN1cnJlbnQgcHJvZ3Jlc3MualxuICAgICAqL1xuICAgIHN0YXRpYyByZ2JhTGVycChzdGFydCwgZW5kLCB0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBtYXRoZl8xLm1hdGhmLmxlcnAoc3RhcnQuciwgZW5kLnIsIHQpID4+IDAsXG4gICAgICAgICAgICBnOiBtYXRoZl8xLm1hdGhmLmxlcnAoc3RhcnQuZywgZW5kLmcsIHQpID4+IDAsXG4gICAgICAgICAgICBiOiBtYXRoZl8xLm1hdGhmLmxlcnAoc3RhcnQuYiwgZW5kLmIsIHQpID4+IDAsXG4gICAgICAgICAgICBhOiBtYXRoZl8xLm1hdGhmLmxlcnAoc3RhcnQuYSwgZW5kLmEsIHQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIHRvIFtbY29sb3IucmdiYUxlcnBdXSBidXQgdXNlcyBlYXNlLlxuICAgICAqIEBwYXJhbSBzdGFydFxuICAgICAqIEBwYXJhbSBlbmRcbiAgICAgKiBAcGFyYW0gdFxuICAgICAqL1xuICAgIHN0YXRpYyByZ2JhRWFzZShzdGFydCwgZW5kLCB0LCBlYXNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBtYXRoZl8xLm1hdGhmLmVhc2Uoc3RhcnQuciwgZW5kLnIsIHQsIGVhc2UpID4+IDAsXG4gICAgICAgICAgICBnOiBtYXRoZl8xLm1hdGhmLmVhc2Uoc3RhcnQuZywgZW5kLmcsIHQsIGVhc2UpID4+IDAsXG4gICAgICAgICAgICBiOiBtYXRoZl8xLm1hdGhmLmVhc2Uoc3RhcnQuYiwgZW5kLmIsIHQsIGVhc2UpID4+IDAsXG4gICAgICAgICAgICBhOiBtYXRoZl8xLm1hdGhmLmVhc2Uoc3RhcnQuYSwgZW5kLmEsIHQsIGVhc2UpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiByZ2Igb3V0IHRvIGEgc3RhbmRhcmQgaGV4IHZhbHVlLlxuICAgICAqXG4gICAgICogTW9kaWZpZWQgdmVyc2lvbiBvZjpcbiAgICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NjIzODM4L3JnYi10by1oZXgtYW5kLWhleC10by1yZ2JcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKiBjb2xvci5yZ2JUb0hleCh7cjogMjU1LCBnOiAyNTUsIGI6IDI1NX0pOyAvLyAjRkZGRkZGXG4gICAgICogY29sb3IucmdiVG9IZXgoe3I6IDAsIGc6IDAsIGI6IDB9KTsgLy8gIzAwMDAwMFxuICAgICAqXG4gICAgICogLy8gWW91IGNhbiBwYXNzIFJHQkEgYnV0IGl0IHdpbGwgc2ltcGx5IGdldCBpZ25vcmVkLlxuICAgICAqIGNvbG9yLnJnYlRvSGV4KHtyOiAyNTUsIGc6IDI1NSwgYjogMjU1LCBhOiAxfSk7IC8vICNGRkZGRkZcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gcmdiXG4gICAgICovXG4gICAgc3RhdGljIHJnYlRvSGV4KHJnYikge1xuICAgICAgICBjb25zdCByID0gcmdiLnI7XG4gICAgICAgIGNvbnN0IGcgPSByZ2IuZztcbiAgICAgICAgY29uc3QgYiA9IHJnYi5iO1xuICAgICAgICByZXR1cm4gKCcjJyArXG4gICAgICAgICAgICAoKDEgPDwgMjQpICsgKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiKS50b1N0cmluZygxNikuc2xpY2UoMSkudG9VcHBlckNhc2UoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgaGV4IHZhbHVlIHRvIHJnYi5cbiAgICAgKiBNb2RpZmllZCB2ZXJzaW9uIG9mOlxuICAgICAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU2MjM4MzgvcmdiLXRvLWhleC1hbmQtaGV4LXRvLXJnYlxuICAgICAqL1xuICAgIHN0YXRpYyBoZXhUb1JnYmEoaGV4LCBhID0gMSkge1xuICAgICAgICBjb25zdCBzaG9ydGhhbmRSZWdleCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2k7XG4gICAgICAgIGhleCA9IGhleC5yZXBsYWNlKHNob3J0aGFuZFJlZ2V4LCAobSwgciwgZywgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHIgKyByICsgZyArIGcgKyBiICsgYjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhoZXgpO1xuICAgICAgICBsZXQgcmdiYSA9IG51bGw7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJnYmEgPSB7XG4gICAgICAgICAgICAgICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksXG4gICAgICAgICAgICAgICAgZzogcGFyc2VJbnQocmVzdWx0WzJdLCAxNiksXG4gICAgICAgICAgICAgICAgYjogcGFyc2VJbnQocmVzdWx0WzNdLCAxNiksXG4gICAgICAgICAgICAgICAgYTogYSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJnYmE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgY3NzIGxpa2UgcmdiYSBzdHJpbmcgdG8gYW4gUkdCQSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqXG4gICAgICogY29sb3IuY3NzVG9SZ2JhKCcjRkZGRkZGJykgLy8geyByOiAyNTUsIGI6IDI1NSwgZzogMjU1LCBhOiAxfVxuICAgICAqIGNvbG9yLmNzc1RvUmdiYSgncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpJykgLy8geyByOiAyNTUsIGI6IDI1NSwgZzogMjU1LCBhOiAwLjN9XG4gICAgICogY29sb3IuY3NzVG9SZ2IoJ3JnYigyNTUsIDI1NSwgMjU1KScpIC8vIHsgcjogMjU1LCBiOiAyNTUsIGc6IDI1NSwgYTogMX1cbiAgICAgKlxuICAgICAqIGNvbG9yLmNzc1RvUmdiYSgyMCkgLy8gbnVsbFxuICAgICAqIGNvbG9yLmNzc1RvUmdiYSgnaGVsbG8nKSAvLyBudWxsXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGNzc1RvUmdiYShjc3MpIHtcbiAgICAgICAgaWYgKF9fMS5pcy5jc3NIZXgoY3NzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbG9yLmhleFRvUmdiYShjc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfXzEuaXMuY3NzUmdiKGNzcykpIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBqdXN0IGdvaW5nIHRvIG1vZGlmeSB0aGUgcmdiIHN0cmluZyB0byBiZSByZ2JhIGxpa2VcbiAgICAgICAgICAgIC8vIGFuZCBwcm9jZXNzIGl0IGFzIGEgcmdiYSB0eXBlIHN0cmluZy5cbiAgICAgICAgICAgIGNzcyA9IGNzcy5yZXBsYWNlKCcpJywgJywxKScpO1xuICAgICAgICAgICAgY3NzID0gY3NzLnJlcGxhY2UoJ3JnYicsICdyZ2JhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9fMS5pcy5jc3NSZ2JhKGNzcykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gY3NzLm1hdGNoKC9ecmdiYVxcKFxccyo/KFxcZHsxLDN9KVxccyo/LFxccyo/KFxcZHsxLDN9KVxccyo/LFxccyo/KFxcZHsxLDN9KVxccyo/LFxccyo/KFxcZCooPzpcXC5cXGQrKT8pXFwpJC8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmdiYSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcjogK21hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICBnOiArbWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgICAgIGI6ICttYXRjaFszXSxcbiAgICAgICAgICAgICAgICAgICAgYTogK21hdGNoWzRdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJnYmE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgQ29sb3JSR0JBIHRvIGEgY3NzIHN0cmluZy5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKiBjb2xvci5yZ2JhVG9Dc3Moe3I6IDI1NSwgZzogMjU1LCBiOiAyNTUsIGE6IDF9KTsgLy8gcmdiYSgyNTUsIDI1NSwgMjU1LCAxKVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmdiYVxuICAgICAqL1xuICAgIHN0YXRpYyByZ2JhVG9Dc3MocmdiYSkge1xuICAgICAgICByZXR1cm4gYHJnYmEoJHtyZ2JhLnJ9LCAke3JnYmEuZ30sICR7cmdiYS5ifSwgJHtyZ2JhLmF9KWA7XG4gICAgfVxufVxuZXhwb3J0cy5jb2xvciA9IGNvbG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sb3IuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/mathf/color.js\n");

/***/ }),

/***/ "./lib/mathf/cubic-bezier.js":
/*!***********************************!*\
  !*** ./lib/mathf/cubic-bezier.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CubicBezier = void 0;\n/**\n * Implements a basic cubic beizer class.\n *\n *\n * The interpolate and interpolateProgress methods are designed to work with\n * normalized values. The most common usecase for this might to apply a CubiicBezier as an\n * easing function.  To do this, you can use the makeEasingFunction which\n * creates the CubicBezier internals and allows you to pass a t (time/progress),\n * to get results.\n *\n * ```ts\n *   var func = CubicBezier.makeEasingFunction(0.2,0.17,0.83,0.67));\n *   func(0.2); // Pass progress.\n * ```\n *\n * Use as instance:\n *\n * ```ts\n * let myBezier = new CubicBezier(0.2, 0.17, 0.83, 0.67);\n * myBezier.interpolate(0);\n * myBezier.interpolate(0.2);\n * myBezier.interpolate(0.5);\n * myBezier.interpolate(0.8);\n * myBezier.interpolate(1);\n *\n * let x = mathf.ease(0, 500, this.progress,\n *            myBeizer.easingFunction());\n *\n * ```\n *\n *\n * Use static method.\n *\n * ```ts\n * CubicBezier.interpolateProgress(0, 0.2, 0.17, 0.83, 0.67);\n * CubicBezier.interpolateProgress(0.2, 0.2, 0.17, 0.83, 0.67);\n * CubicBezier.interpolateProgress(0.5, 0.2, 0.17, 0.83, 0.67);\n * CubicBezier.interpolateProgress(0.8, 0.2, 0.17, 0.83, 0.67);\n * CubicBezier.interpolateProgress(1, 0.2, 0.17, 0.83, 0.67);\n *\n *\n * let x = mathf.ease(0, 500, this.progress,\n *            CubicBezier.makeEasingFunction(0.2,0.17,0.83,0.67));\n *\n * ```\n *\n *\n * You can also use getPoint and getBezierPoint as way to calculate standard\n * bezier curves (non normalized).\n *\n *\n * ```ts\n *\n *   // Create control vectors.\n *   let c1 = new Vector(50, 400);\n *   let c2 = new Vector(100, 200);\n *   let c3 = new Vector(300, 300);\n *   let c4 = new Vector(400, 400);\n *\n *   // Find the vector on the cubic bezier at 0.3 progress / t.\n *   const vector = CubicBezier.getPoint(\n *     0.3, c1, c2, c3, c4\n *    );\n *\n * ```\n *\n *\n * References:\n * @see https://qiita.com/butchi_y/items/abb6d52fda6095b542e5\n * @see http://geom.web.fc2.com/\n * @see http://geom.web.fc2.com/geometry/bezier/cubic.html\n * @see https://stackoverflow.com/questions/27053888/how-to-get-time-value-from-bezier-curve-given-length\n */\nclass CubicBezier {\n    constructor(x2, y2, x3, y3) {\n        this.x2 = x2;\n        this.y2 = y2;\n        this.x3 = x2;\n        this.y3 = y3;\n    }\n    /**\n     * Given 4 points, start, 2, 3 and end, generates the x,y point along the\n     * bezier curve at progress (0-1) value.\n     * @param progress\n     * @param x1 Start point x\n     * @param y1 Start point y\n     * @param x2 Control point 2 x\n     * @param y2 Control point 2 y\n     * @param x3 Control point 3 x\n     * @param y3 Control point 3 y\n     * @param x4 End point x\n     * @param y4 End point y\n     */\n    static getBezierPoint(progress, x1, y1, x2, y2, x3, y3, x4, y4) {\n        const tp = 1 - progress;\n        const x = progress * progress * progress * x4 +\n            3 * progress * progress * tp * x3 +\n            3 * progress * tp * tp * x2 +\n            tp * tp * tp * x1;\n        const y = progress * progress * progress * y4 +\n            3 * progress * progress * tp * y3 +\n            3 * progress * tp * tp * y2 +\n            tp * tp * tp * y1;\n        return {\n            x: x,\n            y: y,\n        };\n    }\n    /**\n     * Gets a point along the cubic bezier.\n     * @param progress\n     * @param v1 The start vector\n     * @param v2 The control2 vector\n     * @param v3 The control3 vector\n     * @param v4  The end vector\n     */\n    static getPoint(progress, v1, v2, v3, v4) {\n        return CubicBezier.getBezierPoint(progress, v1.x, v1.y, v2.x, v2.y, v3.x, v3.y, v4.x, v4.y);\n    }\n    /**\n     * Runs a basic cubic bezier interporalation given progress and point values\n     * for the 2nd and 3rd controls of the cubic bezier.\n     *\n     * ```ts\n     * let x = CubicBezier.interpolateProgress(0.2, 0.17, 0.67, 0.83, 0.67);\n     *\n     * ```\n     * @param progress The progress of the interpolation.  Value between 0-1.\n     * @param x2 The x of the second control point.\n     * @param y2 The y of the second control point.\n     * @param x2 The x of the third control point.\n     * @param y3 The y of the fourth control point.\n     * @return The interpolated value.\n     */\n    static interpolateProgress(progress, x2, y2, x3, y3) {\n        // Get the point (x, y) for this current time.\n        const point = CubicBezier.getBezierPoint(progress, 0, 0, // Start\n        x2, y2, // Point2\n        x3, y3, // Point 3\n        1, 1 // End\n        );\n        // Simply return y since x is time and y is progression.\n        return point.y;\n    }\n    /**\n     * Runs a basic cubic bezier interporalation.\n     *\n     * ```ts\n     * let myBezier = new CubicBezier(0.2, 0.17, 0.83, 0.67);\n     * myBezier.interporate(0);\n     * myBezier.interporate(0.2);\n     *\n     * ```\n     * @param progress The progress of the interpolation.  Value between 0-1.\n     * @return The interpolated value.\n     */\n    interpolate(progress) {\n        return CubicBezier.interpolateProgress(progress, this.x2, this.y2, this.x3, this.y3);\n    }\n    /**\n     * Returns an easing function of this CubicBezier so it can be\n     * used like other easing functions but used for instances.\n     * @return A function that accepts a progresss value.\n     */\n    easingFunction() {\n        return (progress) => {\n            return this.interpolate(progress);\n        };\n    }\n    /**\n     * Returns an easing function of this CubicBezier so it can be\n     * used like other easing functions.  A static method.\n     * @param p0 The first control point.\n     * @param p1 The second control point.\n     * @param p2 The third control point.\n     * @param p3 The fourth control point.\n     * @return A function that accepts a progresss value.\n     */\n    static makeEasingFunction(p0, p1, p2, p3) {\n        return (progress) => {\n            return this.interpolateProgress(progress, p0, p1, p2, p3);\n        };\n    }\n}\nexports.CubicBezier = CubicBezier;\n//# sourceMappingURL=cubic-bezier.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbWF0aGYvY3ViaWMtYmV6aWVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL21hdGhmL2N1YmljLWJlemllci5qcz8wYjg1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DdWJpY0JlemllciA9IHZvaWQgMDtcbi8qKlxuICogSW1wbGVtZW50cyBhIGJhc2ljIGN1YmljIGJlaXplciBjbGFzcy5cbiAqXG4gKlxuICogVGhlIGludGVycG9sYXRlIGFuZCBpbnRlcnBvbGF0ZVByb2dyZXNzIG1ldGhvZHMgYXJlIGRlc2lnbmVkIHRvIHdvcmsgd2l0aFxuICogbm9ybWFsaXplZCB2YWx1ZXMuIFRoZSBtb3N0IGNvbW1vbiB1c2VjYXNlIGZvciB0aGlzIG1pZ2h0IHRvIGFwcGx5IGEgQ3ViaWljQmV6aWVyIGFzIGFuXG4gKiBlYXNpbmcgZnVuY3Rpb24uICBUbyBkbyB0aGlzLCB5b3UgY2FuIHVzZSB0aGUgbWFrZUVhc2luZ0Z1bmN0aW9uIHdoaWNoXG4gKiBjcmVhdGVzIHRoZSBDdWJpY0JlemllciBpbnRlcm5hbHMgYW5kIGFsbG93cyB5b3UgdG8gcGFzcyBhIHQgKHRpbWUvcHJvZ3Jlc3MpLFxuICogdG8gZ2V0IHJlc3VsdHMuXG4gKlxuICogYGBgdHNcbiAqICAgdmFyIGZ1bmMgPSBDdWJpY0Jlemllci5tYWtlRWFzaW5nRnVuY3Rpb24oMC4yLDAuMTcsMC44MywwLjY3KSk7XG4gKiAgIGZ1bmMoMC4yKTsgLy8gUGFzcyBwcm9ncmVzcy5cbiAqIGBgYFxuICpcbiAqIFVzZSBhcyBpbnN0YW5jZTpcbiAqXG4gKiBgYGB0c1xuICogbGV0IG15QmV6aWVyID0gbmV3IEN1YmljQmV6aWVyKDAuMiwgMC4xNywgMC44MywgMC42Nyk7XG4gKiBteUJlemllci5pbnRlcnBvbGF0ZSgwKTtcbiAqIG15QmV6aWVyLmludGVycG9sYXRlKDAuMik7XG4gKiBteUJlemllci5pbnRlcnBvbGF0ZSgwLjUpO1xuICogbXlCZXppZXIuaW50ZXJwb2xhdGUoMC44KTtcbiAqIG15QmV6aWVyLmludGVycG9sYXRlKDEpO1xuICpcbiAqIGxldCB4ID0gbWF0aGYuZWFzZSgwLCA1MDAsIHRoaXMucHJvZ3Jlc3MsXG4gKiAgICAgICAgICAgIG15QmVpemVyLmVhc2luZ0Z1bmN0aW9uKCkpO1xuICpcbiAqIGBgYFxuICpcbiAqXG4gKiBVc2Ugc3RhdGljIG1ldGhvZC5cbiAqXG4gKiBgYGB0c1xuICogQ3ViaWNCZXppZXIuaW50ZXJwb2xhdGVQcm9ncmVzcygwLCAwLjIsIDAuMTcsIDAuODMsIDAuNjcpO1xuICogQ3ViaWNCZXppZXIuaW50ZXJwb2xhdGVQcm9ncmVzcygwLjIsIDAuMiwgMC4xNywgMC44MywgMC42Nyk7XG4gKiBDdWJpY0Jlemllci5pbnRlcnBvbGF0ZVByb2dyZXNzKDAuNSwgMC4yLCAwLjE3LCAwLjgzLCAwLjY3KTtcbiAqIEN1YmljQmV6aWVyLmludGVycG9sYXRlUHJvZ3Jlc3MoMC44LCAwLjIsIDAuMTcsIDAuODMsIDAuNjcpO1xuICogQ3ViaWNCZXppZXIuaW50ZXJwb2xhdGVQcm9ncmVzcygxLCAwLjIsIDAuMTcsIDAuODMsIDAuNjcpO1xuICpcbiAqXG4gKiBsZXQgeCA9IG1hdGhmLmVhc2UoMCwgNTAwLCB0aGlzLnByb2dyZXNzLFxuICogICAgICAgICAgICBDdWJpY0Jlemllci5tYWtlRWFzaW5nRnVuY3Rpb24oMC4yLDAuMTcsMC44MywwLjY3KSk7XG4gKlxuICogYGBgXG4gKlxuICpcbiAqIFlvdSBjYW4gYWxzbyB1c2UgZ2V0UG9pbnQgYW5kIGdldEJlemllclBvaW50IGFzIHdheSB0byBjYWxjdWxhdGUgc3RhbmRhcmRcbiAqIGJlemllciBjdXJ2ZXMgKG5vbiBub3JtYWxpemVkKS5cbiAqXG4gKlxuICogYGBgdHNcbiAqXG4gKiAgIC8vIENyZWF0ZSBjb250cm9sIHZlY3RvcnMuXG4gKiAgIGxldCBjMSA9IG5ldyBWZWN0b3IoNTAsIDQwMCk7XG4gKiAgIGxldCBjMiA9IG5ldyBWZWN0b3IoMTAwLCAyMDApO1xuICogICBsZXQgYzMgPSBuZXcgVmVjdG9yKDMwMCwgMzAwKTtcbiAqICAgbGV0IGM0ID0gbmV3IFZlY3Rvcig0MDAsIDQwMCk7XG4gKlxuICogICAvLyBGaW5kIHRoZSB2ZWN0b3Igb24gdGhlIGN1YmljIGJlemllciBhdCAwLjMgcHJvZ3Jlc3MgLyB0LlxuICogICBjb25zdCB2ZWN0b3IgPSBDdWJpY0Jlemllci5nZXRQb2ludChcbiAqICAgICAwLjMsIGMxLCBjMiwgYzMsIGM0XG4gKiAgICApO1xuICpcbiAqIGBgYFxuICpcbiAqXG4gKiBSZWZlcmVuY2VzOlxuICogQHNlZSBodHRwczovL3FpaXRhLmNvbS9idXRjaGlfeS9pdGVtcy9hYmI2ZDUyZmRhNjA5NWI1NDJlNVxuICogQHNlZSBodHRwOi8vZ2VvbS53ZWIuZmMyLmNvbS9cbiAqIEBzZWUgaHR0cDovL2dlb20ud2ViLmZjMi5jb20vZ2VvbWV0cnkvYmV6aWVyL2N1YmljLmh0bWxcbiAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjcwNTM4ODgvaG93LXRvLWdldC10aW1lLXZhbHVlLWZyb20tYmV6aWVyLWN1cnZlLWdpdmVuLWxlbmd0aFxuICovXG5jbGFzcyBDdWJpY0JlemllciB7XG4gICAgY29uc3RydWN0b3IoeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgICAgdGhpcy54MiA9IHgyO1xuICAgICAgICB0aGlzLnkyID0geTI7XG4gICAgICAgIHRoaXMueDMgPSB4MjtcbiAgICAgICAgdGhpcy55MyA9IHkzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiA0IHBvaW50cywgc3RhcnQsIDIsIDMgYW5kIGVuZCwgZ2VuZXJhdGVzIHRoZSB4LHkgcG9pbnQgYWxvbmcgdGhlXG4gICAgICogYmV6aWVyIGN1cnZlIGF0IHByb2dyZXNzICgwLTEpIHZhbHVlLlxuICAgICAqIEBwYXJhbSBwcm9ncmVzc1xuICAgICAqIEBwYXJhbSB4MSBTdGFydCBwb2ludCB4XG4gICAgICogQHBhcmFtIHkxIFN0YXJ0IHBvaW50IHlcbiAgICAgKiBAcGFyYW0geDIgQ29udHJvbCBwb2ludCAyIHhcbiAgICAgKiBAcGFyYW0geTIgQ29udHJvbCBwb2ludCAyIHlcbiAgICAgKiBAcGFyYW0geDMgQ29udHJvbCBwb2ludCAzIHhcbiAgICAgKiBAcGFyYW0geTMgQ29udHJvbCBwb2ludCAzIHlcbiAgICAgKiBAcGFyYW0geDQgRW5kIHBvaW50IHhcbiAgICAgKiBAcGFyYW0geTQgRW5kIHBvaW50IHlcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QmV6aWVyUG9pbnQocHJvZ3Jlc3MsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCkge1xuICAgICAgICBjb25zdCB0cCA9IDEgLSBwcm9ncmVzcztcbiAgICAgICAgY29uc3QgeCA9IHByb2dyZXNzICogcHJvZ3Jlc3MgKiBwcm9ncmVzcyAqIHg0ICtcbiAgICAgICAgICAgIDMgKiBwcm9ncmVzcyAqIHByb2dyZXNzICogdHAgKiB4MyArXG4gICAgICAgICAgICAzICogcHJvZ3Jlc3MgKiB0cCAqIHRwICogeDIgK1xuICAgICAgICAgICAgdHAgKiB0cCAqIHRwICogeDE7XG4gICAgICAgIGNvbnN0IHkgPSBwcm9ncmVzcyAqIHByb2dyZXNzICogcHJvZ3Jlc3MgKiB5NCArXG4gICAgICAgICAgICAzICogcHJvZ3Jlc3MgKiBwcm9ncmVzcyAqIHRwICogeTMgK1xuICAgICAgICAgICAgMyAqIHByb2dyZXNzICogdHAgKiB0cCAqIHkyICtcbiAgICAgICAgICAgIHRwICogdHAgKiB0cCAqIHkxO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBwb2ludCBhbG9uZyB0aGUgY3ViaWMgYmV6aWVyLlxuICAgICAqIEBwYXJhbSBwcm9ncmVzc1xuICAgICAqIEBwYXJhbSB2MSBUaGUgc3RhcnQgdmVjdG9yXG4gICAgICogQHBhcmFtIHYyIFRoZSBjb250cm9sMiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gdjMgVGhlIGNvbnRyb2wzIHZlY3RvclxuICAgICAqIEBwYXJhbSB2NCAgVGhlIGVuZCB2ZWN0b3JcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UG9pbnQocHJvZ3Jlc3MsIHYxLCB2MiwgdjMsIHY0KSB7XG4gICAgICAgIHJldHVybiBDdWJpY0Jlemllci5nZXRCZXppZXJQb2ludChwcm9ncmVzcywgdjEueCwgdjEueSwgdjIueCwgdjIueSwgdjMueCwgdjMueSwgdjQueCwgdjQueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBiYXNpYyBjdWJpYyBiZXppZXIgaW50ZXJwb3JhbGF0aW9uIGdpdmVuIHByb2dyZXNzIGFuZCBwb2ludCB2YWx1ZXNcbiAgICAgKiBmb3IgdGhlIDJuZCBhbmQgM3JkIGNvbnRyb2xzIG9mIHRoZSBjdWJpYyBiZXppZXIuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGxldCB4ID0gQ3ViaWNCZXppZXIuaW50ZXJwb2xhdGVQcm9ncmVzcygwLjIsIDAuMTcsIDAuNjcsIDAuODMsIDAuNjcpO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHByb2dyZXNzIFRoZSBwcm9ncmVzcyBvZiB0aGUgaW50ZXJwb2xhdGlvbi4gIFZhbHVlIGJldHdlZW4gMC0xLlxuICAgICAqIEBwYXJhbSB4MiBUaGUgeCBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAgICogQHBhcmFtIHkyIFRoZSB5IG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICAgKiBAcGFyYW0geDIgVGhlIHggb2YgdGhlIHRoaXJkIGNvbnRyb2wgcG9pbnQuXG4gICAgICogQHBhcmFtIHkzIFRoZSB5IG9mIHRoZSBmb3VydGggY29udHJvbCBwb2ludC5cbiAgICAgKiBAcmV0dXJuIFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgc3RhdGljIGludGVycG9sYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgIC8vIEdldCB0aGUgcG9pbnQgKHgsIHkpIGZvciB0aGlzIGN1cnJlbnQgdGltZS5cbiAgICAgICAgY29uc3QgcG9pbnQgPSBDdWJpY0Jlemllci5nZXRCZXppZXJQb2ludChwcm9ncmVzcywgMCwgMCwgLy8gU3RhcnRcbiAgICAgICAgeDIsIHkyLCAvLyBQb2ludDJcbiAgICAgICAgeDMsIHkzLCAvLyBQb2ludCAzXG4gICAgICAgIDEsIDEgLy8gRW5kXG4gICAgICAgICk7XG4gICAgICAgIC8vIFNpbXBseSByZXR1cm4geSBzaW5jZSB4IGlzIHRpbWUgYW5kIHkgaXMgcHJvZ3Jlc3Npb24uXG4gICAgICAgIHJldHVybiBwb2ludC55O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgYmFzaWMgY3ViaWMgYmV6aWVyIGludGVycG9yYWxhdGlvbi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbGV0IG15QmV6aWVyID0gbmV3IEN1YmljQmV6aWVyKDAuMiwgMC4xNywgMC44MywgMC42Nyk7XG4gICAgICogbXlCZXppZXIuaW50ZXJwb3JhdGUoMCk7XG4gICAgICogbXlCZXppZXIuaW50ZXJwb3JhdGUoMC4yKTtcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBwcm9ncmVzcyBUaGUgcHJvZ3Jlc3Mgb2YgdGhlIGludGVycG9sYXRpb24uICBWYWx1ZSBiZXR3ZWVuIDAtMS5cbiAgICAgKiBAcmV0dXJuIFRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgaW50ZXJwb2xhdGUocHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuIEN1YmljQmV6aWVyLmludGVycG9sYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MsIHRoaXMueDIsIHRoaXMueTIsIHRoaXMueDMsIHRoaXMueTMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVhc2luZyBmdW5jdGlvbiBvZiB0aGlzIEN1YmljQmV6aWVyIHNvIGl0IGNhbiBiZVxuICAgICAqIHVzZWQgbGlrZSBvdGhlciBlYXNpbmcgZnVuY3Rpb25zIGJ1dCB1c2VkIGZvciBpbnN0YW5jZXMuXG4gICAgICogQHJldHVybiBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHByb2dyZXNzcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBlYXNpbmdGdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIChwcm9ncmVzcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJwb2xhdGUocHJvZ3Jlc3MpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVhc2luZyBmdW5jdGlvbiBvZiB0aGlzIEN1YmljQmV6aWVyIHNvIGl0IGNhbiBiZVxuICAgICAqIHVzZWQgbGlrZSBvdGhlciBlYXNpbmcgZnVuY3Rpb25zLiAgQSBzdGF0aWMgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwMCBUaGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAgICAgKiBAcGFyYW0gcDEgVGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgICAqIEBwYXJhbSBwMiBUaGUgdGhpcmQgY29udHJvbCBwb2ludC5cbiAgICAgKiBAcGFyYW0gcDMgVGhlIGZvdXJ0aCBjb250cm9sIHBvaW50LlxuICAgICAqIEByZXR1cm4gQSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYSBwcm9ncmVzc3MgdmFsdWUuXG4gICAgICovXG4gICAgc3RhdGljIG1ha2VFYXNpbmdGdW5jdGlvbihwMCwgcDEsIHAyLCBwMykge1xuICAgICAgICByZXR1cm4gKHByb2dyZXNzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZVByb2dyZXNzKHByb2dyZXNzLCBwMCwgcDEsIHAyLCBwMyk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DdWJpY0JlemllciA9IEN1YmljQmV6aWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3ViaWMtYmV6aWVyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/mathf/cubic-bezier.js\n");

/***/ }),

/***/ "./lib/mathf/hermite-curve.js":
/*!************************************!*\
  !*** ./lib/mathf/hermite-curve.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HermiteCurve = void 0;\n/**\n * Calculates the points on a hermite curve given contrl points and a time.\n *\n *\n * ```ts\n *\n * let hermitCurve = HermiteCurve.getPoint(\n *          0.3,\n *          new Vector(0, 100),\n *          new Vector(50, 100),\n *          new Vector(100, 200),\n *          new Vector(300, 300),\n * )\n *\n * let myXPoint = hermiteCurve.x;\n * let myYPoint = hermiteCurve.y;\n * ```\n *\n * @see http://marina.sys.wakayama-u.ac.jp/~tokoi/?date=20150105\n * @see https://en.wikibooks.org/wiki/Cg_Programming/Unity/Hermite_Curves#/media/File:Hermite_spline_2-segments.svg\n * @see https://en.wikipedia.org/wiki/Cubic_Hermite_spline\n * @see https://en.wikibooks.org/wiki/Cg_Programming/Unity/Hermite_Curves\n */\nclass HermiteCurve {\n    constructor() { }\n    /**\n     * Given start point p0 and it's tangent m0 and the endpoint p1 and it's\n     * tangent m1, calculates a cubic hermit curve.\n     *\n     * Keep in mind that t here is a progress of value 0-1 but it is for this\n     * curve.  So at 0, we would be at the start point and 1 would be at the end\n     * point.\n     *\n     *\n     * @param t The current progress.\n     * @param p0 The start voint p0\n     * @param m0 The tangent of p0\n     * @param p1 The end point\n     * @param m1 The tangent of p1\n     */\n    static getPoint(t, p0, m0, p1, m1) {\n        return (p0\n            .clone()\n            .scale(1 - 3 * t * t + 2 * t * t * t)\n            // h1\n            .add(m0.clone().scale(t - 2 * t * t + t * t * t))\n            // h2\n            .add(m1.clone().scale(-t * t + t * t * t))\n            // h3\n            .add(p1.clone().scale(3 * t * t - 2 * t * t * t)));\n    }\n}\nexports.HermiteCurve = HermiteCurve;\n//# sourceMappingURL=hermite-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbWF0aGYvaGVybWl0ZS1jdXJ2ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9tYXRoZi9oZXJtaXRlLWN1cnZlLmpzPzExMTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhlcm1pdGVDdXJ2ZSA9IHZvaWQgMDtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgcG9pbnRzIG9uIGEgaGVybWl0ZSBjdXJ2ZSBnaXZlbiBjb250cmwgcG9pbnRzIGFuZCBhIHRpbWUuXG4gKlxuICpcbiAqIGBgYHRzXG4gKlxuICogbGV0IGhlcm1pdEN1cnZlID0gSGVybWl0ZUN1cnZlLmdldFBvaW50KFxuICogICAgICAgICAgMC4zLFxuICogICAgICAgICAgbmV3IFZlY3RvcigwLCAxMDApLFxuICogICAgICAgICAgbmV3IFZlY3Rvcig1MCwgMTAwKSxcbiAqICAgICAgICAgIG5ldyBWZWN0b3IoMTAwLCAyMDApLFxuICogICAgICAgICAgbmV3IFZlY3RvcigzMDAsIDMwMCksXG4gKiApXG4gKlxuICogbGV0IG15WFBvaW50ID0gaGVybWl0ZUN1cnZlLng7XG4gKiBsZXQgbXlZUG9pbnQgPSBoZXJtaXRlQ3VydmUueTtcbiAqIGBgYFxuICpcbiAqIEBzZWUgaHR0cDovL21hcmluYS5zeXMud2FrYXlhbWEtdS5hYy5qcC9+dG9rb2kvP2RhdGU9MjAxNTAxMDVcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQ2dfUHJvZ3JhbW1pbmcvVW5pdHkvSGVybWl0ZV9DdXJ2ZXMjL21lZGlhL0ZpbGU6SGVybWl0ZV9zcGxpbmVfMi1zZWdtZW50cy5zdmdcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfSGVybWl0ZV9zcGxpbmVcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQ2dfUHJvZ3JhbW1pbmcvVW5pdHkvSGVybWl0ZV9DdXJ2ZXNcbiAqL1xuY2xhc3MgSGVybWl0ZUN1cnZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIHN0YXJ0IHBvaW50IHAwIGFuZCBpdCdzIHRhbmdlbnQgbTAgYW5kIHRoZSBlbmRwb2ludCBwMSBhbmQgaXQnc1xuICAgICAqIHRhbmdlbnQgbTEsIGNhbGN1bGF0ZXMgYSBjdWJpYyBoZXJtaXQgY3VydmUuXG4gICAgICpcbiAgICAgKiBLZWVwIGluIG1pbmQgdGhhdCB0IGhlcmUgaXMgYSBwcm9ncmVzcyBvZiB2YWx1ZSAwLTEgYnV0IGl0IGlzIGZvciB0aGlzXG4gICAgICogY3VydmUuICBTbyBhdCAwLCB3ZSB3b3VsZCBiZSBhdCB0aGUgc3RhcnQgcG9pbnQgYW5kIDEgd291bGQgYmUgYXQgdGhlIGVuZFxuICAgICAqIHBvaW50LlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdCBUaGUgY3VycmVudCBwcm9ncmVzcy5cbiAgICAgKiBAcGFyYW0gcDAgVGhlIHN0YXJ0IHZvaW50IHAwXG4gICAgICogQHBhcmFtIG0wIFRoZSB0YW5nZW50IG9mIHAwXG4gICAgICogQHBhcmFtIHAxIFRoZSBlbmQgcG9pbnRcbiAgICAgKiBAcGFyYW0gbTEgVGhlIHRhbmdlbnQgb2YgcDFcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UG9pbnQodCwgcDAsIG0wLCBwMSwgbTEpIHtcbiAgICAgICAgcmV0dXJuIChwMFxuICAgICAgICAgICAgLmNsb25lKClcbiAgICAgICAgICAgIC5zY2FsZSgxIC0gMyAqIHQgKiB0ICsgMiAqIHQgKiB0ICogdClcbiAgICAgICAgICAgIC8vIGgxXG4gICAgICAgICAgICAuYWRkKG0wLmNsb25lKCkuc2NhbGUodCAtIDIgKiB0ICogdCArIHQgKiB0ICogdCkpXG4gICAgICAgICAgICAvLyBoMlxuICAgICAgICAgICAgLmFkZChtMS5jbG9uZSgpLnNjYWxlKC10ICogdCArIHQgKiB0ICogdCkpXG4gICAgICAgICAgICAvLyBoM1xuICAgICAgICAgICAgLmFkZChwMS5jbG9uZSgpLnNjYWxlKDMgKiB0ICogdCAtIDIgKiB0ICogdCAqIHQpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5IZXJtaXRlQ3VydmUgPSBIZXJtaXRlQ3VydmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZXJtaXRlLWN1cnZlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/mathf/hermite-curve.js\n");

/***/ }),

/***/ "./lib/mathf/mathf.js":
/*!****************************!*\
  !*** ./lib/mathf/mathf.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mathf = void 0;\nconst ease_1 = __webpack_require__(/*! ../ease/ease */ \"./lib/ease/ease.js\");\n/**\n * Degu Math utility functions.\n */\nclass mathf {\n    /**\n     * Returns 0 if value is 0 or -0, otherwise, passes through the value.\n     * ```ts\n     * mathf.absZero(-0)  --> 0\n     * mathf.absZero(0)  --> 0\n     * mathf.absZero(10)  --> 10\n     * mathf.absZero(-12)  --> -12\n     * ```\n     * @tested\n     */\n    static absZero(value) {\n        return Object.is(value, -0) ? 0 : value;\n    }\n    /**\n     * Takes a number like a float and fixes it's digits.\n     * Example:\n     * ```ts\n     *   mathf.fixDigits(20.12345, 2) ==> 20.12\n     *   mathf.fixDigits(20.12345, 3) ==> 20.123\n     * ```\n     * @tested\n     * @param {number} value The number to convert\n     * @param {number} digits The number of digits to output.\n     */\n    static fixDigits(value, digits) {\n        return +parseFloat(value).toFixed(digits);\n    }\n    /**\n     * Takes a number and forces it to an int with rounding up.\n     * ```ts\n     *   mathf.int(20.3333)  --> 20\n     *   mathf.int(20.32)    --> 20\n     *   mathf.int(20.5)    --> 21\n     *   mathf.int(20)       --> 20\n     * ```\n     * @tested\n     * @param {number} value The number to convert\n     * @param {number} digits The number of digits to output.\n     */\n    static int(value) {\n        return mathf.fixDigits(value, 0);\n    }\n    /**\n     *\n     * Takes a number and forces it to an int by simply dropping decimals.\n     * ```ts\n     *   mathf.int(20.3333)  --> 20\n     *   mathf.int(20.32)    --> 20\n     *   mathf.int(20.555)  --> 20\n     *   mathf.int(20.9999)  --> 20\n     *   mathf.int(20)       --> 20\n     * ```\n     * @tested\n     * @param {number} value The number to convert\n     * @param {number} digits The number of digits to output.\n     */\n    static int0(value) {\n        return value >> 0;\n    }\n    /**\n     * Flips a coin.  Give you either a 1 or 0.\n     */\n    static flipCoin() {\n        return mathf.getRandomInt(0, 1);\n    }\n    /**\n     * Returns a random number (float) between min (inclusive) and max (exclusive)\n     * @param {number} min The minimum range.\n     * @param {number} max The maximum range.\n     * @return {number} A random number between the provided range.\n     * @function\n     */\n    static getRandomFloat(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n    /**\n     * Returns a random integer between min (inclusive) and max (inclusive)\n     * @param {number} min The minimum range.\n     * @param {number} max The maximum range.\n     * @return {number} A random integer betwen the provided range.\n     */\n    static getRandomInt(min, max) {\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n    /**\n     * Returns a random integrater between min and max but ensures it is not a\n     * certain value.\n     * @param {number} min The minimum range.\n     * @param {number} max The maximum range.\n     * @param {number} not The value it should not be.\n     */\n    static getUniqueRandomInt(min, max, not) {\n        const random = mathf.getRandomInt(min, max);\n        if (random === not) {\n            return mathf.getUniqueRandomInt(min, max, not);\n        }\n        else {\n            return random;\n        }\n    }\n    /**\n     * Clamps a number to a given range.\n     * ```ts\n     * mathf.clamp(0, 10, 100)  --> 10\n     * mathf.clamp(0, 10, -10)  --> 0\n     * ```\n     * @tested\n     * @param {number} min The mininum value.\n     * @param {number} max The maximum value:\n     * @param {number} num The number to limit.\n     * @return {number} A number within the min and max range.\n     */\n    static clamp(min, max, num) {\n        return Math.min(Math.max(num, min), max);\n    }\n    /**\n     * Given a progress (a value that ranges from 0 to 1), this method allows you\n     * to create a child progress based on the parent progress.\n     *\n     * Imaging the following progress.\n     * ```\n     * Parent progress\n     * 0 -----0.2------0.4-------0.6-------0.8------1\n     *\n     * Child progress\n     *        0.2----------------0.6\n     *\n     * mathf.childProgress(parentProgress, 0.2, 0.6)\n     * ```\n     * If you have a parent progress runnning from 0 to 1 and  you wanted your child\n     * progress to start at 0.2 and end at 0.6.\n     *\n     * Given the parent progress,  this method would return:\n     * ```\n     * Parent progress        Output\n     * 0            --------->   0\n     * |\n     * 0.2          --------->   0\n     * 0.3          --------->   0.25\n     * 0.4          --------->   0.5\n     * 0.5          --------->   0.75\n     * 0.6          --------->   1\n     * 0.7          --------->   1\n     * |\n     * 1            --------->   1\n     * ```\n     *\n     * @tested\n     * @param {number} number The parent progress as a value between 0 and 1.\n     * @param {number} start The starting value of the child progress.  Value\n     *     between 0 and 1.\n     * @param {number} end The end value of the child progress.  Value\n     *     between 0 and 1.\n     */\n    static childProgress(progress, start, end, noClamp = false) {\n        const range = end - start;\n        let childProgress = mathf.clamp(0, 1, progress - start);\n        if (noClamp) {\n            childProgress = progress - start;\n        }\n        childProgress = childProgress / range;\n        if (noClamp) {\n            return childProgress;\n        }\n        else {\n            return mathf.clampAsPercent(childProgress);\n        }\n    }\n    /**\n     * Rounds to a specific precision.\n     * ```\n     * mathf.roundToPrecision(0.49999, 1)  --> 0.5\n     * mathf.roundToPrecision(0.49999, 2)  --> 0.5\n     * mathf.roundToPrecision(0.41199, 3)  --> 0.412\n     * mathf.roundToPrecision(0.5555, 3)  --> 0.556\n     * mathf.roundToPrecision(0.5555, 2)  --> 0.56\n     * ```\n     * @tested\n     * @param value\n     * @param precision\n     */\n    static roundToPrecision(value, precision) {\n        precision = mathf.int(precision);\n        const shifter = Math.pow(10, precision);\n        return Math.round(value * shifter) / shifter;\n    }\n    /**\n     * Floors number to a specific precision.\n     * ```\n     * mathf.floorToPrecision(0.5555, 3)  --> 0.555\n     * mathf.floorToPrecission(0.5555, 2)  --> 0.55\n     * ```\n     * @tested\n     * @param value\n     * @param precision\n     */\n    static floorToPrecision(value, precision) {\n        precision = mathf.int(precision);\n        const shifter = Math.pow(10, precision);\n        return Math.floor(value * shifter) / shifter;\n    }\n    /**\n     * Ceils number to a specific precision.\n     * ```\n     * mathf.ceilToPrecision(0.5555, 3)  --> 0.555\n     * mathf.ceilToPrecission(0.5555, 2)  --> 0.55\n     * ```\n     * @tested\n     * @param value\n     * @param precision\n     */\n    static ceilToPrecision(value, precision) {\n        precision = mathf.int(precision);\n        const shifter = Math.pow(10, precision);\n        return Math.ceil(value * shifter) / shifter;\n    }\n    /**\n     * Converts a number to a specific number of decimasl\n     * ```\n     * mathf.toFixed(1.943, 2) --> 1.94\n     * mathf.toFixed(1.943, 1) --> 1.9\n     * ```\n     * @param value\n     * @param precision\n     */\n    static toFixed(value, precision) {\n        return +value.toFixed(precision);\n    }\n    /**\n     * Calculate the angle between two points.\n     * @param  {number} x1 The x position of the first point.\n     * @param  {number} y1 The y position of the first point.\n     * @param  {number} x2 The x position of the second point.\n     * @param  {number} y2 The y position of the second point.\n     * @return {number} The angle in radians.\n     */\n    static angleRadians(x1, y1, x2, y2) {\n        return Math.atan2(y2 - y1, x2 - x1);\n    }\n    /**\n     * Calculate the angle between two points given cartesian coordinates system.\n     * @param  {number} x1 The x position of the first point.\n     * @param  {number} y1 The y position of the first point.\n     * @param  {number} x2 The x position of the second point.\n     * @param  {number} y2 The y position of the second point.\n     * @return {number} The angle in degrees.\n     */\n    static angleDegree(x1, y1, x2, y2) {\n        return (Math.atan2(y2 - y1, x2 - x1) * 180) / Math.PI;\n    }\n    /**\n     * Determine the angular distance between two angles in degree.\n     *\n     * In a 360 circle, if you had one degre at 90 and another at 80,\n     * the angle distance is 10, the difference between the two.\n     *\n     * Examples\n     * ```ts\n     *   mathf.angleDistanceDegree(10, 10) ==> 0\n     *   mathf.angleDistanceDegree(30, 10) ==> -20\n     *   mathf.angleDistanceDegree(10, 50) ==> 40 *   mathf.angleDistanceDegree(10, 340) ==> -30 * ``` *\n     * @tested\n     * @param {number} angle0 The first angle in degrees.\n     * @param {number} angle1 The second angle in degrees.\n     * @param {number?} max The max value at which point the numerical system\n     *     repeats.  In a circle this would be 360.  This value defaults to 360.\n     * @return {number} Distance in degrees.\n     */\n    static angleDistanceDegree(angle0, angle1, max) {\n        const angle0Rad = mathf.degreeToRadian(angle0);\n        const angle1Rad = mathf.degreeToRadian(angle1);\n        if (max) {\n            max = mathf.degreeToRadian(max);\n        }\n        const result = mathf.angleDistanceRadian(angle0Rad, angle1Rad, max);\n        return mathf.radianToDegree(result);\n    }\n    /**\n     * Determine the angular distance between two angles in radians.\n     * [[mathf.angleDistanceDegree]] for more information and equivelant degree\n     * samples.\n     * @tested\n     * @param {number} angle0 The first angle in radians\n     * @param {number} angle1 The second angle in degrees.\n     * @param {number?} max The max value at which point the numerical system\n     *     repeats.  In a circle this would be 2 radian.  This value defaults to\n     *     2 radian.\n     * @return {number} Distance in radians\n     */\n    static angleDistanceRadian(angle0, angle1, max) {\n        if (!max) {\n            max = Math.PI * 2;\n        }\n        const delta = (angle1 - angle0) % max;\n        return ((2 * delta) % max) - delta;\n    }\n    /**\n     * Converts radians to degrees.\n     * @param  {number} deg The degree value.\n     * @return {number} The converted radian.\n     */\n    static degreeToRadian(deg) {\n        return deg * (Math.PI / 180);\n    }\n    /**\n     * Converts radians to degrees.\n     * @param  {number} radian The radian value.\n     * @return {number} The converted degree.\n     */\n    static radianToDegree(radian) {\n        return (radian * 180) / Math.PI;\n    }\n    /**\n     * Checks for collision detection.\n     * @param {Object} a An object with x, y, width and height.\n     * @param {Object} b An object with x, y, width and height.\n     * @return {boolean} Whether the areas are colliding.\n     */\n    static boxCollision(a, b) {\n        return !(a.y + a.height < b.y ||\n            a.y > b.y + b.height ||\n            a.x + a.width < b.x ||\n            a.x > b.x + b.width);\n    }\n    /**\n     * Given a circular and rectangular object, detects when the two collide\n     * with each other on a 2d space.  Assumes Box is unrotated.\n     * @param rect An object with x, y, width and height.\n     * @see https://yal.cc/rectangle-circle-intersection-test/\n     */\n    static collisionCircVsBox(circ, rect) {\n        const dx = circ.x - Math.max(rect.x, Math.min(circ.x, rect.x + rect.width));\n        const dy = circ.y - Math.max(rect.y, Math.min(circ.y, rect.y + rect.height));\n        return dx * dx + dy * dy < circ.radius * circ.radius;\n    }\n    /**\n     * Performs a test whether a point resized inside a convex polygon using\n     * raycasting.\n     * @param point An object with x,y coords of the point.\n     * @param poly An array of x,y points of a polygon.\n     * @return Whether the point is inside the polygon or not.\n     * @see http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n     * @see https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169\n     * @see https://www.gamedevelopment.blog/collision-detection-circles-rectangles-and-polygons/\n     * @see https://stackoverflow.com/questions/22521982/check-if-point-inside-a-polygon\n     * @see https://github.com/mikolalysenko/robust-point-in-polygon/blob/master/robust-pnp.js\n     */\n    static collisionPointVersusConvexPolygon(point, poly) {\n        // We go around in the polygon.\n        // Assuming there are four point (but could be more),\n        //\n        //   0----1\n        //   |    |\n        //   3----2\n        // We perform raycasting, 0-3, 1-0, 2-1, 3-2 points.\n        //\n        let isInside = false;\n        const size = poly.length;\n        let pointPolyAIndex = 0;\n        let pointPolyBIndex = size - 1;\n        for (let i = 0; i < size; i++) {\n            const polyA = poly[pointPolyAIndex];\n            const polyB = poly[pointPolyBIndex];\n            const intersects = polyA.y > point.y !== polyB.y > point.y &&\n                point.x <\n                    ((polyB.x - polyA.x) * (point.y - polyA.y)) / (polyB.y - polyA.y) +\n                        polyA.x;\n            if (intersects) {\n                isInside = !isInside;\n            }\n            pointPolyBIndex = pointPolyAIndex;\n            pointPolyAIndex++;\n        }\n        return isInside;\n    }\n    /**\n     * Use rotational matrix to calculate the new coordinates of a rotated\n     * point.\n     *\n     * Put another way, given point x and y, and a center point of cx and cy,\n     * calculates the translated x, y points when rotated at a given angle.\n     *\n     * For example:\n     *\n     *      0,0--------------4,0\n     *       |               |\n     *       |       2,2     |\n     *       |               |\n     *      0,4 ------------ 4,4\n     *\n     * Say for example you have a rectangle.  The rotational center of the\n     * rectangle is the center in this case at 2,2.\n     *\n     * You can use this algo to calculate rotation.\n     * Lets say you rotate the rectangle by 1 radian (~57 degrees).\n     * What is the new coordinates of the top right corner?\n     *\n     * ```\n     * const newCoords = mathf.calculate2dPointRotation(2,2,4,0,1);\n     *\n     * newCoords.x;  // 1.398\n     * newCoords.y;  // -0.764\n     *\n     * ```\n     *\n     * Troubleshoot?\n     *\n     * The most common issue is that your rotation value is inverted.\n     * Try passing in -rotation and see if that helps.\n     *\n     * https://www.youtube.com/watch?v=xsN8cD6oisY&feature=youtu.be\n     * https://www.youtube.com/watch?v=a59YQ4qe7mE\n     * https://en.wikipedia.org/wiki/Rotation_matrix\n     *\n     * @param cx The x center point to rotate around.\n     * @param cy The y center point to rotate around.\n     * @param x The x value of the point to be rotated prior to rotation.\n     * @param y The y value of the point to be rotated prior to rotation.\n     * @param angle The angle in radians\n     * @tested\n     */\n    static calculate2dPointRotation(cx, cy, x, y, angle) {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        const tx = cos * (x - cx) + sin * (y - cy) + cx;\n        const ty = cos * (y - cy) - sin * (x - cx) + cy;\n        return {\n            x: tx,\n            y: ty,\n        };\n    }\n    /**\n     * Rotates a point around another point with angle and distance.\n     * This is similar to\n     * [[mathf.calculate2dPointRotation]] except that you are specifying a\n     * distance as well.\n     * @param cx The x center point to rotate around.\n     * @param cy The y center point to rotate around.\n     * @param x The x value of the point to be rotated prior to rotation.\n     * @param y The y value of the point to be rotated prior to rotation.\n     * @param angle The angle in radians\n     * @param distance The distance from cx and cy in which we should place the\n     *     new coordinates to.\n     */\n    static calculate2dPointRotationWithDistance(cx, cy, x, y, angle, distance) {\n        const t = angle + Math.atan2(y - cy, x - cx);\n        x = cx + distance * Math.cos(t);\n        y = cy + distance * Math.sin(t);\n        return {\n            x: x,\n            y: y,\n        };\n    }\n    /**\n     * Calculates the distance of two sets of x, y coordinates.\n     * @param  {number} x1 The x value of point 1.\n     * @param  {number} y1 The y value of point 1.\n     * @param  {number} x2 The x value of point 2.\n     * @param  {number} y2 The y value of point 2.\n     * @return {number} The distance between point 1 and point 2.\n     */\n    static distance(x1, y1, x2, y2) {\n        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    }\n    /**\n     * Gets the direction in which a number is progress.\n     * 0 means the same, no movement.\n     * 1 means moving forward.\n     * -1 means moving backwards.\n     * ```ts\n     * matfh.direction(1, 2) ---> 1\n     * matfh.direction(3, 1) ---> -1\n     * matfh.direction(1, 1) ---> 0\n     * ```\n     * @param previous\n     * @param current\n     * @tested\n     */\n    static direction(previous, current) {\n        if (previous === current) {\n            return 0;\n        }\n        return previous < current ? 1 : -1;\n    }\n    /**\n     * Calculates the offset value to center a given element within a container.\n     *\n     * Imagine the below:\n     *\n     * ```\n     * ------------------8 (parent)----------------\n     * |                                           |\n     * |             |----5(child)-----|           |\n     * |                                           |\n     * |---offset--|                               |\n     * --------------------------------------------\n     * ```\n     *\n     *  You have a parent of width 8 and child of with 5 and you want to\n     *  center the child.\n     *\n     *  In the example above, parent = 8, child = 5, would return the offset of 1.5\n     *  So you know that if you offsetted the child element by 1.5, it would\n     *  horizontally center.\n     *\n     *  You can also use this method to calculate vertical alignment as well.\n     *\n     * Example:\n     * Here is an example of calculating the x, y offsets to center an object\n     * to the screen.\n     * ```ts\n     *  let x = mathf.calculateCenterOffset(\n     *     screen.width, object.width);\n     *  let y = mathf.calculateCenterOffset(\n     *     screen.height, object.width);\n     * ```\n     * @tested\n     * @param {number} parent The parent value\n     * @param {number} child The child value\n     * @return {number} The offset value.\n     */\n    static calculateCenterOffset(parent, child) {\n        const halfParent = parent / 2;\n        const halfChild = child / 2;\n        const offset = halfParent - halfChild;\n        return offset;\n    }\n    /**\n     * Given a known set of sizes, scales and returns a y1.\n     *\n     * `````ts\n     *  x1     x2 (return)\n     * ---- = ----\n     *  y1     y2\n     *\n     * ````\n     */\n    static scaleX(x1, y1, y2) {\n        return (x1 * y2) / y1;\n    }\n    /**\n     * Given a known set of sizes, scales and returns a y2.\n     *\n     * `````ts\n     *  x1     x2\n     * ---- = ----\n     *  y1     y2 (return)\n     *\n     * ````\n     */\n    static scaleY(x1, y1, x2) {\n        return (x2 * y1) / x1;\n    }\n    /**\n     * Given a width and height, returns the aspect ratio.\n     * @param {box} dimensionalBox An object containing the width and height.\n     */\n    static aspectRatio(box) {\n        return box.width / box.height;\n    }\n    /**\n     * Tests if a given value is between a range.\n     * @param testValue\n     * @param range1\n     * @param range2\n     * @param inclusive Whether the test should be inclusive.\n     * @return Whether the test value is between range1 and range2.\n     */\n    static isBetween(testValue, range1, range2, inclusive = true) {\n        const min = Math.min(range1, range2);\n        const max = Math.max(range1, range2);\n        return inclusive\n            ? testValue >= min && testValue <= max\n            : testValue > min && testValue < max;\n    }\n    /**\n     * Resizes a given dimensional box (width and height) to a given width while\n     * maintaining the aspect ratio.  Useful for scaling up or down a box.\n     * @param {number} box\n     * @param {number} width\n     * @return {dimensionalBox}\n     * @tested\n     */\n    static resizeDimensionalBoxToWidth(box, width) {\n        return {\n            width,\n            height: mathf.scaleY(box.width, box.height, width),\n        };\n    }\n    /**\n     * Resizes a given dimensional box (width and height) to a given height while\n     * maintaining the aspect ratio.  Useful for scaling up or down a box.\n     * @param {number} box\n     * @param {number} height\n     * @return {dimensionalBox}\n     * @tested\n     */\n    static resizeDimensionalBoxToHeight(box, height) {\n        return {\n            width: mathf.scaleX(box.width, box.height, height),\n            height,\n        };\n    }\n    /**\n     * Clamps a value within 0-1.\n     * ```ts\n     * mathf.clampAsPercent(0.2) --> 0.2\n     * mathf.clampAsPercent(1) --> 1\n     * mathf.clampAsPercent(-2) --> 0\n     * mathf.clampAsPercent(2) -->  1\n     * ```\n     * @tested\n     * @param percent\n     * @return percent A value within 0-1.\n     */\n    static clampAsPercent(percent) {\n        return mathf.clamp(0, 1, mathf.absZero(percent));\n    }\n    /**\n     * Clamps a number to within 0-1.\n     * An alias of [[mathf.clampAsProgress]]\n     * @tested\n     * @param progress\n     * @return progress A value within 0-1.\n     */\n    static clampAsProgress(progress) {\n        return mathf.clampAsPercent(progress);\n    }\n    /**\n     * Clamps a number to within 0-1.\n     * An alias of [[mathf.clampAsProgress]]\n     * @tested\n     * @param progress\n     * @return progress A value within 0-1.\n     */\n    static clamp01(progress) {\n        return mathf.clampAsPercent(progress);\n    }\n    /**\n     * Used to get a value within a range by progress.\n     * Note this is an alias of [[mathf.lerp]] since it's the same thing.\n     *\n     * For instance, let's say you have a range of 325-1450.\n     * You want 0% = 325 and 100% = 1450.\n     *\n     * You can pass a progress (such as 20% or 0.2) and this will return the value\n     * within that range.\n     *\n     * @tested\n     * @param {number} progress The percent to calculate.  Should be between 0 and 1.\n     * @param {number} min The low end of the range.\n     * @param {number} max The high end of the range.\n     * @return {number} The value within the range.\n     */\n    static getValueInRangeByProgress(progress, min, max) {\n        return mathf.lerp(min, max, progress);\n    }\n    /**\n     * Normalizes a given range (min and max) to a progress (a value between 0 and\n     * 1)\n     * For instance, let's say you have a range of 325-1450.\n     * You want 0% = 325 and 100% = 1450.\n     * You can pass a value 420 and this will return the progress (percentage).\n     *\n     * ```ts\n     *\n     *    mathf.getProgressInRangeByValue(2, 0, 10) // 0.2\n     *    mathf.getProgressInRangeByValue(10, 0, 10) // 1\n     *    mathf.getProgressInRangeByValue(7, 2, 12) // 0.5\n     *\n     * ```\n     *\n     * @param {number} value The value to determine the progress.\n     * @param {number} min The low end of the range.\n     * @param {number} max The high end of the range.\n     * @return {number} The progress within the range.\n     */\n    static getProgressInRangeByValue(val, min, max) {\n        return mathf.clampAsPercent((val - min) / (max - min));\n    }\n    /**\n     * Normalized a value between a min and max returning a value between\n     * 0 and 1.\n     * An alias to [[mathf.getProgressInRangeByValue]].\n     */\n    static normalize(val, min, max) {\n        return mathf.getProgressInRangeByValue(val, min, max);\n    }\n    /**\n     * Linear interpolate from start to end given amount.\n     * ```ts\n     * mathf.lerp(0, 1, 0)   ---> 0\n     * mathf.lerp(0, 1, 0.2) ---> 0.2\n     * mathf.lerp(0, 1, 0.5) ---> 0.5\n     * mathf.lerp(0, 2, 0.5) ----> 1\n     * mathf.lerp(25, 79, 0.2) ----> 35.8\n     * ```\n     *\n     * Lerp can be used for various things.  See [[mathf.getValueInRangeByProgress]]\n     * which is an alias of lerp.\n     *\n     * Lerp can also be used for animations.   If you were doing the old school:\n     * ```ts\n     * onRafLoop() {\n     *   // Update the position by 20% of the distance between position and target.\n     *   position.x += (target.x - position.x) * 0.2;\n     * }\n     * ```\n     * this can be replaced with:\n     * ```ts\n     * onRafLoop() {\n     *   // Same thing. Update the position by 20% of the distance between\n     *   // position and target on each raf loop.  This has the effect of\n     *   // tweening in the position to the target.\n     *   position.x = mathf.lerp(position.x, target.x, 0.2);\n     * }\n     * ```\n     *\n     * @tested\n     * @param {number} value1 The start of the range to lerp.\n     * @param {number} value2 The target of the range to lerp.\n     * @param {number} amount A value between 0-1 representing the progress of the\n     *     lerp.\n     * @return {number} The interporalated value.\n     */\n    static lerp(value1, value2, amount) {\n        const clampedAmount = mathf.clamp01(amount);\n        return (1 - clampedAmount) * value1 + clampedAmount * value2;\n        // Alternative ways to calculate lerp.\n        // Neither behave properly for lerping from negative to positive\n        // return value1 + (value2 - value1) * mathf.clamp01(amount);\n        // return ((value2 - value1) * amount) + amount\n    }\n    /**\n     * Inverse lerp function\n     * @param a Start value\n     * @param b End value\n     * @param value  Value beteen start and end.\n     * @param noClamp Defaults to false, whether to disable clamping.\n     * @return {number} A normalized value between 0-1\n     */\n    static inverseLerp(a, b, value, noClamp = false) {\n        if (noClamp) {\n            return (value - a) / (b - a);\n        }\n        else {\n            return mathf.clamp01((value - a) / (b - a));\n        }\n    }\n    /**\n     * Another linear interpolation option.   Same as mathf.lerp but different algo\n     * with no hard clamping.\n     *\n     * ```ts\n     * mathf.mix(a, b, 0.0) ---> a\n     * mathf.mix(a, b, 1.0) ---> b\n     * mathf.mix(a, b, 0.5) ---> between x and y, blended values.\n     * ```\n     * @param a\n     * @param b\n     * @param blend\n     * @untested\n     */\n    static mix(a, b, blend) {\n        return a * (1 - blend) + b * blend;\n    }\n    /**\n     * Step method.  Will  return 0 or 1.\n     * If n is greater than edge, 1\n     * If n is less than edge, 0\n     *\n     * ```ts\n     * mathf.step(1, 2) ---> 1\n     * mathf.step(1, 0.2) ---> 0\n     * mathf.step(1, 1.1) ---> 1\n     * ```\n     */\n    static step(edge, n) {\n        if (n > edge) {\n            return 1.0;\n        }\n        else {\n            return 0.0;\n        }\n    }\n    /**\n     * Performs smoothstep from min to max using the given value using Hermite\n     * interpolation.\n     *\n     * Given three values, min, max and input, this will return a number between 0\n     * and 1 that represents the progress of the input value to the min and max\n     * values.\n     *\n     * This is similar too [[mathf.normalize]] or\n     * [[mathf.getProgressInRangeByValue]] except the curve is slightly smoothed\n     * out.\n     *\n     * ```ts\n     * mathf.smoothStep(100, 200, 100); // 0\n     * mathf.smoothStep(100, 200, 150); // 0.5\n     * mathf.smoothStep(100, 200, 300); // 1\n     * ```\n     * @see  https://en.wikipedia.org/wiki/Smoothstep\n     * @see http://www.fundza.com/rman_shaders/smoothstep/index.html\n     * @param {number} min The min of the range to lerp.\n     * @param {number} max The max of the range to lerp.\n     * @param {number} input A value between\n     */\n    static smoothStep(min, max, input) {\n        const x = Math.max(0, Math.min(1, (input - min) / (max - min)));\n        return x * x * (3 - 2 * x);\n    }\n    /**\n     * Lerps within a given range.\n     *\n     * Let's say you have to ranges that\n     * you want to make a linear association to.\n     *\n     * The easiest way to imagine this is imagine two ranges.\n     *\n     * ```\n     * 0     Range1        100\n     * |------10------------|\n     *\n     * 0               Range2                 200\n     * |-------------?-------------------------|\n     *```\n     *\n     * range1: 0 - 100\n     * range2: 0 - 200\n     *\n     * You have the value of 20 on range1 and want to know what the value would\n     * be on range2.\n     *\n     * The above would return 20 since 10% of 200 = 20.\n     *\n     * ```ts\n     * mathf.interpolateRange(0, 0, 100, 0, 200); // 0\n     * mathf.interpolateRange(10, 0, 100, 0, 200); // 20\n     * mathf.interpolateRange(30, 0, 100, 0, 200); // 60\n     *\n     * ```\n     *\n     * A practical example.\n     * Here when the screen width is 300, the padding is 0\n     * and when it's 1200, the padding is 500 and everything\n     * it clculates everything between.\n     * ```ts\n     *\n     * let padding = mathf.interpolateRange(\n     *     screenWidth,\n     *     300, 1200,\n     *     0, 500\n     * );\n     * ```\n     *\n     *\n     */\n    static interpolateRange(range1Value, range1Min, range1Max, range2Min, range2Max) {\n        const progress = mathf.clampAsProgress(range1Value / (range1Max - range1Min));\n        return mathf.lerp(range2Min, range2Max, progress);\n    }\n    /**\n     * A normalized sin - so instead of returning -1 to 1, normalized sin returns\n     * a value between 0 and 1.\n     * @param time\n     */\n    static sinNormalized(time) {\n        return mathf.interpolateRange(Math.sin(time) + 1, 0, 2, 0, 1);\n    }\n    /**\n     * Same as lerp but will apply an easingFunction to the current\n     * progress, prior to running lerp.\n     *\n     * @tested\n     * @param {number} value1 The start of the range to lerp.\n     * @param {number} value2 The target of the range to lerp.\n     * @param {number} amount A value between 0-1 representing the progress of the\n     *     lerp.\n     * @param easeFunction An easing function. See [[ease]].  Defaults to linear\n     *   in which case, linear is equal to a regular lerp.\n     */\n    static lerpEase(value1, value2, amount, easeFunction = ease_1.EASE.linear) {\n        amount = easeFunction(amount);\n        return mathf.lerp(value1, value2, amount);\n    }\n    /**\n     * Similar to [[mathf.lerp]] but is damped and smoothed out with exponential\n     * decay.  Useful to use as an alternative to [[mathf.lerp]] or [[mathf.ease]]\n     * to smooth out animation movement.\n     * @see http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n     * @tested\n     * @param {number} value1 The start of the range to lerp.\n     * @param {number} value2 The target of the range to lerp.\n     * @param {number} amount A value between 0-1 representing the progress of the\n     *     lerp.\n     * @param {number} damp A value between 0-1 representing the amount to damp.\n     * @param easeFunction An easing function. See [[ease]].  Defaults to linear\n     *   in which case, linear is equal to a regular lerp.\n     */\n    static damp(value1, value2, amount, damp) {\n        return mathf.lerp(value1, value2, 1 - Math.exp(-amount * damp));\n    }\n    /**\n     * An alias of [[mathf.lerpEase]]\n     *\n     * This is a general ease function that is pretty handy for animations.\n     *\n     * This is basically a way of saying, given my start and end values, what is the\n     * value when it's at x percent (progress) with easing.\n     *\n     * Under the hood, it is simply an alias of [[mathf.lerpEase]] which is\n     * essentially a regular lerp but it passes the progress value (0-1) through\n     * an easing function first.\n     *\n     *\n     * Using mathf.ease, you can pretty easily calculate eases for numberic values.\n     *\n     * Say I wanted to animate a box.x position from 0 - 100.\n     * Without specifying a easing function, you will just get linear interpolation.\n     *\n     * ```\n     * mathf.ease(0, 100, 0) ---> 0\n     * mathf.ease(0, 100, 0.3) ---> 30\n     * mathf.ease(0, 100, 0.5) ---> 50\n     * mathf.ease(0, 100, 0.9) ---> 90\n     * mathf.ease(0, 100, 1) ---> 100\n     * ```\n     *\n     * Now lets try this with easing.  You can see the returned values between\n     * 0 and 1 are different than a linear ease.\n     *\n     * You can also combine with CubicBezier.makeEasingFunction or a catmull-roll.\n     * ```\n     * import { EASE, mathf} from '@blinkk/degu'\n     * mathf.ease(0, 100, 0, EASE.easeInExpo)   ---> 0\n     * mathf.ease(0, 100, 0.3, EASE.easeInExpo) ---> 0.1953125\n     * mathf.ease(0, 100, 0.5, EASE.easeInExpo) ---> 3.125\n     * mathf.ease(0, 100, 0.9, EASE.easeInExpo) ---> 70.710678\n     * mathf.ease(0, 100, 1, EASE.easeInExpo) ---> 100\n     *\n     *\n     *\n     * import { CubicBezier, EASE, mathf} from '@blinkk/degu'\n     * mathf.ease(0, 100, 0.3, CubicBezier.makeEasingFunction(0, 1, 0.75, 0.9)) ---> 100\n     *\n     * ```\n     *\n     * How can I use this with animations?\n     *\n     * You can ease out positions, opacity etc based on \"progress\".\n     * Progress can be time, scroll position, mouse position etc but it needs to\n     * be normalized to a value between 0 and 1.\n     *\n     * See examples of this in [[RafTimer]] where there is a demo of easing an\n     * element for a set duration.\n     *\n     * For an exmaple where you may want to tie ease with window.scroll or another\n     * input represented by a normalized value/ progress (a number between 0 and 1)i\n     * see mathf-ease.html in the /examples folder where there is element and\n     * progress level easing to smooth\n     * interaction.\n     *\n     * Also related is [[Interpolate]].\n     *\n     * @alias\n     * @param {number} start The start of the range to lerp.\n     * @param {number} end The target of the range to lerp.\n     * @param {number} progress A value between 0-1 representing the progress of the\n     *     lerp.\n     * @param easeFunction An easing function. See [[ease]]\n     */\n    static ease(start, end, progress, easeFunction = ease_1.EASE.linear) {\n        return mathf.lerpEase(start, end, progress, easeFunction);\n    }\n    /**\n     * Wraps a given number between two values.\n     *\n     * ```ts\n     *\n     * mathf.wrap(angle, 0, 360);  // Wrap between 0 and 360 degress\n     * mathf.wrap(angle, -90, 90); // Wrap between -90 and 90 degress\n     *\n     *\n     * mathf.wrap(15, 0, 10); // Wrap between 0 and 10 --> result 5\n     * mathf.wrap(400, 0, 360); // --> result 40\n     * mathf.wrap(120, -90, 90); // --> -60\n     *\n     * ```\n     *\n     * @param value\n     * @param min\n     * @param max\n     */\n    static wrap(value, min, max) {\n        const diff = max - min;\n        return min + ((((value - min) % diff) + diff) % diff);\n    }\n    /**\n     * Given two boxes of different aspect ratios,\n     * calculates the values in order to make the child cover the parent.\n     * This acts similar to background: cover of css.\n     *\n     * Imagine the following:\n     * ```\n     * -------p--------\n     * |               |\n     * |   -----       |\n     * |   | C  |      |\n     * |   -----       |\n     * |               |\n     * -----------------\n     * ```\n     *\n     * This case, c would have to scale up to cover the\n     * parent.  It would return something like:\n     *\n     * - width: What the child width should be\n     * - height: What the child height should be\n     * - xOffset: The Amount to offset x by in order to center.\n     * - yOffset: The Amount to offset y by in order to center.\n     * - scalar: The amount to scale\n     *\n     *\n     * Note on xOffset and yOffset, this algo assumes that the child will scale\n     * from the top left corner of the box and is positioned to the top left.\n     *\n     * @param {dimensionalBox} parentBox The parent element dimensions\n     * @param {dimensionalBox} childBox The child elment dimensions\n     * @return {backgroundCoverBox} backgroundCoverBox The dimensions required to\n     *     transform the child element to background cover.\n     */\n    static calculateBackgroundCover(parentBox, childBox) {\n        const parentRatio = mathf.aspectRatio(parentBox);\n        const childRatio = mathf.aspectRatio(childBox);\n        let finalWidth;\n        let finalHeight;\n        let scale;\n        if (childRatio >= parentRatio) {\n            finalHeight = parentBox.height;\n            scale = parentBox.height / childBox.height;\n            finalWidth = childBox.width * scale;\n        }\n        else {\n            finalWidth = parentBox.width;\n            scale = parentBox.width / childBox.width;\n            finalHeight = childBox.height * scale;\n        }\n        const finalScale = Math.max(finalWidth / childBox.width, finalHeight / childBox.height);\n        // Position to vertical bottom.\n        const offsetHeight = mathf.absZero(-Math.round((parentBox.height - finalHeight) / 2));\n        // Position to horizontal center.\n        const offsetWidth = mathf.absZero(-Math.round((parentBox.width - finalWidth) / 2));\n        return {\n            width: Math.round(finalWidth),\n            height: Math.round(finalHeight),\n            xOffset: offsetWidth,\n            yOffset: offsetHeight,\n            scalar: finalScale,\n        };\n    }\n    /**\n     * Given two boxes of different sizes calculates the amount that the childBox\n     * would need to scale in order to mimic the background:contain effect in html.\n     *\n     * Imagine the following:\n     * ```\n     * -------p--------\n     * |               |\n     * |   -----       |\n     * |   | C  |      |\n     * |   -----       |\n     * |               |\n     * -----------------\n     * ```\n     *\n     * This case, c would have to scale up to cover the\n     * parent.      This method would return the amount that C needs to scale\n     * (up or down).\n     *\n     * Since this is contain, applying the scale value to the child would never\n     * exceed the width or height of the parent (no bleeding).\n     *\n     * Note that this method assumes that the child is absolutely centered against\n     * the parent.\n     *\n     * ```ts\n     * parentBox = { width: 100, height: 100 };\n     * childBox = { width: 200, height: 100 };\n     * mathf.calculateBackgroundContain(parentBox, childBox) // return 0.5.\n     *\n     *\n     * parentBox = { width: 500, height: 500 };\n     * childBox = { width: 50, height: 50 };\n     * mathf.calculateBackgroundContain(parentBox, childBox) // return 10\n     *\n     * ```\n     *\n     * @param parentBox\n     * @param childBox\n     */\n    static calculateBackgroundContain(parentBox, childBox) {\n        const heightScale = parentBox.height / childBox.height;\n        const widthScale = parentBox.width / childBox.width;\n        const scale = Math.min(heightScale, widthScale);\n        return scale;\n    }\n    /**\n     * Implements asympotic average which is an additive average.\n     * Basically says, given the current value, catch up to the target by X% every\n     * frame.\n     *\n     * This is similar to lerp but respects the last given amount the most which\n     * results in a smooth response to sudden jumps in the difference between\n     * current and target.\n     *\n     * This can be used for things like camera movement or scroll movement where\n     * sudden jerks in movement can happen.\n     *\n     * ```\n     * onRaf() {\n     *    // Update target value.\n     *    targetValue = this.value + (this.mouseInputX * 30);\n     *    // Update the current value to the target value by 30%.\n     *    this.value = mathf.asymptoticAverage(this.value, targetValue, 0.3);\n     * }\n     * ```\n     *\n     * @param current\n     * @param target\n     * @param amount\n     */\n    static asymptoticAverage(current, target, amount) {\n        return (current += (target - current) * amount);\n    }\n    /**\n     * Implements basic smooth start.  See EASE for more.\n     */\n    static smoothStart2(t) {\n        return t * t;\n    }\n    /**\n     * Implements basic smooth stop.  See EASE for more.\n     */\n    static smoothStop2(t) {\n        return 1 - (1 - t) * (1 - t);\n    }\n    /**\n     * Implements basic smooth start.  See EASE for more.\n     */\n    static smoothStart3(t) {\n        return t * t * t;\n    }\n    /**\n     * Implements basic smooth stop.  See EASE for more.\n     */\n    static smoothStop3(t) {\n        return 1 - (1 - t) * (1 - t) * (1 - t);\n    }\n    /**\n     * Basic smooth step2 allowing you to specify the gradient between\n     * smoothstart and smoothstop with mix value.\n     * @param value\n     * @param mix\n     * @param t\n     *\n     * ```\n     *   value = mathf.smoothStep2(value, 0.5, t);\n     * ```\n     */\n    static smoothStep2(value, mix, t) {\n        return (mathf.lerp(mathf.smoothStart2(value), mathf.smoothStop2(value), mix) * t);\n    }\n    /**\n     * Basic sigmoid function with option to move the mix value.\n     * Mix value of 0 mixes to smoothstart. 1 mixes to smoothstop.\n     * A clean sigmoidish curve woud be 0.5.\n     *\n     * Based on smoothStep2 curves.\n     * @param value\n     * @param mix\n     */\n    static sigmoid(value, mix) {\n        return this.smoothStep2(value, mix, value);\n    }\n    /**\n     Creates a basic remap.\n  \n     Let's say you want to make a color bar go from 20, 50\n     when your health goes from 0, 100.\n  \n    ```\n     mathf.remap(20, 50, 0, 100, health);  --> output a value between 20-50 based on health.\n     ```\n     */\n    static remap(minA, maxA, minB, maxB, valueB) {\n        const t = mathf.inverseLerp(minB, maxB, valueB);\n        return mathf.lerp(minA, maxA, t);\n    }\n    /**\n     * Total/sum/add-up the given values.\n     */\n    static sum(values) {\n        return values.reduce((result, value) => result + value, 0);\n    }\n}\nexports.mathf = mathf;\n/**\n * Generates a set of random x,y points.\n * @param {number} num Number of points.\n * @param {number} minX Minimum of x.\n * @param {number} maxX Maximum of x.\n * @param {number} minY Minimum of y.\n * @param {number} maxY Maximum of y.\n * @return {Array.<Object>} An array of objects containing x, y values.\n */\nmathf.generateRandomPoints = (num, minX, maxX, minY, maxY) => {\n    const points = [];\n    for (let i = 0; i < num; i++) {\n        points.push({\n            x: mathf.getRandomInt(minX, maxX),\n            y: mathf.getRandomInt(minY, maxY),\n        });\n    }\n    return points;\n};\n//# sourceMappingURL=mathf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbWF0aGYvbWF0aGYuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvbWF0aGYvbWF0aGYuanM/NDFhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWF0aGYgPSB2b2lkIDA7XG5jb25zdCBlYXNlXzEgPSByZXF1aXJlKFwiLi4vZWFzZS9lYXNlXCIpO1xuLyoqXG4gKiBEZWd1IE1hdGggdXRpbGl0eSBmdW5jdGlvbnMuXG4gKi9cbmNsYXNzIG1hdGhmIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIDAgaWYgdmFsdWUgaXMgMCBvciAtMCwgb3RoZXJ3aXNlLCBwYXNzZXMgdGhyb3VnaCB0aGUgdmFsdWUuXG4gICAgICogYGBgdHNcbiAgICAgKiBtYXRoZi5hYnNaZXJvKC0wKSAgLS0+IDBcbiAgICAgKiBtYXRoZi5hYnNaZXJvKDApICAtLT4gMFxuICAgICAqIG1hdGhmLmFic1plcm8oMTApICAtLT4gMTBcbiAgICAgKiBtYXRoZi5hYnNaZXJvKC0xMikgIC0tPiAtMTJcbiAgICAgKiBgYGBcbiAgICAgKiBAdGVzdGVkXG4gICAgICovXG4gICAgc3RhdGljIGFic1plcm8odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5pcyh2YWx1ZSwgLTApID8gMCA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIG51bWJlciBsaWtlIGEgZmxvYXQgYW5kIGZpeGVzIGl0J3MgZGlnaXRzLlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogYGBgdHNcbiAgICAgKiAgIG1hdGhmLmZpeERpZ2l0cygyMC4xMjM0NSwgMikgPT0+IDIwLjEyXG4gICAgICogICBtYXRoZi5maXhEaWdpdHMoMjAuMTIzNDUsIDMpID09PiAyMC4xMjNcbiAgICAgKiBgYGBcbiAgICAgKiBAdGVzdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgdG8gY29udmVydFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaWdpdHMgVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gb3V0cHV0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmaXhEaWdpdHModmFsdWUsIGRpZ2l0cykge1xuICAgICAgICByZXR1cm4gK3BhcnNlRmxvYXQodmFsdWUpLnRvRml4ZWQoZGlnaXRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBudW1iZXIgYW5kIGZvcmNlcyBpdCB0byBhbiBpbnQgd2l0aCByb3VuZGluZyB1cC5cbiAgICAgKiBgYGB0c1xuICAgICAqICAgbWF0aGYuaW50KDIwLjMzMzMpICAtLT4gMjBcbiAgICAgKiAgIG1hdGhmLmludCgyMC4zMikgICAgLS0+IDIwXG4gICAgICogICBtYXRoZi5pbnQoMjAuNSkgICAgLS0+IDIxXG4gICAgICogICBtYXRoZi5pbnQoMjApICAgICAgIC0tPiAyMFxuICAgICAqIGBgYFxuICAgICAqIEB0ZXN0ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciB0byBjb252ZXJ0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpZ2l0cyBUaGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBvdXRwdXQuXG4gICAgICovXG4gICAgc3RhdGljIGludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbWF0aGYuZml4RGlnaXRzKHZhbHVlLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUYWtlcyBhIG51bWJlciBhbmQgZm9yY2VzIGl0IHRvIGFuIGludCBieSBzaW1wbHkgZHJvcHBpbmcgZGVjaW1hbHMuXG4gICAgICogYGBgdHNcbiAgICAgKiAgIG1hdGhmLmludCgyMC4zMzMzKSAgLS0+IDIwXG4gICAgICogICBtYXRoZi5pbnQoMjAuMzIpICAgIC0tPiAyMFxuICAgICAqICAgbWF0aGYuaW50KDIwLjU1NSkgIC0tPiAyMFxuICAgICAqICAgbWF0aGYuaW50KDIwLjk5OTkpICAtLT4gMjBcbiAgICAgKiAgIG1hdGhmLmludCgyMCkgICAgICAgLS0+IDIwXG4gICAgICogYGBgXG4gICAgICogQHRlc3RlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIHRvIGNvbnZlcnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlnaXRzIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIG91dHB1dC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50MCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPj4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmxpcHMgYSBjb2luLiAgR2l2ZSB5b3UgZWl0aGVyIGEgMSBvciAwLlxuICAgICAqL1xuICAgIHN0YXRpYyBmbGlwQ29pbigpIHtcbiAgICAgICAgcmV0dXJuIG1hdGhmLmdldFJhbmRvbUludCgwLCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJhbmRvbSBudW1iZXIgKGZsb2F0KSBiZXR3ZWVuIG1pbiAoaW5jbHVzaXZlKSBhbmQgbWF4IChleGNsdXNpdmUpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHJhbmdlLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gQSByYW5kb20gbnVtYmVyIGJldHdlZW4gdGhlIHByb3ZpZGVkIHJhbmdlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSYW5kb21GbG9hdChtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gKGluY2x1c2l2ZSkgYW5kIG1heCAoaW5jbHVzaXZlKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSByYW5nZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgcmFuZG9tIGludGVnZXIgYmV0d2VuIHRoZSBwcm92aWRlZCByYW5nZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UmFuZG9tSW50KG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmFuZG9tIGludGVncmF0ZXIgYmV0d2VlbiBtaW4gYW5kIG1heCBidXQgZW5zdXJlcyBpdCBpcyBub3QgYVxuICAgICAqIGNlcnRhaW4gdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBub3QgVGhlIHZhbHVlIGl0IHNob3VsZCBub3QgYmUuXG4gICAgICovXG4gICAgc3RhdGljIGdldFVuaXF1ZVJhbmRvbUludChtaW4sIG1heCwgbm90KSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbSA9IG1hdGhmLmdldFJhbmRvbUludChtaW4sIG1heCk7XG4gICAgICAgIGlmIChyYW5kb20gPT09IG5vdCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGhmLmdldFVuaXF1ZVJhbmRvbUludChtaW4sIG1heCwgbm90KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByYW5kb207XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xhbXBzIGEgbnVtYmVyIHRvIGEgZ2l2ZW4gcmFuZ2UuXG4gICAgICogYGBgdHNcbiAgICAgKiBtYXRoZi5jbGFtcCgwLCAxMCwgMTAwKSAgLS0+IDEwXG4gICAgICogbWF0aGYuY2xhbXAoMCwgMTAsIC0xMCkgIC0tPiAwXG4gICAgICogYGBgXG4gICAgICogQHRlc3RlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmludW0gdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB2YWx1ZTpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdG8gbGltaXQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBBIG51bWJlciB3aXRoaW4gdGhlIG1pbiBhbmQgbWF4IHJhbmdlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjbGFtcChtaW4sIG1heCwgbnVtKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChudW0sIG1pbiksIG1heCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgcHJvZ3Jlc3MgKGEgdmFsdWUgdGhhdCByYW5nZXMgZnJvbSAwIHRvIDEpLCB0aGlzIG1ldGhvZCBhbGxvd3MgeW91XG4gICAgICogdG8gY3JlYXRlIGEgY2hpbGQgcHJvZ3Jlc3MgYmFzZWQgb24gdGhlIHBhcmVudCBwcm9ncmVzcy5cbiAgICAgKlxuICAgICAqIEltYWdpbmcgdGhlIGZvbGxvd2luZyBwcm9ncmVzcy5cbiAgICAgKiBgYGBcbiAgICAgKiBQYXJlbnQgcHJvZ3Jlc3NcbiAgICAgKiAwIC0tLS0tMC4yLS0tLS0tMC40LS0tLS0tLTAuNi0tLS0tLS0wLjgtLS0tLS0xXG4gICAgICpcbiAgICAgKiBDaGlsZCBwcm9ncmVzc1xuICAgICAqICAgICAgICAwLjItLS0tLS0tLS0tLS0tLS0tMC42XG4gICAgICpcbiAgICAgKiBtYXRoZi5jaGlsZFByb2dyZXNzKHBhcmVudFByb2dyZXNzLCAwLjIsIDAuNilcbiAgICAgKiBgYGBcbiAgICAgKiBJZiB5b3UgaGF2ZSBhIHBhcmVudCBwcm9ncmVzcyBydW5ubmluZyBmcm9tIDAgdG8gMSBhbmQgIHlvdSB3YW50ZWQgeW91ciBjaGlsZFxuICAgICAqIHByb2dyZXNzIHRvIHN0YXJ0IGF0IDAuMiBhbmQgZW5kIGF0IDAuNi5cbiAgICAgKlxuICAgICAqIEdpdmVuIHRoZSBwYXJlbnQgcHJvZ3Jlc3MsICB0aGlzIG1ldGhvZCB3b3VsZCByZXR1cm46XG4gICAgICogYGBgXG4gICAgICogUGFyZW50IHByb2dyZXNzICAgICAgICBPdXRwdXRcbiAgICAgKiAwICAgICAgICAgICAgLS0tLS0tLS0tPiAgIDBcbiAgICAgKiB8XG4gICAgICogMC4yICAgICAgICAgIC0tLS0tLS0tLT4gICAwXG4gICAgICogMC4zICAgICAgICAgIC0tLS0tLS0tLT4gICAwLjI1XG4gICAgICogMC40ICAgICAgICAgIC0tLS0tLS0tLT4gICAwLjVcbiAgICAgKiAwLjUgICAgICAgICAgLS0tLS0tLS0tPiAgIDAuNzVcbiAgICAgKiAwLjYgICAgICAgICAgLS0tLS0tLS0tPiAgIDFcbiAgICAgKiAwLjcgICAgICAgICAgLS0tLS0tLS0tPiAgIDFcbiAgICAgKiB8XG4gICAgICogMSAgICAgICAgICAgIC0tLS0tLS0tLT4gICAxXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAdGVzdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgcGFyZW50IHByb2dyZXNzIGFzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnRpbmcgdmFsdWUgb2YgdGhlIGNoaWxkIHByb2dyZXNzLiAgVmFsdWVcbiAgICAgKiAgICAgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCB2YWx1ZSBvZiB0aGUgY2hpbGQgcHJvZ3Jlc3MuICBWYWx1ZVxuICAgICAqICAgICBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICovXG4gICAgc3RhdGljIGNoaWxkUHJvZ3Jlc3MocHJvZ3Jlc3MsIHN0YXJ0LCBlbmQsIG5vQ2xhbXAgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCByYW5nZSA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICBsZXQgY2hpbGRQcm9ncmVzcyA9IG1hdGhmLmNsYW1wKDAsIDEsIHByb2dyZXNzIC0gc3RhcnQpO1xuICAgICAgICBpZiAobm9DbGFtcCkge1xuICAgICAgICAgICAgY2hpbGRQcm9ncmVzcyA9IHByb2dyZXNzIC0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRQcm9ncmVzcyA9IGNoaWxkUHJvZ3Jlc3MgLyByYW5nZTtcbiAgICAgICAgaWYgKG5vQ2xhbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFByb2dyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGhmLmNsYW1wQXNQZXJjZW50KGNoaWxkUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvdW5kcyB0byBhIHNwZWNpZmljIHByZWNpc2lvbi5cbiAgICAgKiBgYGBcbiAgICAgKiBtYXRoZi5yb3VuZFRvUHJlY2lzaW9uKDAuNDk5OTksIDEpICAtLT4gMC41XG4gICAgICogbWF0aGYucm91bmRUb1ByZWNpc2lvbigwLjQ5OTk5LCAyKSAgLS0+IDAuNVxuICAgICAqIG1hdGhmLnJvdW5kVG9QcmVjaXNpb24oMC40MTE5OSwgMykgIC0tPiAwLjQxMlxuICAgICAqIG1hdGhmLnJvdW5kVG9QcmVjaXNpb24oMC41NTU1LCAzKSAgLS0+IDAuNTU2XG4gICAgICogbWF0aGYucm91bmRUb1ByZWNpc2lvbigwLjU1NTUsIDIpICAtLT4gMC41NlxuICAgICAqIGBgYFxuICAgICAqIEB0ZXN0ZWRcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gcHJlY2lzaW9uXG4gICAgICovXG4gICAgc3RhdGljIHJvdW5kVG9QcmVjaXNpb24odmFsdWUsIHByZWNpc2lvbikge1xuICAgICAgICBwcmVjaXNpb24gPSBtYXRoZi5pbnQocHJlY2lzaW9uKTtcbiAgICAgICAgY29uc3Qgc2hpZnRlciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIHNoaWZ0ZXIpIC8gc2hpZnRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmxvb3JzIG51bWJlciB0byBhIHNwZWNpZmljIHByZWNpc2lvbi5cbiAgICAgKiBgYGBcbiAgICAgKiBtYXRoZi5mbG9vclRvUHJlY2lzaW9uKDAuNTU1NSwgMykgIC0tPiAwLjU1NVxuICAgICAqIG1hdGhmLmZsb29yVG9QcmVjaXNzaW9uKDAuNTU1NSwgMikgIC0tPiAwLjU1XG4gICAgICogYGBgXG4gICAgICogQHRlc3RlZFxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBwcmVjaXNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZmxvb3JUb1ByZWNpc2lvbih2YWx1ZSwgcHJlY2lzaW9uKSB7XG4gICAgICAgIHByZWNpc2lvbiA9IG1hdGhmLmludChwcmVjaXNpb24pO1xuICAgICAgICBjb25zdCBzaGlmdGVyID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlICogc2hpZnRlcikgLyBzaGlmdGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDZWlscyBudW1iZXIgdG8gYSBzcGVjaWZpYyBwcmVjaXNpb24uXG4gICAgICogYGBgXG4gICAgICogbWF0aGYuY2VpbFRvUHJlY2lzaW9uKDAuNTU1NSwgMykgIC0tPiAwLjU1NVxuICAgICAqIG1hdGhmLmNlaWxUb1ByZWNpc3Npb24oMC41NTU1LCAyKSAgLS0+IDAuNTVcbiAgICAgKiBgYGBcbiAgICAgKiBAdGVzdGVkXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIHByZWNpc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBjZWlsVG9QcmVjaXNpb24odmFsdWUsIHByZWNpc2lvbikge1xuICAgICAgICBwcmVjaXNpb24gPSBtYXRoZi5pbnQocHJlY2lzaW9uKTtcbiAgICAgICAgY29uc3Qgc2hpZnRlciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHZhbHVlICogc2hpZnRlcikgLyBzaGlmdGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIG51bWJlciB0byBhIHNwZWNpZmljIG51bWJlciBvZiBkZWNpbWFzbFxuICAgICAqIGBgYFxuICAgICAqIG1hdGhmLnRvRml4ZWQoMS45NDMsIDIpIC0tPiAxLjk0XG4gICAgICogbWF0aGYudG9GaXhlZCgxLjk0MywgMSkgLS0+IDEuOVxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBwcmVjaXNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgdG9GaXhlZCh2YWx1ZSwgcHJlY2lzaW9uKSB7XG4gICAgICAgIHJldHVybiArdmFsdWUudG9GaXhlZChwcmVjaXNpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludC5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludC5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnMuXG4gICAgICovXG4gICAgc3RhdGljIGFuZ2xlUmFkaWFucyh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBwb2ludHMgZ2l2ZW4gY2FydGVzaWFuIGNvb3JkaW5hdGVzIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludC5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkxIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludC5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQuXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50LlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFuZ2xlIGluIGRlZ3JlZXMuXG4gICAgICovXG4gICAgc3RhdGljIGFuZ2xlRGVncmVlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKSAqIDE4MCkgLyBNYXRoLlBJO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGFuZ3VsYXIgZGlzdGFuY2UgYmV0d2VlbiB0d28gYW5nbGVzIGluIGRlZ3JlZS5cbiAgICAgKlxuICAgICAqIEluIGEgMzYwIGNpcmNsZSwgaWYgeW91IGhhZCBvbmUgZGVncmUgYXQgOTAgYW5kIGFub3RoZXIgYXQgODAsXG4gICAgICogdGhlIGFuZ2xlIGRpc3RhbmNlIGlzIDEwLCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28uXG4gICAgICpcbiAgICAgKiBFeGFtcGxlc1xuICAgICAqIGBgYHRzXG4gICAgICogICBtYXRoZi5hbmdsZURpc3RhbmNlRGVncmVlKDEwLCAxMCkgPT0+IDBcbiAgICAgKiAgIG1hdGhmLmFuZ2xlRGlzdGFuY2VEZWdyZWUoMzAsIDEwKSA9PT4gLTIwXG4gICAgICogICBtYXRoZi5hbmdsZURpc3RhbmNlRGVncmVlKDEwLCA1MCkgPT0+IDQwICogICBtYXRoZi5hbmdsZURpc3RhbmNlRGVncmVlKDEwLCAzNDApID09PiAtMzAgKiBgYGAgKlxuICAgICAqIEB0ZXN0ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUwIFRoZSBmaXJzdCBhbmdsZSBpbiBkZWdyZWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZTEgVGhlIHNlY29uZCBhbmdsZSBpbiBkZWdyZWVzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyP30gbWF4IFRoZSBtYXggdmFsdWUgYXQgd2hpY2ggcG9pbnQgdGhlIG51bWVyaWNhbCBzeXN0ZW1cbiAgICAgKiAgICAgcmVwZWF0cy4gIEluIGEgY2lyY2xlIHRoaXMgd291bGQgYmUgMzYwLiAgVGhpcyB2YWx1ZSBkZWZhdWx0cyB0byAzNjAuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBEaXN0YW5jZSBpbiBkZWdyZWVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhbmdsZURpc3RhbmNlRGVncmVlKGFuZ2xlMCwgYW5nbGUxLCBtYXgpIHtcbiAgICAgICAgY29uc3QgYW5nbGUwUmFkID0gbWF0aGYuZGVncmVlVG9SYWRpYW4oYW5nbGUwKTtcbiAgICAgICAgY29uc3QgYW5nbGUxUmFkID0gbWF0aGYuZGVncmVlVG9SYWRpYW4oYW5nbGUxKTtcbiAgICAgICAgaWYgKG1heCkge1xuICAgICAgICAgICAgbWF4ID0gbWF0aGYuZGVncmVlVG9SYWRpYW4obWF4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBtYXRoZi5hbmdsZURpc3RhbmNlUmFkaWFuKGFuZ2xlMFJhZCwgYW5nbGUxUmFkLCBtYXgpO1xuICAgICAgICByZXR1cm4gbWF0aGYucmFkaWFuVG9EZWdyZWUocmVzdWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBhbmd1bGFyIGRpc3RhbmNlIGJldHdlZW4gdHdvIGFuZ2xlcyBpbiByYWRpYW5zLlxuICAgICAqIFtbbWF0aGYuYW5nbGVEaXN0YW5jZURlZ3JlZV1dIGZvciBtb3JlIGluZm9ybWF0aW9uIGFuZCBlcXVpdmVsYW50IGRlZ3JlZVxuICAgICAqIHNhbXBsZXMuXG4gICAgICogQHRlc3RlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZTAgVGhlIGZpcnN0IGFuZ2xlIGluIHJhZGlhbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUxIFRoZSBzZWNvbmQgYW5nbGUgaW4gZGVncmVlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcj99IG1heCBUaGUgbWF4IHZhbHVlIGF0IHdoaWNoIHBvaW50IHRoZSBudW1lcmljYWwgc3lzdGVtXG4gICAgICogICAgIHJlcGVhdHMuICBJbiBhIGNpcmNsZSB0aGlzIHdvdWxkIGJlIDIgcmFkaWFuLiAgVGhpcyB2YWx1ZSBkZWZhdWx0cyB0b1xuICAgICAqICAgICAyIHJhZGlhbi5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IERpc3RhbmNlIGluIHJhZGlhbnNcbiAgICAgKi9cbiAgICBzdGF0aWMgYW5nbGVEaXN0YW5jZVJhZGlhbihhbmdsZTAsIGFuZ2xlMSwgbWF4KSB7XG4gICAgICAgIGlmICghbWF4KSB7XG4gICAgICAgICAgICBtYXggPSBNYXRoLlBJICogMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IChhbmdsZTEgLSBhbmdsZTApICUgbWF4O1xuICAgICAgICByZXR1cm4gKCgyICogZGVsdGEpICUgbWF4KSAtIGRlbHRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyByYWRpYW5zIHRvIGRlZ3JlZXMuXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBkZWcgVGhlIGRlZ3JlZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjb252ZXJ0ZWQgcmFkaWFuLlxuICAgICAqL1xuICAgIHN0YXRpYyBkZWdyZWVUb1JhZGlhbihkZWcpIHtcbiAgICAgICAgcmV0dXJuIGRlZyAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgcmFkaWFucyB0byBkZWdyZWVzLlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcmFkaWFuIFRoZSByYWRpYW4gdmFsdWUuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgY29udmVydGVkIGRlZ3JlZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmFkaWFuVG9EZWdyZWUocmFkaWFuKSB7XG4gICAgICAgIHJldHVybiAocmFkaWFuICogMTgwKSAvIE1hdGguUEk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgY29sbGlzaW9uIGRldGVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYSBBbiBvYmplY3Qgd2l0aCB4LCB5LCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiIEFuIG9iamVjdCB3aXRoIHgsIHksIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgYXJlYXMgYXJlIGNvbGxpZGluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYm94Q29sbGlzaW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICEoYS55ICsgYS5oZWlnaHQgPCBiLnkgfHxcbiAgICAgICAgICAgIGEueSA+IGIueSArIGIuaGVpZ2h0IHx8XG4gICAgICAgICAgICBhLnggKyBhLndpZHRoIDwgYi54IHx8XG4gICAgICAgICAgICBhLnggPiBiLnggKyBiLndpZHRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBjaXJjdWxhciBhbmQgcmVjdGFuZ3VsYXIgb2JqZWN0LCBkZXRlY3RzIHdoZW4gdGhlIHR3byBjb2xsaWRlXG4gICAgICogd2l0aCBlYWNoIG90aGVyIG9uIGEgMmQgc3BhY2UuICBBc3N1bWVzIEJveCBpcyB1bnJvdGF0ZWQuXG4gICAgICogQHBhcmFtIHJlY3QgQW4gb2JqZWN0IHdpdGggeCwgeSwgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgKiBAc2VlIGh0dHBzOi8veWFsLmNjL3JlY3RhbmdsZS1jaXJjbGUtaW50ZXJzZWN0aW9uLXRlc3QvXG4gICAgICovXG4gICAgc3RhdGljIGNvbGxpc2lvbkNpcmNWc0JveChjaXJjLCByZWN0KSB7XG4gICAgICAgIGNvbnN0IGR4ID0gY2lyYy54IC0gTWF0aC5tYXgocmVjdC54LCBNYXRoLm1pbihjaXJjLngsIHJlY3QueCArIHJlY3Qud2lkdGgpKTtcbiAgICAgICAgY29uc3QgZHkgPSBjaXJjLnkgLSBNYXRoLm1heChyZWN0LnksIE1hdGgubWluKGNpcmMueSwgcmVjdC55ICsgcmVjdC5oZWlnaHQpKTtcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5IDwgY2lyYy5yYWRpdXMgKiBjaXJjLnJhZGl1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSB0ZXN0IHdoZXRoZXIgYSBwb2ludCByZXNpemVkIGluc2lkZSBhIGNvbnZleCBwb2x5Z29uIHVzaW5nXG4gICAgICogcmF5Y2FzdGluZy5cbiAgICAgKiBAcGFyYW0gcG9pbnQgQW4gb2JqZWN0IHdpdGggeCx5IGNvb3JkcyBvZiB0aGUgcG9pbnQuXG4gICAgICogQHBhcmFtIHBvbHkgQW4gYXJyYXkgb2YgeCx5IHBvaW50cyBvZiBhIHBvbHlnb24uXG4gICAgICogQHJldHVybiBXaGV0aGVyIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHBvbHlnb24gb3Igbm90LlxuICAgICAqIEBzZWUgaHR0cDovL3d3dy5lY3NlLnJwaS5lZHUvSG9tZXBhZ2VzL3dyZi9SZXNlYXJjaC9TaG9ydF9Ob3Rlcy9wbnBvbHkuaHRtbFxuICAgICAqIEBzZWUgaHR0cHM6Ly9nYW1lZGV2ZWxvcG1lbnQudHV0c3BsdXMuY29tL3R1dG9yaWFscy9jb2xsaXNpb24tZGV0ZWN0aW9uLXVzaW5nLXRoZS1zZXBhcmF0aW5nLWF4aXMtdGhlb3JlbS0tZ2FtZWRldi0xNjlcbiAgICAgKiBAc2VlIGh0dHBzOi8vd3d3LmdhbWVkZXZlbG9wbWVudC5ibG9nL2NvbGxpc2lvbi1kZXRlY3Rpb24tY2lyY2xlcy1yZWN0YW5nbGVzLWFuZC1wb2x5Z29ucy9cbiAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIyNTIxOTgyL2NoZWNrLWlmLXBvaW50LWluc2lkZS1hLXBvbHlnb25cbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWtvbGFseXNlbmtvL3JvYnVzdC1wb2ludC1pbi1wb2x5Z29uL2Jsb2IvbWFzdGVyL3JvYnVzdC1wbnAuanNcbiAgICAgKi9cbiAgICBzdGF0aWMgY29sbGlzaW9uUG9pbnRWZXJzdXNDb252ZXhQb2x5Z29uKHBvaW50LCBwb2x5KSB7XG4gICAgICAgIC8vIFdlIGdvIGFyb3VuZCBpbiB0aGUgcG9seWdvbi5cbiAgICAgICAgLy8gQXNzdW1pbmcgdGhlcmUgYXJlIGZvdXIgcG9pbnQgKGJ1dCBjb3VsZCBiZSBtb3JlKSxcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAwLS0tLTFcbiAgICAgICAgLy8gICB8ICAgIHxcbiAgICAgICAgLy8gICAzLS0tLTJcbiAgICAgICAgLy8gV2UgcGVyZm9ybSByYXljYXN0aW5nLCAwLTMsIDEtMCwgMi0xLCAzLTIgcG9pbnRzLlxuICAgICAgICAvL1xuICAgICAgICBsZXQgaXNJbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBvbHkubGVuZ3RoO1xuICAgICAgICBsZXQgcG9pbnRQb2x5QUluZGV4ID0gMDtcbiAgICAgICAgbGV0IHBvaW50UG9seUJJbmRleCA9IHNpemUgLSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcG9seUEgPSBwb2x5W3BvaW50UG9seUFJbmRleF07XG4gICAgICAgICAgICBjb25zdCBwb2x5QiA9IHBvbHlbcG9pbnRQb2x5QkluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdHMgPSBwb2x5QS55ID4gcG9pbnQueSAhPT0gcG9seUIueSA+IHBvaW50LnkgJiZcbiAgICAgICAgICAgICAgICBwb2ludC54IDxcbiAgICAgICAgICAgICAgICAgICAgKChwb2x5Qi54IC0gcG9seUEueCkgKiAocG9pbnQueSAtIHBvbHlBLnkpKSAvIChwb2x5Qi55IC0gcG9seUEueSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9seUEueDtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKSB7XG4gICAgICAgICAgICAgICAgaXNJbnNpZGUgPSAhaXNJbnNpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludFBvbHlCSW5kZXggPSBwb2ludFBvbHlBSW5kZXg7XG4gICAgICAgICAgICBwb2ludFBvbHlBSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNJbnNpZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSByb3RhdGlvbmFsIG1hdHJpeCB0byBjYWxjdWxhdGUgdGhlIG5ldyBjb29yZGluYXRlcyBvZiBhIHJvdGF0ZWRcbiAgICAgKiBwb2ludC5cbiAgICAgKlxuICAgICAqIFB1dCBhbm90aGVyIHdheSwgZ2l2ZW4gcG9pbnQgeCBhbmQgeSwgYW5kIGEgY2VudGVyIHBvaW50IG9mIGN4IGFuZCBjeSxcbiAgICAgKiBjYWxjdWxhdGVzIHRoZSB0cmFuc2xhdGVkIHgsIHkgcG9pbnRzIHdoZW4gcm90YXRlZCBhdCBhIGdpdmVuIGFuZ2xlLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgIDAsMC0tLS0tLS0tLS0tLS0tNCwwXG4gICAgICogICAgICAgfCAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgICB8ICAgICAgIDIsMiAgICAgfFxuICAgICAqICAgICAgIHwgICAgICAgICAgICAgICB8XG4gICAgICogICAgICAwLDQgLS0tLS0tLS0tLS0tIDQsNFxuICAgICAqXG4gICAgICogU2F5IGZvciBleGFtcGxlIHlvdSBoYXZlIGEgcmVjdGFuZ2xlLiAgVGhlIHJvdGF0aW9uYWwgY2VudGVyIG9mIHRoZVxuICAgICAqIHJlY3RhbmdsZSBpcyB0aGUgY2VudGVyIGluIHRoaXMgY2FzZSBhdCAyLDIuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHVzZSB0aGlzIGFsZ28gdG8gY2FsY3VsYXRlIHJvdGF0aW9uLlxuICAgICAqIExldHMgc2F5IHlvdSByb3RhdGUgdGhlIHJlY3RhbmdsZSBieSAxIHJhZGlhbiAofjU3IGRlZ3JlZXMpLlxuICAgICAqIFdoYXQgaXMgdGhlIG5ldyBjb29yZGluYXRlcyBvZiB0aGUgdG9wIHJpZ2h0IGNvcm5lcj9cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IG5ld0Nvb3JkcyA9IG1hdGhmLmNhbGN1bGF0ZTJkUG9pbnRSb3RhdGlvbigyLDIsNCwwLDEpO1xuICAgICAqXG4gICAgICogbmV3Q29vcmRzLng7ICAvLyAxLjM5OFxuICAgICAqIG5ld0Nvb3Jkcy55OyAgLy8gLTAuNzY0XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRyb3VibGVzaG9vdD9cbiAgICAgKlxuICAgICAqIFRoZSBtb3N0IGNvbW1vbiBpc3N1ZSBpcyB0aGF0IHlvdXIgcm90YXRpb24gdmFsdWUgaXMgaW52ZXJ0ZWQuXG4gICAgICogVHJ5IHBhc3NpbmcgaW4gLXJvdGF0aW9uIGFuZCBzZWUgaWYgdGhhdCBoZWxwcy5cbiAgICAgKlxuICAgICAqIGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9eHNOOGNENm9pc1kmZmVhdHVyZT15b3V0dS5iZVxuICAgICAqIGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9YTU5WVE0cWU3bUVcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb3RhdGlvbl9tYXRyaXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjeCBUaGUgeCBjZW50ZXIgcG9pbnQgdG8gcm90YXRlIGFyb3VuZC5cbiAgICAgKiBAcGFyYW0gY3kgVGhlIHkgY2VudGVyIHBvaW50IHRvIHJvdGF0ZSBhcm91bmQuXG4gICAgICogQHBhcmFtIHggVGhlIHggdmFsdWUgb2YgdGhlIHBvaW50IHRvIGJlIHJvdGF0ZWQgcHJpb3IgdG8gcm90YXRpb24uXG4gICAgICogQHBhcmFtIHkgVGhlIHkgdmFsdWUgb2YgdGhlIHBvaW50IHRvIGJlIHJvdGF0ZWQgcHJpb3IgdG8gcm90YXRpb24uXG4gICAgICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gICAgICogQHRlc3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGUyZFBvaW50Um90YXRpb24oY3gsIGN5LCB4LCB5LCBhbmdsZSkge1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgY29uc3QgdHggPSBjb3MgKiAoeCAtIGN4KSArIHNpbiAqICh5IC0gY3kpICsgY3g7XG4gICAgICAgIGNvbnN0IHR5ID0gY29zICogKHkgLSBjeSkgLSBzaW4gKiAoeCAtIGN4KSArIGN5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogdHgsXG4gICAgICAgICAgICB5OiB0eSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlcyBhIHBvaW50IGFyb3VuZCBhbm90aGVyIHBvaW50IHdpdGggYW5nbGUgYW5kIGRpc3RhbmNlLlxuICAgICAqIFRoaXMgaXMgc2ltaWxhciB0b1xuICAgICAqIFtbbWF0aGYuY2FsY3VsYXRlMmRQb2ludFJvdGF0aW9uXV0gZXhjZXB0IHRoYXQgeW91IGFyZSBzcGVjaWZ5aW5nIGFcbiAgICAgKiBkaXN0YW5jZSBhcyB3ZWxsLlxuICAgICAqIEBwYXJhbSBjeCBUaGUgeCBjZW50ZXIgcG9pbnQgdG8gcm90YXRlIGFyb3VuZC5cbiAgICAgKiBAcGFyYW0gY3kgVGhlIHkgY2VudGVyIHBvaW50IHRvIHJvdGF0ZSBhcm91bmQuXG4gICAgICogQHBhcmFtIHggVGhlIHggdmFsdWUgb2YgdGhlIHBvaW50IHRvIGJlIHJvdGF0ZWQgcHJpb3IgdG8gcm90YXRpb24uXG4gICAgICogQHBhcmFtIHkgVGhlIHkgdmFsdWUgb2YgdGhlIHBvaW50IHRvIGJlIHJvdGF0ZWQgcHJpb3IgdG8gcm90YXRpb24uXG4gICAgICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gICAgICogQHBhcmFtIGRpc3RhbmNlIFRoZSBkaXN0YW5jZSBmcm9tIGN4IGFuZCBjeSBpbiB3aGljaCB3ZSBzaG91bGQgcGxhY2UgdGhlXG4gICAgICogICAgIG5ldyBjb29yZGluYXRlcyB0by5cbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY3VsYXRlMmRQb2ludFJvdGF0aW9uV2l0aERpc3RhbmNlKGN4LCBjeSwgeCwgeSwgYW5nbGUsIGRpc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IHQgPSBhbmdsZSArIE1hdGguYXRhbjIoeSAtIGN5LCB4IC0gY3gpO1xuICAgICAgICB4ID0gY3ggKyBkaXN0YW5jZSAqIE1hdGguY29zKHQpO1xuICAgICAgICB5ID0gY3kgKyBkaXN0YW5jZSAqIE1hdGguc2luKHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIG9mIHR3byBzZXRzIG9mIHgsIHkgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB4MSBUaGUgeCB2YWx1ZSBvZiBwb2ludCAxLlxuICAgICAqIEBwYXJhbSAge251bWJlcn0geTEgVGhlIHkgdmFsdWUgb2YgcG9pbnQgMS5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyIFRoZSB4IHZhbHVlIG9mIHBvaW50IDIuXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB5MiBUaGUgeSB2YWx1ZSBvZiBwb2ludCAyLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnQgMSBhbmQgcG9pbnQgMi5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MiAtIHgxLCAyKSArIE1hdGgucG93KHkyIC0geTEsIDIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGlyZWN0aW9uIGluIHdoaWNoIGEgbnVtYmVyIGlzIHByb2dyZXNzLlxuICAgICAqIDAgbWVhbnMgdGhlIHNhbWUsIG5vIG1vdmVtZW50LlxuICAgICAqIDEgbWVhbnMgbW92aW5nIGZvcndhcmQuXG4gICAgICogLTEgbWVhbnMgbW92aW5nIGJhY2t3YXJkcy5cbiAgICAgKiBgYGB0c1xuICAgICAqIG1hdGZoLmRpcmVjdGlvbigxLCAyKSAtLS0+IDFcbiAgICAgKiBtYXRmaC5kaXJlY3Rpb24oMywgMSkgLS0tPiAtMVxuICAgICAqIG1hdGZoLmRpcmVjdGlvbigxLCAxKSAtLS0+IDBcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gcHJldmlvdXNcbiAgICAgKiBAcGFyYW0gY3VycmVudFxuICAgICAqIEB0ZXN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZGlyZWN0aW9uKHByZXZpb3VzLCBjdXJyZW50KSB7XG4gICAgICAgIGlmIChwcmV2aW91cyA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXZpb3VzIDwgY3VycmVudCA/IDEgOiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgb2Zmc2V0IHZhbHVlIHRvIGNlbnRlciBhIGdpdmVuIGVsZW1lbnQgd2l0aGluIGEgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogSW1hZ2luZSB0aGUgYmVsb3c6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS04IChwYXJlbnQpLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqIHwgICAgICAgICAgICAgfC0tLS01KGNoaWxkKS0tLS0tfCAgICAgICAgICAgfFxuICAgICAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqIHwtLS1vZmZzZXQtLXwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAgWW91IGhhdmUgYSBwYXJlbnQgb2Ygd2lkdGggOCBhbmQgY2hpbGQgb2Ygd2l0aCA1IGFuZCB5b3Ugd2FudCB0b1xuICAgICAqICBjZW50ZXIgdGhlIGNoaWxkLlxuICAgICAqXG4gICAgICogIEluIHRoZSBleGFtcGxlIGFib3ZlLCBwYXJlbnQgPSA4LCBjaGlsZCA9IDUsIHdvdWxkIHJldHVybiB0aGUgb2Zmc2V0IG9mIDEuNVxuICAgICAqICBTbyB5b3Uga25vdyB0aGF0IGlmIHlvdSBvZmZzZXR0ZWQgdGhlIGNoaWxkIGVsZW1lbnQgYnkgMS41LCBpdCB3b3VsZFxuICAgICAqICBob3Jpem9udGFsbHkgY2VudGVyLlxuICAgICAqXG4gICAgICogIFlvdSBjYW4gYWxzbyB1c2UgdGhpcyBtZXRob2QgdG8gY2FsY3VsYXRlIHZlcnRpY2FsIGFsaWdubWVudCBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgb2YgY2FsY3VsYXRpbmcgdGhlIHgsIHkgb2Zmc2V0cyB0byBjZW50ZXIgYW4gb2JqZWN0XG4gICAgICogdG8gdGhlIHNjcmVlbi5cbiAgICAgKiBgYGB0c1xuICAgICAqICBsZXQgeCA9IG1hdGhmLmNhbGN1bGF0ZUNlbnRlck9mZnNldChcbiAgICAgKiAgICAgc2NyZWVuLndpZHRoLCBvYmplY3Qud2lkdGgpO1xuICAgICAqICBsZXQgeSA9IG1hdGhmLmNhbGN1bGF0ZUNlbnRlck9mZnNldChcbiAgICAgKiAgICAgc2NyZWVuLmhlaWdodCwgb2JqZWN0LndpZHRoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAdGVzdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhcmVudCBUaGUgcGFyZW50IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoaWxkIFRoZSBjaGlsZCB2YWx1ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG9mZnNldCB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY2FsY3VsYXRlQ2VudGVyT2Zmc2V0KHBhcmVudCwgY2hpbGQpIHtcbiAgICAgICAgY29uc3QgaGFsZlBhcmVudCA9IHBhcmVudCAvIDI7XG4gICAgICAgIGNvbnN0IGhhbGZDaGlsZCA9IGNoaWxkIC8gMjtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaGFsZlBhcmVudCAtIGhhbGZDaGlsZDtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBrbm93biBzZXQgb2Ygc2l6ZXMsIHNjYWxlcyBhbmQgcmV0dXJucyBhIHkxLlxuICAgICAqXG4gICAgICogYGBgYGB0c1xuICAgICAqICB4MSAgICAgeDIgKHJldHVybilcbiAgICAgKiAtLS0tID0gLS0tLVxuICAgICAqICB5MSAgICAgeTJcbiAgICAgKlxuICAgICAqIGBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgc2NhbGVYKHgxLCB5MSwgeTIpIHtcbiAgICAgICAgcmV0dXJuICh4MSAqIHkyKSAvIHkxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGtub3duIHNldCBvZiBzaXplcywgc2NhbGVzIGFuZCByZXR1cm5zIGEgeTIuXG4gICAgICpcbiAgICAgKiBgYGBgYHRzXG4gICAgICogIHgxICAgICB4MlxuICAgICAqIC0tLS0gPSAtLS0tXG4gICAgICogIHkxICAgICB5MiAocmV0dXJuKVxuICAgICAqXG4gICAgICogYGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBzY2FsZVkoeDEsIHkxLCB4Mikge1xuICAgICAgICByZXR1cm4gKHgyICogeTEpIC8geDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgd2lkdGggYW5kIGhlaWdodCwgcmV0dXJucyB0aGUgYXNwZWN0IHJhdGlvLlxuICAgICAqIEBwYXJhbSB7Ym94fSBkaW1lbnNpb25hbEJveCBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXNwZWN0UmF0aW8oYm94KSB7XG4gICAgICAgIHJldHVybiBib3gud2lkdGggLyBib3guaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiBhIGdpdmVuIHZhbHVlIGlzIGJldHdlZW4gYSByYW5nZS5cbiAgICAgKiBAcGFyYW0gdGVzdFZhbHVlXG4gICAgICogQHBhcmFtIHJhbmdlMVxuICAgICAqIEBwYXJhbSByYW5nZTJcbiAgICAgKiBAcGFyYW0gaW5jbHVzaXZlIFdoZXRoZXIgdGhlIHRlc3Qgc2hvdWxkIGJlIGluY2x1c2l2ZS5cbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhlIHRlc3QgdmFsdWUgaXMgYmV0d2VlbiByYW5nZTEgYW5kIHJhbmdlMi5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNCZXR3ZWVuKHRlc3RWYWx1ZSwgcmFuZ2UxLCByYW5nZTIsIGluY2x1c2l2ZSA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4ocmFuZ2UxLCByYW5nZTIpO1xuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChyYW5nZTEsIHJhbmdlMik7XG4gICAgICAgIHJldHVybiBpbmNsdXNpdmVcbiAgICAgICAgICAgID8gdGVzdFZhbHVlID49IG1pbiAmJiB0ZXN0VmFsdWUgPD0gbWF4XG4gICAgICAgICAgICA6IHRlc3RWYWx1ZSA+IG1pbiAmJiB0ZXN0VmFsdWUgPCBtYXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgYSBnaXZlbiBkaW1lbnNpb25hbCBib3ggKHdpZHRoIGFuZCBoZWlnaHQpIHRvIGEgZ2l2ZW4gd2lkdGggd2hpbGVcbiAgICAgKiBtYWludGFpbmluZyB0aGUgYXNwZWN0IHJhdGlvLiAgVXNlZnVsIGZvciBzY2FsaW5nIHVwIG9yIGRvd24gYSBib3guXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEByZXR1cm4ge2RpbWVuc2lvbmFsQm94fVxuICAgICAqIEB0ZXN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVzaXplRGltZW5zaW9uYWxCb3hUb1dpZHRoKGJveCwgd2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBtYXRoZi5zY2FsZVkoYm94LndpZHRoLCBib3guaGVpZ2h0LCB3aWR0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgYSBnaXZlbiBkaW1lbnNpb25hbCBib3ggKHdpZHRoIGFuZCBoZWlnaHQpIHRvIGEgZ2l2ZW4gaGVpZ2h0IHdoaWxlXG4gICAgICogbWFpbnRhaW5pbmcgdGhlIGFzcGVjdCByYXRpby4gIFVzZWZ1bCBmb3Igc2NhbGluZyB1cCBvciBkb3duIGEgYm94LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBib3hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHJldHVybiB7ZGltZW5zaW9uYWxCb3h9XG4gICAgICogQHRlc3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyByZXNpemVEaW1lbnNpb25hbEJveFRvSGVpZ2h0KGJveCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogbWF0aGYuc2NhbGVYKGJveC53aWR0aCwgYm94LmhlaWdodCwgaGVpZ2h0KSxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xhbXBzIGEgdmFsdWUgd2l0aGluIDAtMS5cbiAgICAgKiBgYGB0c1xuICAgICAqIG1hdGhmLmNsYW1wQXNQZXJjZW50KDAuMikgLS0+IDAuMlxuICAgICAqIG1hdGhmLmNsYW1wQXNQZXJjZW50KDEpIC0tPiAxXG4gICAgICogbWF0aGYuY2xhbXBBc1BlcmNlbnQoLTIpIC0tPiAwXG4gICAgICogbWF0aGYuY2xhbXBBc1BlcmNlbnQoMikgLS0+ICAxXG4gICAgICogYGBgXG4gICAgICogQHRlc3RlZFxuICAgICAqIEBwYXJhbSBwZXJjZW50XG4gICAgICogQHJldHVybiBwZXJjZW50IEEgdmFsdWUgd2l0aGluIDAtMS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY2xhbXBBc1BlcmNlbnQocGVyY2VudCkge1xuICAgICAgICByZXR1cm4gbWF0aGYuY2xhbXAoMCwgMSwgbWF0aGYuYWJzWmVybyhwZXJjZW50KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsYW1wcyBhIG51bWJlciB0byB3aXRoaW4gMC0xLlxuICAgICAqIEFuIGFsaWFzIG9mIFtbbWF0aGYuY2xhbXBBc1Byb2dyZXNzXV1cbiAgICAgKiBAdGVzdGVkXG4gICAgICogQHBhcmFtIHByb2dyZXNzXG4gICAgICogQHJldHVybiBwcm9ncmVzcyBBIHZhbHVlIHdpdGhpbiAwLTEuXG4gICAgICovXG4gICAgc3RhdGljIGNsYW1wQXNQcm9ncmVzcyhwcm9ncmVzcykge1xuICAgICAgICByZXR1cm4gbWF0aGYuY2xhbXBBc1BlcmNlbnQocHJvZ3Jlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgYSBudW1iZXIgdG8gd2l0aGluIDAtMS5cbiAgICAgKiBBbiBhbGlhcyBvZiBbW21hdGhmLmNsYW1wQXNQcm9ncmVzc11dXG4gICAgICogQHRlc3RlZFxuICAgICAqIEBwYXJhbSBwcm9ncmVzc1xuICAgICAqIEByZXR1cm4gcHJvZ3Jlc3MgQSB2YWx1ZSB3aXRoaW4gMC0xLlxuICAgICAqL1xuICAgIHN0YXRpYyBjbGFtcDAxKHByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybiBtYXRoZi5jbGFtcEFzUGVyY2VudChwcm9ncmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZ2V0IGEgdmFsdWUgd2l0aGluIGEgcmFuZ2UgYnkgcHJvZ3Jlc3MuXG4gICAgICogTm90ZSB0aGlzIGlzIGFuIGFsaWFzIG9mIFtbbWF0aGYubGVycF1dIHNpbmNlIGl0J3MgdGhlIHNhbWUgdGhpbmcuXG4gICAgICpcbiAgICAgKiBGb3IgaW5zdGFuY2UsIGxldCdzIHNheSB5b3UgaGF2ZSBhIHJhbmdlIG9mIDMyNS0xNDUwLlxuICAgICAqIFlvdSB3YW50IDAlID0gMzI1IGFuZCAxMDAlID0gMTQ1MC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gcGFzcyBhIHByb2dyZXNzIChzdWNoIGFzIDIwJSBvciAwLjIpIGFuZCB0aGlzIHdpbGwgcmV0dXJuIHRoZSB2YWx1ZVxuICAgICAqIHdpdGhpbiB0aGF0IHJhbmdlLlxuICAgICAqXG4gICAgICogQHRlc3RlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwcm9ncmVzcyBUaGUgcGVyY2VudCB0byBjYWxjdWxhdGUuICBTaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIGxvdyBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIGhpZ2ggZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2YWx1ZSB3aXRoaW4gdGhlIHJhbmdlLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRWYWx1ZUluUmFuZ2VCeVByb2dyZXNzKHByb2dyZXNzLCBtaW4sIG1heCkge1xuICAgICAgICByZXR1cm4gbWF0aGYubGVycChtaW4sIG1heCwgcHJvZ3Jlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIGEgZ2l2ZW4gcmFuZ2UgKG1pbiBhbmQgbWF4KSB0byBhIHByb2dyZXNzIChhIHZhbHVlIGJldHdlZW4gMCBhbmRcbiAgICAgKiAxKVxuICAgICAqIEZvciBpbnN0YW5jZSwgbGV0J3Mgc2F5IHlvdSBoYXZlIGEgcmFuZ2Ugb2YgMzI1LTE0NTAuXG4gICAgICogWW91IHdhbnQgMCUgPSAzMjUgYW5kIDEwMCUgPSAxNDUwLlxuICAgICAqIFlvdSBjYW4gcGFzcyBhIHZhbHVlIDQyMCBhbmQgdGhpcyB3aWxsIHJldHVybiB0aGUgcHJvZ3Jlc3MgKHBlcmNlbnRhZ2UpLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqICAgIG1hdGhmLmdldFByb2dyZXNzSW5SYW5nZUJ5VmFsdWUoMiwgMCwgMTApIC8vIDAuMlxuICAgICAqICAgIG1hdGhmLmdldFByb2dyZXNzSW5SYW5nZUJ5VmFsdWUoMTAsIDAsIDEwKSAvLyAxXG4gICAgICogICAgbWF0aGYuZ2V0UHJvZ3Jlc3NJblJhbmdlQnlWYWx1ZSg3LCAyLCAxMikgLy8gMC41XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZGV0ZXJtaW5lIHRoZSBwcm9ncmVzcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBsb3cgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBoaWdoIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcHJvZ3Jlc3Mgd2l0aGluIHRoZSByYW5nZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UHJvZ3Jlc3NJblJhbmdlQnlWYWx1ZSh2YWwsIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiBtYXRoZi5jbGFtcEFzUGVyY2VudCgodmFsIC0gbWluKSAvIChtYXggLSBtaW4pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplZCBhIHZhbHVlIGJldHdlZW4gYSBtaW4gYW5kIG1heCByZXR1cm5pbmcgYSB2YWx1ZSBiZXR3ZWVuXG4gICAgICogMCBhbmQgMS5cbiAgICAgKiBBbiBhbGlhcyB0byBbW21hdGhmLmdldFByb2dyZXNzSW5SYW5nZUJ5VmFsdWVdXS5cbiAgICAgKi9cbiAgICBzdGF0aWMgbm9ybWFsaXplKHZhbCwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIG1hdGhmLmdldFByb2dyZXNzSW5SYW5nZUJ5VmFsdWUodmFsLCBtaW4sIG1heCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpbmVhciBpbnRlcnBvbGF0ZSBmcm9tIHN0YXJ0IHRvIGVuZCBnaXZlbiBhbW91bnQuXG4gICAgICogYGBgdHNcbiAgICAgKiBtYXRoZi5sZXJwKDAsIDEsIDApICAgLS0tPiAwXG4gICAgICogbWF0aGYubGVycCgwLCAxLCAwLjIpIC0tLT4gMC4yXG4gICAgICogbWF0aGYubGVycCgwLCAxLCAwLjUpIC0tLT4gMC41XG4gICAgICogbWF0aGYubGVycCgwLCAyLCAwLjUpIC0tLS0+IDFcbiAgICAgKiBtYXRoZi5sZXJwKDI1LCA3OSwgMC4yKSAtLS0tPiAzNS44XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBMZXJwIGNhbiBiZSB1c2VkIGZvciB2YXJpb3VzIHRoaW5ncy4gIFNlZSBbW21hdGhmLmdldFZhbHVlSW5SYW5nZUJ5UHJvZ3Jlc3NdXVxuICAgICAqIHdoaWNoIGlzIGFuIGFsaWFzIG9mIGxlcnAuXG4gICAgICpcbiAgICAgKiBMZXJwIGNhbiBhbHNvIGJlIHVzZWQgZm9yIGFuaW1hdGlvbnMuICAgSWYgeW91IHdlcmUgZG9pbmcgdGhlIG9sZCBzY2hvb2w6XG4gICAgICogYGBgdHNcbiAgICAgKiBvblJhZkxvb3AoKSB7XG4gICAgICogICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9uIGJ5IDIwJSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb3NpdGlvbiBhbmQgdGFyZ2V0LlxuICAgICAqICAgcG9zaXRpb24ueCArPSAodGFyZ2V0LnggLSBwb3NpdGlvbi54KSAqIDAuMjtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogdGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aDpcbiAgICAgKiBgYGB0c1xuICAgICAqIG9uUmFmTG9vcCgpIHtcbiAgICAgKiAgIC8vIFNhbWUgdGhpbmcuIFVwZGF0ZSB0aGUgcG9zaXRpb24gYnkgMjAlIG9mIHRoZSBkaXN0YW5jZSBiZXR3ZWVuXG4gICAgICogICAvLyBwb3NpdGlvbiBhbmQgdGFyZ2V0IG9uIGVhY2ggcmFmIGxvb3AuICBUaGlzIGhhcyB0aGUgZWZmZWN0IG9mXG4gICAgICogICAvLyB0d2VlbmluZyBpbiB0aGUgcG9zaXRpb24gdG8gdGhlIHRhcmdldC5cbiAgICAgKiAgIHBvc2l0aW9uLnggPSBtYXRoZi5sZXJwKHBvc2l0aW9uLngsIHRhcmdldC54LCAwLjIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEB0ZXN0ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUxIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG8gbGVycC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUyIFRoZSB0YXJnZXQgb2YgdGhlIHJhbmdlIHRvIGxlcnAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBBIHZhbHVlIGJldHdlZW4gMC0xIHJlcHJlc2VudGluZyB0aGUgcHJvZ3Jlc3Mgb2YgdGhlXG4gICAgICogICAgIGxlcnAuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW50ZXJwb3JhbGF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgc3RhdGljIGxlcnAodmFsdWUxLCB2YWx1ZTIsIGFtb3VudCkge1xuICAgICAgICBjb25zdCBjbGFtcGVkQW1vdW50ID0gbWF0aGYuY2xhbXAwMShhbW91bnQpO1xuICAgICAgICByZXR1cm4gKDEgLSBjbGFtcGVkQW1vdW50KSAqIHZhbHVlMSArIGNsYW1wZWRBbW91bnQgKiB2YWx1ZTI7XG4gICAgICAgIC8vIEFsdGVybmF0aXZlIHdheXMgdG8gY2FsY3VsYXRlIGxlcnAuXG4gICAgICAgIC8vIE5laXRoZXIgYmVoYXZlIHByb3Blcmx5IGZvciBsZXJwaW5nIGZyb20gbmVnYXRpdmUgdG8gcG9zaXRpdmVcbiAgICAgICAgLy8gcmV0dXJuIHZhbHVlMSArICh2YWx1ZTIgLSB2YWx1ZTEpICogbWF0aGYuY2xhbXAwMShhbW91bnQpO1xuICAgICAgICAvLyByZXR1cm4gKCh2YWx1ZTIgLSB2YWx1ZTEpICogYW1vdW50KSArIGFtb3VudFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIGxlcnAgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gYSBTdGFydCB2YWx1ZVxuICAgICAqIEBwYXJhbSBiIEVuZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB2YWx1ZSAgVmFsdWUgYmV0ZWVuIHN0YXJ0IGFuZCBlbmQuXG4gICAgICogQHBhcmFtIG5vQ2xhbXAgRGVmYXVsdHMgdG8gZmFsc2UsIHdoZXRoZXIgdG8gZGlzYWJsZSBjbGFtcGluZy5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgbm9ybWFsaXplZCB2YWx1ZSBiZXR3ZWVuIDAtMVxuICAgICAqL1xuICAgIHN0YXRpYyBpbnZlcnNlTGVycChhLCBiLCB2YWx1ZSwgbm9DbGFtcCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChub0NsYW1wKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIC0gYSkgLyAoYiAtIGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGhmLmNsYW1wMDEoKHZhbHVlIC0gYSkgLyAoYiAtIGEpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbm90aGVyIGxpbmVhciBpbnRlcnBvbGF0aW9uIG9wdGlvbi4gICBTYW1lIGFzIG1hdGhmLmxlcnAgYnV0IGRpZmZlcmVudCBhbGdvXG4gICAgICogd2l0aCBubyBoYXJkIGNsYW1waW5nLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBtYXRoZi5taXgoYSwgYiwgMC4wKSAtLS0+IGFcbiAgICAgKiBtYXRoZi5taXgoYSwgYiwgMS4wKSAtLS0+IGJcbiAgICAgKiBtYXRoZi5taXgoYSwgYiwgMC41KSAtLS0+IGJldHdlZW4geCBhbmQgeSwgYmxlbmRlZCB2YWx1ZXMuXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIGFcbiAgICAgKiBAcGFyYW0gYlxuICAgICAqIEBwYXJhbSBibGVuZFxuICAgICAqIEB1bnRlc3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBtaXgoYSwgYiwgYmxlbmQpIHtcbiAgICAgICAgcmV0dXJuIGEgKiAoMSAtIGJsZW5kKSArIGIgKiBibGVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RlcCBtZXRob2QuICBXaWxsICByZXR1cm4gMCBvciAxLlxuICAgICAqIElmIG4gaXMgZ3JlYXRlciB0aGFuIGVkZ2UsIDFcbiAgICAgKiBJZiBuIGlzIGxlc3MgdGhhbiBlZGdlLCAwXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIG1hdGhmLnN0ZXAoMSwgMikgLS0tPiAxXG4gICAgICogbWF0aGYuc3RlcCgxLCAwLjIpIC0tLT4gMFxuICAgICAqIG1hdGhmLnN0ZXAoMSwgMS4xKSAtLS0+IDFcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RlcChlZGdlLCBuKSB7XG4gICAgICAgIGlmIChuID4gZWRnZSkge1xuICAgICAgICAgICAgcmV0dXJuIDEuMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgc21vb3Roc3RlcCBmcm9tIG1pbiB0byBtYXggdXNpbmcgdGhlIGdpdmVuIHZhbHVlIHVzaW5nIEhlcm1pdGVcbiAgICAgKiBpbnRlcnBvbGF0aW9uLlxuICAgICAqXG4gICAgICogR2l2ZW4gdGhyZWUgdmFsdWVzLCBtaW4sIG1heCBhbmQgaW5wdXQsIHRoaXMgd2lsbCByZXR1cm4gYSBudW1iZXIgYmV0d2VlbiAwXG4gICAgICogYW5kIDEgdGhhdCByZXByZXNlbnRzIHRoZSBwcm9ncmVzcyBvZiB0aGUgaW5wdXQgdmFsdWUgdG8gdGhlIG1pbiBhbmQgbWF4XG4gICAgICogdmFsdWVzLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBzaW1pbGFyIHRvbyBbW21hdGhmLm5vcm1hbGl6ZV1dIG9yXG4gICAgICogW1ttYXRoZi5nZXRQcm9ncmVzc0luUmFuZ2VCeVZhbHVlXV0gZXhjZXB0IHRoZSBjdXJ2ZSBpcyBzbGlnaHRseSBzbW9vdGhlZFxuICAgICAqIG91dC5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbWF0aGYuc21vb3RoU3RlcCgxMDAsIDIwMCwgMTAwKTsgLy8gMFxuICAgICAqIG1hdGhmLnNtb290aFN0ZXAoMTAwLCAyMDAsIDE1MCk7IC8vIDAuNVxuICAgICAqIG1hdGhmLnNtb290aFN0ZXAoMTAwLCAyMDAsIDMwMCk7IC8vIDFcbiAgICAgKiBgYGBcbiAgICAgKiBAc2VlICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbW9vdGhzdGVwXG4gICAgICogQHNlZSBodHRwOi8vd3d3LmZ1bmR6YS5jb20vcm1hbl9zaGFkZXJzL3Ntb290aHN0ZXAvaW5kZXguaHRtbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbiBvZiB0aGUgcmFuZ2UgdG8gbGVycC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXggb2YgdGhlIHJhbmdlIHRvIGxlcnAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlucHV0IEEgdmFsdWUgYmV0d2VlblxuICAgICAqL1xuICAgIHN0YXRpYyBzbW9vdGhTdGVwKG1pbiwgbWF4LCBpbnB1dCkge1xuICAgICAgICBjb25zdCB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKGlucHV0IC0gbWluKSAvIChtYXggLSBtaW4pKSk7XG4gICAgICAgIHJldHVybiB4ICogeCAqICgzIC0gMiAqIHgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXJwcyB3aXRoaW4gYSBnaXZlbiByYW5nZS5cbiAgICAgKlxuICAgICAqIExldCdzIHNheSB5b3UgaGF2ZSB0byByYW5nZXMgdGhhdFxuICAgICAqIHlvdSB3YW50IHRvIG1ha2UgYSBsaW5lYXIgYXNzb2NpYXRpb24gdG8uXG4gICAgICpcbiAgICAgKiBUaGUgZWFzaWVzdCB3YXkgdG8gaW1hZ2luZSB0aGlzIGlzIGltYWdpbmUgdHdvIHJhbmdlcy5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDAgICAgIFJhbmdlMSAgICAgICAgMTAwXG4gICAgICogfC0tLS0tLTEwLS0tLS0tLS0tLS0tfFxuICAgICAqXG4gICAgICogMCAgICAgICAgICAgICAgIFJhbmdlMiAgICAgICAgICAgICAgICAgMjAwXG4gICAgICogfC0tLS0tLS0tLS0tLS0/LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAgKmBgYFxuICAgICAqXG4gICAgICogcmFuZ2UxOiAwIC0gMTAwXG4gICAgICogcmFuZ2UyOiAwIC0gMjAwXG4gICAgICpcbiAgICAgKiBZb3UgaGF2ZSB0aGUgdmFsdWUgb2YgMjAgb24gcmFuZ2UxIGFuZCB3YW50IHRvIGtub3cgd2hhdCB0aGUgdmFsdWUgd291bGRcbiAgICAgKiBiZSBvbiByYW5nZTIuXG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgd291bGQgcmV0dXJuIDIwIHNpbmNlIDEwJSBvZiAyMDAgPSAyMC5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbWF0aGYuaW50ZXJwb2xhdGVSYW5nZSgwLCAwLCAxMDAsIDAsIDIwMCk7IC8vIDBcbiAgICAgKiBtYXRoZi5pbnRlcnBvbGF0ZVJhbmdlKDEwLCAwLCAxMDAsIDAsIDIwMCk7IC8vIDIwXG4gICAgICogbWF0aGYuaW50ZXJwb2xhdGVSYW5nZSgzMCwgMCwgMTAwLCAwLCAyMDApOyAvLyA2MFxuICAgICAqXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBBIHByYWN0aWNhbCBleGFtcGxlLlxuICAgICAqIEhlcmUgd2hlbiB0aGUgc2NyZWVuIHdpZHRoIGlzIDMwMCwgdGhlIHBhZGRpbmcgaXMgMFxuICAgICAqIGFuZCB3aGVuIGl0J3MgMTIwMCwgdGhlIHBhZGRpbmcgaXMgNTAwIGFuZCBldmVyeXRoaW5nXG4gICAgICogaXQgY2xjdWxhdGVzIGV2ZXJ5dGhpbmcgYmV0d2Vlbi5cbiAgICAgKiBgYGB0c1xuICAgICAqXG4gICAgICogbGV0IHBhZGRpbmcgPSBtYXRoZi5pbnRlcnBvbGF0ZVJhbmdlKFxuICAgICAqICAgICBzY3JlZW5XaWR0aCxcbiAgICAgKiAgICAgMzAwLCAxMjAwLFxuICAgICAqICAgICAwLCA1MDBcbiAgICAgKiApO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ZXJwb2xhdGVSYW5nZShyYW5nZTFWYWx1ZSwgcmFuZ2UxTWluLCByYW5nZTFNYXgsIHJhbmdlMk1pbiwgcmFuZ2UyTWF4KSB7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gbWF0aGYuY2xhbXBBc1Byb2dyZXNzKHJhbmdlMVZhbHVlIC8gKHJhbmdlMU1heCAtIHJhbmdlMU1pbikpO1xuICAgICAgICByZXR1cm4gbWF0aGYubGVycChyYW5nZTJNaW4sIHJhbmdlMk1heCwgcHJvZ3Jlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG5vcm1hbGl6ZWQgc2luIC0gc28gaW5zdGVhZCBvZiByZXR1cm5pbmcgLTEgdG8gMSwgbm9ybWFsaXplZCBzaW4gcmV0dXJuc1xuICAgICAqIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEBwYXJhbSB0aW1lXG4gICAgICovXG4gICAgc3RhdGljIHNpbk5vcm1hbGl6ZWQodGltZSkge1xuICAgICAgICByZXR1cm4gbWF0aGYuaW50ZXJwb2xhdGVSYW5nZShNYXRoLnNpbih0aW1lKSArIDEsIDAsIDIsIDAsIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGxlcnAgYnV0IHdpbGwgYXBwbHkgYW4gZWFzaW5nRnVuY3Rpb24gdG8gdGhlIGN1cnJlbnRcbiAgICAgKiBwcm9ncmVzcywgcHJpb3IgdG8gcnVubmluZyBsZXJwLlxuICAgICAqXG4gICAgICogQHRlc3RlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZTEgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZSB0byBsZXJwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZTIgVGhlIHRhcmdldCBvZiB0aGUgcmFuZ2UgdG8gbGVycC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IEEgdmFsdWUgYmV0d2VlbiAwLTEgcmVwcmVzZW50aW5nIHRoZSBwcm9ncmVzcyBvZiB0aGVcbiAgICAgKiAgICAgbGVycC5cbiAgICAgKiBAcGFyYW0gZWFzZUZ1bmN0aW9uIEFuIGVhc2luZyBmdW5jdGlvbi4gU2VlIFtbZWFzZV1dLiAgRGVmYXVsdHMgdG8gbGluZWFyXG4gICAgICogICBpbiB3aGljaCBjYXNlLCBsaW5lYXIgaXMgZXF1YWwgdG8gYSByZWd1bGFyIGxlcnAuXG4gICAgICovXG4gICAgc3RhdGljIGxlcnBFYXNlKHZhbHVlMSwgdmFsdWUyLCBhbW91bnQsIGVhc2VGdW5jdGlvbiA9IGVhc2VfMS5FQVNFLmxpbmVhcikge1xuICAgICAgICBhbW91bnQgPSBlYXNlRnVuY3Rpb24oYW1vdW50KTtcbiAgICAgICAgcmV0dXJuIG1hdGhmLmxlcnAodmFsdWUxLCB2YWx1ZTIsIGFtb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbWlsYXIgdG8gW1ttYXRoZi5sZXJwXV0gYnV0IGlzIGRhbXBlZCBhbmQgc21vb3RoZWQgb3V0IHdpdGggZXhwb25lbnRpYWxcbiAgICAgKiBkZWNheS4gIFVzZWZ1bCB0byB1c2UgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gW1ttYXRoZi5sZXJwXV0gb3IgW1ttYXRoZi5lYXNlXV1cbiAgICAgKiB0byBzbW9vdGggb3V0IGFuaW1hdGlvbiBtb3ZlbWVudC5cbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cucm9yeWRyaXNjb2xsLmNvbS8yMDE2LzAzLzA3L2ZyYW1lLXJhdGUtaW5kZXBlbmRlbnQtZGFtcGluZy11c2luZy1sZXJwL1xuICAgICAqIEB0ZXN0ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUxIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG8gbGVycC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUyIFRoZSB0YXJnZXQgb2YgdGhlIHJhbmdlIHRvIGxlcnAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBBIHZhbHVlIGJldHdlZW4gMC0xIHJlcHJlc2VudGluZyB0aGUgcHJvZ3Jlc3Mgb2YgdGhlXG4gICAgICogICAgIGxlcnAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRhbXAgQSB2YWx1ZSBiZXR3ZWVuIDAtMSByZXByZXNlbnRpbmcgdGhlIGFtb3VudCB0byBkYW1wLlxuICAgICAqIEBwYXJhbSBlYXNlRnVuY3Rpb24gQW4gZWFzaW5nIGZ1bmN0aW9uLiBTZWUgW1tlYXNlXV0uICBEZWZhdWx0cyB0byBsaW5lYXJcbiAgICAgKiAgIGluIHdoaWNoIGNhc2UsIGxpbmVhciBpcyBlcXVhbCB0byBhIHJlZ3VsYXIgbGVycC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGFtcCh2YWx1ZTEsIHZhbHVlMiwgYW1vdW50LCBkYW1wKSB7XG4gICAgICAgIHJldHVybiBtYXRoZi5sZXJwKHZhbHVlMSwgdmFsdWUyLCAxIC0gTWF0aC5leHAoLWFtb3VudCAqIGRhbXApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gYWxpYXMgb2YgW1ttYXRoZi5sZXJwRWFzZV1dXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgZ2VuZXJhbCBlYXNlIGZ1bmN0aW9uIHRoYXQgaXMgcHJldHR5IGhhbmR5IGZvciBhbmltYXRpb25zLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBiYXNpY2FsbHkgYSB3YXkgb2Ygc2F5aW5nLCBnaXZlbiBteSBzdGFydCBhbmQgZW5kIHZhbHVlcywgd2hhdCBpcyB0aGVcbiAgICAgKiB2YWx1ZSB3aGVuIGl0J3MgYXQgeCBwZXJjZW50IChwcm9ncmVzcykgd2l0aCBlYXNpbmcuXG4gICAgICpcbiAgICAgKiBVbmRlciB0aGUgaG9vZCwgaXQgaXMgc2ltcGx5IGFuIGFsaWFzIG9mIFtbbWF0aGYubGVycEVhc2VdXSB3aGljaCBpc1xuICAgICAqIGVzc2VudGlhbGx5IGEgcmVndWxhciBsZXJwIGJ1dCBpdCBwYXNzZXMgdGhlIHByb2dyZXNzIHZhbHVlICgwLTEpIHRocm91Z2hcbiAgICAgKiBhbiBlYXNpbmcgZnVuY3Rpb24gZmlyc3QuXG4gICAgICpcbiAgICAgKlxuICAgICAqIFVzaW5nIG1hdGhmLmVhc2UsIHlvdSBjYW4gcHJldHR5IGVhc2lseSBjYWxjdWxhdGUgZWFzZXMgZm9yIG51bWJlcmljIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIFNheSBJIHdhbnRlZCB0byBhbmltYXRlIGEgYm94LnggcG9zaXRpb24gZnJvbSAwIC0gMTAwLlxuICAgICAqIFdpdGhvdXQgc3BlY2lmeWluZyBhIGVhc2luZyBmdW5jdGlvbiwgeW91IHdpbGwganVzdCBnZXQgbGluZWFyIGludGVycG9sYXRpb24uXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBtYXRoZi5lYXNlKDAsIDEwMCwgMCkgLS0tPiAwXG4gICAgICogbWF0aGYuZWFzZSgwLCAxMDAsIDAuMykgLS0tPiAzMFxuICAgICAqIG1hdGhmLmVhc2UoMCwgMTAwLCAwLjUpIC0tLT4gNTBcbiAgICAgKiBtYXRoZi5lYXNlKDAsIDEwMCwgMC45KSAtLS0+IDkwXG4gICAgICogbWF0aGYuZWFzZSgwLCAxMDAsIDEpIC0tLT4gMTAwXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3cgbGV0cyB0cnkgdGhpcyB3aXRoIGVhc2luZy4gIFlvdSBjYW4gc2VlIHRoZSByZXR1cm5lZCB2YWx1ZXMgYmV0d2VlblxuICAgICAqIDAgYW5kIDEgYXJlIGRpZmZlcmVudCB0aGFuIGEgbGluZWFyIGVhc2UuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFsc28gY29tYmluZSB3aXRoIEN1YmljQmV6aWVyLm1ha2VFYXNpbmdGdW5jdGlvbiBvciBhIGNhdG11bGwtcm9sbC5cbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQgeyBFQVNFLCBtYXRoZn0gZnJvbSAnQGJsaW5ray9kZWd1J1xuICAgICAqIG1hdGhmLmVhc2UoMCwgMTAwLCAwLCBFQVNFLmVhc2VJbkV4cG8pICAgLS0tPiAwXG4gICAgICogbWF0aGYuZWFzZSgwLCAxMDAsIDAuMywgRUFTRS5lYXNlSW5FeHBvKSAtLS0+IDAuMTk1MzEyNVxuICAgICAqIG1hdGhmLmVhc2UoMCwgMTAwLCAwLjUsIEVBU0UuZWFzZUluRXhwbykgLS0tPiAzLjEyNVxuICAgICAqIG1hdGhmLmVhc2UoMCwgMTAwLCAwLjksIEVBU0UuZWFzZUluRXhwbykgLS0tPiA3MC43MTA2NzhcbiAgICAgKiBtYXRoZi5lYXNlKDAsIDEwMCwgMSwgRUFTRS5lYXNlSW5FeHBvKSAtLS0+IDEwMFxuICAgICAqXG4gICAgICpcbiAgICAgKlxuICAgICAqIGltcG9ydCB7IEN1YmljQmV6aWVyLCBFQVNFLCBtYXRoZn0gZnJvbSAnQGJsaW5ray9kZWd1J1xuICAgICAqIG1hdGhmLmVhc2UoMCwgMTAwLCAwLjMsIEN1YmljQmV6aWVyLm1ha2VFYXNpbmdGdW5jdGlvbigwLCAxLCAwLjc1LCAwLjkpKSAtLS0+IDEwMFxuICAgICAqXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBIb3cgY2FuIEkgdXNlIHRoaXMgd2l0aCBhbmltYXRpb25zP1xuICAgICAqXG4gICAgICogWW91IGNhbiBlYXNlIG91dCBwb3NpdGlvbnMsIG9wYWNpdHkgZXRjIGJhc2VkIG9uIFwicHJvZ3Jlc3NcIi5cbiAgICAgKiBQcm9ncmVzcyBjYW4gYmUgdGltZSwgc2Nyb2xsIHBvc2l0aW9uLCBtb3VzZSBwb3NpdGlvbiBldGMgYnV0IGl0IG5lZWRzIHRvXG4gICAgICogYmUgbm9ybWFsaXplZCB0byBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKlxuICAgICAqIFNlZSBleGFtcGxlcyBvZiB0aGlzIGluIFtbUmFmVGltZXJdXSB3aGVyZSB0aGVyZSBpcyBhIGRlbW8gb2YgZWFzaW5nIGFuXG4gICAgICogZWxlbWVudCBmb3IgYSBzZXQgZHVyYXRpb24uXG4gICAgICpcbiAgICAgKiBGb3IgYW4gZXhtYXBsZSB3aGVyZSB5b3UgbWF5IHdhbnQgdG8gdGllIGVhc2Ugd2l0aCB3aW5kb3cuc2Nyb2xsIG9yIGFub3RoZXJcbiAgICAgKiBpbnB1dCByZXByZXNlbnRlZCBieSBhIG5vcm1hbGl6ZWQgdmFsdWUvIHByb2dyZXNzIChhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEpaVxuICAgICAqIHNlZSBtYXRoZi1lYXNlLmh0bWwgaW4gdGhlIC9leGFtcGxlcyBmb2xkZXIgd2hlcmUgdGhlcmUgaXMgZWxlbWVudCBhbmRcbiAgICAgKiBwcm9ncmVzcyBsZXZlbCBlYXNpbmcgdG8gc21vb3RoXG4gICAgICogaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBBbHNvIHJlbGF0ZWQgaXMgW1tJbnRlcnBvbGF0ZV1dLlxuICAgICAqXG4gICAgICogQGFsaWFzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG8gbGVycC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSB0YXJnZXQgb2YgdGhlIHJhbmdlIHRvIGxlcnAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHByb2dyZXNzIEEgdmFsdWUgYmV0d2VlbiAwLTEgcmVwcmVzZW50aW5nIHRoZSBwcm9ncmVzcyBvZiB0aGVcbiAgICAgKiAgICAgbGVycC5cbiAgICAgKiBAcGFyYW0gZWFzZUZ1bmN0aW9uIEFuIGVhc2luZyBmdW5jdGlvbi4gU2VlIFtbZWFzZV1dXG4gICAgICovXG4gICAgc3RhdGljIGVhc2Uoc3RhcnQsIGVuZCwgcHJvZ3Jlc3MsIGVhc2VGdW5jdGlvbiA9IGVhc2VfMS5FQVNFLmxpbmVhcikge1xuICAgICAgICByZXR1cm4gbWF0aGYubGVycEVhc2Uoc3RhcnQsIGVuZCwgcHJvZ3Jlc3MsIGVhc2VGdW5jdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXBzIGEgZ2l2ZW4gbnVtYmVyIGJldHdlZW4gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKiBtYXRoZi53cmFwKGFuZ2xlLCAwLCAzNjApOyAgLy8gV3JhcCBiZXR3ZWVuIDAgYW5kIDM2MCBkZWdyZXNzXG4gICAgICogbWF0aGYud3JhcChhbmdsZSwgLTkwLCA5MCk7IC8vIFdyYXAgYmV0d2VlbiAtOTAgYW5kIDkwIGRlZ3Jlc3NcbiAgICAgKlxuICAgICAqXG4gICAgICogbWF0aGYud3JhcCgxNSwgMCwgMTApOyAvLyBXcmFwIGJldHdlZW4gMCBhbmQgMTAgLS0+IHJlc3VsdCA1XG4gICAgICogbWF0aGYud3JhcCg0MDAsIDAsIDM2MCk7IC8vIC0tPiByZXN1bHQgNDBcbiAgICAgKiBtYXRoZi53cmFwKDEyMCwgLTkwLCA5MCk7IC8vIC0tPiAtNjBcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIG1pblxuICAgICAqIEBwYXJhbSBtYXhcbiAgICAgKi9cbiAgICBzdGF0aWMgd3JhcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgY29uc3QgZGlmZiA9IG1heCAtIG1pbjtcbiAgICAgICAgcmV0dXJuIG1pbiArICgoKCh2YWx1ZSAtIG1pbikgJSBkaWZmKSArIGRpZmYpICUgZGlmZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIHR3byBib3hlcyBvZiBkaWZmZXJlbnQgYXNwZWN0IHJhdGlvcyxcbiAgICAgKiBjYWxjdWxhdGVzIHRoZSB2YWx1ZXMgaW4gb3JkZXIgdG8gbWFrZSB0aGUgY2hpbGQgY292ZXIgdGhlIHBhcmVudC5cbiAgICAgKiBUaGlzIGFjdHMgc2ltaWxhciB0byBiYWNrZ3JvdW5kOiBjb3ZlciBvZiBjc3MuXG4gICAgICpcbiAgICAgKiBJbWFnaW5lIHRoZSBmb2xsb3dpbmc6XG4gICAgICogYGBgXG4gICAgICogLS0tLS0tLXAtLS0tLS0tLVxuICAgICAqIHwgICAgICAgICAgICAgICB8XG4gICAgICogfCAgIC0tLS0tICAgICAgIHxcbiAgICAgKiB8ICAgfCBDICB8ICAgICAgfFxuICAgICAqIHwgICAtLS0tLSAgICAgICB8XG4gICAgICogfCAgICAgICAgICAgICAgIHxcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhpcyBjYXNlLCBjIHdvdWxkIGhhdmUgdG8gc2NhbGUgdXAgdG8gY292ZXIgdGhlXG4gICAgICogcGFyZW50LiAgSXQgd291bGQgcmV0dXJuIHNvbWV0aGluZyBsaWtlOlxuICAgICAqXG4gICAgICogLSB3aWR0aDogV2hhdCB0aGUgY2hpbGQgd2lkdGggc2hvdWxkIGJlXG4gICAgICogLSBoZWlnaHQ6IFdoYXQgdGhlIGNoaWxkIGhlaWdodCBzaG91bGQgYmVcbiAgICAgKiAtIHhPZmZzZXQ6IFRoZSBBbW91bnQgdG8gb2Zmc2V0IHggYnkgaW4gb3JkZXIgdG8gY2VudGVyLlxuICAgICAqIC0geU9mZnNldDogVGhlIEFtb3VudCB0byBvZmZzZXQgeSBieSBpbiBvcmRlciB0byBjZW50ZXIuXG4gICAgICogLSBzY2FsYXI6IFRoZSBhbW91bnQgdG8gc2NhbGVcbiAgICAgKlxuICAgICAqXG4gICAgICogTm90ZSBvbiB4T2Zmc2V0IGFuZCB5T2Zmc2V0LCB0aGlzIGFsZ28gYXNzdW1lcyB0aGF0IHRoZSBjaGlsZCB3aWxsIHNjYWxlXG4gICAgICogZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBib3ggYW5kIGlzIHBvc2l0aW9uZWQgdG8gdGhlIHRvcCBsZWZ0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtkaW1lbnNpb25hbEJveH0gcGFyZW50Qm94IFRoZSBwYXJlbnQgZWxlbWVudCBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtkaW1lbnNpb25hbEJveH0gY2hpbGRCb3ggVGhlIGNoaWxkIGVsbWVudCBkaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7YmFja2dyb3VuZENvdmVyQm94fSBiYWNrZ3JvdW5kQ292ZXJCb3ggVGhlIGRpbWVuc2lvbnMgcmVxdWlyZWQgdG9cbiAgICAgKiAgICAgdHJhbnNmb3JtIHRoZSBjaGlsZCBlbGVtZW50IHRvIGJhY2tncm91bmQgY292ZXIuXG4gICAgICovXG4gICAgc3RhdGljIGNhbGN1bGF0ZUJhY2tncm91bmRDb3ZlcihwYXJlbnRCb3gsIGNoaWxkQm94KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFJhdGlvID0gbWF0aGYuYXNwZWN0UmF0aW8ocGFyZW50Qm94KTtcbiAgICAgICAgY29uc3QgY2hpbGRSYXRpbyA9IG1hdGhmLmFzcGVjdFJhdGlvKGNoaWxkQm94KTtcbiAgICAgICAgbGV0IGZpbmFsV2lkdGg7XG4gICAgICAgIGxldCBmaW5hbEhlaWdodDtcbiAgICAgICAgbGV0IHNjYWxlO1xuICAgICAgICBpZiAoY2hpbGRSYXRpbyA+PSBwYXJlbnRSYXRpbykge1xuICAgICAgICAgICAgZmluYWxIZWlnaHQgPSBwYXJlbnRCb3guaGVpZ2h0O1xuICAgICAgICAgICAgc2NhbGUgPSBwYXJlbnRCb3guaGVpZ2h0IC8gY2hpbGRCb3guaGVpZ2h0O1xuICAgICAgICAgICAgZmluYWxXaWR0aCA9IGNoaWxkQm94LndpZHRoICogc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaW5hbFdpZHRoID0gcGFyZW50Qm94LndpZHRoO1xuICAgICAgICAgICAgc2NhbGUgPSBwYXJlbnRCb3gud2lkdGggLyBjaGlsZEJveC53aWR0aDtcbiAgICAgICAgICAgIGZpbmFsSGVpZ2h0ID0gY2hpbGRCb3guaGVpZ2h0ICogc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmluYWxTY2FsZSA9IE1hdGgubWF4KGZpbmFsV2lkdGggLyBjaGlsZEJveC53aWR0aCwgZmluYWxIZWlnaHQgLyBjaGlsZEJveC5oZWlnaHQpO1xuICAgICAgICAvLyBQb3NpdGlvbiB0byB2ZXJ0aWNhbCBib3R0b20uXG4gICAgICAgIGNvbnN0IG9mZnNldEhlaWdodCA9IG1hdGhmLmFic1plcm8oLU1hdGgucm91bmQoKHBhcmVudEJveC5oZWlnaHQgLSBmaW5hbEhlaWdodCkgLyAyKSk7XG4gICAgICAgIC8vIFBvc2l0aW9uIHRvIGhvcml6b250YWwgY2VudGVyLlxuICAgICAgICBjb25zdCBvZmZzZXRXaWR0aCA9IG1hdGhmLmFic1plcm8oLU1hdGgucm91bmQoKHBhcmVudEJveC53aWR0aCAtIGZpbmFsV2lkdGgpIC8gMikpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQoZmluYWxXaWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQoZmluYWxIZWlnaHQpLFxuICAgICAgICAgICAgeE9mZnNldDogb2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICB5T2Zmc2V0OiBvZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICBzY2FsYXI6IGZpbmFsU2NhbGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIHR3byBib3hlcyBvZiBkaWZmZXJlbnQgc2l6ZXMgY2FsY3VsYXRlcyB0aGUgYW1vdW50IHRoYXQgdGhlIGNoaWxkQm94XG4gICAgICogd291bGQgbmVlZCB0byBzY2FsZSBpbiBvcmRlciB0byBtaW1pYyB0aGUgYmFja2dyb3VuZDpjb250YWluIGVmZmVjdCBpbiBodG1sLlxuICAgICAqXG4gICAgICogSW1hZ2luZSB0aGUgZm9sbG93aW5nOlxuICAgICAqIGBgYFxuICAgICAqIC0tLS0tLS1wLS0tLS0tLS1cbiAgICAgKiB8ICAgICAgICAgICAgICAgfFxuICAgICAqIHwgICAtLS0tLSAgICAgICB8XG4gICAgICogfCAgIHwgQyAgfCAgICAgIHxcbiAgICAgKiB8ICAgLS0tLS0gICAgICAgfFxuICAgICAqIHwgICAgICAgICAgICAgICB8XG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoaXMgY2FzZSwgYyB3b3VsZCBoYXZlIHRvIHNjYWxlIHVwIHRvIGNvdmVyIHRoZVxuICAgICAqIHBhcmVudC4gICAgICBUaGlzIG1ldGhvZCB3b3VsZCByZXR1cm4gdGhlIGFtb3VudCB0aGF0IEMgbmVlZHMgdG8gc2NhbGVcbiAgICAgKiAodXAgb3IgZG93bikuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGlzIGlzIGNvbnRhaW4sIGFwcGx5aW5nIHRoZSBzY2FsZSB2YWx1ZSB0byB0aGUgY2hpbGQgd291bGQgbmV2ZXJcbiAgICAgKiBleGNlZWQgdGhlIHdpZHRoIG9yIGhlaWdodCBvZiB0aGUgcGFyZW50IChubyBibGVlZGluZykuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgYXNzdW1lcyB0aGF0IHRoZSBjaGlsZCBpcyBhYnNvbHV0ZWx5IGNlbnRlcmVkIGFnYWluc3RcbiAgICAgKiB0aGUgcGFyZW50LlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBwYXJlbnRCb3ggPSB7IHdpZHRoOiAxMDAsIGhlaWdodDogMTAwIH07XG4gICAgICogY2hpbGRCb3ggPSB7IHdpZHRoOiAyMDAsIGhlaWdodDogMTAwIH07XG4gICAgICogbWF0aGYuY2FsY3VsYXRlQmFja2dyb3VuZENvbnRhaW4ocGFyZW50Qm94LCBjaGlsZEJveCkgLy8gcmV0dXJuIDAuNS5cbiAgICAgKlxuICAgICAqXG4gICAgICogcGFyZW50Qm94ID0geyB3aWR0aDogNTAwLCBoZWlnaHQ6IDUwMCB9O1xuICAgICAqIGNoaWxkQm94ID0geyB3aWR0aDogNTAsIGhlaWdodDogNTAgfTtcbiAgICAgKiBtYXRoZi5jYWxjdWxhdGVCYWNrZ3JvdW5kQ29udGFpbihwYXJlbnRCb3gsIGNoaWxkQm94KSAvLyByZXR1cm4gMTBcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmVudEJveFxuICAgICAqIEBwYXJhbSBjaGlsZEJveFxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVCYWNrZ3JvdW5kQ29udGFpbihwYXJlbnRCb3gsIGNoaWxkQm94KSB7XG4gICAgICAgIGNvbnN0IGhlaWdodFNjYWxlID0gcGFyZW50Qm94LmhlaWdodCAvIGNoaWxkQm94LmhlaWdodDtcbiAgICAgICAgY29uc3Qgd2lkdGhTY2FsZSA9IHBhcmVudEJveC53aWR0aCAvIGNoaWxkQm94LndpZHRoO1xuICAgICAgICBjb25zdCBzY2FsZSA9IE1hdGgubWluKGhlaWdodFNjYWxlLCB3aWR0aFNjYWxlKTtcbiAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGFzeW1wb3RpYyBhdmVyYWdlIHdoaWNoIGlzIGFuIGFkZGl0aXZlIGF2ZXJhZ2UuXG4gICAgICogQmFzaWNhbGx5IHNheXMsIGdpdmVuIHRoZSBjdXJyZW50IHZhbHVlLCBjYXRjaCB1cCB0byB0aGUgdGFyZ2V0IGJ5IFglIGV2ZXJ5XG4gICAgICogZnJhbWUuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHNpbWlsYXIgdG8gbGVycCBidXQgcmVzcGVjdHMgdGhlIGxhc3QgZ2l2ZW4gYW1vdW50IHRoZSBtb3N0IHdoaWNoXG4gICAgICogcmVzdWx0cyBpbiBhIHNtb290aCByZXNwb25zZSB0byBzdWRkZW4ganVtcHMgaW4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlblxuICAgICAqIGN1cnJlbnQgYW5kIHRhcmdldC5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgZm9yIHRoaW5ncyBsaWtlIGNhbWVyYSBtb3ZlbWVudCBvciBzY3JvbGwgbW92ZW1lbnQgd2hlcmVcbiAgICAgKiBzdWRkZW4gamVya3MgaW4gbW92ZW1lbnQgY2FuIGhhcHBlbi5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIG9uUmFmKCkge1xuICAgICAqICAgIC8vIFVwZGF0ZSB0YXJnZXQgdmFsdWUuXG4gICAgICogICAgdGFyZ2V0VmFsdWUgPSB0aGlzLnZhbHVlICsgKHRoaXMubW91c2VJbnB1dFggKiAzMCk7XG4gICAgICogICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IHZhbHVlIHRvIHRoZSB0YXJnZXQgdmFsdWUgYnkgMzAlLlxuICAgICAqICAgIHRoaXMudmFsdWUgPSBtYXRoZi5hc3ltcHRvdGljQXZlcmFnZSh0aGlzLnZhbHVlLCB0YXJnZXRWYWx1ZSwgMC4zKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3VycmVudFxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gYW1vdW50XG4gICAgICovXG4gICAgc3RhdGljIGFzeW1wdG90aWNBdmVyYWdlKGN1cnJlbnQsIHRhcmdldCwgYW1vdW50KSB7XG4gICAgICAgIHJldHVybiAoY3VycmVudCArPSAodGFyZ2V0IC0gY3VycmVudCkgKiBhbW91bnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGJhc2ljIHNtb290aCBzdGFydC4gIFNlZSBFQVNFIGZvciBtb3JlLlxuICAgICAqL1xuICAgIHN0YXRpYyBzbW9vdGhTdGFydDIodCkge1xuICAgICAgICByZXR1cm4gdCAqIHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgYmFzaWMgc21vb3RoIHN0b3AuICBTZWUgRUFTRSBmb3IgbW9yZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgc21vb3RoU3RvcDIodCkge1xuICAgICAgICByZXR1cm4gMSAtICgxIC0gdCkgKiAoMSAtIHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGJhc2ljIHNtb290aCBzdGFydC4gIFNlZSBFQVNFIGZvciBtb3JlLlxuICAgICAqL1xuICAgIHN0YXRpYyBzbW9vdGhTdGFydDModCkge1xuICAgICAgICByZXR1cm4gdCAqIHQgKiB0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGJhc2ljIHNtb290aCBzdG9wLiAgU2VlIEVBU0UgZm9yIG1vcmUuXG4gICAgICovXG4gICAgc3RhdGljIHNtb290aFN0b3AzKHQpIHtcbiAgICAgICAgcmV0dXJuIDEgLSAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhc2ljIHNtb290aCBzdGVwMiBhbGxvd2luZyB5b3UgdG8gc3BlY2lmeSB0aGUgZ3JhZGllbnQgYmV0d2VlblxuICAgICAqIHNtb290aHN0YXJ0IGFuZCBzbW9vdGhzdG9wIHdpdGggbWl4IHZhbHVlLlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBtaXhcbiAgICAgKiBAcGFyYW0gdFxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogICB2YWx1ZSA9IG1hdGhmLnNtb290aFN0ZXAyKHZhbHVlLCAwLjUsIHQpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBzbW9vdGhTdGVwMih2YWx1ZSwgbWl4LCB0KSB7XG4gICAgICAgIHJldHVybiAobWF0aGYubGVycChtYXRoZi5zbW9vdGhTdGFydDIodmFsdWUpLCBtYXRoZi5zbW9vdGhTdG9wMih2YWx1ZSksIG1peCkgKiB0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmFzaWMgc2lnbW9pZCBmdW5jdGlvbiB3aXRoIG9wdGlvbiB0byBtb3ZlIHRoZSBtaXggdmFsdWUuXG4gICAgICogTWl4IHZhbHVlIG9mIDAgbWl4ZXMgdG8gc21vb3Roc3RhcnQuIDEgbWl4ZXMgdG8gc21vb3Roc3RvcC5cbiAgICAgKiBBIGNsZWFuIHNpZ21vaWRpc2ggY3VydmUgd291ZCBiZSAwLjUuXG4gICAgICpcbiAgICAgKiBCYXNlZCBvbiBzbW9vdGhTdGVwMiBjdXJ2ZXMuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIG1peFxuICAgICAqL1xuICAgIHN0YXRpYyBzaWdtb2lkKHZhbHVlLCBtaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc21vb3RoU3RlcDIodmFsdWUsIG1peCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgQ3JlYXRlcyBhIGJhc2ljIHJlbWFwLlxuICBcbiAgICAgTGV0J3Mgc2F5IHlvdSB3YW50IHRvIG1ha2UgYSBjb2xvciBiYXIgZ28gZnJvbSAyMCwgNTBcbiAgICAgd2hlbiB5b3VyIGhlYWx0aCBnb2VzIGZyb20gMCwgMTAwLlxuICBcbiAgICBgYGBcbiAgICAgbWF0aGYucmVtYXAoMjAsIDUwLCAwLCAxMDAsIGhlYWx0aCk7ICAtLT4gb3V0cHV0IGEgdmFsdWUgYmV0d2VlbiAyMC01MCBiYXNlZCBvbiBoZWFsdGguXG4gICAgIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyByZW1hcChtaW5BLCBtYXhBLCBtaW5CLCBtYXhCLCB2YWx1ZUIpIHtcbiAgICAgICAgY29uc3QgdCA9IG1hdGhmLmludmVyc2VMZXJwKG1pbkIsIG1heEIsIHZhbHVlQik7XG4gICAgICAgIHJldHVybiBtYXRoZi5sZXJwKG1pbkEsIG1heEEsIHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb3RhbC9zdW0vYWRkLXVwIHRoZSBnaXZlbiB2YWx1ZXMuXG4gICAgICovXG4gICAgc3RhdGljIHN1bSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoKHJlc3VsdCwgdmFsdWUpID0+IHJlc3VsdCArIHZhbHVlLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLm1hdGhmID0gbWF0aGY7XG4vKipcbiAqIEdlbmVyYXRlcyBhIHNldCBvZiByYW5kb20geCx5IHBvaW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gTnVtYmVyIG9mIHBvaW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIE1pbmltdW0gb2YgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIE1heGltdW0gb2YgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZIE1pbmltdW0gb2YgeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIE1heGltdW0gb2YgeS5cbiAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fSBBbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgeCwgeSB2YWx1ZXMuXG4gKi9cbm1hdGhmLmdlbmVyYXRlUmFuZG9tUG9pbnRzID0gKG51bSwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSkgPT4ge1xuICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgeDogbWF0aGYuZ2V0UmFuZG9tSW50KG1pblgsIG1heFgpLFxuICAgICAgICAgICAgeTogbWF0aGYuZ2V0UmFuZG9tSW50KG1pblksIG1heFkpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoZi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/mathf/mathf.js\n");

/***/ }),

/***/ "./lib/mathf/matrixIV.js":
/*!*******************************!*\
  !*** ./lib/mathf/matrixIV.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MatrixIV = void 0;\nconst vector_1 = __webpack_require__(/*! ./vector */ \"./lib/mathf/vector.js\");\n/**\n * A 4 four dimensional homogenous matrix class.\n *\n * See examples in /examples for uses of matrix.\n *\n * ```\n * // Creates a new matrix.  Default matrix is set to identity.\n * let matrixA = new MatrixIV();\n *\n * matrixA.translateXyz(20, 30, 40);\n *\n *\n * // Creates an identity matrix.\n * let matrixB = MatrixIV.IDENTITY;\n *\n * // Rotate it on the Z axis by 90 degrees.\n * matrixB.scale(90 * Math.PI / 180, new Vector(0,0, 1));\n *\n * ```\n *\n * Referenced:\n * @see http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/\n * @see https://github.com/doxas/minMatrix.js/blob/master/minMatrix.js\n * @see https://github.com/photonstorm/phaser/blob/v3.17.0/src/math/Matrix4.js\n * @see https://www.youtube.com/channel/UCEhBM2x5MG9-e_JSOzU068w\n * @see https://www.useragentman.com/blog/2011/01/07/css3-matrix-transform-for-the-mathematically-challenged/\n * @see https://github.com/toji/gl-matrix\n * @see https://github.com/adragonite/math3d/blob/master/src/Matrix4x4.js\n * @see https://github.com/mrdoob/three.js/blob/master/src/math/Matrix4.js\n *\n * @unstable\n */\nclass MatrixIV {\n    constructor(matrix) {\n        this.value = new Float32Array(16);\n        this.identity();\n        // If matrix was provided, copy it, otherwise, create\n        // an identity default matrix.\n        if (matrix) {\n            this.copy(matrix);\n        }\n        else {\n            this.identity();\n        }\n    }\n    /**\n     * Sets this matrix to a default identity matrix.\n     */\n    identity() {\n        this.value[0] = 1;\n        this.value[1] = 0;\n        this.value[2] = 0;\n        this.value[3] = 0;\n        this.value[4] = 0;\n        this.value[5] = 1;\n        this.value[6] = 0;\n        this.value[7] = 0;\n        this.value[8] = 0;\n        this.value[9] = 0;\n        this.value[10] = 1;\n        this.value[11] = 0;\n        this.value[12] = 0;\n        this.value[13] = 0;\n        this.value[14] = 0;\n        this.value[15] = 1;\n        return this;\n    }\n    /**\n     * Sets this matrix to have all 0 value.\n     */\n    zero() {\n        this.value[0] = 0;\n        this.value[1] = 0;\n        this.value[2] = 0;\n        this.value[3] = 0;\n        this.value[4] = 0;\n        this.value[5] = 0;\n        this.value[6] = 0;\n        this.value[7] = 0;\n        this.value[8] = 0;\n        this.value[9] = 0;\n        this.value[10] = 0;\n        this.value[11] = 0;\n        this.value[12] = 0;\n        this.value[13] = 0;\n        this.value[14] = 0;\n        this.value[15] = 0;\n        return this;\n    }\n    /**\n     * Clones this matrix.\n     *\n     * ```ts\n     * let m = myMatrix.clone();  // m is now a new clone of myMatrix.\n     * ```\n     */\n    clone() {\n        return new MatrixIV(this);\n    }\n    /**\n     * Copies the values of another matrix into this matrix.\n     *\n     * ```ts\n     * matrixA.copy(matrixB) // Now matrixA has the values of matrixB.\n     * ```\n     * @param {MatrixIV} matrixIV\n     */\n    copy(matrix4) {\n        this.value = matrix4.value.slice(0);\n        return this;\n    }\n    /**\n     * Fills a specific column of this matrix with a vector values.\n     *\n     * ```\n     *\n     * For example, passing 2 as the column would:\n     * [\n     *   1,  0,  x,  0\n     *   0,  1,  y,  0,\n     *   0,  0,  z,  0,\n     *   0,  0,  0,  1\n     * ]\n     *\n     * ```\n     * This is useful to create a basis matrix.  Below is a 4x4\n     * matrix constructed of up, right and forward vectors.\n     *\n     * ```ts\n     *\n     *   let up = new Vector(0, 50);\n     *   let right = new Vector(50, 0);\n     *   let forward = Vector.ONE.cross(up);\n     *   let basisMatrix = new MatrixIV();\n     *   basisMatrix.setVectorColumn(0, right);\n     *   basisMatrix.setVectorColumn(1, up);\n     *   basisMatrix.setVectorColumn(2, foward);\n     *\n     * ```\n     *\n     * @param column The column number to fill.  A value between 0 and 3.\n     * @param vector The vector to set.\n     */\n    setVectorColumn(column, v) {\n        this.value[1 * column] = v.x;\n        this.value[1 * column + 4] = v.y;\n        this.value[1 * column + 8] = v.z;\n    }\n    /**\n     * Scales this matrix given x, y, z values.\n     *\n     * ```ts\n     * myMatrix.scaleXyz(0.5, 0.5, 0.5);\n     * ```\n     *\n     * @param x\n     * @param y\n     * @param z\n     * @return {MatrixIV}\n     */\n    scaleXyz(x, y, z) {\n        this.value[0] = this.value[0] * x;\n        this.value[1] = this.value[1] * x;\n        this.value[2] = this.value[2] * x;\n        this.value[3] = this.value[3] * x;\n        this.value[4] = this.value[4] * y;\n        this.value[5] = this.value[5] * y;\n        this.value[6] = this.value[6] * y;\n        this.value[7] = this.value[7] * y;\n        this.value[8] = this.value[8] * z;\n        this.value[9] = this.value[9] * z;\n        this.value[10] = this.value[10] * z;\n        this.value[11] = this.value[11] * z;\n        return this;\n    }\n    /**\n     * Apply a scale transformation to this matrix given a scale vector.\n     *\n     * ```ts\n     * myMatrix.scale(new Vector(0.5, 0.5, 0.5));\n     * ```\n     *\n     * @param v {Vector} The vector to scale this matrix.\n     * @return {MatrixIV}\n     */\n    scale(v) {\n        return this.scaleXyz(v.x, v.y, v.z);\n    }\n    /**\n     * Translates this matrix given the values.\n     *\n     * ```ts\n     * myMatrix.translateXyz(10, 20, 0));\n     * ```\n     * @param x\n     * @param y\n     * @param z\n     */\n    translateXyz(x, y, z) {\n        this.value[12] =\n            this.value[0] * x +\n                this.value[4] * y +\n                this.value[8] * z +\n                this.value[12];\n        this.value[13] =\n            this.value[1] * x +\n                this.value[5] * y +\n                this.value[9] * z +\n                this.value[13];\n        this.value[14] =\n            this.value[2] * x +\n                this.value[6] * y +\n                this.value[10] * z +\n                this.value[14];\n        this.value[15] =\n            this.value[3] * x +\n                this.value[7] * y +\n                this.value[11] * z +\n                this.value[15];\n        return this;\n    }\n    /**\n     * Apply a translation.\n     *\n     * ```ts\n     * myMatrix.translate(new Vector(1, 1, 1));\n     * ```\n     */\n    translate(v) {\n        return this.translateXyz(v.x, v.y, v.z);\n    }\n    /**\n     * Converts the current 4x4 matrix over to a css 3d matrix translation string.\n     *\n     * ```\n     *\n     * [\n     * a1 a2 a3 a4\n     * b1 b2 b3 b4\n     * c1 c2 c3 c4\n     * d1 d2 d3 d4\n     * ]\n     * = matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4)\n     * ```\n     *\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n     */\n    toCss3dMatrix() {\n        const a1 = this.value[0];\n        const a2 = this.value[1];\n        const a3 = this.value[2];\n        const a4 = this.value[3];\n        const b1 = this.value[4];\n        const b2 = this.value[5];\n        const b3 = this.value[6];\n        const b4 = this.value[7];\n        const c1 = this.value[8];\n        const c2 = this.value[9];\n        const c3 = this.value[10];\n        const c4 = this.value[11];\n        const d1 = this.value[12];\n        const d2 = this.value[13];\n        const d3 = this.value[14];\n        const d4 = this.value[15];\n        return `matrix3d(${a1}, ${b1}, ${c1}, ${d1}, ${a2}, ${b2},\n            ${c2}, ${d2}, ${a3}, ${b3}, ${c3}, ${d3}, ${a4}, ${b4}, ${c4}, ${d4})`;\n    }\n    /**\n     * Multiply the current matrix with another.\n     *\n     * ```ts\n     * matrixA.multiply(matrixB); // Now value of matrixA is multiplied with B.\n     *\n     * matrixC = matrixA.clone().multiply(matrixB); // matrixC is product.\n     * ```\n     * @param mat\n     */\n    multiply(mat) {\n        const a00 = this.value[0];\n        const a01 = this.value[1];\n        const a02 = this.value[2];\n        const a03 = this.value[3];\n        const a10 = this.value[4];\n        const a11 = this.value[5];\n        const a12 = this.value[6];\n        const a13 = this.value[7];\n        const a20 = this.value[8];\n        const a21 = this.value[9];\n        const a22 = this.value[10];\n        const a23 = this.value[11];\n        const a30 = this.value[12];\n        const a31 = this.value[13];\n        const a32 = this.value[14];\n        const a33 = this.value[15];\n        const b = mat.value;\n        let b0 = b[0];\n        let b1 = b[1];\n        let b2 = b[2];\n        let b3 = b[3];\n        this.value[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        this.value[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        this.value[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        this.value[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n        b0 = b[4];\n        b1 = b[5];\n        b2 = b[6];\n        b3 = b[7];\n        this.value[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        this.value[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        this.value[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        this.value[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n        b0 = b[8];\n        b1 = b[9];\n        b2 = b[10];\n        b3 = b[11];\n        this.value[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        this.value[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        this.value[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        this.value[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n        b0 = b[12];\n        b1 = b[13];\n        b2 = b[14];\n        b3 = b[15];\n        this.value[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        this.value[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        this.value[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        this.value[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n        return this;\n    }\n    /**\n     * Multiplies this 4x4 matrix by a 4x1 matrix.  This results in\n     * returning the results as a 4x1 matrix.\n     *\n     * ```\n     *     4x4 Matrix         4x1 (Vector)\n     *      a, b, c, d               x      = ax + by + cz + dw\n     *      e, f, g, h     x         y      = ex + fy + gz + hw\n     *      i, j, k, l               z      = ix + jy + kz + lw\n     *     m,  n,  o, p              w      = mx + ny + oz + pw\n     * ```\n     *\n     * @param x\n     * @param y\n     * @param z\n     * @param w Use 1 for positions and 0 for direction.\n     */\n    multiplyBy4x1(x, y, z, w = 1) {\n        const a = this.value;\n        return [\n            a[0] * x + a[1] * y + a[2] * z + a[3] * w,\n            a[4] * x + a[5] * y + a[6] * z + a[7] * w,\n            a[8] * x + a[9] * y + a[10] * z + a[11] * w,\n            a[12] * x + a[13] * y + a[14] * z + a[15] * w,\n        ];\n    }\n    /**\n     * Multiplies this matrix by a vector that is converted to a 4x1.  Returns\n     * a vector that was converted from the resulting 4x1.\n     *\n     * ```\n     *     Basis Matrix         4x1 (Vector)\n     *      a, b, c, d               x\n     *      e, f, g, h     x         y\n     *      i, j, k, l               z\n     *     m,  n,  o, p              w\n     *\n     * ```\n     *\n     * ```ts\n     *\n     *   let up = new Vector(0, 50);\n     *   let right = new Vector(50, 0);\n     *   let forward = Vector.ONE.cross(up);\n     *   let basisMatrix = new MatrixIV();\n     *   basisMatrix.setVectorColumn(0, right);\n     *   basisMatrix.setVectorColumn(1, up);\n     *   basisMatrix.setVectorColumn(2, forward);\n     *\n     *   let p0 = new Vector(-1, -1);\n     *   let p1 = new Vector(1, -1);\n     *   let p2 = new Vector(1, 1);\n     *   let p3 = new Vector(-1, 1);\n     *   let t0 = basisMatrix.clone().multiplyByVector(p1);\n     *   let t1 = basisMatrix.clone().multiplyByVector(p1);\n     *   let t2 = basisMatrix.clone().multiplyByVector(p2);\n     *   let t3 = basisMatrix.clone().multiplyByVector(p3);\n     *\n     *   // Now t0-t3 are vector of the corner points of a 100x100 square.\n     *\n     * ```\n     */\n    multiplyByVector(v, w = 1) {\n        const result = this.multiplyBy4x1(v.x, v.y, v.z, w);\n        return new vector_1.Vector(result[0], result[1], result[2]);\n    }\n    /**\n     * Rotates this matrix at an given angle and axis.\n     *\n     *\n     * ```\n     *  // Rotate along X as the axis, similar to rotateX\n     *   let matrix = new MatrixIV().rotate(angle, new Vector(1, 0, 0));\n     *\n     *  // Rotate along y as the axis, similar to rotateY\n     *   matrix = new MatrixIV().rotate(angle, new Vector(0, 1, 0));\n     *\n     *  // Rotate along y as the axis, similar to rotateZ\n     *   matrix = new MatrixIV().rotate(angle, new Vector(0, 0, 1));\n     * ```\n     *\n     * @param angle An angle in radians\n     * @param axis A vector point that acts as the axis.\n     */\n    rotate(angle, axis) {\n        let mg = axis.magnitude();\n        if (!mg) {\n            return null;\n        }\n        let a = axis.x, b = axis.y, c = axis.z;\n        if (mg !== 1) {\n            mg = 1 / mg;\n            a *= mg;\n            b *= mg;\n            c *= mg;\n        }\n        const d = Math.sin(angle), e = Math.cos(angle), f = 1 - e, g = this.value[0], h = this.value[1], i = this.value[2], j = this.value[3], k = this.value[4], l = this.value[5], m = this.value[6], n = this.value[7], o = this.value[8], p = this.value[9], q = this.value[10], r = this.value[11], s = a * a * f + e, t = b * a * f + c * d, u = c * a * f - b * d, v = a * b * f - c * d, w = b * b * f + e, x = c * b * f + a * d, y = a * c * f + b * d, z = b * c * f - a * d, A = c * c * f + e;\n        // this.value[12] = this.value[12];\n        // this.value[13] = this.value[13];\n        // this.value[14] = this.value[14];\n        // this.value[15] = this.value[15];\n        this.value[0] = g * s + k * t + o * u;\n        this.value[1] = h * s + l * t + p * u;\n        this.value[2] = i * s + m * t + q * u;\n        this.value[3] = j * s + n * t + r * u;\n        this.value[4] = g * v + k * w + o * x;\n        this.value[5] = h * v + l * w + p * x;\n        this.value[6] = i * v + m * w + q * x;\n        this.value[7] = j * v + n * w + r * x;\n        this.value[8] = g * y + k * z + o * A;\n        this.value[9] = h * y + l * z + p * A;\n        this.value[10] = i * y + m * z + q * A;\n        this.value[11] = j * y + n * z + r * A;\n        return this;\n    }\n    /**\n     * Rotates this matrix along the x plane.\n     * @param angle Angle in radians.\n     */\n    rotateX(angle) {\n        this.rotate(angle, new vector_1.Vector(1, 0, 0));\n        return this;\n    }\n    /**\n     * Rotates this matrix along the y plane.\n     * @param angle Angle in radians.\n     */\n    rotateY(angle) {\n        this.rotate(angle, new vector_1.Vector(0, 1, 0));\n        return this;\n    }\n    /**\n     * Rotates this matrix along the z plane.\n     * @param angle Angle in radians.\n     */\n    rotateZ(angle) {\n        this.rotate(angle, new vector_1.Vector(0, 0, 1));\n        return this;\n    }\n    /**\n     * Generates a View Matrix for the world-videw-projection matrix on a\n     * left-handed projection.\n     *\n     * @see https://github.com/doxas/minMatrix.js/blob/master/minMatrix.js\n     * http://web.archive.org/web/20131222170415/http:/robertokoci.com/world-view-projection-matrix-unveiled/\n     *\n     * ```ts\n     *   var eye = new Vector(0.0, 0.0, 5.0);\n     *   var center = new Vector(0.0, 0.0, 0.0);\n     *   var up = new Vector(0.0, 1.0, 0.0);\n     *   var martix = new MatrixIV().lookAt(eye, center, up);\n     * ```\n     *\n     * @param eye The camera position vector\n     * @param center The camera target vector\n     * @param up The up vector relative to the camera.\n     */\n    lookAt(eye, center, up = vector_1.Vector.UP) {\n        const eyex = eye.x;\n        const eyey = eye.y;\n        const eyez = eye.z;\n        const upx = up.x;\n        const upy = up.y;\n        const upz = up.z;\n        const centerx = center.x;\n        const centery = center.y;\n        const centerz = center.z;\n        if (Math.abs(eyex - centerx) < 0.00001 &&\n            Math.abs(eyey - centery) < 0.00001 &&\n            Math.abs(eyez - centerz) < 0.00001) {\n            return MatrixIV.IDENTITY;\n        }\n        let z0 = eyex - centerx;\n        let z1 = eyey - centery;\n        let z2 = eyez - centerz;\n        let len = 1 / Math.hypot(z0, z1, z2);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n        let x0 = upy * z2 - upz * z1;\n        let x1 = upz * z0 - upx * z2;\n        let x2 = upx * z1 - upy * z0;\n        len = Math.hypot(x0, x1, x2);\n        if (!len) {\n            x0 = 0;\n            x1 = 0;\n            x2 = 0;\n        }\n        else {\n            len = 1 / len;\n            x0 *= len;\n            x1 *= len;\n            x2 *= len;\n        }\n        let y0 = z1 * x2 - z2 * x1;\n        let y1 = z2 * x0 - z0 * x2;\n        let y2 = z0 * x1 - z1 * x0;\n        len = Math.hypot(y0, y1, y2);\n        if (!len) {\n            y0 = 0;\n            y1 = 0;\n            y2 = 0;\n        }\n        else {\n            len = 1 / len;\n            y0 *= len;\n            y1 *= len;\n            y2 *= len;\n        }\n        this.value[0] = x0;\n        this.value[1] = y0;\n        this.value[2] = z0;\n        this.value[3] = 0;\n        this.value[4] = x1;\n        this.value[5] = y1;\n        this.value[6] = z1;\n        this.value[7] = 0;\n        this.value[8] = x2;\n        this.value[9] = y2;\n        this.value[10] = z2;\n        this.value[11] = 0;\n        this.value[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n        this.value[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n        this.value[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n        this.value[15] = 1;\n        return this;\n    }\n    /**\n     * Generates a left-handed perspection projection matrix with the given bounds.\n     * The projection matrix is based on near and far view distance,\n     * angle of the view of the camera and your screen resolution proportion.\n     * @param fov The field of view in radians.\n     * @param aspect The aspect ratio of the view.\n     * @param near The near clipping bound of frustum. Should be larger than 0.\n     * @param far The far clipping bound of frustum. Should be larger than 0.\n     */\n    perspective(fov, aspect, near, far) {\n        const f = 1.0 / Math.tan(fov / 2);\n        let nf;\n        this.value[0] = f / aspect;\n        this.value[1] = 0;\n        this.value[2] = 0;\n        this.value[3] = 0;\n        this.value[4] = 0;\n        this.value[5] = f;\n        this.value[6] = 0;\n        this.value[7] = 0;\n        this.value[8] = 0;\n        this.value[9] = 0;\n        this.value[11] = -1;\n        this.value[12] = 0;\n        this.value[13] = 0;\n        this.value[15] = 0;\n        if (far !== null && far !== Infinity) {\n            nf = 1 / (near - far);\n            this.value[10] = (far + near) * nf;\n            this.value[14] = 2 * far * near * nf;\n        }\n        else {\n            this.value[10] = -1;\n            this.value[14] = -2 * near;\n        }\n        return this;\n    }\n    /**\n     * Sets the values of this matrix based on given yaw, pitch and roll.\n     * Degu uses: YXZ Local Axes Yaw (y), Pitch (x), Roll (z)\n     */\n    ypr(yaw, pitch, roll) {\n        this.zero();\n        const temp = new MatrixIV().zero();\n        const temp2 = new MatrixIV().zero();\n        const m0 = this.value;\n        const m1 = temp.value;\n        const m2 = temp2.value;\n        //  Rotate Z\n        let s = Math.sin(roll);\n        let c = Math.cos(roll);\n        m0[10] = 1;\n        m0[15] = 1;\n        m0[0] = c;\n        m0[1] = s;\n        m0[4] = -s;\n        m0[5] = c;\n        //  Rotate X\n        s = Math.sin(pitch);\n        c = Math.cos(pitch);\n        m1[0] = 1;\n        m1[15] = 1;\n        m1[5] = c;\n        m1[10] = c;\n        m1[9] = -s;\n        m1[6] = s;\n        //  Rotate Y\n        s = Math.sin(yaw);\n        c = Math.cos(yaw);\n        m2[5] = 1;\n        m2[15] = 1;\n        m2[0] = c;\n        m2[2] = -s;\n        m2[8] = s;\n        m2[10] = c;\n        this.multiply(temp);\n        this.multiply(temp2);\n        return this;\n    }\n    /**\n     * Sets this matrix from an array.\n     * @param values\n     */\n    fromArray(values) {\n        this.value = values;\n        return this;\n    }\n    static fromArray(values) {\n        return MatrixIV.IDENTITY.fromArray(values);\n    }\n    // static fromQuaternion(q: Quaternion): MatrixIV {\n    //     let position = Vector.ZERO;\n    //     let scale = Vector.ONE;\n    //     return MatrixIV.compose(position, q, scale);\n    // }\n    /**\n     * Creates a matrixIV from a quaternion.\n     * Based off: https://github.com/toji/gl-matrix/blob/master/src/mat4.js\n     * @param q\n     */\n    static fromQuaternion(q) {\n        const x = q.x, y = q.y, z = q.z, w = q.w;\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const yx = y * x2;\n        const yy = y * y2;\n        const zx = z * x2;\n        const zy = z * y2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n        const out = [];\n        out[0] = 1 - yy - zz;\n        out[1] = yx + wz;\n        out[2] = zx - wy;\n        out[3] = 0;\n        out[4] = yx - wz;\n        out[5] = 1 - xx - zz;\n        out[6] = zy + wx;\n        out[7] = 0;\n        out[8] = zx + wy;\n        out[9] = zy - wx;\n        out[10] = 1 - xx - yy;\n        out[11] = 0;\n        out[12] = 0;\n        out[13] = 0;\n        out[14] = 0;\n        out[15] = 1;\n        return MatrixIV.fromArray(new Float32Array(out));\n    }\n    /**\n     * Composes a new matrixIV from a position, rotation and scale.\n     *\n     * ```ts\n     *\n     * let mat = MatrixIV.compose(position, rotation, scale);\n     *\n     * // Create a rotation matrix from a quaternion.  Same effect as\n     * // MatrixIV.fromQuaterion.\n     * let position = Vector.ZERO;\n     * let scale = Vector.ONE;\n     * let myQuaternion = Quaternion.fromEular(90,90,90);\n     * let rotationMatrix = MatrixIV.compose(position, q, scale);\n     *\n     * ```\n     *\n     * Thanks to Mr. Doob:\n     * https://github.com/mrdoob/three.js/blob/master/src/math/Matrix4.js\n     *\n     * @param position\n     * @param quaternion\n     * @param scale\n     */\n    static compose(position, rotation, scale) {\n        const out = [];\n        const x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;\n        const x2 = x + x, y2 = y + y, z2 = z + z;\n        const xx = x * x2, xy = x * y2, xz = x * z2;\n        const yy = y * y2, yz = y * z2, zz = z * z2;\n        const wx = w * x2, wy = w * y2, wz = w * z2;\n        const sx = scale.x, sy = scale.y, sz = scale.z;\n        out[0] = (1 - (yy + zz)) * sx;\n        out[1] = (xy + wz) * sx;\n        out[2] = (xz - wy) * sx;\n        out[3] = 0;\n        out[4] = (xy - wz) * sy;\n        out[5] = (1 - (xx + zz)) * sy;\n        out[6] = (yz + wx) * sy;\n        out[7] = 0;\n        out[8] = (xz + wy) * sz;\n        out[9] = (yz - wx) * sz;\n        out[10] = (1 - (xx + yy)) * sz;\n        out[11] = 0;\n        out[12] = position.x;\n        out[13] = position.y;\n        out[14] = position.z;\n        out[15] = 1;\n        return new MatrixIV().fromArray(new Float32Array(out));\n    }\n    /**\n     * Creates and returns an identity matrix.\n     *\n     * ```ts\n     * let m = MatrixIV.IDENTITY;\n     * ```\n     * @static\n     */\n    static get IDENTITY() {\n        return new MatrixIV().identity();\n    }\n    /**\n     * Alias to MatrixIV identity.\n     */\n    static get _() {\n        return new MatrixIV().identity();\n    }\n}\nexports.MatrixIV = MatrixIV;\n//# sourceMappingURL=matrixIV.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbWF0aGYvbWF0cml4SVYuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvbWF0aGYvbWF0cml4SVYuanM/NGYyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWF0cml4SVYgPSB2b2lkIDA7XG5jb25zdCB2ZWN0b3JfMSA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcbi8qKlxuICogQSA0IGZvdXIgZGltZW5zaW9uYWwgaG9tb2dlbm91cyBtYXRyaXggY2xhc3MuXG4gKlxuICogU2VlIGV4YW1wbGVzIGluIC9leGFtcGxlcyBmb3IgdXNlcyBvZiBtYXRyaXguXG4gKlxuICogYGBgXG4gKiAvLyBDcmVhdGVzIGEgbmV3IG1hdHJpeC4gIERlZmF1bHQgbWF0cml4IGlzIHNldCB0byBpZGVudGl0eS5cbiAqIGxldCBtYXRyaXhBID0gbmV3IE1hdHJpeElWKCk7XG4gKlxuICogbWF0cml4QS50cmFuc2xhdGVYeXooMjAsIDMwLCA0MCk7XG4gKlxuICpcbiAqIC8vIENyZWF0ZXMgYW4gaWRlbnRpdHkgbWF0cml4LlxuICogbGV0IG1hdHJpeEIgPSBNYXRyaXhJVi5JREVOVElUWTtcbiAqXG4gKiAvLyBSb3RhdGUgaXQgb24gdGhlIFogYXhpcyBieSA5MCBkZWdyZWVzLlxuICogbWF0cml4Qi5zY2FsZSg5MCAqIE1hdGguUEkgLyAxODAsIG5ldyBWZWN0b3IoMCwwLCAxKSk7XG4gKlxuICogYGBgXG4gKlxuICogUmVmZXJlbmNlZDpcbiAqIEBzZWUgaHR0cDovL3d3dy5vcGVuZ2wtdHV0b3JpYWwub3JnL2JlZ2lubmVycy10dXRvcmlhbHMvdHV0b3JpYWwtMy1tYXRyaWNlcy9cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RveGFzL21pbk1hdHJpeC5qcy9ibG9iL21hc3Rlci9taW5NYXRyaXguanNcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9ibG9iL3YzLjE3LjAvc3JjL21hdGgvTWF0cml4NC5qc1xuICogQHNlZSBodHRwczovL3d3dy55b3V0dWJlLmNvbS9jaGFubmVsL1VDRWhCTTJ4NU1HOS1lX0pTT3pVMDY4d1xuICogQHNlZSBodHRwczovL3d3dy51c2VyYWdlbnRtYW4uY29tL2Jsb2cvMjAxMS8wMS8wNy9jc3MzLW1hdHJpeC10cmFuc2Zvcm0tZm9yLXRoZS1tYXRoZW1hdGljYWxseS1jaGFsbGVuZ2VkL1xuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXhcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FkcmFnb25pdGUvbWF0aDNkL2Jsb2IvbWFzdGVyL3NyYy9NYXRyaXg0eDQuanNcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iL21hc3Rlci9zcmMvbWF0aC9NYXRyaXg0LmpzXG4gKlxuICogQHVuc3RhYmxlXG4gKi9cbmNsYXNzIE1hdHJpeElWIHtcbiAgICBjb25zdHJ1Y3RvcihtYXRyaXgpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgICAgICB0aGlzLmlkZW50aXR5KCk7XG4gICAgICAgIC8vIElmIG1hdHJpeCB3YXMgcHJvdmlkZWQsIGNvcHkgaXQsIG90aGVyd2lzZSwgY3JlYXRlXG4gICAgICAgIC8vIGFuIGlkZW50aXR5IGRlZmF1bHQgbWF0cml4LlxuICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLmNvcHkobWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaWRlbnRpdHkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgbWF0cml4IHRvIGEgZGVmYXVsdCBpZGVudGl0eSBtYXRyaXguXG4gICAgICovXG4gICAgaWRlbnRpdHkoKSB7XG4gICAgICAgIHRoaXMudmFsdWVbMF0gPSAxO1xuICAgICAgICB0aGlzLnZhbHVlWzFdID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVsyXSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVbM10gPSAwO1xuICAgICAgICB0aGlzLnZhbHVlWzRdID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVs1XSA9IDE7XG4gICAgICAgIHRoaXMudmFsdWVbNl0gPSAwO1xuICAgICAgICB0aGlzLnZhbHVlWzddID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVs4XSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVbOV0gPSAwO1xuICAgICAgICB0aGlzLnZhbHVlWzEwXSA9IDE7XG4gICAgICAgIHRoaXMudmFsdWVbMTFdID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVsxMl0gPSAwO1xuICAgICAgICB0aGlzLnZhbHVlWzEzXSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVbMTRdID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGlzIG1hdHJpeCB0byBoYXZlIGFsbCAwIHZhbHVlLlxuICAgICAqL1xuICAgIHplcm8oKSB7XG4gICAgICAgIHRoaXMudmFsdWVbMF0gPSAwO1xuICAgICAgICB0aGlzLnZhbHVlWzFdID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVsyXSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVbM10gPSAwO1xuICAgICAgICB0aGlzLnZhbHVlWzRdID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVs1XSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVbNl0gPSAwO1xuICAgICAgICB0aGlzLnZhbHVlWzddID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVs4XSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVbOV0gPSAwO1xuICAgICAgICB0aGlzLnZhbHVlWzEwXSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVbMTFdID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVsxMl0gPSAwO1xuICAgICAgICB0aGlzLnZhbHVlWzEzXSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVbMTRdID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVsxNV0gPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoaXMgbWF0cml4LlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBsZXQgbSA9IG15TWF0cml4LmNsb25lKCk7ICAvLyBtIGlzIG5vdyBhIG5ldyBjbG9uZSBvZiBteU1hdHJpeC5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXhJVih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYW5vdGhlciBtYXRyaXggaW50byB0aGlzIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbWF0cml4QS5jb3B5KG1hdHJpeEIpIC8vIE5vdyBtYXRyaXhBIGhhcyB0aGUgdmFsdWVzIG9mIG1hdHJpeEIuXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHtNYXRyaXhJVn0gbWF0cml4SVZcbiAgICAgKi9cbiAgICBjb3B5KG1hdHJpeDQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG1hdHJpeDQudmFsdWUuc2xpY2UoMCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaWxscyBhIHNwZWNpZmljIGNvbHVtbiBvZiB0aGlzIG1hdHJpeCB3aXRoIGEgdmVjdG9yIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHBhc3NpbmcgMiBhcyB0aGUgY29sdW1uIHdvdWxkOlxuICAgICAqIFtcbiAgICAgKiAgIDEsICAwLCAgeCwgIDBcbiAgICAgKiAgIDAsICAxLCAgeSwgIDAsXG4gICAgICogICAwLCAgMCwgIHosICAwLFxuICAgICAqICAgMCwgIDAsICAwLCAgMVxuICAgICAqIF1cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIFRoaXMgaXMgdXNlZnVsIHRvIGNyZWF0ZSBhIGJhc2lzIG1hdHJpeC4gIEJlbG93IGlzIGEgNHg0XG4gICAgICogbWF0cml4IGNvbnN0cnVjdGVkIG9mIHVwLCByaWdodCBhbmQgZm9yd2FyZCB2ZWN0b3JzLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqICAgbGV0IHVwID0gbmV3IFZlY3RvcigwLCA1MCk7XG4gICAgICogICBsZXQgcmlnaHQgPSBuZXcgVmVjdG9yKDUwLCAwKTtcbiAgICAgKiAgIGxldCBmb3J3YXJkID0gVmVjdG9yLk9ORS5jcm9zcyh1cCk7XG4gICAgICogICBsZXQgYmFzaXNNYXRyaXggPSBuZXcgTWF0cml4SVYoKTtcbiAgICAgKiAgIGJhc2lzTWF0cml4LnNldFZlY3RvckNvbHVtbigwLCByaWdodCk7XG4gICAgICogICBiYXNpc01hdHJpeC5zZXRWZWN0b3JDb2x1bW4oMSwgdXApO1xuICAgICAqICAgYmFzaXNNYXRyaXguc2V0VmVjdG9yQ29sdW1uKDIsIGZvd2FyZCk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gVGhlIGNvbHVtbiBudW1iZXIgdG8gZmlsbC4gIEEgdmFsdWUgYmV0d2VlbiAwIGFuZCAzLlxuICAgICAqIEBwYXJhbSB2ZWN0b3IgVGhlIHZlY3RvciB0byBzZXQuXG4gICAgICovXG4gICAgc2V0VmVjdG9yQ29sdW1uKGNvbHVtbiwgdikge1xuICAgICAgICB0aGlzLnZhbHVlWzEgKiBjb2x1bW5dID0gdi54O1xuICAgICAgICB0aGlzLnZhbHVlWzEgKiBjb2x1bW4gKyA0XSA9IHYueTtcbiAgICAgICAgdGhpcy52YWx1ZVsxICogY29sdW1uICsgOF0gPSB2Lno7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYWxlcyB0aGlzIG1hdHJpeCBnaXZlbiB4LCB5LCB6IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbXlNYXRyaXguc2NhbGVYeXooMC41LCAwLjUsIDAuNSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHBhcmFtIHpcbiAgICAgKiBAcmV0dXJuIHtNYXRyaXhJVn1cbiAgICAgKi9cbiAgICBzY2FsZVh5eih4LCB5LCB6KSB7XG4gICAgICAgIHRoaXMudmFsdWVbMF0gPSB0aGlzLnZhbHVlWzBdICogeDtcbiAgICAgICAgdGhpcy52YWx1ZVsxXSA9IHRoaXMudmFsdWVbMV0gKiB4O1xuICAgICAgICB0aGlzLnZhbHVlWzJdID0gdGhpcy52YWx1ZVsyXSAqIHg7XG4gICAgICAgIHRoaXMudmFsdWVbM10gPSB0aGlzLnZhbHVlWzNdICogeDtcbiAgICAgICAgdGhpcy52YWx1ZVs0XSA9IHRoaXMudmFsdWVbNF0gKiB5O1xuICAgICAgICB0aGlzLnZhbHVlWzVdID0gdGhpcy52YWx1ZVs1XSAqIHk7XG4gICAgICAgIHRoaXMudmFsdWVbNl0gPSB0aGlzLnZhbHVlWzZdICogeTtcbiAgICAgICAgdGhpcy52YWx1ZVs3XSA9IHRoaXMudmFsdWVbN10gKiB5O1xuICAgICAgICB0aGlzLnZhbHVlWzhdID0gdGhpcy52YWx1ZVs4XSAqIHo7XG4gICAgICAgIHRoaXMudmFsdWVbOV0gPSB0aGlzLnZhbHVlWzldICogejtcbiAgICAgICAgdGhpcy52YWx1ZVsxMF0gPSB0aGlzLnZhbHVlWzEwXSAqIHo7XG4gICAgICAgIHRoaXMudmFsdWVbMTFdID0gdGhpcy52YWx1ZVsxMV0gKiB6O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgYSBzY2FsZSB0cmFuc2Zvcm1hdGlvbiB0byB0aGlzIG1hdHJpeCBnaXZlbiBhIHNjYWxlIHZlY3Rvci5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbXlNYXRyaXguc2NhbGUobmV3IFZlY3RvcigwLjUsIDAuNSwgMC41KSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdiB7VmVjdG9yfSBUaGUgdmVjdG9yIHRvIHNjYWxlIHRoaXMgbWF0cml4LlxuICAgICAqIEByZXR1cm4ge01hdHJpeElWfVxuICAgICAqL1xuICAgIHNjYWxlKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVYeXoodi54LCB2LnksIHYueik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhpcyBtYXRyaXggZ2l2ZW4gdGhlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbXlNYXRyaXgudHJhbnNsYXRlWHl6KDEwLCAyMCwgMCkpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcGFyYW0gelxuICAgICAqL1xuICAgIHRyYW5zbGF0ZVh5eih4LCB5LCB6KSB7XG4gICAgICAgIHRoaXMudmFsdWVbMTJdID1cbiAgICAgICAgICAgIHRoaXMudmFsdWVbMF0gKiB4ICtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlWzRdICogeSArXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZVs4XSAqIHogK1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVbMTJdO1xuICAgICAgICB0aGlzLnZhbHVlWzEzXSA9XG4gICAgICAgICAgICB0aGlzLnZhbHVlWzFdICogeCArXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZVs1XSAqIHkgK1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVbOV0gKiB6ICtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlWzEzXTtcbiAgICAgICAgdGhpcy52YWx1ZVsxNF0gPVxuICAgICAgICAgICAgdGhpcy52YWx1ZVsyXSAqIHggK1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVbNl0gKiB5ICtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlWzEwXSAqIHogK1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVbMTRdO1xuICAgICAgICB0aGlzLnZhbHVlWzE1XSA9XG4gICAgICAgICAgICB0aGlzLnZhbHVlWzNdICogeCArXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZVs3XSAqIHkgK1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVbMTFdICogeiArXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZVsxNV07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBseSBhIHRyYW5zbGF0aW9uLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBteU1hdHJpeC50cmFuc2xhdGUobmV3IFZlY3RvcigxLCAxLCAxKSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdHJhbnNsYXRlKHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlWHl6KHYueCwgdi55LCB2LnopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudCA0eDQgbWF0cml4IG92ZXIgdG8gYSBjc3MgM2QgbWF0cml4IHRyYW5zbGF0aW9uIHN0cmluZy5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogW1xuICAgICAqIGExIGEyIGEzIGE0XG4gICAgICogYjEgYjIgYjMgYjRcbiAgICAgKiBjMSBjMiBjMyBjNFxuICAgICAqIGQxIGQyIGQzIGQ0XG4gICAgICogXVxuICAgICAqID0gbWF0cml4M2QoYTEsIGIxLCBjMSwgZDEsIGEyLCBiMiwgYzIsIGQyLCBhMywgYjMsIGMzLCBkMywgYTQsIGI0LCBjNCwgZDQpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3RyYW5zZm9ybS1mdW5jdGlvbi9tYXRyaXgzZFxuICAgICAqL1xuICAgIHRvQ3NzM2RNYXRyaXgoKSB7XG4gICAgICAgIGNvbnN0IGExID0gdGhpcy52YWx1ZVswXTtcbiAgICAgICAgY29uc3QgYTIgPSB0aGlzLnZhbHVlWzFdO1xuICAgICAgICBjb25zdCBhMyA9IHRoaXMudmFsdWVbMl07XG4gICAgICAgIGNvbnN0IGE0ID0gdGhpcy52YWx1ZVszXTtcbiAgICAgICAgY29uc3QgYjEgPSB0aGlzLnZhbHVlWzRdO1xuICAgICAgICBjb25zdCBiMiA9IHRoaXMudmFsdWVbNV07XG4gICAgICAgIGNvbnN0IGIzID0gdGhpcy52YWx1ZVs2XTtcbiAgICAgICAgY29uc3QgYjQgPSB0aGlzLnZhbHVlWzddO1xuICAgICAgICBjb25zdCBjMSA9IHRoaXMudmFsdWVbOF07XG4gICAgICAgIGNvbnN0IGMyID0gdGhpcy52YWx1ZVs5XTtcbiAgICAgICAgY29uc3QgYzMgPSB0aGlzLnZhbHVlWzEwXTtcbiAgICAgICAgY29uc3QgYzQgPSB0aGlzLnZhbHVlWzExXTtcbiAgICAgICAgY29uc3QgZDEgPSB0aGlzLnZhbHVlWzEyXTtcbiAgICAgICAgY29uc3QgZDIgPSB0aGlzLnZhbHVlWzEzXTtcbiAgICAgICAgY29uc3QgZDMgPSB0aGlzLnZhbHVlWzE0XTtcbiAgICAgICAgY29uc3QgZDQgPSB0aGlzLnZhbHVlWzE1XTtcbiAgICAgICAgcmV0dXJuIGBtYXRyaXgzZCgke2ExfSwgJHtiMX0sICR7YzF9LCAke2QxfSwgJHthMn0sICR7YjJ9LFxuICAgICAgICAgICAgJHtjMn0sICR7ZDJ9LCAke2EzfSwgJHtiM30sICR7YzN9LCAke2QzfSwgJHthNH0sICR7YjR9LCAke2M0fSwgJHtkNH0pYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggYW5vdGhlci5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbWF0cml4QS5tdWx0aXBseShtYXRyaXhCKTsgLy8gTm93IHZhbHVlIG9mIG1hdHJpeEEgaXMgbXVsdGlwbGllZCB3aXRoIEIuXG4gICAgICpcbiAgICAgKiBtYXRyaXhDID0gbWF0cml4QS5jbG9uZSgpLm11bHRpcGx5KG1hdHJpeEIpOyAvLyBtYXRyaXhDIGlzIHByb2R1Y3QuXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIG1hdFxuICAgICAqL1xuICAgIG11bHRpcGx5KG1hdCkge1xuICAgICAgICBjb25zdCBhMDAgPSB0aGlzLnZhbHVlWzBdO1xuICAgICAgICBjb25zdCBhMDEgPSB0aGlzLnZhbHVlWzFdO1xuICAgICAgICBjb25zdCBhMDIgPSB0aGlzLnZhbHVlWzJdO1xuICAgICAgICBjb25zdCBhMDMgPSB0aGlzLnZhbHVlWzNdO1xuICAgICAgICBjb25zdCBhMTAgPSB0aGlzLnZhbHVlWzRdO1xuICAgICAgICBjb25zdCBhMTEgPSB0aGlzLnZhbHVlWzVdO1xuICAgICAgICBjb25zdCBhMTIgPSB0aGlzLnZhbHVlWzZdO1xuICAgICAgICBjb25zdCBhMTMgPSB0aGlzLnZhbHVlWzddO1xuICAgICAgICBjb25zdCBhMjAgPSB0aGlzLnZhbHVlWzhdO1xuICAgICAgICBjb25zdCBhMjEgPSB0aGlzLnZhbHVlWzldO1xuICAgICAgICBjb25zdCBhMjIgPSB0aGlzLnZhbHVlWzEwXTtcbiAgICAgICAgY29uc3QgYTIzID0gdGhpcy52YWx1ZVsxMV07XG4gICAgICAgIGNvbnN0IGEzMCA9IHRoaXMudmFsdWVbMTJdO1xuICAgICAgICBjb25zdCBhMzEgPSB0aGlzLnZhbHVlWzEzXTtcbiAgICAgICAgY29uc3QgYTMyID0gdGhpcy52YWx1ZVsxNF07XG4gICAgICAgIGNvbnN0IGEzMyA9IHRoaXMudmFsdWVbMTVdO1xuICAgICAgICBjb25zdCBiID0gbWF0LnZhbHVlO1xuICAgICAgICBsZXQgYjAgPSBiWzBdO1xuICAgICAgICBsZXQgYjEgPSBiWzFdO1xuICAgICAgICBsZXQgYjIgPSBiWzJdO1xuICAgICAgICBsZXQgYjMgPSBiWzNdO1xuICAgICAgICB0aGlzLnZhbHVlWzBdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gICAgICAgIHRoaXMudmFsdWVbMV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgICAgICAgdGhpcy52YWx1ZVsyXSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICAgICAgICB0aGlzLnZhbHVlWzNdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gICAgICAgIGIwID0gYls0XTtcbiAgICAgICAgYjEgPSBiWzVdO1xuICAgICAgICBiMiA9IGJbNl07XG4gICAgICAgIGIzID0gYls3XTtcbiAgICAgICAgdGhpcy52YWx1ZVs0XSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICAgICAgICB0aGlzLnZhbHVlWzVdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gICAgICAgIHRoaXMudmFsdWVbNl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgICAgICAgdGhpcy52YWx1ZVs3XSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICAgICAgICBiMCA9IGJbOF07XG4gICAgICAgIGIxID0gYls5XTtcbiAgICAgICAgYjIgPSBiWzEwXTtcbiAgICAgICAgYjMgPSBiWzExXTtcbiAgICAgICAgdGhpcy52YWx1ZVs4XSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICAgICAgICB0aGlzLnZhbHVlWzldID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gICAgICAgIHRoaXMudmFsdWVbMTBdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gICAgICAgIHRoaXMudmFsdWVbMTFdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gICAgICAgIGIwID0gYlsxMl07XG4gICAgICAgIGIxID0gYlsxM107XG4gICAgICAgIGIyID0gYlsxNF07XG4gICAgICAgIGIzID0gYlsxNV07XG4gICAgICAgIHRoaXMudmFsdWVbMTJdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gICAgICAgIHRoaXMudmFsdWVbMTNdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gICAgICAgIHRoaXMudmFsdWVbMTRdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gICAgICAgIHRoaXMudmFsdWVbMTVdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHRoaXMgNHg0IG1hdHJpeCBieSBhIDR4MSBtYXRyaXguICBUaGlzIHJlc3VsdHMgaW5cbiAgICAgKiByZXR1cm5pbmcgdGhlIHJlc3VsdHMgYXMgYSA0eDEgbWF0cml4LlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogICAgIDR4NCBNYXRyaXggICAgICAgICA0eDEgKFZlY3RvcilcbiAgICAgKiAgICAgIGEsIGIsIGMsIGQgICAgICAgICAgICAgICB4ICAgICAgPSBheCArIGJ5ICsgY3ogKyBkd1xuICAgICAqICAgICAgZSwgZiwgZywgaCAgICAgeCAgICAgICAgIHkgICAgICA9IGV4ICsgZnkgKyBneiArIGh3XG4gICAgICogICAgICBpLCBqLCBrLCBsICAgICAgICAgICAgICAgeiAgICAgID0gaXggKyBqeSArIGt6ICsgbHdcbiAgICAgKiAgICAgbSwgIG4sICBvLCBwICAgICAgICAgICAgICB3ICAgICAgPSBteCArIG55ICsgb3ogKyBwd1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEBwYXJhbSB6XG4gICAgICogQHBhcmFtIHcgVXNlIDEgZm9yIHBvc2l0aW9ucyBhbmQgMCBmb3IgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIG11bHRpcGx5Qnk0eDEoeCwgeSwgeiwgdyA9IDEpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBhWzBdICogeCArIGFbMV0gKiB5ICsgYVsyXSAqIHogKyBhWzNdICogdyxcbiAgICAgICAgICAgIGFbNF0gKiB4ICsgYVs1XSAqIHkgKyBhWzZdICogeiArIGFbN10gKiB3LFxuICAgICAgICAgICAgYVs4XSAqIHggKyBhWzldICogeSArIGFbMTBdICogeiArIGFbMTFdICogdyxcbiAgICAgICAgICAgIGFbMTJdICogeCArIGFbMTNdICogeSArIGFbMTRdICogeiArIGFbMTVdICogdyxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGlzIG1hdHJpeCBieSBhIHZlY3RvciB0aGF0IGlzIGNvbnZlcnRlZCB0byBhIDR4MS4gIFJldHVybnNcbiAgICAgKiBhIHZlY3RvciB0aGF0IHdhcyBjb252ZXJ0ZWQgZnJvbSB0aGUgcmVzdWx0aW5nIDR4MS5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICAgICBCYXNpcyBNYXRyaXggICAgICAgICA0eDEgKFZlY3RvcilcbiAgICAgKiAgICAgIGEsIGIsIGMsIGQgICAgICAgICAgICAgICB4XG4gICAgICogICAgICBlLCBmLCBnLCBoICAgICB4ICAgICAgICAgeVxuICAgICAqICAgICAgaSwgaiwgaywgbCAgICAgICAgICAgICAgIHpcbiAgICAgKiAgICAgbSwgIG4sICBvLCBwICAgICAgICAgICAgICB3XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKiAgIGxldCB1cCA9IG5ldyBWZWN0b3IoMCwgNTApO1xuICAgICAqICAgbGV0IHJpZ2h0ID0gbmV3IFZlY3Rvcig1MCwgMCk7XG4gICAgICogICBsZXQgZm9yd2FyZCA9IFZlY3Rvci5PTkUuY3Jvc3ModXApO1xuICAgICAqICAgbGV0IGJhc2lzTWF0cml4ID0gbmV3IE1hdHJpeElWKCk7XG4gICAgICogICBiYXNpc01hdHJpeC5zZXRWZWN0b3JDb2x1bW4oMCwgcmlnaHQpO1xuICAgICAqICAgYmFzaXNNYXRyaXguc2V0VmVjdG9yQ29sdW1uKDEsIHVwKTtcbiAgICAgKiAgIGJhc2lzTWF0cml4LnNldFZlY3RvckNvbHVtbigyLCBmb3J3YXJkKTtcbiAgICAgKlxuICAgICAqICAgbGV0IHAwID0gbmV3IFZlY3RvcigtMSwgLTEpO1xuICAgICAqICAgbGV0IHAxID0gbmV3IFZlY3RvcigxLCAtMSk7XG4gICAgICogICBsZXQgcDIgPSBuZXcgVmVjdG9yKDEsIDEpO1xuICAgICAqICAgbGV0IHAzID0gbmV3IFZlY3RvcigtMSwgMSk7XG4gICAgICogICBsZXQgdDAgPSBiYXNpc01hdHJpeC5jbG9uZSgpLm11bHRpcGx5QnlWZWN0b3IocDEpO1xuICAgICAqICAgbGV0IHQxID0gYmFzaXNNYXRyaXguY2xvbmUoKS5tdWx0aXBseUJ5VmVjdG9yKHAxKTtcbiAgICAgKiAgIGxldCB0MiA9IGJhc2lzTWF0cml4LmNsb25lKCkubXVsdGlwbHlCeVZlY3RvcihwMik7XG4gICAgICogICBsZXQgdDMgPSBiYXNpc01hdHJpeC5jbG9uZSgpLm11bHRpcGx5QnlWZWN0b3IocDMpO1xuICAgICAqXG4gICAgICogICAvLyBOb3cgdDAtdDMgYXJlIHZlY3RvciBvZiB0aGUgY29ybmVyIHBvaW50cyBvZiBhIDEwMHgxMDAgc3F1YXJlLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICovXG4gICAgbXVsdGlwbHlCeVZlY3Rvcih2LCB3ID0gMSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLm11bHRpcGx5Qnk0eDEodi54LCB2LnksIHYueiwgdyk7XG4gICAgICAgIHJldHVybiBuZXcgdmVjdG9yXzEuVmVjdG9yKHJlc3VsdFswXSwgcmVzdWx0WzFdLCByZXN1bHRbMl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoaXMgbWF0cml4IGF0IGFuIGdpdmVuIGFuZ2xlIGFuZCBheGlzLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgLy8gUm90YXRlIGFsb25nIFggYXMgdGhlIGF4aXMsIHNpbWlsYXIgdG8gcm90YXRlWFxuICAgICAqICAgbGV0IG1hdHJpeCA9IG5ldyBNYXRyaXhJVigpLnJvdGF0ZShhbmdsZSwgbmV3IFZlY3RvcigxLCAwLCAwKSk7XG4gICAgICpcbiAgICAgKiAgLy8gUm90YXRlIGFsb25nIHkgYXMgdGhlIGF4aXMsIHNpbWlsYXIgdG8gcm90YXRlWVxuICAgICAqICAgbWF0cml4ID0gbmV3IE1hdHJpeElWKCkucm90YXRlKGFuZ2xlLCBuZXcgVmVjdG9yKDAsIDEsIDApKTtcbiAgICAgKlxuICAgICAqICAvLyBSb3RhdGUgYWxvbmcgeSBhcyB0aGUgYXhpcywgc2ltaWxhciB0byByb3RhdGVaXG4gICAgICogICBtYXRyaXggPSBuZXcgTWF0cml4SVYoKS5yb3RhdGUoYW5nbGUsIG5ldyBWZWN0b3IoMCwgMCwgMSkpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGFuZ2xlIEFuIGFuZ2xlIGluIHJhZGlhbnNcbiAgICAgKiBAcGFyYW0gYXhpcyBBIHZlY3RvciBwb2ludCB0aGF0IGFjdHMgYXMgdGhlIGF4aXMuXG4gICAgICovXG4gICAgcm90YXRlKGFuZ2xlLCBheGlzKSB7XG4gICAgICAgIGxldCBtZyA9IGF4aXMubWFnbml0dWRlKCk7XG4gICAgICAgIGlmICghbWcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhID0gYXhpcy54LCBiID0gYXhpcy55LCBjID0gYXhpcy56O1xuICAgICAgICBpZiAobWcgIT09IDEpIHtcbiAgICAgICAgICAgIG1nID0gMSAvIG1nO1xuICAgICAgICAgICAgYSAqPSBtZztcbiAgICAgICAgICAgIGIgKj0gbWc7XG4gICAgICAgICAgICBjICo9IG1nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGQgPSBNYXRoLnNpbihhbmdsZSksIGUgPSBNYXRoLmNvcyhhbmdsZSksIGYgPSAxIC0gZSwgZyA9IHRoaXMudmFsdWVbMF0sIGggPSB0aGlzLnZhbHVlWzFdLCBpID0gdGhpcy52YWx1ZVsyXSwgaiA9IHRoaXMudmFsdWVbM10sIGsgPSB0aGlzLnZhbHVlWzRdLCBsID0gdGhpcy52YWx1ZVs1XSwgbSA9IHRoaXMudmFsdWVbNl0sIG4gPSB0aGlzLnZhbHVlWzddLCBvID0gdGhpcy52YWx1ZVs4XSwgcCA9IHRoaXMudmFsdWVbOV0sIHEgPSB0aGlzLnZhbHVlWzEwXSwgciA9IHRoaXMudmFsdWVbMTFdLCBzID0gYSAqIGEgKiBmICsgZSwgdCA9IGIgKiBhICogZiArIGMgKiBkLCB1ID0gYyAqIGEgKiBmIC0gYiAqIGQsIHYgPSBhICogYiAqIGYgLSBjICogZCwgdyA9IGIgKiBiICogZiArIGUsIHggPSBjICogYiAqIGYgKyBhICogZCwgeSA9IGEgKiBjICogZiArIGIgKiBkLCB6ID0gYiAqIGMgKiBmIC0gYSAqIGQsIEEgPSBjICogYyAqIGYgKyBlO1xuICAgICAgICAvLyB0aGlzLnZhbHVlWzEyXSA9IHRoaXMudmFsdWVbMTJdO1xuICAgICAgICAvLyB0aGlzLnZhbHVlWzEzXSA9IHRoaXMudmFsdWVbMTNdO1xuICAgICAgICAvLyB0aGlzLnZhbHVlWzE0XSA9IHRoaXMudmFsdWVbMTRdO1xuICAgICAgICAvLyB0aGlzLnZhbHVlWzE1XSA9IHRoaXMudmFsdWVbMTVdO1xuICAgICAgICB0aGlzLnZhbHVlWzBdID0gZyAqIHMgKyBrICogdCArIG8gKiB1O1xuICAgICAgICB0aGlzLnZhbHVlWzFdID0gaCAqIHMgKyBsICogdCArIHAgKiB1O1xuICAgICAgICB0aGlzLnZhbHVlWzJdID0gaSAqIHMgKyBtICogdCArIHEgKiB1O1xuICAgICAgICB0aGlzLnZhbHVlWzNdID0gaiAqIHMgKyBuICogdCArIHIgKiB1O1xuICAgICAgICB0aGlzLnZhbHVlWzRdID0gZyAqIHYgKyBrICogdyArIG8gKiB4O1xuICAgICAgICB0aGlzLnZhbHVlWzVdID0gaCAqIHYgKyBsICogdyArIHAgKiB4O1xuICAgICAgICB0aGlzLnZhbHVlWzZdID0gaSAqIHYgKyBtICogdyArIHEgKiB4O1xuICAgICAgICB0aGlzLnZhbHVlWzddID0gaiAqIHYgKyBuICogdyArIHIgKiB4O1xuICAgICAgICB0aGlzLnZhbHVlWzhdID0gZyAqIHkgKyBrICogeiArIG8gKiBBO1xuICAgICAgICB0aGlzLnZhbHVlWzldID0gaCAqIHkgKyBsICogeiArIHAgKiBBO1xuICAgICAgICB0aGlzLnZhbHVlWzEwXSA9IGkgKiB5ICsgbSAqIHogKyBxICogQTtcbiAgICAgICAgdGhpcy52YWx1ZVsxMV0gPSBqICogeSArIG4gKiB6ICsgciAqIEE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIHRoaXMgbWF0cml4IGFsb25nIHRoZSB4IHBsYW5lLlxuICAgICAqIEBwYXJhbSBhbmdsZSBBbmdsZSBpbiByYWRpYW5zLlxuICAgICAqL1xuICAgIHJvdGF0ZVgoYW5nbGUpIHtcbiAgICAgICAgdGhpcy5yb3RhdGUoYW5nbGUsIG5ldyB2ZWN0b3JfMS5WZWN0b3IoMSwgMCwgMCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGlzIG1hdHJpeCBhbG9uZyB0aGUgeSBwbGFuZS5cbiAgICAgKiBAcGFyYW0gYW5nbGUgQW5nbGUgaW4gcmFkaWFucy5cbiAgICAgKi9cbiAgICByb3RhdGVZKGFuZ2xlKSB7XG4gICAgICAgIHRoaXMucm90YXRlKGFuZ2xlLCBuZXcgdmVjdG9yXzEuVmVjdG9yKDAsIDEsIDApKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgdGhpcyBtYXRyaXggYWxvbmcgdGhlIHogcGxhbmUuXG4gICAgICogQHBhcmFtIGFuZ2xlIEFuZ2xlIGluIHJhZGlhbnMuXG4gICAgICovXG4gICAgcm90YXRlWihhbmdsZSkge1xuICAgICAgICB0aGlzLnJvdGF0ZShhbmdsZSwgbmV3IHZlY3Rvcl8xLlZlY3RvcigwLCAwLCAxKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBWaWV3IE1hdHJpeCBmb3IgdGhlIHdvcmxkLXZpZGV3LXByb2plY3Rpb24gbWF0cml4IG9uIGFcbiAgICAgKiBsZWZ0LWhhbmRlZCBwcm9qZWN0aW9uLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZG94YXMvbWluTWF0cml4LmpzL2Jsb2IvbWFzdGVyL21pbk1hdHJpeC5qc1xuICAgICAqIGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTMxMjIyMTcwNDE1L2h0dHA6L3JvYmVydG9rb2NpLmNvbS93b3JsZC12aWV3LXByb2plY3Rpb24tbWF0cml4LXVudmVpbGVkL1xuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiAgIHZhciBleWUgPSBuZXcgVmVjdG9yKDAuMCwgMC4wLCA1LjApO1xuICAgICAqICAgdmFyIGNlbnRlciA9IG5ldyBWZWN0b3IoMC4wLCAwLjAsIDAuMCk7XG4gICAgICogICB2YXIgdXAgPSBuZXcgVmVjdG9yKDAuMCwgMS4wLCAwLjApO1xuICAgICAqICAgdmFyIG1hcnRpeCA9IG5ldyBNYXRyaXhJVigpLmxvb2tBdChleWUsIGNlbnRlciwgdXApO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGV5ZSBUaGUgY2FtZXJhIHBvc2l0aW9uIHZlY3RvclxuICAgICAqIEBwYXJhbSBjZW50ZXIgVGhlIGNhbWVyYSB0YXJnZXQgdmVjdG9yXG4gICAgICogQHBhcmFtIHVwIFRoZSB1cCB2ZWN0b3IgcmVsYXRpdmUgdG8gdGhlIGNhbWVyYS5cbiAgICAgKi9cbiAgICBsb29rQXQoZXllLCBjZW50ZXIsIHVwID0gdmVjdG9yXzEuVmVjdG9yLlVQKSB7XG4gICAgICAgIGNvbnN0IGV5ZXggPSBleWUueDtcbiAgICAgICAgY29uc3QgZXlleSA9IGV5ZS55O1xuICAgICAgICBjb25zdCBleWV6ID0gZXllLno7XG4gICAgICAgIGNvbnN0IHVweCA9IHVwLng7XG4gICAgICAgIGNvbnN0IHVweSA9IHVwLnk7XG4gICAgICAgIGNvbnN0IHVweiA9IHVwLno7XG4gICAgICAgIGNvbnN0IGNlbnRlcnggPSBjZW50ZXIueDtcbiAgICAgICAgY29uc3QgY2VudGVyeSA9IGNlbnRlci55O1xuICAgICAgICBjb25zdCBjZW50ZXJ6ID0gY2VudGVyLno7XG4gICAgICAgIGlmIChNYXRoLmFicyhleWV4IC0gY2VudGVyeCkgPCAwLjAwMDAxICYmXG4gICAgICAgICAgICBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCAwLjAwMDAxICYmXG4gICAgICAgICAgICBNYXRoLmFicyhleWV6IC0gY2VudGVyeikgPCAwLjAwMDAxKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0cml4SVYuSURFTlRJVFk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHowID0gZXlleCAtIGNlbnRlcng7XG4gICAgICAgIGxldCB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICAgICAgICBsZXQgejIgPSBleWV6IC0gY2VudGVyejtcbiAgICAgICAgbGV0IGxlbiA9IDEgLyBNYXRoLmh5cG90KHowLCB6MSwgejIpO1xuICAgICAgICB6MCAqPSBsZW47XG4gICAgICAgIHoxICo9IGxlbjtcbiAgICAgICAgejIgKj0gbGVuO1xuICAgICAgICBsZXQgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICAgICAgICBsZXQgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICAgICAgICBsZXQgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICAgICAgICBsZW4gPSBNYXRoLmh5cG90KHgwLCB4MSwgeDIpO1xuICAgICAgICBpZiAoIWxlbikge1xuICAgICAgICAgICAgeDAgPSAwO1xuICAgICAgICAgICAgeDEgPSAwO1xuICAgICAgICAgICAgeDIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgICAgIHgwICo9IGxlbjtcbiAgICAgICAgICAgIHgxICo9IGxlbjtcbiAgICAgICAgICAgIHgyICo9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICAgICAgbGV0IHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gICAgICAgIGxldCB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuICAgICAgICBsZW4gPSBNYXRoLmh5cG90KHkwLCB5MSwgeTIpO1xuICAgICAgICBpZiAoIWxlbikge1xuICAgICAgICAgICAgeTAgPSAwO1xuICAgICAgICAgICAgeTEgPSAwO1xuICAgICAgICAgICAgeTIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgICAgIHkwICo9IGxlbjtcbiAgICAgICAgICAgIHkxICo9IGxlbjtcbiAgICAgICAgICAgIHkyICo9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlWzBdID0geDA7XG4gICAgICAgIHRoaXMudmFsdWVbMV0gPSB5MDtcbiAgICAgICAgdGhpcy52YWx1ZVsyXSA9IHowO1xuICAgICAgICB0aGlzLnZhbHVlWzNdID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVs0XSA9IHgxO1xuICAgICAgICB0aGlzLnZhbHVlWzVdID0geTE7XG4gICAgICAgIHRoaXMudmFsdWVbNl0gPSB6MTtcbiAgICAgICAgdGhpcy52YWx1ZVs3XSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVbOF0gPSB4MjtcbiAgICAgICAgdGhpcy52YWx1ZVs5XSA9IHkyO1xuICAgICAgICB0aGlzLnZhbHVlWzEwXSA9IHoyO1xuICAgICAgICB0aGlzLnZhbHVlWzExXSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICAgICAgICB0aGlzLnZhbHVlWzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgICAgICAgdGhpcy52YWx1ZVsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gICAgICAgIHRoaXMudmFsdWVbMTVdID0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIGxlZnQtaGFuZGVkIHBlcnNwZWN0aW9uIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kcy5cbiAgICAgKiBUaGUgcHJvamVjdGlvbiBtYXRyaXggaXMgYmFzZWQgb24gbmVhciBhbmQgZmFyIHZpZXcgZGlzdGFuY2UsXG4gICAgICogYW5nbGUgb2YgdGhlIHZpZXcgb2YgdGhlIGNhbWVyYSBhbmQgeW91ciBzY3JlZW4gcmVzb2x1dGlvbiBwcm9wb3J0aW9uLlxuICAgICAqIEBwYXJhbSBmb3YgVGhlIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFucy5cbiAgICAgKiBAcGFyYW0gYXNwZWN0IFRoZSBhc3BlY3QgcmF0aW8gb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIG5lYXIgVGhlIG5lYXIgY2xpcHBpbmcgYm91bmQgb2YgZnJ1c3R1bS4gU2hvdWxkIGJlIGxhcmdlciB0aGFuIDAuXG4gICAgICogQHBhcmFtIGZhciBUaGUgZmFyIGNsaXBwaW5nIGJvdW5kIG9mIGZydXN0dW0uIFNob3VsZCBiZSBsYXJnZXIgdGhhbiAwLlxuICAgICAqL1xuICAgIHBlcnNwZWN0aXZlKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgICAgICAgY29uc3QgZiA9IDEuMCAvIE1hdGgudGFuKGZvdiAvIDIpO1xuICAgICAgICBsZXQgbmY7XG4gICAgICAgIHRoaXMudmFsdWVbMF0gPSBmIC8gYXNwZWN0O1xuICAgICAgICB0aGlzLnZhbHVlWzFdID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVsyXSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVbM10gPSAwO1xuICAgICAgICB0aGlzLnZhbHVlWzRdID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVs1XSA9IGY7XG4gICAgICAgIHRoaXMudmFsdWVbNl0gPSAwO1xuICAgICAgICB0aGlzLnZhbHVlWzddID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVs4XSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVbOV0gPSAwO1xuICAgICAgICB0aGlzLnZhbHVlWzExXSA9IC0xO1xuICAgICAgICB0aGlzLnZhbHVlWzEyXSA9IDA7XG4gICAgICAgIHRoaXMudmFsdWVbMTNdID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZVsxNV0gPSAwO1xuICAgICAgICBpZiAoZmFyICE9PSBudWxsICYmIGZhciAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgICAgICAgICB0aGlzLnZhbHVlWzE0XSA9IDIgKiBmYXIgKiBuZWFyICogbmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlWzEwXSA9IC0xO1xuICAgICAgICAgICAgdGhpcy52YWx1ZVsxNF0gPSAtMiAqIG5lYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlcyBvZiB0aGlzIG1hdHJpeCBiYXNlZCBvbiBnaXZlbiB5YXcsIHBpdGNoIGFuZCByb2xsLlxuICAgICAqIERlZ3UgdXNlczogWVhaIExvY2FsIEF4ZXMgWWF3ICh5KSwgUGl0Y2ggKHgpLCBSb2xsICh6KVxuICAgICAqL1xuICAgIHlwcih5YXcsIHBpdGNoLCByb2xsKSB7XG4gICAgICAgIHRoaXMuemVybygpO1xuICAgICAgICBjb25zdCB0ZW1wID0gbmV3IE1hdHJpeElWKCkuemVybygpO1xuICAgICAgICBjb25zdCB0ZW1wMiA9IG5ldyBNYXRyaXhJVigpLnplcm8oKTtcbiAgICAgICAgY29uc3QgbTAgPSB0aGlzLnZhbHVlO1xuICAgICAgICBjb25zdCBtMSA9IHRlbXAudmFsdWU7XG4gICAgICAgIGNvbnN0IG0yID0gdGVtcDIudmFsdWU7XG4gICAgICAgIC8vICBSb3RhdGUgWlxuICAgICAgICBsZXQgcyA9IE1hdGguc2luKHJvbGwpO1xuICAgICAgICBsZXQgYyA9IE1hdGguY29zKHJvbGwpO1xuICAgICAgICBtMFsxMF0gPSAxO1xuICAgICAgICBtMFsxNV0gPSAxO1xuICAgICAgICBtMFswXSA9IGM7XG4gICAgICAgIG0wWzFdID0gcztcbiAgICAgICAgbTBbNF0gPSAtcztcbiAgICAgICAgbTBbNV0gPSBjO1xuICAgICAgICAvLyAgUm90YXRlIFhcbiAgICAgICAgcyA9IE1hdGguc2luKHBpdGNoKTtcbiAgICAgICAgYyA9IE1hdGguY29zKHBpdGNoKTtcbiAgICAgICAgbTFbMF0gPSAxO1xuICAgICAgICBtMVsxNV0gPSAxO1xuICAgICAgICBtMVs1XSA9IGM7XG4gICAgICAgIG0xWzEwXSA9IGM7XG4gICAgICAgIG0xWzldID0gLXM7XG4gICAgICAgIG0xWzZdID0gcztcbiAgICAgICAgLy8gIFJvdGF0ZSBZXG4gICAgICAgIHMgPSBNYXRoLnNpbih5YXcpO1xuICAgICAgICBjID0gTWF0aC5jb3MoeWF3KTtcbiAgICAgICAgbTJbNV0gPSAxO1xuICAgICAgICBtMlsxNV0gPSAxO1xuICAgICAgICBtMlswXSA9IGM7XG4gICAgICAgIG0yWzJdID0gLXM7XG4gICAgICAgIG0yWzhdID0gcztcbiAgICAgICAgbTJbMTBdID0gYztcbiAgICAgICAgdGhpcy5tdWx0aXBseSh0ZW1wKTtcbiAgICAgICAgdGhpcy5tdWx0aXBseSh0ZW1wMik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgbWF0cml4IGZyb20gYW4gYXJyYXkuXG4gICAgICogQHBhcmFtIHZhbHVlc1xuICAgICAqL1xuICAgIGZyb21BcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBNYXRyaXhJVi5JREVOVElUWS5mcm9tQXJyYXkodmFsdWVzKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIGZyb21RdWF0ZXJuaW9uKHE6IFF1YXRlcm5pb24pOiBNYXRyaXhJViB7XG4gICAgLy8gICAgIGxldCBwb3NpdGlvbiA9IFZlY3Rvci5aRVJPO1xuICAgIC8vICAgICBsZXQgc2NhbGUgPSBWZWN0b3IuT05FO1xuICAgIC8vICAgICByZXR1cm4gTWF0cml4SVYuY29tcG9zZShwb3NpdGlvbiwgcSwgc2NhbGUpO1xuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWF0cml4SVYgZnJvbSBhIHF1YXRlcm5pb24uXG4gICAgICogQmFzZWQgb2ZmOiBodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXgvYmxvYi9tYXN0ZXIvc3JjL21hdDQuanNcbiAgICAgKiBAcGFyYW0gcVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUXVhdGVybmlvbihxKSB7XG4gICAgICAgIGNvbnN0IHggPSBxLngsIHkgPSBxLnksIHogPSBxLnosIHcgPSBxLnc7XG4gICAgICAgIGNvbnN0IHgyID0geCArIHg7XG4gICAgICAgIGNvbnN0IHkyID0geSArIHk7XG4gICAgICAgIGNvbnN0IHoyID0geiArIHo7XG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHgyO1xuICAgICAgICBjb25zdCB5eCA9IHkgKiB4MjtcbiAgICAgICAgY29uc3QgeXkgPSB5ICogeTI7XG4gICAgICAgIGNvbnN0IHp4ID0geiAqIHgyO1xuICAgICAgICBjb25zdCB6eSA9IHogKiB5MjtcbiAgICAgICAgY29uc3QgenogPSB6ICogejI7XG4gICAgICAgIGNvbnN0IHd4ID0gdyAqIHgyO1xuICAgICAgICBjb25zdCB3eSA9IHcgKiB5MjtcbiAgICAgICAgY29uc3Qgd3ogPSB3ICogejI7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICAgICAgb3V0WzFdID0geXggKyB3ejtcbiAgICAgICAgb3V0WzJdID0genggLSB3eTtcbiAgICAgICAgb3V0WzNdID0gMDtcbiAgICAgICAgb3V0WzRdID0geXggLSB3ejtcbiAgICAgICAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gICAgICAgIG91dFs2XSA9IHp5ICsgd3g7XG4gICAgICAgIG91dFs3XSA9IDA7XG4gICAgICAgIG91dFs4XSA9IHp4ICsgd3k7XG4gICAgICAgIG91dFs5XSA9IHp5IC0gd3g7XG4gICAgICAgIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgICAgICAgb3V0WzExXSA9IDA7XG4gICAgICAgIG91dFsxMl0gPSAwO1xuICAgICAgICBvdXRbMTNdID0gMDtcbiAgICAgICAgb3V0WzE0XSA9IDA7XG4gICAgICAgIG91dFsxNV0gPSAxO1xuICAgICAgICByZXR1cm4gTWF0cml4SVYuZnJvbUFycmF5KG5ldyBGbG9hdDMyQXJyYXkob3V0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBvc2VzIGEgbmV3IG1hdHJpeElWIGZyb20gYSBwb3NpdGlvbiwgcm90YXRpb24gYW5kIHNjYWxlLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIGxldCBtYXQgPSBNYXRyaXhJVi5jb21wb3NlKHBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGUpO1xuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIGEgcm90YXRpb24gbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uLiAgU2FtZSBlZmZlY3QgYXNcbiAgICAgKiAvLyBNYXRyaXhJVi5mcm9tUXVhdGVyaW9uLlxuICAgICAqIGxldCBwb3NpdGlvbiA9IFZlY3Rvci5aRVJPO1xuICAgICAqIGxldCBzY2FsZSA9IFZlY3Rvci5PTkU7XG4gICAgICogbGV0IG15UXVhdGVybmlvbiA9IFF1YXRlcm5pb24uZnJvbUV1bGFyKDkwLDkwLDkwKTtcbiAgICAgKiBsZXQgcm90YXRpb25NYXRyaXggPSBNYXRyaXhJVi5jb21wb3NlKHBvc2l0aW9uLCBxLCBzY2FsZSk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoYW5rcyB0byBNci4gRG9vYjpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2Jsb2IvbWFzdGVyL3NyYy9tYXRoL01hdHJpeDQuanNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBxdWF0ZXJuaW9uXG4gICAgICogQHBhcmFtIHNjYWxlXG4gICAgICovXG4gICAgc3RhdGljIGNvbXBvc2UocG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZSkge1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgY29uc3QgeCA9IHJvdGF0aW9uLngsIHkgPSByb3RhdGlvbi55LCB6ID0gcm90YXRpb24ueiwgdyA9IHJvdGF0aW9uLnc7XG4gICAgICAgIGNvbnN0IHgyID0geCArIHgsIHkyID0geSArIHksIHoyID0geiArIHo7XG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XG4gICAgICAgIGNvbnN0IHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XG4gICAgICAgIGNvbnN0IHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejI7XG4gICAgICAgIGNvbnN0IHN4ID0gc2NhbGUueCwgc3kgPSBzY2FsZS55LCBzeiA9IHNjYWxlLno7XG4gICAgICAgIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICAgICAgICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgICAgICAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gICAgICAgIG91dFszXSA9IDA7XG4gICAgICAgIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICAgICAgICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgICAgICAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gICAgICAgIG91dFs3XSA9IDA7XG4gICAgICAgIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICAgICAgICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgICAgICAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICAgICAgICBvdXRbMTFdID0gMDtcbiAgICAgICAgb3V0WzEyXSA9IHBvc2l0aW9uLng7XG4gICAgICAgIG91dFsxM10gPSBwb3NpdGlvbi55O1xuICAgICAgICBvdXRbMTRdID0gcG9zaXRpb24uejtcbiAgICAgICAgb3V0WzE1XSA9IDE7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4SVYoKS5mcm9tQXJyYXkobmV3IEZsb2F0MzJBcnJheShvdXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBpZGVudGl0eSBtYXRyaXguXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGxldCBtID0gTWF0cml4SVYuSURFTlRJVFk7XG4gICAgICogYGBgXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgSURFTlRJVFkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4SVYoKS5pZGVudGl0eSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyB0byBNYXRyaXhJViBpZGVudGl0eS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IF8oKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4SVYoKS5pZGVudGl0eSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWF0cml4SVYgPSBNYXRyaXhJVjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdHJpeElWLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/mathf/matrixIV.js\n");

/***/ }),

/***/ "./lib/mathf/perlin-noise.js":
/*!***********************************!*\
  !*** ./lib/mathf/perlin-noise.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PerlinNoise = void 0;\n/**\n * Port of Ken Perlin's noise algo and also sipmlex noise algo.\n * Big thanks to Ken Perlin, Kas Thomas for the explanation and also josephg.\n *\n * @see http://webstaff.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n * @see http://cs.nyu.edu/%7Eperlin/noise/\n * @see http://asserttrue.blogspot.com/2011/12/perlin-noise-in-javascript_31.html\n * @see https://github.com/josephg/noisejs/blob/master/perlin.js\n */\nclass PerlinNoise {\n    /**\n     * Generates perlin noise.  Specify normalized coordinates between 0 and 1.\n     * @param x  The x coordinate.\n     * @param y  The y coordinate.\n     * @param z  The z coordinate.\n     * @return A value between 0 and 1.\n     */\n    static noise3(x, y, z = 0) {\n        const fade = (t) => {\n            return t * t * t * (t * (t * 6 - 15) + 10);\n        };\n        const lerp = (t, a, b) => {\n            return a + t * (b - a);\n        };\n        const grad = (hash, x, y, z) => {\n            const h = hash & 15;\n            const u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : z;\n            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);\n        };\n        const scale = (n) => {\n            return (1 + n) / 2;\n        };\n        const p = new Array(512);\n        const permutation = [\n            151,\n            160,\n            137,\n            91,\n            90,\n            15,\n            131,\n            13,\n            201,\n            95,\n            96,\n            53,\n            194,\n            233,\n            7,\n            225,\n            140,\n            36,\n            103,\n            30,\n            69,\n            142,\n            8,\n            99,\n            37,\n            240,\n            21,\n            10,\n            23,\n            190,\n            6,\n            148,\n            247,\n            120,\n            234,\n            75,\n            0,\n            26,\n            197,\n            62,\n            94,\n            252,\n            219,\n            203,\n            117,\n            35,\n            11,\n            32,\n            57,\n            177,\n            33,\n            88,\n            237,\n            149,\n            56,\n            87,\n            174,\n            20,\n            125,\n            136,\n            171,\n            168,\n            68,\n            175,\n            74,\n            165,\n            71,\n            134,\n            139,\n            48,\n            27,\n            166,\n            77,\n            146,\n            158,\n            231,\n            83,\n            111,\n            229,\n            122,\n            60,\n            211,\n            133,\n            230,\n            220,\n            105,\n            92,\n            41,\n            55,\n            46,\n            245,\n            40,\n            244,\n            102,\n            143,\n            54,\n            65,\n            25,\n            63,\n            161,\n            1,\n            216,\n            80,\n            73,\n            209,\n            76,\n            132,\n            187,\n            208,\n            89,\n            18,\n            169,\n            200,\n            196,\n            135,\n            130,\n            116,\n            188,\n            159,\n            86,\n            164,\n            100,\n            109,\n            198,\n            173,\n            186,\n            3,\n            64,\n            52,\n            217,\n            226,\n            250,\n            124,\n            123,\n            5,\n            202,\n            38,\n            147,\n            118,\n            126,\n            255,\n            82,\n            85,\n            212,\n            207,\n            206,\n            59,\n            227,\n            47,\n            16,\n            58,\n            17,\n            182,\n            189,\n            28,\n            42,\n            223,\n            183,\n            170,\n            213,\n            119,\n            248,\n            152,\n            2,\n            44,\n            154,\n            163,\n            70,\n            221,\n            153,\n            101,\n            155,\n            167,\n            43,\n            172,\n            9,\n            129,\n            22,\n            39,\n            253,\n            19,\n            98,\n            108,\n            110,\n            79,\n            113,\n            224,\n            232,\n            178,\n            185,\n            112,\n            104,\n            218,\n            246,\n            97,\n            228,\n            251,\n            34,\n            242,\n            193,\n            238,\n            210,\n            144,\n            12,\n            191,\n            179,\n            162,\n            241,\n            81,\n            51,\n            145,\n            235,\n            249,\n            14,\n            239,\n            107,\n            49,\n            192,\n            214,\n            31,\n            181,\n            199,\n            106,\n            157,\n            184,\n            84,\n            204,\n            176,\n            115,\n            121,\n            50,\n            45,\n            127,\n            4,\n            150,\n            254,\n            138,\n            236,\n            205,\n            93,\n            222,\n            114,\n            67,\n            29,\n            24,\n            72,\n            243,\n            141,\n            128,\n            195,\n            78,\n            66,\n            215,\n            61,\n            156,\n            180,\n        ];\n        for (let i = 0; i < 256; i++)\n            p[256 + i] = p[i] = permutation[i];\n        const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;\n        x -= Math.floor(x);\n        y -= Math.floor(y);\n        z -= Math.floor(z);\n        const u = fade(x), v = fade(y), w = fade(z);\n        const A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z, B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;\n        return scale(lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), grad(p[BA], x - 1, y, z)), lerp(u, grad(p[AB], x, y - 1, z), grad(p[BB], x - 1, y - 1, z))), lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1), grad(p[BA + 1], x - 1, y, z - 1)), lerp(u, grad(p[AB + 1], x, y - 1, z - 1), grad(p[BB + 1], x - 1, y - 1, z - 1)))));\n    }\n}\nexports.PerlinNoise = PerlinNoise;\n//# sourceMappingURL=perlin-noise.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbWF0aGYvcGVybGluLW5vaXNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL21hdGhmL3Blcmxpbi1ub2lzZS5qcz8xY2U3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QZXJsaW5Ob2lzZSA9IHZvaWQgMDtcbi8qKlxuICogUG9ydCBvZiBLZW4gUGVybGluJ3Mgbm9pc2UgYWxnbyBhbmQgYWxzbyBzaXBtbGV4IG5vaXNlIGFsZ28uXG4gKiBCaWcgdGhhbmtzIHRvIEtlbiBQZXJsaW4sIEthcyBUaG9tYXMgZm9yIHRoZSBleHBsYW5hdGlvbiBhbmQgYWxzbyBqb3NlcGhnLlxuICpcbiAqIEBzZWUgaHR0cDovL3dlYnN0YWZmLml0bi5saXUuc2UvfnN0ZWd1L3NpbXBsZXhub2lzZS9zaW1wbGV4bm9pc2UucGRmXG4gKiBAc2VlIGh0dHA6Ly9jcy5ueXUuZWR1LyU3RXBlcmxpbi9ub2lzZS9cbiAqIEBzZWUgaHR0cDovL2Fzc2VydHRydWUuYmxvZ3Nwb3QuY29tLzIwMTEvMTIvcGVybGluLW5vaXNlLWluLWphdmFzY3JpcHRfMzEuaHRtbFxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vam9zZXBoZy9ub2lzZWpzL2Jsb2IvbWFzdGVyL3Blcmxpbi5qc1xuICovXG5jbGFzcyBQZXJsaW5Ob2lzZSB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHBlcmxpbiBub2lzZS4gIFNwZWNpZnkgbm9ybWFsaXplZCBjb29yZGluYXRlcyBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHBhcmFtIHggIFRoZSB4IGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHkgIFRoZSB5IGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHogIFRoZSB6IGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiBBIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKi9cbiAgICBzdGF0aWMgbm9pc2UzKHgsIHksIHogPSAwKSB7XG4gICAgICAgIGNvbnN0IGZhZGUgPSAodCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHQgKiB0ICogdCAqICh0ICogKHQgKiA2IC0gMTUpICsgMTApO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBsZXJwID0gKHQsIGEsIGIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhICsgdCAqIChiIC0gYSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGdyYWQgPSAoaGFzaCwgeCwgeSwgeikgPT4ge1xuICAgICAgICAgICAgY29uc3QgaCA9IGhhc2ggJiAxNTtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoIDwgOCA/IHggOiB5LCB2ID0gaCA8IDQgPyB5IDogaCA9PT0gMTIgfHwgaCA9PT0gMTQgPyB4IDogejtcbiAgICAgICAgICAgIHJldHVybiAoKGggJiAxKSA9PT0gMCA/IHUgOiAtdSkgKyAoKGggJiAyKSA9PT0gMCA/IHYgOiAtdik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNjYWxlID0gKG4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoMSArIG4pIC8gMjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBBcnJheSg1MTIpO1xuICAgICAgICBjb25zdCBwZXJtdXRhdGlvbiA9IFtcbiAgICAgICAgICAgIDE1MSxcbiAgICAgICAgICAgIDE2MCxcbiAgICAgICAgICAgIDEzNyxcbiAgICAgICAgICAgIDkxLFxuICAgICAgICAgICAgOTAsXG4gICAgICAgICAgICAxNSxcbiAgICAgICAgICAgIDEzMSxcbiAgICAgICAgICAgIDEzLFxuICAgICAgICAgICAgMjAxLFxuICAgICAgICAgICAgOTUsXG4gICAgICAgICAgICA5NixcbiAgICAgICAgICAgIDUzLFxuICAgICAgICAgICAgMTk0LFxuICAgICAgICAgICAgMjMzLFxuICAgICAgICAgICAgNyxcbiAgICAgICAgICAgIDIyNSxcbiAgICAgICAgICAgIDE0MCxcbiAgICAgICAgICAgIDM2LFxuICAgICAgICAgICAgMTAzLFxuICAgICAgICAgICAgMzAsXG4gICAgICAgICAgICA2OSxcbiAgICAgICAgICAgIDE0MixcbiAgICAgICAgICAgIDgsXG4gICAgICAgICAgICA5OSxcbiAgICAgICAgICAgIDM3LFxuICAgICAgICAgICAgMjQwLFxuICAgICAgICAgICAgMjEsXG4gICAgICAgICAgICAxMCxcbiAgICAgICAgICAgIDIzLFxuICAgICAgICAgICAgMTkwLFxuICAgICAgICAgICAgNixcbiAgICAgICAgICAgIDE0OCxcbiAgICAgICAgICAgIDI0NyxcbiAgICAgICAgICAgIDEyMCxcbiAgICAgICAgICAgIDIzNCxcbiAgICAgICAgICAgIDc1LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDI2LFxuICAgICAgICAgICAgMTk3LFxuICAgICAgICAgICAgNjIsXG4gICAgICAgICAgICA5NCxcbiAgICAgICAgICAgIDI1MixcbiAgICAgICAgICAgIDIxOSxcbiAgICAgICAgICAgIDIwMyxcbiAgICAgICAgICAgIDExNyxcbiAgICAgICAgICAgIDM1LFxuICAgICAgICAgICAgMTEsXG4gICAgICAgICAgICAzMixcbiAgICAgICAgICAgIDU3LFxuICAgICAgICAgICAgMTc3LFxuICAgICAgICAgICAgMzMsXG4gICAgICAgICAgICA4OCxcbiAgICAgICAgICAgIDIzNyxcbiAgICAgICAgICAgIDE0OSxcbiAgICAgICAgICAgIDU2LFxuICAgICAgICAgICAgODcsXG4gICAgICAgICAgICAxNzQsXG4gICAgICAgICAgICAyMCxcbiAgICAgICAgICAgIDEyNSxcbiAgICAgICAgICAgIDEzNixcbiAgICAgICAgICAgIDE3MSxcbiAgICAgICAgICAgIDE2OCxcbiAgICAgICAgICAgIDY4LFxuICAgICAgICAgICAgMTc1LFxuICAgICAgICAgICAgNzQsXG4gICAgICAgICAgICAxNjUsXG4gICAgICAgICAgICA3MSxcbiAgICAgICAgICAgIDEzNCxcbiAgICAgICAgICAgIDEzOSxcbiAgICAgICAgICAgIDQ4LFxuICAgICAgICAgICAgMjcsXG4gICAgICAgICAgICAxNjYsXG4gICAgICAgICAgICA3NyxcbiAgICAgICAgICAgIDE0NixcbiAgICAgICAgICAgIDE1OCxcbiAgICAgICAgICAgIDIzMSxcbiAgICAgICAgICAgIDgzLFxuICAgICAgICAgICAgMTExLFxuICAgICAgICAgICAgMjI5LFxuICAgICAgICAgICAgMTIyLFxuICAgICAgICAgICAgNjAsXG4gICAgICAgICAgICAyMTEsXG4gICAgICAgICAgICAxMzMsXG4gICAgICAgICAgICAyMzAsXG4gICAgICAgICAgICAyMjAsXG4gICAgICAgICAgICAxMDUsXG4gICAgICAgICAgICA5MixcbiAgICAgICAgICAgIDQxLFxuICAgICAgICAgICAgNTUsXG4gICAgICAgICAgICA0NixcbiAgICAgICAgICAgIDI0NSxcbiAgICAgICAgICAgIDQwLFxuICAgICAgICAgICAgMjQ0LFxuICAgICAgICAgICAgMTAyLFxuICAgICAgICAgICAgMTQzLFxuICAgICAgICAgICAgNTQsXG4gICAgICAgICAgICA2NSxcbiAgICAgICAgICAgIDI1LFxuICAgICAgICAgICAgNjMsXG4gICAgICAgICAgICAxNjEsXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMjE2LFxuICAgICAgICAgICAgODAsXG4gICAgICAgICAgICA3MyxcbiAgICAgICAgICAgIDIwOSxcbiAgICAgICAgICAgIDc2LFxuICAgICAgICAgICAgMTMyLFxuICAgICAgICAgICAgMTg3LFxuICAgICAgICAgICAgMjA4LFxuICAgICAgICAgICAgODksXG4gICAgICAgICAgICAxOCxcbiAgICAgICAgICAgIDE2OSxcbiAgICAgICAgICAgIDIwMCxcbiAgICAgICAgICAgIDE5NixcbiAgICAgICAgICAgIDEzNSxcbiAgICAgICAgICAgIDEzMCxcbiAgICAgICAgICAgIDExNixcbiAgICAgICAgICAgIDE4OCxcbiAgICAgICAgICAgIDE1OSxcbiAgICAgICAgICAgIDg2LFxuICAgICAgICAgICAgMTY0LFxuICAgICAgICAgICAgMTAwLFxuICAgICAgICAgICAgMTA5LFxuICAgICAgICAgICAgMTk4LFxuICAgICAgICAgICAgMTczLFxuICAgICAgICAgICAgMTg2LFxuICAgICAgICAgICAgMyxcbiAgICAgICAgICAgIDY0LFxuICAgICAgICAgICAgNTIsXG4gICAgICAgICAgICAyMTcsXG4gICAgICAgICAgICAyMjYsXG4gICAgICAgICAgICAyNTAsXG4gICAgICAgICAgICAxMjQsXG4gICAgICAgICAgICAxMjMsXG4gICAgICAgICAgICA1LFxuICAgICAgICAgICAgMjAyLFxuICAgICAgICAgICAgMzgsXG4gICAgICAgICAgICAxNDcsXG4gICAgICAgICAgICAxMTgsXG4gICAgICAgICAgICAxMjYsXG4gICAgICAgICAgICAyNTUsXG4gICAgICAgICAgICA4MixcbiAgICAgICAgICAgIDg1LFxuICAgICAgICAgICAgMjEyLFxuICAgICAgICAgICAgMjA3LFxuICAgICAgICAgICAgMjA2LFxuICAgICAgICAgICAgNTksXG4gICAgICAgICAgICAyMjcsXG4gICAgICAgICAgICA0NyxcbiAgICAgICAgICAgIDE2LFxuICAgICAgICAgICAgNTgsXG4gICAgICAgICAgICAxNyxcbiAgICAgICAgICAgIDE4MixcbiAgICAgICAgICAgIDE4OSxcbiAgICAgICAgICAgIDI4LFxuICAgICAgICAgICAgNDIsXG4gICAgICAgICAgICAyMjMsXG4gICAgICAgICAgICAxODMsXG4gICAgICAgICAgICAxNzAsXG4gICAgICAgICAgICAyMTMsXG4gICAgICAgICAgICAxMTksXG4gICAgICAgICAgICAyNDgsXG4gICAgICAgICAgICAxNTIsXG4gICAgICAgICAgICAyLFxuICAgICAgICAgICAgNDQsXG4gICAgICAgICAgICAxNTQsXG4gICAgICAgICAgICAxNjMsXG4gICAgICAgICAgICA3MCxcbiAgICAgICAgICAgIDIyMSxcbiAgICAgICAgICAgIDE1MyxcbiAgICAgICAgICAgIDEwMSxcbiAgICAgICAgICAgIDE1NSxcbiAgICAgICAgICAgIDE2NyxcbiAgICAgICAgICAgIDQzLFxuICAgICAgICAgICAgMTcyLFxuICAgICAgICAgICAgOSxcbiAgICAgICAgICAgIDEyOSxcbiAgICAgICAgICAgIDIyLFxuICAgICAgICAgICAgMzksXG4gICAgICAgICAgICAyNTMsXG4gICAgICAgICAgICAxOSxcbiAgICAgICAgICAgIDk4LFxuICAgICAgICAgICAgMTA4LFxuICAgICAgICAgICAgMTEwLFxuICAgICAgICAgICAgNzksXG4gICAgICAgICAgICAxMTMsXG4gICAgICAgICAgICAyMjQsXG4gICAgICAgICAgICAyMzIsXG4gICAgICAgICAgICAxNzgsXG4gICAgICAgICAgICAxODUsXG4gICAgICAgICAgICAxMTIsXG4gICAgICAgICAgICAxMDQsXG4gICAgICAgICAgICAyMTgsXG4gICAgICAgICAgICAyNDYsXG4gICAgICAgICAgICA5NyxcbiAgICAgICAgICAgIDIyOCxcbiAgICAgICAgICAgIDI1MSxcbiAgICAgICAgICAgIDM0LFxuICAgICAgICAgICAgMjQyLFxuICAgICAgICAgICAgMTkzLFxuICAgICAgICAgICAgMjM4LFxuICAgICAgICAgICAgMjEwLFxuICAgICAgICAgICAgMTQ0LFxuICAgICAgICAgICAgMTIsXG4gICAgICAgICAgICAxOTEsXG4gICAgICAgICAgICAxNzksXG4gICAgICAgICAgICAxNjIsXG4gICAgICAgICAgICAyNDEsXG4gICAgICAgICAgICA4MSxcbiAgICAgICAgICAgIDUxLFxuICAgICAgICAgICAgMTQ1LFxuICAgICAgICAgICAgMjM1LFxuICAgICAgICAgICAgMjQ5LFxuICAgICAgICAgICAgMTQsXG4gICAgICAgICAgICAyMzksXG4gICAgICAgICAgICAxMDcsXG4gICAgICAgICAgICA0OSxcbiAgICAgICAgICAgIDE5MixcbiAgICAgICAgICAgIDIxNCxcbiAgICAgICAgICAgIDMxLFxuICAgICAgICAgICAgMTgxLFxuICAgICAgICAgICAgMTk5LFxuICAgICAgICAgICAgMTA2LFxuICAgICAgICAgICAgMTU3LFxuICAgICAgICAgICAgMTg0LFxuICAgICAgICAgICAgODQsXG4gICAgICAgICAgICAyMDQsXG4gICAgICAgICAgICAxNzYsXG4gICAgICAgICAgICAxMTUsXG4gICAgICAgICAgICAxMjEsXG4gICAgICAgICAgICA1MCxcbiAgICAgICAgICAgIDQ1LFxuICAgICAgICAgICAgMTI3LFxuICAgICAgICAgICAgNCxcbiAgICAgICAgICAgIDE1MCxcbiAgICAgICAgICAgIDI1NCxcbiAgICAgICAgICAgIDEzOCxcbiAgICAgICAgICAgIDIzNixcbiAgICAgICAgICAgIDIwNSxcbiAgICAgICAgICAgIDkzLFxuICAgICAgICAgICAgMjIyLFxuICAgICAgICAgICAgMTE0LFxuICAgICAgICAgICAgNjcsXG4gICAgICAgICAgICAyOSxcbiAgICAgICAgICAgIDI0LFxuICAgICAgICAgICAgNzIsXG4gICAgICAgICAgICAyNDMsXG4gICAgICAgICAgICAxNDEsXG4gICAgICAgICAgICAxMjgsXG4gICAgICAgICAgICAxOTUsXG4gICAgICAgICAgICA3OCxcbiAgICAgICAgICAgIDY2LFxuICAgICAgICAgICAgMjE1LFxuICAgICAgICAgICAgNjEsXG4gICAgICAgICAgICAxNTYsXG4gICAgICAgICAgICAxODAsXG4gICAgICAgIF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspXG4gICAgICAgICAgICBwWzI1NiArIGldID0gcFtpXSA9IHBlcm11dGF0aW9uW2ldO1xuICAgICAgICBjb25zdCBYID0gTWF0aC5mbG9vcih4KSAmIDI1NSwgWSA9IE1hdGguZmxvb3IoeSkgJiAyNTUsIFogPSBNYXRoLmZsb29yKHopICYgMjU1O1xuICAgICAgICB4IC09IE1hdGguZmxvb3IoeCk7XG4gICAgICAgIHkgLT0gTWF0aC5mbG9vcih5KTtcbiAgICAgICAgeiAtPSBNYXRoLmZsb29yKHopO1xuICAgICAgICBjb25zdCB1ID0gZmFkZSh4KSwgdiA9IGZhZGUoeSksIHcgPSBmYWRlKHopO1xuICAgICAgICBjb25zdCBBID0gcFtYXSArIFksIEFBID0gcFtBXSArIFosIEFCID0gcFtBICsgMV0gKyBaLCBCID0gcFtYICsgMV0gKyBZLCBCQSA9IHBbQl0gKyBaLCBCQiA9IHBbQiArIDFdICsgWjtcbiAgICAgICAgcmV0dXJuIHNjYWxlKGxlcnAodywgbGVycCh2LCBsZXJwKHUsIGdyYWQocFtBQV0sIHgsIHksIHopLCBncmFkKHBbQkFdLCB4IC0gMSwgeSwgeikpLCBsZXJwKHUsIGdyYWQocFtBQl0sIHgsIHkgLSAxLCB6KSwgZ3JhZChwW0JCXSwgeCAtIDEsIHkgLSAxLCB6KSkpLCBsZXJwKHYsIGxlcnAodSwgZ3JhZChwW0FBICsgMV0sIHgsIHksIHogLSAxKSwgZ3JhZChwW0JBICsgMV0sIHggLSAxLCB5LCB6IC0gMSkpLCBsZXJwKHUsIGdyYWQocFtBQiArIDFdLCB4LCB5IC0gMSwgeiAtIDEpLCBncmFkKHBbQkIgKyAxXSwgeCAtIDEsIHkgLSAxLCB6IC0gMSkpKSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGVybGluTm9pc2UgPSBQZXJsaW5Ob2lzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcmxpbi1ub2lzZS5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/mathf/perlin-noise.js\n");

/***/ }),

/***/ "./lib/mathf/quaternion.js":
/*!*********************************!*\
  !*** ./lib/mathf/quaternion.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Quaternion = void 0;\nconst mathf_1 = __webpack_require__(/*! ./mathf */ \"./lib/mathf/mathf.js\");\nconst matrixIV_1 = __webpack_require__(/*! ./matrixIV */ \"./lib/mathf/matrixIV.js\");\nconst vector_1 = __webpack_require__(/*! ./vector */ \"./lib/mathf/vector.js\");\n/**\n * A basic quaternion class.\n *\n * A good intro on quaternion is:\n * https://github.com/NickCuso/Tutorials/blob/master/Quaternions.md\n *\n *\n * Some common uses:\n * ```ts\n * // Slerp to a specific eular angle.\n *  let target = Quaternion.fromEuler(90, 20, 0);\n *  myQuat.slerp(target, this.progress);\n *\n * // Add rotation by 90 degrees in X and 90 degress in y.\n * let xRadian = mathf.degreesToRadian(90);\n * let yRadian = mathf.degreesToRadian(90);\n * let q1 = Quaternion.IDENTITY.angleAxis(xRadian, Vector.RIGHT); // x\n * let q2 = Quaternion.IDENTITY.angleAxis(yRadian, Vector.UP); /// y\n * myQuat.rotation.multiply(q1).multiply(q2).multiply(q3);\n *\n *\n * // Add 90 degrees in X rotation to whatever it is now.\n * myQuat.addEular(90, 0, 0);\n *\n *\n * // Create rotational matrix from Quaternion\n * const rotationMatrix = MatrivIV.fromQuaternion(myQuat);\n * const matrixString = rotationMatrix.toCss3dMatrix();\n *\n * // Apply it to a DOM element if you want\n * // (although this would only be rotaiton, no positon or scale)\n * this.element.style.transform = matrixString;\n *\n * ```\n *\n * Adapted from:\n * https://github.com/NickCuso/Tutorials/blob/master/Quaternions.md\n * @see https://github.com/toji/gl-matrix\n * @see https://github.com/mattdesl/vecmath\n * @see https://cubap.github.io/phaser3-docs/math_Quaternion.js.html\n *\n * @unstable\n */\nclass Quaternion {\n    constructor(x = 0, y = 0, z = 0, w = 1) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    /***\n     * Makes a clone of this quaternion.\n     *\n     * ```ts\n     *\n     * var q = new Quaternion(0.4,0,0,1);\n     * var clone = q.clone();\n     *\n     * ```\n     */\n    clone() {\n        return new Quaternion(this.x, this.y, this.z, this.w);\n    }\n    /**\n     * Sets x, y, z, w of this quaternion.\n     */\n    set(x = 0, y = 0, z = 0, w = 1) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n        return this;\n    }\n    /**\n     * Adds a given quaternion or vector to this quaternion.\n     *\n     * ```ts\n     *\n     * var q = new Quaternion(0,0,0,0);\n     * var q2 = new Quaternion(0,0,0,0);\n     * q.add(q2);\n     *\n     * ```\n     */\n    add(q) {\n        return Quaternion.add(this.clone(), q);\n    }\n    /**\n     * Adds a given quaternion or vector to another quaternion or vector and\n     * return a new one.\n     *\n     * ```ts\n     *\n     * var q = new Quaternion(0,0,0,0);\n     * var q2 = new Quaternion(0,0,0,0);\n     * var q3 = Quaternion.add(q, q2);\n     *\n     * ```\n     */\n    static add(q1, q2) {\n        const x = q1.x + q2.x;\n        const y = q1.y + q2.y;\n        const z = q1.z + q2.z;\n        const w = q1.w + q2.w;\n        return new Quaternion(x, y, z, w);\n    }\n    /**\n     * Combines eular degrees to the quaternion.\n     *\n     *```ts\n     * // Add 30 degrees in x rotation.\n     * var q = new Quaternion(0,0,0,0);\n     * q.addEular(30, 0, 0);\n     *\n     * ```\n     *\n     * @param x x in degrees\n     * @param y y in degrees\n     * @param z z in degrees\n     */\n    addEuler(x, y, z) {\n        x = mathf_1.mathf.degreeToRadian(x);\n        y = mathf_1.mathf.degreeToRadian(y);\n        z = mathf_1.mathf.degreeToRadian(z);\n        const q = Quaternion.fromEuler(x, y, z);\n        this.multiply(q);\n        return this;\n    }\n    /**\n     * Subtracts a given quaternion or vector to this quaternion.\n     *\n     * ```ts\n     *\n     * var q = new Quaternion(0,0,0,0);\n     * var q2 = new Quaternion(0,0,0,0);\n     * q.subtract(q2);\n     *\n     * ```\n     */\n    subtract(q) {\n        this.x -= q.x;\n        this.y -= q.y;\n        this.z -= q.z;\n        this.w -= q.w;\n        return this;\n    }\n    /**\n     * Subtracts a given quaternion or vector to another quaternion or vector and\n     * return a new one.\n     *\n     * ```ts\n     *\n     * var q = new Quaternion(0,0,0,0);\n     * var q2 = new Quaternion(0,0,0,0);\n     * var q3 = Quaternion.subtract(q, q2);\n     *\n     * ```\n     */\n    static subtract(q1, q2) {\n        const x = q1.x - q2.x;\n        const y = q1.y - q2.y;\n        const z = q1.z - q2.z;\n        const w = q1.w - q2.w;\n        return new Quaternion(x, y, z, w);\n    }\n    /**\n     * Multiplies two quaternions.\n     * @param a\n     * @param b\n     */\n    static multiply(a, b) {\n        const ax = a.x, ay = a.y, az = a.z, aw = a.w;\n        const bx = b.x, by = b.y, bz = b.z, bw = b.w;\n        const out = Quaternion.IDENTITY;\n        out.x = ax * bw + aw * bx + ay * bz - az * by;\n        out.y = ay * bw + aw * by + az * bx - ax * bz;\n        out.z = az * bw + aw * bz + ax * by - ay * bx;\n        out.w = aw * bw - ax * bx - ay * by - az * bz;\n        return out;\n    }\n    /**\n     * Multiplies the current quaternion with provided Quaternion a.\n     *\n     *\n     * ```ts\n     *   // Given x, y, z radians, add x,y,z rotation to the current quaternion.\n     *   let q1 = Quaternion.IDENTITY.angleAxis(x, Vector.RIGHT);\n     *   let q2 = Quaternion.IDENTITY.angleAxis(y, Vector.UP);\n     *   let q3 = Quaternion.IDENTITY.angleAxis(z, Vector.FORWARD);\n     *   this.multiply(q1).multiply(q2).multiply(q3);\n     *\n     * ```\n     *\n     *\n     * @param a\n     */\n    multiply(a) {\n        const n = Quaternion.multiply(this, a);\n        this.copy(n);\n        return this;\n    }\n    /**\n     * Scales this Quaternion by a given scale.\n     */\n    scale(scalar) {\n        if (isFinite(scalar)) {\n            this.x *= scalar;\n            this.y *= scalar;\n            this.z *= scalar;\n            this.w *= scalar;\n            return this;\n        }\n        else {\n            return Quaternion.ZERO;\n        }\n    }\n    /**\n     * Calculates the length / magnitude of this quaternion.\n     */\n    length() {\n        const x = this.x;\n        const y = this.y;\n        const z = this.z;\n        const w = this.w;\n        return Math.sqrt(x * x + y * y + z * z + w * w);\n    }\n    /**\n     * Calculates the length squared\n     */\n    lengthSquared() {\n        const x = this.x;\n        const y = this.y;\n        const z = this.z;\n        const w = this.w;\n        return x * x + y * y + z * z + w * w;\n    }\n    /**\n     * Calculates the magnitude of this quaternion.\n     * Alias of [[Quaternion.length]]\n     */\n    magnitude() {\n        return this.length();\n    }\n    /**\n     * Normalizes this quaternion.\n     */\n    normalize() {\n        const x = this.x;\n        const y = this.y;\n        const z = this.z;\n        const w = this.w;\n        let len = x * x + y * y + z * z + w * w;\n        if (len > 0) {\n            len = 1 / Math.sqrt(len);\n            this.x = x * len;\n            this.y = y * len;\n            this.z = z * len;\n            this.w = w * len;\n        }\n        return this;\n    }\n    /**\n     * Calculates the dot product of this Quaternion (or Vector) and the given\n     * Quaternion (or Vector)\n     * @return The dot product of this quarternion and the provided quaternion.\n     */\n    dot(q) {\n        return this.x * q.x + this.y * q.y + this.z * q.z + this.w * q.w;\n    }\n    /**\n     * Linear interpolates this Quaternion towards the given quaternion or vector.\n     * @param q\n     * @param progress\n     */\n    lerp(q, progress) {\n        this.x = mathf_1.mathf.lerp(this.x, q.x, progress);\n        this.y = mathf_1.mathf.lerp(this.y, q.y, progress);\n        this.z = mathf_1.mathf.lerp(this.z, q.z, progress);\n        this.w = mathf_1.mathf.lerp(this.w, q.z, progress);\n        return this;\n    }\n    /**\n     * Slerps to a specific rotation in Euler degrees.\n     *\n     * ```ts\n     *\n     * myQuat.slerpEuler(30, 0, 0, this.progress);\n     *\n     * ```\n     * @param x\n     * @param y\n     * @param z\n     */\n    slerpEuler(x, y, z, progress) {\n        const target = Quaternion.fromEuler(x, y, z);\n        this.slerp(target, progress);\n        return this;\n    }\n    /**\n     * Slerps to a specific rotation in Eular degrees where eular is provided\n     * by a Vector\n     * @param v\n     * @param progress\n     */\n    slerpEulerVector(v, progress) {\n        return this.slerpEuler(v.x, v.y, v.z, progress);\n    }\n    /**\n     * Slerps this quaternion towards the given quaternion or vector.\n     * Inspired by: https://jsperf.com/quaternion-slerp-implementations\n     *\n     * ```ts\n     *\n     *  let target = Quaternion.fromEuler(90, 20, 0);\n     *  myQuat.slerp(target, this.progress);\n     *\n     * ```\n     *\n     *\n     * @param q\n     * @param progress\n     */\n    slerp(q, progress) {\n        const EPSILON = 0.000001;\n        const ax = this.x;\n        const ay = this.y;\n        const az = this.z;\n        const aw = this.w;\n        let bx = q.x;\n        let by = q.y;\n        let bz = q.z;\n        let bw = q.w;\n        let cosom = ax * bx + ay * by + az * bz + aw * bw;\n        if (cosom < 0) {\n            cosom = -cosom;\n            bx = -bx;\n            by = -by;\n            bz = -bz;\n            bw = -bw;\n        }\n        let s0 = 1 - progress;\n        let s1 = progress;\n        if (1 - cosom > EPSILON) {\n            const omega = Math.acos(cosom);\n            const sinom = Math.sin(omega);\n            s0 = Math.sin((1.0 - progress) * omega) / sinom;\n            s1 = Math.sin(progress * omega) / sinom;\n        }\n        this.x = s0 * ax + s1 * bx;\n        this.y = s0 * ay + s1 * by;\n        this.z = s0 * az + s1 * bz;\n        this.w = s0 * aw + s1 * bw;\n        return this;\n    }\n    /**\n     * Inverts this quaternion.\n     */\n    invert() {\n        const a0 = this.x;\n        const a1 = this.y;\n        const a2 = this.z;\n        const a3 = this.w;\n        const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n        const invDot = dot ? 1 / dot : 0;\n        this.x = -a0 * invDot;\n        this.y = -a1 * invDot;\n        this.z = -a2 * invDot;\n        this.w = a3 * invDot;\n        return this;\n    }\n    /**\n     * Set rotation X of the quaternion by given degree\n     * @param rad\n     */\n    rotateX(degree) {\n        const q1 = Quaternion.IDENTITY.angleAxis(mathf_1.mathf.degreeToRadian(degree), vector_1.Vector.RIGHT);\n        return this.multiply(q1);\n    }\n    /**\n     * Set rotation Y of the quaternion by given degree\n     * @param rad\n     */\n    rotateY(degree) {\n        const q1 = Quaternion.IDENTITY.angleAxis(mathf_1.mathf.degreeToRadian(degree), vector_1.Vector.UP);\n        return this.multiply(q1);\n    }\n    /**\n     * Set rotation Y of the quaternion by given degree\n     * @param rad\n     */\n    rotateZ(degree) {\n        const q1 = Quaternion.IDENTITY.angleAxis(mathf_1.mathf.degreeToRadian(degree), vector_1.Vector.FORWARD);\n        return this.multiply(q1);\n    }\n    /**\n     * Copies the content of another Quaternion into this quaterion.\n     * @param q\n     */\n    copy(q) {\n        this.x = q.x;\n        this.y = q.y;\n        this.z = q.z;\n        this.w = q.w;\n        return this;\n    }\n    /**\n     * Conjugate this quaternion\n     */\n    conjugate() {\n        this.x = -this.x;\n        this.y = -this.y;\n        this.z = -this.z;\n        return this;\n    }\n    /**\n     * Creates a Quaternion from the given euler angle x, y, z.\n     *\n     * ```ts\n     *\n     * let quat = Quaternion.fromEuler(180, 90, -90);\n     *\n     * ```\n     * @see https://quaternions.online/\n     * @see https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles\n     * @param x x\n     * @param y y\n     * @param z z\n     */\n    static fromEuler(x, y, z) {\n        x = mathf_1.mathf.degreeToRadian(x);\n        y = mathf_1.mathf.degreeToRadian(y);\n        z = mathf_1.mathf.degreeToRadian(z);\n        const cos = Math.cos;\n        const sin = Math.sin;\n        const c1 = cos(x / 2);\n        const c2 = cos(y / 2);\n        const c3 = cos(z / 2);\n        const s1 = sin(x / 2);\n        const s2 = sin(y / 2);\n        const s3 = sin(z / 2);\n        // XYZ ordering.\n        // https://github.com/mrdoob/three.js/blob/master/src/math/Quaternion.js#L224\n        const rx = s1 * c2 * c3 + c1 * s2 * s3;\n        const ry = c1 * s2 * c3 - s1 * c2 * s3;\n        const rz = c1 * c2 * s3 + s1 * s2 * c3;\n        const rw = c1 * c2 * c3 - s1 * s2 * s3;\n        return new Quaternion(rx, ry, rz, rw);\n    }\n    /**\n     * Converts a Euler Degree vector to a Quaternion.\n     *\n     * ```ts\n     *\n     * let eulerVector = new Vector(90, 180, 0);\n     * let quat = Quaternion.fromEulerVector(eulerVector);\n     * ```\n     *\n     * @param v\n     */\n    static fromEulerVector(v) {\n        return Quaternion.fromEuler(v.x, v.y, v.z);\n    }\n    /**\n     * Converts a quaternion to a EulerVector consisting of degrees.\n     * YXZ Local Axes Yaw (y), Pitch (x), Roll (z)\n     * Outputs XYZ ordering.\n     *\n     * This method is best avoided because of instability.\n     *\n     * Yaw, Roll will be +-180.\n     * Pitch will be +- 90.\n     *\n     * ```ts\n     *\n     * let quaternion = new Quaternion(2,3,4);\n     * let v = Quaternion.toEulerVector(q);\n     *\n     * ```\n     *\n     * @see https://bit.ly/1TzLyaC\n     * @param q\n     */\n    static toEulerVector(q) {\n        let result = vector_1.Vector.ZERO;\n        // // Create a rotation matrix from the quaternion.\n        const matrix = matrixIV_1.MatrixIV.fromQuaternion(q.clone());\n        result = vector_1.Vector.fromRotationMatrixIV(matrix);\n        return result;\n    }\n    /**\n     * Creates a rotation which rotates angle degrees around axis.\n     * Assumes the axis vector is normalized.\n     * ```ts\n     *\n     * // Rotate 23 degrees around X and Y axis.\n     * let rad = mathf.degreesToRadian(23);\n     *\n     *\n     * let q1 = Quaternion.IDENTITY.angleAxis(rad, Vector.UP); // Y\n     * let q2 = Quaternion.IDENTITY.angleAxis(rad, Vector.RIGHT); // X\n     *\n     * myQuat.multiply(q1).multiply(q2)\n     *\n     * ```\n     *\n     * @param rad Angle in radians\n     * @param axis An axis vector to rotate on. Axis should be normalized.\n     */\n    angleAxis(rad, axis) {\n        rad = rad * 0.5;\n        const s = Math.sin(rad);\n        this.x = s * axis.x;\n        this.y = s * axis.y;\n        this.z = s * axis.z;\n        this.w = Math.cos(rad);\n        return this;\n    }\n    /**\n     * Creates a quaternion from a rotation matrix.\n     * @param m\n     */\n    static fromRotationMatrixIV(m) {\n        let q = Quaternion.IDENTITY;\n        const a00 = m.value[0];\n        const a01 = m.value[1];\n        const a02 = m.value[2];\n        // const a03 = m.value[3];\n        const a10 = m.value[4];\n        const a11 = m.value[5];\n        const a12 = m.value[6];\n        // const a13 = m.value[7];\n        const a20 = m.value[8];\n        const a21 = m.value[9];\n        const a22 = m.value[10];\n        // const a23 = m.value[11];\n        // const a30 = m.value[12];\n        // const a31 = m.value[13];\n        // const a32 = m.value[14];\n        // const a33 = m.value[15];\n        // q.w = Math.sqrt(1.0 + a00 + a11 + a22) / 2.0;\n        // let w4 = (4.0 * q.w);\n        // q.x = -(a21 - a12) / w4;\n        // q.y = -(a02 - a20) / w4;\n        // q.z = -(a10 - a01) / w4;\n        let t;\n        if (a22 < 0) {\n            if (a00 > a11) {\n                t = 1 + a00 - a11 - a22;\n                q = new Quaternion(t, a01 + a10, a20 + a02, a12 - a21);\n            }\n            else {\n                t = 1 - a00 + a11 - a22;\n                q = new Quaternion(a01 + a10, t, a12 + a21, a20 - a02);\n            }\n        }\n        else {\n            if (a00 < -a11) {\n                t = 1 - a00 - a11 + a22;\n                q = new Quaternion(a20 + a02, a12 + a21, t, a01 - a10);\n            }\n            else {\n                t = 1 + a00 + a11 + a22;\n                q = new Quaternion(a12 - a21, a20 - a02, a01 - a10, t);\n            }\n        }\n        q.scale(0.5 / Math.sqrt(t));\n        return q;\n    }\n    /**\n     * Creates a new quat from a set of arrays.\n     *\n     * ```ts\n     * var q = Quaternion.fromArray([0,2,2,0]);\n     * ```\n     */\n    static fromArray(values) {\n        return new Quaternion(values[0], values[1], values[2], values[3]);\n    }\n    /**\n     * Limits the number of decimals on each quaternion dimension.\n     * @param numberOfDecimals\n     */\n    toFixed(numberOfDecimals) {\n        return new Quaternion(mathf_1.mathf.toFixed(mathf_1.mathf.absZero(this.x), numberOfDecimals), mathf_1.mathf.toFixed(mathf_1.mathf.absZero(this.y), numberOfDecimals), mathf_1.mathf.toFixed(mathf_1.mathf.absZero(this.z), numberOfDecimals), mathf_1.mathf.toFixed(mathf_1.mathf.absZero(this.w), numberOfDecimals));\n    }\n    /**\n     *\n     * @param source https://github.com/mrdoob/three.js/issues/382\n     * @param target\n     */\n    static rotateTo(source, target, up) {\n        const m = matrixIV_1.MatrixIV.IDENTITY;\n        m.lookAt(target, source, up);\n        const temp = m.value;\n        //         var m00 = temp.n11, m10 = temp.n21, m20 = temp.n31,\n        // m01 = temp.n12, m11 = temp.n22, m21 = temp.n32,\n        // m02 = temp.n13, m12 = temp.n23, m22 = temp.n33;\n        const m00 = temp[0], m10 = temp[1], m20 = temp[2], m01 = temp[5], m11 = temp[6], m21 = temp[7], m02 = temp[9], m12 = temp[10], m22 = temp[11];\n        const t = m00 + m11 + m22;\n        let s, x, y, z, w;\n        if (t > 0) {\n            s = Math.sqrt(t + 1) * 2;\n            w = 0.25 * s;\n            x = (m21 - m12) / s;\n            y = (m02 - m20) / s;\n            z = (m10 - m01) / s;\n        }\n        else if (m00 > m11 && m00 > m22) {\n            s = Math.sqrt(1.0 + m00 - m11 - m22) * 2;\n            x = s * 0.25;\n            y = (m10 + m01) / s;\n            z = (m02 + m20) / s;\n            w = (m21 - m12) / s;\n        }\n        else if (m11 > m22) {\n            s = Math.sqrt(1.0 + m11 - m00 - m22) * 2;\n            y = s * 0.25;\n            x = (m10 + m01) / s;\n            z = (m21 + m12) / s;\n            w = (m02 - m20) / s;\n        }\n        else {\n            s = Math.sqrt(1.0 + m22 - m00 - m11) * 2;\n            z = s * 0.25;\n            x = (m02 + m20) / s;\n            y = (m21 + m12) / s;\n            w = (m10 - m01) / s;\n        }\n        const rotation = new Quaternion(x, y, z, w);\n        rotation.normalize();\n        return rotation;\n    }\n    /**\n     * A static zero quaternion.  Additive identity.\n     *\n     * ```ts\n     * let q = Quaternion.ZERO;\n     * ```\n     */\n    static get ZERO() {\n        return new Quaternion(0, 0, 0, 0);\n    }\n    static get I() {\n        return new Quaternion(0, 1, 0, 0);\n    }\n    static get J() {\n        return new Quaternion(0, 0, 1, 0);\n    }\n    static get K() {\n        return new Quaternion(0, 0, 0, 1);\n    }\n    /**\n     * A static identity quaternion.  Multiplicative identity.\n     *\n     * ```ts\n     * let q = Quaternion.IDENTITY;\n     * ```\n     */\n    static get IDENTITY() {\n        return new Quaternion(0, 0, 0, 1);\n    }\n    /**\n     * A static one quaternion.\n     *\n     * ```ts\n     * let q = Quaternion.ONE;\n     * ```\n     */\n    static get ONE() {\n        return new Quaternion(1, 1, 1);\n    }\n}\nexports.Quaternion = Quaternion;\n//# sourceMappingURL=quaternion.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbWF0aGYvcXVhdGVybmlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9tYXRoZi9xdWF0ZXJuaW9uLmpzPzU4NDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1YXRlcm5pb24gPSB2b2lkIDA7XG5jb25zdCBtYXRoZl8xID0gcmVxdWlyZShcIi4vbWF0aGZcIik7XG5jb25zdCBtYXRyaXhJVl8xID0gcmVxdWlyZShcIi4vbWF0cml4SVZcIik7XG5jb25zdCB2ZWN0b3JfMSA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcbi8qKlxuICogQSBiYXNpYyBxdWF0ZXJuaW9uIGNsYXNzLlxuICpcbiAqIEEgZ29vZCBpbnRybyBvbiBxdWF0ZXJuaW9uIGlzOlxuICogaHR0cHM6Ly9naXRodWIuY29tL05pY2tDdXNvL1R1dG9yaWFscy9ibG9iL21hc3Rlci9RdWF0ZXJuaW9ucy5tZFxuICpcbiAqXG4gKiBTb21lIGNvbW1vbiB1c2VzOlxuICogYGBgdHNcbiAqIC8vIFNsZXJwIHRvIGEgc3BlY2lmaWMgZXVsYXIgYW5nbGUuXG4gKiAgbGV0IHRhcmdldCA9IFF1YXRlcm5pb24uZnJvbUV1bGVyKDkwLCAyMCwgMCk7XG4gKiAgbXlRdWF0LnNsZXJwKHRhcmdldCwgdGhpcy5wcm9ncmVzcyk7XG4gKlxuICogLy8gQWRkIHJvdGF0aW9uIGJ5IDkwIGRlZ3JlZXMgaW4gWCBhbmQgOTAgZGVncmVzcyBpbiB5LlxuICogbGV0IHhSYWRpYW4gPSBtYXRoZi5kZWdyZWVzVG9SYWRpYW4oOTApO1xuICogbGV0IHlSYWRpYW4gPSBtYXRoZi5kZWdyZWVzVG9SYWRpYW4oOTApO1xuICogbGV0IHExID0gUXVhdGVybmlvbi5JREVOVElUWS5hbmdsZUF4aXMoeFJhZGlhbiwgVmVjdG9yLlJJR0hUKTsgLy8geFxuICogbGV0IHEyID0gUXVhdGVybmlvbi5JREVOVElUWS5hbmdsZUF4aXMoeVJhZGlhbiwgVmVjdG9yLlVQKTsgLy8vIHlcbiAqIG15UXVhdC5yb3RhdGlvbi5tdWx0aXBseShxMSkubXVsdGlwbHkocTIpLm11bHRpcGx5KHEzKTtcbiAqXG4gKlxuICogLy8gQWRkIDkwIGRlZ3JlZXMgaW4gWCByb3RhdGlvbiB0byB3aGF0ZXZlciBpdCBpcyBub3cuXG4gKiBteVF1YXQuYWRkRXVsYXIoOTAsIDAsIDApO1xuICpcbiAqXG4gKiAvLyBDcmVhdGUgcm90YXRpb25hbCBtYXRyaXggZnJvbSBRdWF0ZXJuaW9uXG4gKiBjb25zdCByb3RhdGlvbk1hdHJpeCA9IE1hdHJpdklWLmZyb21RdWF0ZXJuaW9uKG15UXVhdCk7XG4gKiBjb25zdCBtYXRyaXhTdHJpbmcgPSByb3RhdGlvbk1hdHJpeC50b0NzczNkTWF0cml4KCk7XG4gKlxuICogLy8gQXBwbHkgaXQgdG8gYSBET00gZWxlbWVudCBpZiB5b3Ugd2FudFxuICogLy8gKGFsdGhvdWdoIHRoaXMgd291bGQgb25seSBiZSByb3RhaXRvbiwgbm8gcG9zaXRvbiBvciBzY2FsZSlcbiAqIHRoaXMuZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBtYXRyaXhTdHJpbmc7XG4gKlxuICogYGBgXG4gKlxuICogQWRhcHRlZCBmcm9tOlxuICogaHR0cHM6Ly9naXRodWIuY29tL05pY2tDdXNvL1R1dG9yaWFscy9ibG9iL21hc3Rlci9RdWF0ZXJuaW9ucy5tZFxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdG9qaS9nbC1tYXRyaXhcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL3ZlY21hdGhcbiAqIEBzZWUgaHR0cHM6Ly9jdWJhcC5naXRodWIuaW8vcGhhc2VyMy1kb2NzL21hdGhfUXVhdGVybmlvbi5qcy5odG1sXG4gKlxuICogQHVuc3RhYmxlXG4gKi9cbmNsYXNzIFF1YXRlcm5pb24ge1xuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIHcgPSAxKSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgICAgIHRoaXMudyA9IHc7XG4gICAgfVxuICAgIC8qKipcbiAgICAgKiBNYWtlcyBhIGNsb25lIG9mIHRoaXMgcXVhdGVybmlvbi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKiB2YXIgcSA9IG5ldyBRdWF0ZXJuaW9uKDAuNCwwLDAsMSk7XG4gICAgICogdmFyIGNsb25lID0gcS5jbG9uZSgpO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbih0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHgsIHksIHosIHcgb2YgdGhpcyBxdWF0ZXJuaW9uLlxuICAgICAqL1xuICAgIHNldCh4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGdpdmVuIHF1YXRlcm5pb24gb3IgdmVjdG9yIHRvIHRoaXMgcXVhdGVybmlvbi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKiB2YXIgcSA9IG5ldyBRdWF0ZXJuaW9uKDAsMCwwLDApO1xuICAgICAqIHZhciBxMiA9IG5ldyBRdWF0ZXJuaW9uKDAsMCwwLDApO1xuICAgICAqIHEuYWRkKHEyKTtcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFkZChxKSB7XG4gICAgICAgIHJldHVybiBRdWF0ZXJuaW9uLmFkZCh0aGlzLmNsb25lKCksIHEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZ2l2ZW4gcXVhdGVybmlvbiBvciB2ZWN0b3IgdG8gYW5vdGhlciBxdWF0ZXJuaW9uIG9yIHZlY3RvciBhbmRcbiAgICAgKiByZXR1cm4gYSBuZXcgb25lLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIHZhciBxID0gbmV3IFF1YXRlcm5pb24oMCwwLDAsMCk7XG4gICAgICogdmFyIHEyID0gbmV3IFF1YXRlcm5pb24oMCwwLDAsMCk7XG4gICAgICogdmFyIHEzID0gUXVhdGVybmlvbi5hZGQocSwgcTIpO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGFkZChxMSwgcTIpIHtcbiAgICAgICAgY29uc3QgeCA9IHExLnggKyBxMi54O1xuICAgICAgICBjb25zdCB5ID0gcTEueSArIHEyLnk7XG4gICAgICAgIGNvbnN0IHogPSBxMS56ICsgcTIuejtcbiAgICAgICAgY29uc3QgdyA9IHExLncgKyBxMi53O1xuICAgICAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oeCwgeSwgeiwgdyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbWJpbmVzIGV1bGFyIGRlZ3JlZXMgdG8gdGhlIHF1YXRlcm5pb24uXG4gICAgICpcbiAgICAgKmBgYHRzXG4gICAgICogLy8gQWRkIDMwIGRlZ3JlZXMgaW4geCByb3RhdGlvbi5cbiAgICAgKiB2YXIgcSA9IG5ldyBRdWF0ZXJuaW9uKDAsMCwwLDApO1xuICAgICAqIHEuYWRkRXVsYXIoMzAsIDAsIDApO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0geCB4IGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0geSB5IGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0geiB6IGluIGRlZ3JlZXNcbiAgICAgKi9cbiAgICBhZGRFdWxlcih4LCB5LCB6KSB7XG4gICAgICAgIHggPSBtYXRoZl8xLm1hdGhmLmRlZ3JlZVRvUmFkaWFuKHgpO1xuICAgICAgICB5ID0gbWF0aGZfMS5tYXRoZi5kZWdyZWVUb1JhZGlhbih5KTtcbiAgICAgICAgeiA9IG1hdGhmXzEubWF0aGYuZGVncmVlVG9SYWRpYW4oeik7XG4gICAgICAgIGNvbnN0IHEgPSBRdWF0ZXJuaW9uLmZyb21FdWxlcih4LCB5LCB6KTtcbiAgICAgICAgdGhpcy5tdWx0aXBseShxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBhIGdpdmVuIHF1YXRlcm5pb24gb3IgdmVjdG9yIHRvIHRoaXMgcXVhdGVybmlvbi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKiB2YXIgcSA9IG5ldyBRdWF0ZXJuaW9uKDAsMCwwLDApO1xuICAgICAqIHZhciBxMiA9IG5ldyBRdWF0ZXJuaW9uKDAsMCwwLDApO1xuICAgICAqIHEuc3VidHJhY3QocTIpO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3VidHJhY3QocSkge1xuICAgICAgICB0aGlzLnggLT0gcS54O1xuICAgICAgICB0aGlzLnkgLT0gcS55O1xuICAgICAgICB0aGlzLnogLT0gcS56O1xuICAgICAgICB0aGlzLncgLT0gcS53O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIGEgZ2l2ZW4gcXVhdGVybmlvbiBvciB2ZWN0b3IgdG8gYW5vdGhlciBxdWF0ZXJuaW9uIG9yIHZlY3RvciBhbmRcbiAgICAgKiByZXR1cm4gYSBuZXcgb25lLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIHZhciBxID0gbmV3IFF1YXRlcm5pb24oMCwwLDAsMCk7XG4gICAgICogdmFyIHEyID0gbmV3IFF1YXRlcm5pb24oMCwwLDAsMCk7XG4gICAgICogdmFyIHEzID0gUXVhdGVybmlvbi5zdWJ0cmFjdChxLCBxMik7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgc3VidHJhY3QocTEsIHEyKSB7XG4gICAgICAgIGNvbnN0IHggPSBxMS54IC0gcTIueDtcbiAgICAgICAgY29uc3QgeSA9IHExLnkgLSBxMi55O1xuICAgICAgICBjb25zdCB6ID0gcTEueiAtIHEyLno7XG4gICAgICAgIGNvbnN0IHcgPSBxMS53IC0gcTIudztcbiAgICAgICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKHgsIHksIHosIHcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHR3byBxdWF0ZXJuaW9ucy5cbiAgICAgKiBAcGFyYW0gYVxuICAgICAqIEBwYXJhbSBiXG4gICAgICovXG4gICAgc3RhdGljIG11bHRpcGx5KGEsIGIpIHtcbiAgICAgICAgY29uc3QgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEueiwgYXcgPSBhLnc7XG4gICAgICAgIGNvbnN0IGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLnosIGJ3ID0gYi53O1xuICAgICAgICBjb25zdCBvdXQgPSBRdWF0ZXJuaW9uLklERU5USVRZO1xuICAgICAgICBvdXQueCA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gICAgICAgIG91dC55ID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgICAgICAgb3V0LnogPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICAgICAgICBvdXQudyA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhlIGN1cnJlbnQgcXVhdGVybmlvbiB3aXRoIHByb3ZpZGVkIFF1YXRlcm5pb24gYS5cbiAgICAgKlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiAgIC8vIEdpdmVuIHgsIHksIHogcmFkaWFucywgYWRkIHgseSx6IHJvdGF0aW9uIHRvIHRoZSBjdXJyZW50IHF1YXRlcm5pb24uXG4gICAgICogICBsZXQgcTEgPSBRdWF0ZXJuaW9uLklERU5USVRZLmFuZ2xlQXhpcyh4LCBWZWN0b3IuUklHSFQpO1xuICAgICAqICAgbGV0IHEyID0gUXVhdGVybmlvbi5JREVOVElUWS5hbmdsZUF4aXMoeSwgVmVjdG9yLlVQKTtcbiAgICAgKiAgIGxldCBxMyA9IFF1YXRlcm5pb24uSURFTlRJVFkuYW5nbGVBeGlzKHosIFZlY3Rvci5GT1JXQVJEKTtcbiAgICAgKiAgIHRoaXMubXVsdGlwbHkocTEpLm11bHRpcGx5KHEyKS5tdWx0aXBseShxMyk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIGFcbiAgICAgKi9cbiAgICBtdWx0aXBseShhKSB7XG4gICAgICAgIGNvbnN0IG4gPSBRdWF0ZXJuaW9uLm11bHRpcGx5KHRoaXMsIGEpO1xuICAgICAgICB0aGlzLmNvcHkobik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgdGhpcyBRdWF0ZXJuaW9uIGJ5IGEgZ2l2ZW4gc2NhbGUuXG4gICAgICovXG4gICAgc2NhbGUoc2NhbGFyKSB7XG4gICAgICAgIGlmIChpc0Zpbml0ZShzY2FsYXIpKSB7XG4gICAgICAgICAgICB0aGlzLnggKj0gc2NhbGFyO1xuICAgICAgICAgICAgdGhpcy55ICo9IHNjYWxhcjtcbiAgICAgICAgICAgIHRoaXMueiAqPSBzY2FsYXI7XG4gICAgICAgICAgICB0aGlzLncgKj0gc2NhbGFyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUXVhdGVybmlvbi5aRVJPO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCAvIG1hZ25pdHVkZSBvZiB0aGlzIHF1YXRlcm5pb24uXG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy54O1xuICAgICAgICBjb25zdCB5ID0gdGhpcy55O1xuICAgICAgICBjb25zdCB6ID0gdGhpcy56O1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53O1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIHNxdWFyZWRcbiAgICAgKi9cbiAgICBsZW5ndGhTcXVhcmVkKCkge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy54O1xuICAgICAgICBjb25zdCB5ID0gdGhpcy55O1xuICAgICAgICBjb25zdCB6ID0gdGhpcy56O1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53O1xuICAgICAgICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG1hZ25pdHVkZSBvZiB0aGlzIHF1YXRlcm5pb24uXG4gICAgICogQWxpYXMgb2YgW1tRdWF0ZXJuaW9uLmxlbmd0aF1dXG4gICAgICovXG4gICAgbWFnbml0dWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGgoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGlzIHF1YXRlcm5pb24uXG4gICAgICovXG4gICAgbm9ybWFsaXplKCkge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy54O1xuICAgICAgICBjb25zdCB5ID0gdGhpcy55O1xuICAgICAgICBjb25zdCB6ID0gdGhpcy56O1xuICAgICAgICBjb25zdCB3ID0gdGhpcy53O1xuICAgICAgICBsZXQgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG4gICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgICAgICB0aGlzLnggPSB4ICogbGVuO1xuICAgICAgICAgICAgdGhpcy55ID0geSAqIGxlbjtcbiAgICAgICAgICAgIHRoaXMueiA9IHogKiBsZW47XG4gICAgICAgICAgICB0aGlzLncgPSB3ICogbGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIFF1YXRlcm5pb24gKG9yIFZlY3RvcikgYW5kIHRoZSBnaXZlblxuICAgICAqIFF1YXRlcm5pb24gKG9yIFZlY3RvcilcbiAgICAgKiBAcmV0dXJuIFRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIHF1YXJ0ZXJuaW9uIGFuZCB0aGUgcHJvdmlkZWQgcXVhdGVybmlvbi5cbiAgICAgKi9cbiAgICBkb3QocSkge1xuICAgICAgICByZXR1cm4gdGhpcy54ICogcS54ICsgdGhpcy55ICogcS55ICsgdGhpcy56ICogcS56ICsgdGhpcy53ICogcS53O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaW5lYXIgaW50ZXJwb2xhdGVzIHRoaXMgUXVhdGVybmlvbiB0b3dhcmRzIHRoZSBnaXZlbiBxdWF0ZXJuaW9uIG9yIHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gcVxuICAgICAqIEBwYXJhbSBwcm9ncmVzc1xuICAgICAqL1xuICAgIGxlcnAocSwgcHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy54ID0gbWF0aGZfMS5tYXRoZi5sZXJwKHRoaXMueCwgcS54LCBwcm9ncmVzcyk7XG4gICAgICAgIHRoaXMueSA9IG1hdGhmXzEubWF0aGYubGVycCh0aGlzLnksIHEueSwgcHJvZ3Jlc3MpO1xuICAgICAgICB0aGlzLnogPSBtYXRoZl8xLm1hdGhmLmxlcnAodGhpcy56LCBxLnosIHByb2dyZXNzKTtcbiAgICAgICAgdGhpcy53ID0gbWF0aGZfMS5tYXRoZi5sZXJwKHRoaXMudywgcS56LCBwcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTbGVycHMgdG8gYSBzcGVjaWZpYyByb3RhdGlvbiBpbiBFdWxlciBkZWdyZWVzLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIG15UXVhdC5zbGVycEV1bGVyKDMwLCAwLCAwLCB0aGlzLnByb2dyZXNzKTtcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcGFyYW0gelxuICAgICAqL1xuICAgIHNsZXJwRXVsZXIoeCwgeSwgeiwgcHJvZ3Jlc3MpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gUXVhdGVybmlvbi5mcm9tRXVsZXIoeCwgeSwgeik7XG4gICAgICAgIHRoaXMuc2xlcnAodGFyZ2V0LCBwcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTbGVycHMgdG8gYSBzcGVjaWZpYyByb3RhdGlvbiBpbiBFdWxhciBkZWdyZWVzIHdoZXJlIGV1bGFyIGlzIHByb3ZpZGVkXG4gICAgICogYnkgYSBWZWN0b3JcbiAgICAgKiBAcGFyYW0gdlxuICAgICAqIEBwYXJhbSBwcm9ncmVzc1xuICAgICAqL1xuICAgIHNsZXJwRXVsZXJWZWN0b3IodiwgcHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xlcnBFdWxlcih2LngsIHYueSwgdi56LCBwcm9ncmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNsZXJwcyB0aGlzIHF1YXRlcm5pb24gdG93YXJkcyB0aGUgZ2l2ZW4gcXVhdGVybmlvbiBvciB2ZWN0b3IuXG4gICAgICogSW5zcGlyZWQgYnk6IGh0dHBzOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXNsZXJwLWltcGxlbWVudGF0aW9uc1xuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqICBsZXQgdGFyZ2V0ID0gUXVhdGVybmlvbi5mcm9tRXVsZXIoOTAsIDIwLCAwKTtcbiAgICAgKiAgbXlRdWF0LnNsZXJwKHRhcmdldCwgdGhpcy5wcm9ncmVzcyk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHFcbiAgICAgKiBAcGFyYW0gcHJvZ3Jlc3NcbiAgICAgKi9cbiAgICBzbGVycChxLCBwcm9ncmVzcykge1xuICAgICAgICBjb25zdCBFUFNJTE9OID0gMC4wMDAwMDE7XG4gICAgICAgIGNvbnN0IGF4ID0gdGhpcy54O1xuICAgICAgICBjb25zdCBheSA9IHRoaXMueTtcbiAgICAgICAgY29uc3QgYXogPSB0aGlzLno7XG4gICAgICAgIGNvbnN0IGF3ID0gdGhpcy53O1xuICAgICAgICBsZXQgYnggPSBxLng7XG4gICAgICAgIGxldCBieSA9IHEueTtcbiAgICAgICAgbGV0IGJ6ID0gcS56O1xuICAgICAgICBsZXQgYncgPSBxLnc7XG4gICAgICAgIGxldCBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7XG4gICAgICAgIGlmIChjb3NvbSA8IDApIHtcbiAgICAgICAgICAgIGNvc29tID0gLWNvc29tO1xuICAgICAgICAgICAgYnggPSAtYng7XG4gICAgICAgICAgICBieSA9IC1ieTtcbiAgICAgICAgICAgIGJ6ID0gLWJ6O1xuICAgICAgICAgICAgYncgPSAtYnc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHMwID0gMSAtIHByb2dyZXNzO1xuICAgICAgICBsZXQgczEgPSBwcm9ncmVzcztcbiAgICAgICAgaWYgKDEgLSBjb3NvbSA+IEVQU0lMT04pIHtcbiAgICAgICAgICAgIGNvbnN0IG9tZWdhID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICAgICAgICAgIGNvbnN0IHNpbm9tID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICAgICAgczAgPSBNYXRoLnNpbigoMS4wIC0gcHJvZ3Jlc3MpICogb21lZ2EpIC8gc2lub207XG4gICAgICAgICAgICBzMSA9IE1hdGguc2luKHByb2dyZXNzICogb21lZ2EpIC8gc2lub207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54ID0gczAgKiBheCArIHMxICogYng7XG4gICAgICAgIHRoaXMueSA9IHMwICogYXkgKyBzMSAqIGJ5O1xuICAgICAgICB0aGlzLnogPSBzMCAqIGF6ICsgczEgKiBiejtcbiAgICAgICAgdGhpcy53ID0gczAgKiBhdyArIHMxICogYnc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnRzIHRoaXMgcXVhdGVybmlvbi5cbiAgICAgKi9cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIGNvbnN0IGEwID0gdGhpcy54O1xuICAgICAgICBjb25zdCBhMSA9IHRoaXMueTtcbiAgICAgICAgY29uc3QgYTIgPSB0aGlzLno7XG4gICAgICAgIGNvbnN0IGEzID0gdGhpcy53O1xuICAgICAgICBjb25zdCBkb3QgPSBhMCAqIGEwICsgYTEgKiBhMSArIGEyICogYTIgKyBhMyAqIGEzO1xuICAgICAgICBjb25zdCBpbnZEb3QgPSBkb3QgPyAxIC8gZG90IDogMDtcbiAgICAgICAgdGhpcy54ID0gLWEwICogaW52RG90O1xuICAgICAgICB0aGlzLnkgPSAtYTEgKiBpbnZEb3Q7XG4gICAgICAgIHRoaXMueiA9IC1hMiAqIGludkRvdDtcbiAgICAgICAgdGhpcy53ID0gYTMgKiBpbnZEb3Q7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgcm90YXRpb24gWCBvZiB0aGUgcXVhdGVybmlvbiBieSBnaXZlbiBkZWdyZWVcbiAgICAgKiBAcGFyYW0gcmFkXG4gICAgICovXG4gICAgcm90YXRlWChkZWdyZWUpIHtcbiAgICAgICAgY29uc3QgcTEgPSBRdWF0ZXJuaW9uLklERU5USVRZLmFuZ2xlQXhpcyhtYXRoZl8xLm1hdGhmLmRlZ3JlZVRvUmFkaWFuKGRlZ3JlZSksIHZlY3Rvcl8xLlZlY3Rvci5SSUdIVCk7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KHExKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHJvdGF0aW9uIFkgb2YgdGhlIHF1YXRlcm5pb24gYnkgZ2l2ZW4gZGVncmVlXG4gICAgICogQHBhcmFtIHJhZFxuICAgICAqL1xuICAgIHJvdGF0ZVkoZGVncmVlKSB7XG4gICAgICAgIGNvbnN0IHExID0gUXVhdGVybmlvbi5JREVOVElUWS5hbmdsZUF4aXMobWF0aGZfMS5tYXRoZi5kZWdyZWVUb1JhZGlhbihkZWdyZWUpLCB2ZWN0b3JfMS5WZWN0b3IuVVApO1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShxMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCByb3RhdGlvbiBZIG9mIHRoZSBxdWF0ZXJuaW9uIGJ5IGdpdmVuIGRlZ3JlZVxuICAgICAqIEBwYXJhbSByYWRcbiAgICAgKi9cbiAgICByb3RhdGVaKGRlZ3JlZSkge1xuICAgICAgICBjb25zdCBxMSA9IFF1YXRlcm5pb24uSURFTlRJVFkuYW5nbGVBeGlzKG1hdGhmXzEubWF0aGYuZGVncmVlVG9SYWRpYW4oZGVncmVlKSwgdmVjdG9yXzEuVmVjdG9yLkZPUldBUkQpO1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShxMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgY29udGVudCBvZiBhbm90aGVyIFF1YXRlcm5pb24gaW50byB0aGlzIHF1YXRlcmlvbi5cbiAgICAgKiBAcGFyYW0gcVxuICAgICAqL1xuICAgIGNvcHkocSkge1xuICAgICAgICB0aGlzLnggPSBxLng7XG4gICAgICAgIHRoaXMueSA9IHEueTtcbiAgICAgICAgdGhpcy56ID0gcS56O1xuICAgICAgICB0aGlzLncgPSBxLnc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25qdWdhdGUgdGhpcyBxdWF0ZXJuaW9uXG4gICAgICovXG4gICAgY29uanVnYXRlKCkge1xuICAgICAgICB0aGlzLnggPSAtdGhpcy54O1xuICAgICAgICB0aGlzLnkgPSAtdGhpcy55O1xuICAgICAgICB0aGlzLnogPSAtdGhpcy56O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gZXVsZXIgYW5nbGUgeCwgeSwgei5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKiBsZXQgcXVhdCA9IFF1YXRlcm5pb24uZnJvbUV1bGVyKDE4MCwgOTAsIC05MCk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAc2VlIGh0dHBzOi8vcXVhdGVybmlvbnMub25saW5lL1xuICAgICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udmVyc2lvbl9iZXR3ZWVuX3F1YXRlcm5pb25zX2FuZF9FdWxlcl9hbmdsZXNcbiAgICAgKiBAcGFyYW0geCB4XG4gICAgICogQHBhcmFtIHkgeVxuICAgICAqIEBwYXJhbSB6IHpcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUV1bGVyKHgsIHksIHopIHtcbiAgICAgICAgeCA9IG1hdGhmXzEubWF0aGYuZGVncmVlVG9SYWRpYW4oeCk7XG4gICAgICAgIHkgPSBtYXRoZl8xLm1hdGhmLmRlZ3JlZVRvUmFkaWFuKHkpO1xuICAgICAgICB6ID0gbWF0aGZfMS5tYXRoZi5kZWdyZWVUb1JhZGlhbih6KTtcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3M7XG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luO1xuICAgICAgICBjb25zdCBjMSA9IGNvcyh4IC8gMik7XG4gICAgICAgIGNvbnN0IGMyID0gY29zKHkgLyAyKTtcbiAgICAgICAgY29uc3QgYzMgPSBjb3MoeiAvIDIpO1xuICAgICAgICBjb25zdCBzMSA9IHNpbih4IC8gMik7XG4gICAgICAgIGNvbnN0IHMyID0gc2luKHkgLyAyKTtcbiAgICAgICAgY29uc3QgczMgPSBzaW4oeiAvIDIpO1xuICAgICAgICAvLyBYWVogb3JkZXJpbmcuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi9tYXN0ZXIvc3JjL21hdGgvUXVhdGVybmlvbi5qcyNMMjI0XG4gICAgICAgIGNvbnN0IHJ4ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICBjb25zdCByeSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgICAgY29uc3QgcnogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICAgIGNvbnN0IHJ3ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuICAgICAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24ocngsIHJ5LCByeiwgcncpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIEV1bGVyIERlZ3JlZSB2ZWN0b3IgdG8gYSBRdWF0ZXJuaW9uLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIGxldCBldWxlclZlY3RvciA9IG5ldyBWZWN0b3IoOTAsIDE4MCwgMCk7XG4gICAgICogbGV0IHF1YXQgPSBRdWF0ZXJuaW9uLmZyb21FdWxlclZlY3RvcihldWxlclZlY3Rvcik7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tRXVsZXJWZWN0b3Iodikge1xuICAgICAgICByZXR1cm4gUXVhdGVybmlvbi5mcm9tRXVsZXIodi54LCB2LnksIHYueik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgcXVhdGVybmlvbiB0byBhIEV1bGVyVmVjdG9yIGNvbnNpc3Rpbmcgb2YgZGVncmVlcy5cbiAgICAgKiBZWFogTG9jYWwgQXhlcyBZYXcgKHkpLCBQaXRjaCAoeCksIFJvbGwgKHopXG4gICAgICogT3V0cHV0cyBYWVogb3JkZXJpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBiZXN0IGF2b2lkZWQgYmVjYXVzZSBvZiBpbnN0YWJpbGl0eS5cbiAgICAgKlxuICAgICAqIFlhdywgUm9sbCB3aWxsIGJlICstMTgwLlxuICAgICAqIFBpdGNoIHdpbGwgYmUgKy0gOTAuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqXG4gICAgICogbGV0IHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigyLDMsNCk7XG4gICAgICogbGV0IHYgPSBRdWF0ZXJuaW9uLnRvRXVsZXJWZWN0b3IocSk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9iaXQubHkvMVR6THlhQ1xuICAgICAqIEBwYXJhbSBxXG4gICAgICovXG4gICAgc3RhdGljIHRvRXVsZXJWZWN0b3IocSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdmVjdG9yXzEuVmVjdG9yLlpFUk87XG4gICAgICAgIC8vIC8vIENyZWF0ZSBhIHJvdGF0aW9uIG1hdHJpeCBmcm9tIHRoZSBxdWF0ZXJuaW9uLlxuICAgICAgICBjb25zdCBtYXRyaXggPSBtYXRyaXhJVl8xLk1hdHJpeElWLmZyb21RdWF0ZXJuaW9uKHEuY2xvbmUoKSk7XG4gICAgICAgIHJlc3VsdCA9IHZlY3Rvcl8xLlZlY3Rvci5mcm9tUm90YXRpb25NYXRyaXhJVihtYXRyaXgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcm90YXRpb24gd2hpY2ggcm90YXRlcyBhbmdsZSBkZWdyZWVzIGFyb3VuZCBheGlzLlxuICAgICAqIEFzc3VtZXMgdGhlIGF4aXMgdmVjdG9yIGlzIG5vcm1hbGl6ZWQuXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIC8vIFJvdGF0ZSAyMyBkZWdyZWVzIGFyb3VuZCBYIGFuZCBZIGF4aXMuXG4gICAgICogbGV0IHJhZCA9IG1hdGhmLmRlZ3JlZXNUb1JhZGlhbigyMyk7XG4gICAgICpcbiAgICAgKlxuICAgICAqIGxldCBxMSA9IFF1YXRlcm5pb24uSURFTlRJVFkuYW5nbGVBeGlzKHJhZCwgVmVjdG9yLlVQKTsgLy8gWVxuICAgICAqIGxldCBxMiA9IFF1YXRlcm5pb24uSURFTlRJVFkuYW5nbGVBeGlzKHJhZCwgVmVjdG9yLlJJR0hUKTsgLy8gWFxuICAgICAqXG4gICAgICogbXlRdWF0Lm11bHRpcGx5KHExKS5tdWx0aXBseShxMilcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHJhZCBBbmdsZSBpbiByYWRpYW5zXG4gICAgICogQHBhcmFtIGF4aXMgQW4gYXhpcyB2ZWN0b3IgdG8gcm90YXRlIG9uLiBBeGlzIHNob3VsZCBiZSBub3JtYWxpemVkLlxuICAgICAqL1xuICAgIGFuZ2xlQXhpcyhyYWQsIGF4aXMpIHtcbiAgICAgICAgcmFkID0gcmFkICogMC41O1xuICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICAgICAgdGhpcy54ID0gcyAqIGF4aXMueDtcbiAgICAgICAgdGhpcy55ID0gcyAqIGF4aXMueTtcbiAgICAgICAgdGhpcy56ID0gcyAqIGF4aXMuejtcbiAgICAgICAgdGhpcy53ID0gTWF0aC5jb3MocmFkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gYSByb3RhdGlvbiBtYXRyaXguXG4gICAgICogQHBhcmFtIG1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVJvdGF0aW9uTWF0cml4SVYobSkge1xuICAgICAgICBsZXQgcSA9IFF1YXRlcm5pb24uSURFTlRJVFk7XG4gICAgICAgIGNvbnN0IGEwMCA9IG0udmFsdWVbMF07XG4gICAgICAgIGNvbnN0IGEwMSA9IG0udmFsdWVbMV07XG4gICAgICAgIGNvbnN0IGEwMiA9IG0udmFsdWVbMl07XG4gICAgICAgIC8vIGNvbnN0IGEwMyA9IG0udmFsdWVbM107XG4gICAgICAgIGNvbnN0IGExMCA9IG0udmFsdWVbNF07XG4gICAgICAgIGNvbnN0IGExMSA9IG0udmFsdWVbNV07XG4gICAgICAgIGNvbnN0IGExMiA9IG0udmFsdWVbNl07XG4gICAgICAgIC8vIGNvbnN0IGExMyA9IG0udmFsdWVbN107XG4gICAgICAgIGNvbnN0IGEyMCA9IG0udmFsdWVbOF07XG4gICAgICAgIGNvbnN0IGEyMSA9IG0udmFsdWVbOV07XG4gICAgICAgIGNvbnN0IGEyMiA9IG0udmFsdWVbMTBdO1xuICAgICAgICAvLyBjb25zdCBhMjMgPSBtLnZhbHVlWzExXTtcbiAgICAgICAgLy8gY29uc3QgYTMwID0gbS52YWx1ZVsxMl07XG4gICAgICAgIC8vIGNvbnN0IGEzMSA9IG0udmFsdWVbMTNdO1xuICAgICAgICAvLyBjb25zdCBhMzIgPSBtLnZhbHVlWzE0XTtcbiAgICAgICAgLy8gY29uc3QgYTMzID0gbS52YWx1ZVsxNV07XG4gICAgICAgIC8vIHEudyA9IE1hdGguc3FydCgxLjAgKyBhMDAgKyBhMTEgKyBhMjIpIC8gMi4wO1xuICAgICAgICAvLyBsZXQgdzQgPSAoNC4wICogcS53KTtcbiAgICAgICAgLy8gcS54ID0gLShhMjEgLSBhMTIpIC8gdzQ7XG4gICAgICAgIC8vIHEueSA9IC0oYTAyIC0gYTIwKSAvIHc0O1xuICAgICAgICAvLyBxLnogPSAtKGExMCAtIGEwMSkgLyB3NDtcbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIGlmIChhMjIgPCAwKSB7XG4gICAgICAgICAgICBpZiAoYTAwID4gYTExKSB7XG4gICAgICAgICAgICAgICAgdCA9IDEgKyBhMDAgLSBhMTEgLSBhMjI7XG4gICAgICAgICAgICAgICAgcSA9IG5ldyBRdWF0ZXJuaW9uKHQsIGEwMSArIGExMCwgYTIwICsgYTAyLCBhMTIgLSBhMjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdCA9IDEgLSBhMDAgKyBhMTEgLSBhMjI7XG4gICAgICAgICAgICAgICAgcSA9IG5ldyBRdWF0ZXJuaW9uKGEwMSArIGExMCwgdCwgYTEyICsgYTIxLCBhMjAgLSBhMDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGEwMCA8IC1hMTEpIHtcbiAgICAgICAgICAgICAgICB0ID0gMSAtIGEwMCAtIGExMSArIGEyMjtcbiAgICAgICAgICAgICAgICBxID0gbmV3IFF1YXRlcm5pb24oYTIwICsgYTAyLCBhMTIgKyBhMjEsIHQsIGEwMSAtIGExMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ID0gMSArIGEwMCArIGExMSArIGEyMjtcbiAgICAgICAgICAgICAgICBxID0gbmV3IFF1YXRlcm5pb24oYTEyIC0gYTIxLCBhMjAgLSBhMDIsIGEwMSAtIGExMCwgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcS5zY2FsZSgwLjUgLyBNYXRoLnNxcnQodCkpO1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBxdWF0IGZyb20gYSBzZXQgb2YgYXJyYXlzLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiB2YXIgcSA9IFF1YXRlcm5pb24uZnJvbUFycmF5KFswLDIsMiwwXSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGZyb21BcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKHZhbHVlc1swXSwgdmFsdWVzWzFdLCB2YWx1ZXNbMl0sIHZhbHVlc1szXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpbWl0cyB0aGUgbnVtYmVyIG9mIGRlY2ltYWxzIG9uIGVhY2ggcXVhdGVybmlvbiBkaW1lbnNpb24uXG4gICAgICogQHBhcmFtIG51bWJlck9mRGVjaW1hbHNcbiAgICAgKi9cbiAgICB0b0ZpeGVkKG51bWJlck9mRGVjaW1hbHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKG1hdGhmXzEubWF0aGYudG9GaXhlZChtYXRoZl8xLm1hdGhmLmFic1plcm8odGhpcy54KSwgbnVtYmVyT2ZEZWNpbWFscyksIG1hdGhmXzEubWF0aGYudG9GaXhlZChtYXRoZl8xLm1hdGhmLmFic1plcm8odGhpcy55KSwgbnVtYmVyT2ZEZWNpbWFscyksIG1hdGhmXzEubWF0aGYudG9GaXhlZChtYXRoZl8xLm1hdGhmLmFic1plcm8odGhpcy56KSwgbnVtYmVyT2ZEZWNpbWFscyksIG1hdGhmXzEubWF0aGYudG9GaXhlZChtYXRoZl8xLm1hdGhmLmFic1plcm8odGhpcy53KSwgbnVtYmVyT2ZEZWNpbWFscykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb3VyY2UgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMzgyXG4gICAgICogQHBhcmFtIHRhcmdldFxuICAgICAqL1xuICAgIHN0YXRpYyByb3RhdGVUbyhzb3VyY2UsIHRhcmdldCwgdXApIHtcbiAgICAgICAgY29uc3QgbSA9IG1hdHJpeElWXzEuTWF0cml4SVYuSURFTlRJVFk7XG4gICAgICAgIG0ubG9va0F0KHRhcmdldCwgc291cmNlLCB1cCk7XG4gICAgICAgIGNvbnN0IHRlbXAgPSBtLnZhbHVlO1xuICAgICAgICAvLyAgICAgICAgIHZhciBtMDAgPSB0ZW1wLm4xMSwgbTEwID0gdGVtcC5uMjEsIG0yMCA9IHRlbXAubjMxLFxuICAgICAgICAvLyBtMDEgPSB0ZW1wLm4xMiwgbTExID0gdGVtcC5uMjIsIG0yMSA9IHRlbXAubjMyLFxuICAgICAgICAvLyBtMDIgPSB0ZW1wLm4xMywgbTEyID0gdGVtcC5uMjMsIG0yMiA9IHRlbXAubjMzO1xuICAgICAgICBjb25zdCBtMDAgPSB0ZW1wWzBdLCBtMTAgPSB0ZW1wWzFdLCBtMjAgPSB0ZW1wWzJdLCBtMDEgPSB0ZW1wWzVdLCBtMTEgPSB0ZW1wWzZdLCBtMjEgPSB0ZW1wWzddLCBtMDIgPSB0ZW1wWzldLCBtMTIgPSB0ZW1wWzEwXSwgbTIyID0gdGVtcFsxMV07XG4gICAgICAgIGNvbnN0IHQgPSBtMDAgKyBtMTEgKyBtMjI7XG4gICAgICAgIGxldCBzLCB4LCB5LCB6LCB3O1xuICAgICAgICBpZiAodCA+IDApIHtcbiAgICAgICAgICAgIHMgPSBNYXRoLnNxcnQodCArIDEpICogMjtcbiAgICAgICAgICAgIHcgPSAwLjI1ICogcztcbiAgICAgICAgICAgIHggPSAobTIxIC0gbTEyKSAvIHM7XG4gICAgICAgICAgICB5ID0gKG0wMiAtIG0yMCkgLyBzO1xuICAgICAgICAgICAgeiA9IChtMTAgLSBtMDEpIC8gcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtMDAgPiBtMTEgJiYgbTAwID4gbTIyKSB7XG4gICAgICAgICAgICBzID0gTWF0aC5zcXJ0KDEuMCArIG0wMCAtIG0xMSAtIG0yMikgKiAyO1xuICAgICAgICAgICAgeCA9IHMgKiAwLjI1O1xuICAgICAgICAgICAgeSA9IChtMTAgKyBtMDEpIC8gcztcbiAgICAgICAgICAgIHogPSAobTAyICsgbTIwKSAvIHM7XG4gICAgICAgICAgICB3ID0gKG0yMSAtIG0xMikgLyBzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0xMSA+IG0yMikge1xuICAgICAgICAgICAgcyA9IE1hdGguc3FydCgxLjAgKyBtMTEgLSBtMDAgLSBtMjIpICogMjtcbiAgICAgICAgICAgIHkgPSBzICogMC4yNTtcbiAgICAgICAgICAgIHggPSAobTEwICsgbTAxKSAvIHM7XG4gICAgICAgICAgICB6ID0gKG0yMSArIG0xMikgLyBzO1xuICAgICAgICAgICAgdyA9IChtMDIgLSBtMjApIC8gcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBNYXRoLnNxcnQoMS4wICsgbTIyIC0gbTAwIC0gbTExKSAqIDI7XG4gICAgICAgICAgICB6ID0gcyAqIDAuMjU7XG4gICAgICAgICAgICB4ID0gKG0wMiArIG0yMCkgLyBzO1xuICAgICAgICAgICAgeSA9IChtMjEgKyBtMTIpIC8gcztcbiAgICAgICAgICAgIHcgPSAobTEwIC0gbTAxKSAvIHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSBuZXcgUXVhdGVybmlvbih4LCB5LCB6LCB3KTtcbiAgICAgICAgcm90YXRpb24ubm9ybWFsaXplKCk7XG4gICAgICAgIHJldHVybiByb3RhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgemVybyBxdWF0ZXJuaW9uLiAgQWRkaXRpdmUgaWRlbnRpdHkuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGxldCBxID0gUXVhdGVybmlvbi5aRVJPO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgWkVSTygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKDAsIDAsIDAsIDApO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IEkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbigwLCAxLCAwLCAwKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBKKCkge1xuICAgICAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oMCwgMCwgMSwgMCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgSygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKDAsIDAsIDAsIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHN0YXRpYyBpZGVudGl0eSBxdWF0ZXJuaW9uLiAgTXVsdGlwbGljYXRpdmUgaWRlbnRpdHkuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGxldCBxID0gUXVhdGVybmlvbi5JREVOVElUWTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IElERU5USVRZKCkge1xuICAgICAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oMCwgMCwgMCwgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc3RhdGljIG9uZSBxdWF0ZXJuaW9uLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBsZXQgcSA9IFF1YXRlcm5pb24uT05FO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgT05FKCkge1xuICAgICAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24oMSwgMSwgMSk7XG4gICAgfVxufVxuZXhwb3J0cy5RdWF0ZXJuaW9uID0gUXVhdGVybmlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1YXRlcm5pb24uanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/mathf/quaternion.js\n");

/***/ }),

/***/ "./lib/mathf/raycast.js":
/*!******************************!*\
  !*** ./lib/mathf/raycast.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Raycast = void 0;\nconst mathf_1 = __webpack_require__(/*! ./mathf */ \"./lib/mathf/mathf.js\");\nconst vector_1 = __webpack_require__(/*! ./vector */ \"./lib/mathf/vector.js\");\n/**\n * A 2d based Raycast class which tests collisions.\n * @unstable\n */\nclass Raycast {\n    /**\n     * Casts an inifinite ray (a vector of infinite maginitude) from the origin\n     * at a specific angle and tests if it intersects with boundaryA - boundaryB.\n     * See [[Raycast.cast2d]] for more.\n     *\n     * ```\n     *                        x (boundary A)\n     *        angle            |\n     *    o ------------------- |-----------------------------Infinite--->\n     *  (origin)                 |\n     *                            |\n     *                             |\n     *                              x (boundary Bb)\n     *\n     * ```\n     *\n     * @param origin\n     * @param angle The angle in radians\n     * @param boundaryA\n     * @param boundaryB\n     */\n    static castInfinite2dRay(origin, angle, boundaryA, boundaryB) {\n        const direction = vector_1.Vector.fromAngle(angle);\n        return Raycast.cast2d(origin, direction, boundaryA, boundaryB);\n    }\n    /**\n     * Raycasts out to 2d coordinates ignoring z.  Basically we do a line-line\n     * intersection test to see if the origin vector intersects the vector\n     * the boundary created by boundaryA and boundaryB Vectors.\n     *\n     *\n     * ```\n     *                        x (boundary A)\n     *        d (direction)    |\n     *    o ----------------->  |\n     *  (origin)                 |\n     *                            |\n     *                             |\n     *                              x (boundary Bb)\n     *\n     * ```\n     *\n     * Usage:\n     *\n     * ```ts\n     *\n     * // Starting from 5, 10, cast out a ray at 10 degrees of 1000 length.\n     * let origin = new Vector(5,10);\n     * let direction = Vector.fromAngle(mathf.degreeToRadian(10), 1000);\n     *\n     * let linePointA = new Vector(8, 2);\n     * let linePointB = new Vector(10, 20);\n     *\n     * // See if that intersects between linePointA and linePointB.\n     * // If it does, castResults.collision will contain a vector point of\n     * // intersection.\n     * let castResults =\n     *      Raycast.cast2d(origin, direction, linePointA, linePointB);\n     *\n     * if(castResults.hit) {\n     *     console.log(castResults.collision) // The collision point vector\n     * }\n     *\n     * ```\n     *\n     *\n     * @param origin The origin vector\n     * @param direction The origin vector\n     * @param boundaryA The first point of the boundary vector\n     * @param boundaryB The first point of the boundary vector\n     * @return RayCastObject\n     * @see https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n     * @see https://bit.ly/2WPb4X3\n     */\n    static cast2d(origin, direction, boundaryA, boundaryB) {\n        // From wikipedia: The intersection point falls within the first line\n        // segment if\n        // 0.0  t  1.0, and it falls within the second line segment\n        // if 0.0  u  1.0.\n        // However since the ray is infinite, can we can just use u < 1.0.\n        // Define endpoints.\n        const x1 = boundaryA.x;\n        const y1 = boundaryA.y;\n        const x2 = boundaryB.x;\n        const y2 = boundaryB.y;\n        const x3 = origin.x;\n        const y3 = origin.y;\n        const x4 = vector_1.Vector.add(origin, direction).x;\n        const y4 = vector_1.Vector.add(origin, direction).y;\n        const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        // If the denominator is 0, then the two lines are perfectly in\n        // parallel so they would never intersect.\n        if (denominator === 0) {\n            return {\n                hit: false,\n            };\n        }\n        // Now calculate t and u.\n        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;\n        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;\n        // If there is a hit calculate the interaction vector point.\n        if (t > 0 && t < 1 && u > 0) {\n            const x = x1 + t * (x2 - x1);\n            const y = y1 + t * (y2 - y1);\n            const collision = new vector_1.Vector(x, y);\n            return {\n                hit: true,\n                collision: collision,\n                distance: vector_1.Vector.subtract(origin, collision).length(),\n                angle: mathf_1.mathf.toFixed(vector_1.Vector.angle2d(origin, collision), 3),\n            };\n        }\n        else {\n            return {\n                hit: false,\n            };\n        }\n    }\n}\nexports.Raycast = Raycast;\n//# sourceMappingURL=raycast.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbWF0aGYvcmF5Y2FzdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9tYXRoZi9yYXljYXN0LmpzP2JiNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJheWNhc3QgPSB2b2lkIDA7XG5jb25zdCBtYXRoZl8xID0gcmVxdWlyZShcIi4vbWF0aGZcIik7XG5jb25zdCB2ZWN0b3JfMSA9IHJlcXVpcmUoXCIuL3ZlY3RvclwiKTtcbi8qKlxuICogQSAyZCBiYXNlZCBSYXljYXN0IGNsYXNzIHdoaWNoIHRlc3RzIGNvbGxpc2lvbnMuXG4gKiBAdW5zdGFibGVcbiAqL1xuY2xhc3MgUmF5Y2FzdCB7XG4gICAgLyoqXG4gICAgICogQ2FzdHMgYW4gaW5pZmluaXRlIHJheSAoYSB2ZWN0b3Igb2YgaW5maW5pdGUgbWFnaW5pdHVkZSkgZnJvbSB0aGUgb3JpZ2luXG4gICAgICogYXQgYSBzcGVjaWZpYyBhbmdsZSBhbmQgdGVzdHMgaWYgaXQgaW50ZXJzZWN0cyB3aXRoIGJvdW5kYXJ5QSAtIGJvdW5kYXJ5Qi5cbiAgICAgKiBTZWUgW1tSYXljYXN0LmNhc3QyZF1dIGZvciBtb3JlLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICB4IChib3VuZGFyeSBBKVxuICAgICAqICAgICAgICBhbmdsZSAgICAgICAgICAgIHxcbiAgICAgKiAgICBvIC0tLS0tLS0tLS0tLS0tLS0tLS0gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tSW5maW5pdGUtLS0+XG4gICAgICogIChvcmlnaW4pICAgICAgICAgICAgICAgICB8XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4IChib3VuZGFyeSBCYilcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpblxuICAgICAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICAgICAqIEBwYXJhbSBib3VuZGFyeUFcbiAgICAgKiBAcGFyYW0gYm91bmRhcnlCXG4gICAgICovXG4gICAgc3RhdGljIGNhc3RJbmZpbml0ZTJkUmF5KG9yaWdpbiwgYW5nbGUsIGJvdW5kYXJ5QSwgYm91bmRhcnlCKSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHZlY3Rvcl8xLlZlY3Rvci5mcm9tQW5nbGUoYW5nbGUpO1xuICAgICAgICByZXR1cm4gUmF5Y2FzdC5jYXN0MmQob3JpZ2luLCBkaXJlY3Rpb24sIGJvdW5kYXJ5QSwgYm91bmRhcnlCKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmF5Y2FzdHMgb3V0IHRvIDJkIGNvb3JkaW5hdGVzIGlnbm9yaW5nIHouICBCYXNpY2FsbHkgd2UgZG8gYSBsaW5lLWxpbmVcbiAgICAgKiBpbnRlcnNlY3Rpb24gdGVzdCB0byBzZWUgaWYgdGhlIG9yaWdpbiB2ZWN0b3IgaW50ZXJzZWN0cyB0aGUgdmVjdG9yXG4gICAgICogdGhlIGJvdW5kYXJ5IGNyZWF0ZWQgYnkgYm91bmRhcnlBIGFuZCBib3VuZGFyeUIgVmVjdG9ycy5cbiAgICAgKlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICB4IChib3VuZGFyeSBBKVxuICAgICAqICAgICAgICBkIChkaXJlY3Rpb24pICAgIHxcbiAgICAgKiAgICBvIC0tLS0tLS0tLS0tLS0tLS0tPiAgfFxuICAgICAqICAob3JpZ2luKSAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCAoYm91bmRhcnkgQmIpXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFVzYWdlOlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIC8vIFN0YXJ0aW5nIGZyb20gNSwgMTAsIGNhc3Qgb3V0IGEgcmF5IGF0IDEwIGRlZ3JlZXMgb2YgMTAwMCBsZW5ndGguXG4gICAgICogbGV0IG9yaWdpbiA9IG5ldyBWZWN0b3IoNSwxMCk7XG4gICAgICogbGV0IGRpcmVjdGlvbiA9IFZlY3Rvci5mcm9tQW5nbGUobWF0aGYuZGVncmVlVG9SYWRpYW4oMTApLCAxMDAwKTtcbiAgICAgKlxuICAgICAqIGxldCBsaW5lUG9pbnRBID0gbmV3IFZlY3Rvcig4LCAyKTtcbiAgICAgKiBsZXQgbGluZVBvaW50QiA9IG5ldyBWZWN0b3IoMTAsIDIwKTtcbiAgICAgKlxuICAgICAqIC8vIFNlZSBpZiB0aGF0IGludGVyc2VjdHMgYmV0d2VlbiBsaW5lUG9pbnRBIGFuZCBsaW5lUG9pbnRCLlxuICAgICAqIC8vIElmIGl0IGRvZXMsIGNhc3RSZXN1bHRzLmNvbGxpc2lvbiB3aWxsIGNvbnRhaW4gYSB2ZWN0b3IgcG9pbnQgb2ZcbiAgICAgKiAvLyBpbnRlcnNlY3Rpb24uXG4gICAgICogbGV0IGNhc3RSZXN1bHRzID1cbiAgICAgKiAgICAgIFJheWNhc3QuY2FzdDJkKG9yaWdpbiwgZGlyZWN0aW9uLCBsaW5lUG9pbnRBLCBsaW5lUG9pbnRCKTtcbiAgICAgKlxuICAgICAqIGlmKGNhc3RSZXN1bHRzLmhpdCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhjYXN0UmVzdWx0cy5jb2xsaXNpb24pIC8vIFRoZSBjb2xsaXNpb24gcG9pbnQgdmVjdG9yXG4gICAgICogfVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gVGhlIG9yaWdpbiB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uIFRoZSBvcmlnaW4gdmVjdG9yXG4gICAgICogQHBhcmFtIGJvdW5kYXJ5QSBUaGUgZmlyc3QgcG9pbnQgb2YgdGhlIGJvdW5kYXJ5IHZlY3RvclxuICAgICAqIEBwYXJhbSBib3VuZGFyeUIgVGhlIGZpcnN0IHBvaW50IG9mIHRoZSBib3VuZGFyeSB2ZWN0b3JcbiAgICAgKiBAcmV0dXJuIFJheUNhc3RPYmplY3RcbiAgICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmUlRTIlODAlOTNsaW5lX2ludGVyc2VjdGlvblxuICAgICAqIEBzZWUgaHR0cHM6Ly9iaXQubHkvMldQYjRYM1xuICAgICAqL1xuICAgIHN0YXRpYyBjYXN0MmQob3JpZ2luLCBkaXJlY3Rpb24sIGJvdW5kYXJ5QSwgYm91bmRhcnlCKSB7XG4gICAgICAgIC8vIEZyb20gd2lraXBlZGlhOiBUaGUgaW50ZXJzZWN0aW9uIHBvaW50IGZhbGxzIHdpdGhpbiB0aGUgZmlyc3QgbGluZVxuICAgICAgICAvLyBzZWdtZW50IGlmXG4gICAgICAgIC8vIDAuMCDiiaQgdCDiiaQgMS4wLCBhbmQgaXQgZmFsbHMgd2l0aGluIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50XG4gICAgICAgIC8vIGlmIDAuMCDiiaQgdSDiiaQgMS4wLlxuICAgICAgICAvLyBIb3dldmVyIHNpbmNlIHRoZSByYXkgaXMgaW5maW5pdGUsIGNhbiB3ZSBjYW4ganVzdCB1c2UgdSA8IDEuMC5cbiAgICAgICAgLy8gRGVmaW5lIGVuZHBvaW50cy5cbiAgICAgICAgY29uc3QgeDEgPSBib3VuZGFyeUEueDtcbiAgICAgICAgY29uc3QgeTEgPSBib3VuZGFyeUEueTtcbiAgICAgICAgY29uc3QgeDIgPSBib3VuZGFyeUIueDtcbiAgICAgICAgY29uc3QgeTIgPSBib3VuZGFyeUIueTtcbiAgICAgICAgY29uc3QgeDMgPSBvcmlnaW4ueDtcbiAgICAgICAgY29uc3QgeTMgPSBvcmlnaW4ueTtcbiAgICAgICAgY29uc3QgeDQgPSB2ZWN0b3JfMS5WZWN0b3IuYWRkKG9yaWdpbiwgZGlyZWN0aW9uKS54O1xuICAgICAgICBjb25zdCB5NCA9IHZlY3Rvcl8xLlZlY3Rvci5hZGQob3JpZ2luLCBkaXJlY3Rpb24pLnk7XG4gICAgICAgIGNvbnN0IGRlbm9taW5hdG9yID0gKHgxIC0geDIpICogKHkzIC0geTQpIC0gKHkxIC0geTIpICogKHgzIC0geDQpO1xuICAgICAgICAvLyBJZiB0aGUgZGVub21pbmF0b3IgaXMgMCwgdGhlbiB0aGUgdHdvIGxpbmVzIGFyZSBwZXJmZWN0bHkgaW5cbiAgICAgICAgLy8gcGFyYWxsZWwgc28gdGhleSB3b3VsZCBuZXZlciBpbnRlcnNlY3QuXG4gICAgICAgIGlmIChkZW5vbWluYXRvciA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBoaXQ6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgY2FsY3VsYXRlIHQgYW5kIHUuXG4gICAgICAgIGNvbnN0IHQgPSAoKHgxIC0geDMpICogKHkzIC0geTQpIC0gKHkxIC0geTMpICogKHgzIC0geDQpKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICBjb25zdCB1ID0gLSgoeDEgLSB4MikgKiAoeTEgLSB5MykgLSAoeTEgLSB5MikgKiAoeDEgLSB4MykpIC8gZGVub21pbmF0b3I7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgaGl0IGNhbGN1bGF0ZSB0aGUgaW50ZXJhY3Rpb24gdmVjdG9yIHBvaW50LlxuICAgICAgICBpZiAodCA+IDAgJiYgdCA8IDEgJiYgdSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB4MSArIHQgKiAoeDIgLSB4MSk7XG4gICAgICAgICAgICBjb25zdCB5ID0geTEgKyB0ICogKHkyIC0geTEpO1xuICAgICAgICAgICAgY29uc3QgY29sbGlzaW9uID0gbmV3IHZlY3Rvcl8xLlZlY3Rvcih4LCB5KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbjogY29sbGlzaW9uLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlOiB2ZWN0b3JfMS5WZWN0b3Iuc3VidHJhY3Qob3JpZ2luLCBjb2xsaXNpb24pLmxlbmd0aCgpLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBtYXRoZl8xLm1hdGhmLnRvRml4ZWQodmVjdG9yXzEuVmVjdG9yLmFuZ2xlMmQob3JpZ2luLCBjb2xsaXNpb24pLCAzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhpdDogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SYXljYXN0ID0gUmF5Y2FzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJheWNhc3QuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/mathf/raycast.js\n");

/***/ }),

/***/ "./lib/mathf/vector.js":
/*!*****************************!*\
  !*** ./lib/mathf/vector.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Vector = void 0;\nconst ease_1 = __webpack_require__(/*! ../ease/ease */ \"./lib/ease/ease.js\");\nconst mathf_1 = __webpack_require__(/*! ./mathf */ \"./lib/mathf/mathf.js\");\n/**\n *\n * A basic vector class that can be used for 2d or 3d.  When using for 2d,\n * the z defaults to 0.\n *\n * ```ts\n *\n * let v = new Vector(0,0,0);\n * let v2 = new Vector(2,1,0);\n *\n * v.add(v2);\n * let v3 = v.clone();\n * v3.scale(5);\n *\n * v3.dot(v2);\n *\n * ```\n *\n *\n * TODO (uxder): Add matrix transformations.\n *\n * TODO (uxder): Add more tests.\n *\n * Some good resource on Vectors if you are unfamiliar with them.\n * @see https://www.mathsisfun.com/algebra/vectors.html\n * @see https://bit.ly/2wGFKdv\n *\n * Inspirted by:\n * @see https://github.com/mrdoob/three.js/blob/master/src/math/Vector3.js\n * @see https://github.com/photonstorm/phaser/blob/v3.17.0/src/math/Vector3.js\n * @see https://evanw.github.io/lightgl.js/docs/vector.html\n *\n */\nclass Vector {\n    constructor(x = 0, y = 0, z = 0, w = 0) {\n        this.x = x || 0;\n        this.y = y || 0;\n        this.z = z || 0;\n        this.w = w || 0;\n    }\n    /**\n     * Makes a clone of this vector.\n     *\n     * ```ts\n     * var v = new Vector(0,1,0);\n     * var clonedVector = v.clone();\n     * ```\n     * @tested\n     */\n    clone() {\n        return new Vector(this.x, this.y, this.z);\n    }\n    /**\n     * Makes a clone of this vector.\n     *\n     * ```ts\n     * var v = new Vector(0,1,0);\n     * var clonedVector = Vecrtor3.clone(v);\n     * ```\n     * @tested\n     */\n    static clone(v) {\n        return new Vector(v.x, v.y, v.z);\n    }\n    /**\n     * Sets x,y,z.\n     * @tested\n     */\n    set(x, y, z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        return this;\n    }\n    /**\n     * Floors out the internal values to avoid subpixel rendering.\n     */\n    floor() {\n        this.x = ~~this.x;\n        this.y = ~~this.y;\n        this.z = ~~this.z;\n        return this;\n    }\n    /**\n     * Converts internal values to int\n     */\n    int() {\n        this.x = this.x >> 0;\n        this.y = this.y >> 0;\n        this.z = this.z >> 0;\n        return this;\n    }\n    /**\n     * Tests the equality of this vector against another.\n     *\n     * ```ts\n     * var v = new Vector(0,1,0);\n     * var v2 = new Vector(0,1,0);\n     * v.equals(v2); // true\n     * ```\n     * @tested\n     */\n    equals(vector) {\n        return this.x === vector.x && this.y === vector.y && this.z === vector.z;\n    }\n    /**\n     * A static method testing the equality of two vectors.\n     *\n     * ```ts\n     * var v = new Vectorr3(0,1,0);\n     * var v2 = new Vector(0,1,0);\n     * Vector.equals(v2); // true\n     * ```\n     *\n     * @param v1\n     * @param v2\n     * @tested\n     */\n    static equals(v1, v2) {\n        return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;\n    }\n    /**\n     * Converts the current vector to an array.\n     *\n     * ```ts\n     * var v = new Vector(0,1,0);\n     * v.toArray(); // [0,1,0]\n     * ```\n     */\n    toArray() {\n        return [this.x, this.y, this.z];\n    }\n    /**\n     * Converts the current vector to an array.\n     *\n     * ```ts\n     * var v = new Vector(0,1,0);\n     * var a = Vector.toArray(v);// [0,1,0]\n     * ```\n     */\n    static toArray(v) {\n        return [v.x, v.y, v.z];\n    }\n    /**\n     * Creates a new Vector from a set of arrays.\n     *\n     * ```ts\n     * var v = Vector.fromArray([0,2,2]);\n     * ```\n     */\n    static fromArray(values) {\n        return new Vector(values[0], values[1], values[2]);\n    }\n    /**\n     * Creates a new Vector from static method.\n     *\n     * ```ts\n     * var v = Vector.create(0,2,2);\n     * ```\n     * @param x\n     * @param y\n     * @param z\n     * @tested\n     */\n    static create(x, y, z = 0) {\n        return new Vector(x, y, z);\n    }\n    /**\n     * Creates a new 2d Vector with a specific angle and length.\n     * This is useful to create a directional vector.\n     *\n     * Example:\n     * ```ts\n     *\n     *  let origin = new Vector(10, 20);\n     *  // Create a ray that goes 90 degrees down in 100 length.\n     *  let ray = Vector.fromAngle(mathf.degreeToRadian(90), 100);\n     *\n     *  // Combine the origin and ray to get the endpoint (the tip of the ray).\n     *  let endPoint = Vector.add(origin, ray);\n     *\n     * ```\n     *\n     *\n     * @param angle Angle in radians\n     * @param length The length, magnitude of the vector. Defaults to a\n     *     semi-infinite length.\n     */\n    static fromAngle(angle, length = 100000) {\n        return new Vector(length * Math.cos(angle), length * Math.sin(angle), 0);\n    }\n    /**\n     * Gets the angle between two vectors.\n     *\n     *\n     * ```ts\n     *\n     * let a = new Vector(100,200);\n     * let b = new Vector(150,240);\n     *\n     * let angle = Vector.angle2d(a, b);\n     *\n     * ```\n     *\n     * @param a The first vector\n     * @param b The second vector\n     * @return The angle of the two vectors in radians.\n     */\n    static angle2d(a, b) {\n        const dx = a.x - b.x, dy = a.y - b.y;\n        return Math.atan2(dy, dx);\n    }\n    /**\n     * Given a targetVector, this will find the rotation angles of each\n     * axis which you can then later use to on rotateX, rotateY, rotateZ\n     * values on a matrix or rotational vector.\n     *\n     *\n     * Basic Example:\n     * ```ts\n     *\n     * let origin = Vector.ZERO;\n     * let target = new Vector(10,15,20);\n     * let angles = Vector.getXyzRotationTo(origin, target);\n     *\n     * angles[0] // 1.95.. -- radian x rotation value\n     * angles[1] // 2.16.. -- radian y rotation value\n     * angles[2] // 2.40.. -- radian z rotation value\n     *\n     * ```\n     *\n     * See for a reference but the below is not using this:\n     * https://stackoverflow.com/questions/48532207/get-xyz-rotation-from-pvector\n     * @param targetVector\n     * @return Array<number> An array with three numbers,\n     *      angleX, angleY and angleZ in radians.\n     */\n    static getXyzRotationTo(originVector, targetVector) {\n        // Use the difference between current vector and target as the basis.\n        const delta = originVector.clone().subtract(targetVector);\n        const angleX = Math.atan(delta.x);\n        const angleY = Math.atan(delta.y);\n        const angleZ = Math.atan(delta.z);\n        return [angleX, angleY, angleZ];\n    }\n    /**\n     * Find the Eular rotation from one vector to another.  This will you\n     * the angle delta between the two.\n     *\n     *\n     * ```ts\n     * let eularVector = Vector.getEularRotation(origin, target);\n     * eularVector.x // degrees in x rotation\n     * eularVector.y // degrees in y rotation\n     * eularVector.z // degrees in z rotation\n     * ```\n     *\n     * @param originVector\n     * @param targetVector\n     */\n    static getEularRotationTo(originVector, targetVector) {\n        // Use the difference between current vector and target as the basis.\n        const delta = originVector\n            .clone()\n            .normalize()\n            .subtract(targetVector.clone().normalize());\n        const angleX = -Math.atan(delta.x);\n        const angleY = Math.atan(delta.y);\n        const angleZ = -Math.atan(delta.z);\n        return new Vector(mathf_1.mathf.radianToDegree(angleX), mathf_1.mathf.radianToDegree(angleY), mathf_1.mathf.radianToDegree(angleZ));\n    }\n    /**\n     * Adds this vector to another.\n     */\n    add(v) {\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z || 0;\n        return this;\n    }\n    static add(v2, v1) {\n        const x = v2.x + v1.x;\n        const y = v2.y + v1.y;\n        const z = v2.z + v1.z;\n        return new Vector(x, y, z);\n    }\n    /**\n     * Subtract this vector from another .\n     */\n    subtract(v) {\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z || 0;\n        return this;\n    }\n    /**\n     * Subtract this vector from another and create a new vector.\n     */\n    static subtract(v2, v1) {\n        const x = v2.x - v1.x;\n        const y = v2.y - v1.y;\n        const z = v2.z - v1.z;\n        return new Vector(x, y, z);\n    }\n    /**\n     * Multiply this vector with another.\n     */\n    multiply(v) {\n        this.x *= v.x;\n        this.y *= v.y;\n        this.z *= v.z || 1;\n        return this;\n    }\n    /**\n     * Divide this vector with another.\n     */\n    divide(v) {\n        this.x /= v.x;\n        this.y /= v.y;\n        this.z /= v.z || 1;\n        return this;\n    }\n    /**\n     * Scales this vector by the given scalar value.\n     */\n    scale(scalar) {\n        if (isFinite(scalar)) {\n            this.x *= scalar;\n            this.y *= scalar;\n            this.z *= scalar;\n            return this;\n        }\n        else {\n            return Vector.ZERO;\n        }\n    }\n    /**\n     * Negate this vector as a 3d vector.\n     */\n    negate() {\n        this.x = -this.x;\n        this.y = -this.y;\n        this.z = mathf_1.mathf.absZero(-this.z);\n        return this;\n    }\n    static negate(v) {\n        const x = -v.x;\n        const y = -v.y;\n        const z = mathf_1.mathf.absZero(-v.z);\n        return new Vector(x, y, z);\n    }\n    /**\n     * Calculates the distance between this vector and another.\n     * @return The distance from this vector to another\n     */\n    distance(v) {\n        const dx = v.x - this.x;\n        const dy = v.y - this.y;\n        const dz = v.z - this.z || 0;\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    /**\n     * Calculates the length / magnitude of this vector.\n     */\n    length() {\n        const x = this.x;\n        const y = this.y;\n        const z = this.z;\n        return Math.sqrt(x * x + y * y + z * z);\n    }\n    /**\n     * Calculates the length squared\n     */\n    lengthSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    /**\n     * Calculates the magnitude of this vector.\n     * Alias of [[Vector.length]]\n     */\n    magnitude() {\n        return this.length();\n    }\n    /**\n     * Normalizes this vector.\n     */\n    normalize() {\n        const x = this.x;\n        const y = this.y;\n        const z = this.z;\n        let len = x * x + y * y + z * z;\n        if (len > 0) {\n            len = 1 / Math.sqrt(len);\n            this.x = x * len;\n            this.y = y * len;\n            this.z = z * len;\n        }\n        return this;\n    }\n    /**\n     * Calculates the dot product of this Vector and the given vector.\n     * @return The dot product of this vector and provided vector.\n     */\n    dot(v) {\n        return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    cross(v) {\n        const ax = this.x;\n        const ay = this.y;\n        const az = this.z;\n        const bx = v.x;\n        const by = v.y;\n        const bz = v.z;\n        this.x = ay * bz - az * by;\n        this.y = az * bx - ax * bz;\n        this.z = ax * by - ay * bx;\n        return this;\n    }\n    /**\n     * Transform this vector given the provided matrix4.\n     */\n    transformWithMatrixIV(matrix) {\n        const x = this.x;\n        const y = this.y;\n        const z = this.z;\n        const mat = matrix.value;\n        const tx = x * mat[0] + y * mat[4] + z * mat[8] + mat[12];\n        const ty = x * mat[1] + y * mat[5] + z * mat[9] + mat[13];\n        const tz = x * mat[2] + y * mat[6] + z * mat[10] + mat[14];\n        let tw = x * mat[3] + y * mat[7] + z * mat[11] + mat[15];\n        tw = tw || 1.0;\n        this.x = tx / tw;\n        this.y = ty / tw;\n        this.z = tz / tw;\n        return new Vector(this.x, this.y, this.z);\n    }\n    /**\n     * Transform the current vector with the provided matrix4 to a\n     * 2d.  This effectively takes this 3d vector and makes it into\n     * the cooresponding 2d coordinates using the transformMatrix.\n     *\n     * This operation is the same as transformWithMatrixIV except the\n     * z is dropped.\n     * @param matrix\n     */\n    transformWithMatrixIVTo2d(matrix) {\n        return this.transformWithMatrixIV(matrix).set(this.x, this.y, 0);\n    }\n    // /**\n    //  * Adds a 3d rotation.  This is NOT a rotation based on the center of the\n    //  * this vector but based from VECTOR.ZERO.  (so adding a rotation will move\n    //  * the position not the direction it's looking).\n    //  * https://ikeryou.hatenablog.com/entry/2018/01/07/104729\n    //  * @param v\n    //  * @param angle Angle in radians.\n    //  * TODO (uxder): Maybe move to vector-dom instead?\n    //  */\n    // rotateX(angle: number) {\n    //     const cos = Math.cos(angle);\n    //     const sin = Math.sin(angle);\n    //     this.y = this.y * cos - this.z * sin;\n    //     this.z = this.z * cos + this.y * sin;\n    //     return this;\n    // }\n    // /**\n    //  * Adds a 3d rotation.  This is NOT a rotation based on the center of the\n    //  * this vector but based from VECTOR.ZERO.  (so adding a rotation will move\n    //  * the position not the direction it's looking).\n    //  * https://ikeryou.hatenablog.com/entry/2018/01/07/104729\n    //  * @param v\n    //  * @param angle Angle in radians.\n    //  * TODO (uxder): Maybe move to vector-dom instead?\n    //  */\n    // rotateY(angle: number) {\n    //     const cos = Math.cos(angle);\n    //     const sin = Math.sin(angle);\n    //     this.x = this.x * cos - this.z * sin;\n    //     this.z = this.z * cos + this.x * sin;\n    //     return this;\n    // }\n    // /**\n    //  * Adds a 3d rotation.  This is NOT a rotation based on the center of the\n    //  * this vector but based from VECTOR.ZERO.  (so adding a rotation will move\n    //  * the position not the direction it's looking).\n    //  * https://ikeryou.hatenablog.com/entry/2018/01/07/104729\n    //  * @param v\n    //  * @param angle Angle in radians.\n    //  * TODO (uxder): Maybe move to vector-dom instead?\n    //  */\n    // rotateZ(angle: number) {\n    //     const cos = Math.cos(angle);\n    //     const sin = Math.sin(angle);\n    //     this.x = this.x * cos - this.y * sin;\n    //     this.y = this.y * cos + this.x * sin;\n    //     return this;\n    // }\n    /**\n     * Linear interpolates this vector TOWARDS the provided vector.\n     * @param v\n     * @param progress A number between 0-1.\n     */\n    lerp(v, progress = 0) {\n        this.x = mathf_1.mathf.lerp(this.x, v.x, progress);\n        this.y = mathf_1.mathf.lerp(this.y, v.y, progress);\n        this.z = mathf_1.mathf.lerp(this.z, v.z, progress);\n        return this;\n    }\n    /**\n     * Similar to lerp but uses exponential decay.   Useful to\n     * smooth out animations with damping.\n     * @param v\n     * @param progress A number between 0-1.\n     */\n    damp(v, progress = 0, damp) {\n        this.x = mathf_1.mathf.damp(this.x, v.x, progress, damp);\n        this.y = mathf_1.mathf.damp(this.y, v.y, progress, damp);\n        this.z = mathf_1.mathf.damp(this.z, v.z, progress, damp);\n        return this;\n    }\n    /**\n     * Ease interpolates this vector TOWARDS the provided vector.\n     * @param v\n     * @param progress A number between 0-1.\n     * @param easeFunction An easing function. See [[mathf.ease]].\n     */\n    ease(v, progress = 0, easeFunction = ease_1.EASE.linear) {\n        this.x = mathf_1.mathf.ease(this.x, v.x, progress, easeFunction);\n        this.y = mathf_1.mathf.ease(this.y, v.y, progress, easeFunction);\n        this.z = mathf_1.mathf.ease(this.z, v.z, progress, easeFunction);\n        return this;\n    }\n    /**\n     * Ease interpolates and eases 1 vector towards another.\n     * @param v1 startVector\n     * @param v2 endVector\n     * @param progress\n     * @param easeFunction\n     */\n    static ease(v1, v2, progress = 0, easeFunction = ease_1.EASE.linear) {\n        const x = mathf_1.mathf.ease(v1.x, v2.x, progress, easeFunction);\n        const y = mathf_1.mathf.ease(v1.y, v2.y, progress, easeFunction);\n        const z = mathf_1.mathf.ease(v1.z, v2.z, progress, easeFunction);\n        return new Vector(x, y, z);\n    }\n    /**\n     * Given vector a and vector b, takes the Math.min values of x,y,z and\n     * returns a new Vector.\n     * @param a Vector A\n     * @param b Vector B\n     */\n    static min(a, b) {\n        return new Vector(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.min(a.z, b.z));\n    }\n    /**\n     * Given vector a and vector b, takes the Math.max values of x,y,z and\n     * returns a new Vector.\n     * @param a Vector A\n     * @param b Vector B\n     */\n    static max(a, b) {\n        return new Vector(Math.max(a.x, b.x), Math.max(a.y, b.y), Math.max(a.z, b.z));\n    }\n    /**\n     * Given a Vector storing Euler degrees, converts it to radians.\n     *\n     * ```ts\n     * let eulerVector = new Vector(90, 180, 0);\n     * let radianVector = Vector.eulerVectorToRadians(eulerVector);\n     *\n     * ```\n     */\n    static degreeToRadians(v) {\n        return new Vector(mathf_1.mathf.degreeToRadian(v.x), mathf_1.mathf.degreeToRadian(v.y), mathf_1.mathf.degreeToRadian(v.z));\n    }\n    degreeToRadians() {\n        return Vector.degreeToRadians(this);\n    }\n    /**\n     * Clamps a given vector between a min and max vector.\n     * @param min The min vector\n     * @param max The max vector\n     * @param vector The vector to clamp\n     */\n    static clamp(min, max, vector) {\n        return new Vector(mathf_1.mathf.clamp(min.x, max.x, vector.x), mathf_1.mathf.clamp(min.y, max.y, vector.y), mathf_1.mathf.clamp(min.z, max.z, vector.z));\n    }\n    /**\n     * Creates a Eular vector from a rotationalMatrix. This conversion is better\n     * avoided for different reasons.  The pitch (y) will be limited to +-90.\n     *\n     * There are also cases where accuracy suffers so use with caution.\n     *\n     * Yaw, Roll will be +-180.\n     * Pitch will be +- 90.\n     *\n     * ```ts\n     *   // Example converts a quaternion back over to euler.\n     *   let quat = new Quaternion(0.2, 0.2, 0.2, 0.1);\n     *   let matrix = MatrixIV.fromQuaternion(quat.clone());\n     *   let eularVector = Vector.fromRotationMatrixIV(matrix);\n     * ```\n     *\n     */\n    static fromRotationMatrixIV(m) {\n        const result = Vector.ZERO;\n        const te = m.value;\n        const m11 = te[0], m12 = te[4], m13 = te[8];\n        // eslint-disable-next-line\n        const m21 = te[1], m22 = te[5], m23 = te[9];\n        // eslint-disable-next-line\n        const m31 = te[2], m32 = te[6], m33 = te[10];\n        // XYZ ordering\n        // https://github.com/mrdoob/three.js/blob/master/src/math/Euler.js#L146\n        result.y = Math.asin(mathf_1.mathf.clamp(-1, 1, m13));\n        if (Math.abs(m13) < 0.9999999) {\n            result.x = Math.atan2(-m23, m33);\n            result.z = Math.atan2(-m12, m11);\n        }\n        else {\n            result.x = Math.atan2(m32, m22);\n            result.z = 0;\n        }\n        result.x = mathf_1.mathf.radianToDegree(result.x);\n        // result.y = mathf.wrap(mathf.radianToDegree(result.y), -89.9999, 89.9999);\n        result.y = mathf_1.mathf.radianToDegree(result.y);\n        result.z = mathf_1.mathf.radianToDegree(result.z);\n        return result;\n    }\n    /**\n     * A static zero vector.\n     *\n     * ```ts\n     * let positon = Vector.ZERO;\n     * ```\n     */\n    static get ZERO() {\n        return new Vector(0, 0, 0);\n    }\n    /**\n     * A static one vector.\n     *\n     * ```ts\n     * let positon = Vector.ONE;\n     * ```\n     */\n    static get ONE() {\n        return new Vector(1, 1, 1);\n    }\n    /**\n     * A static right vector for reference .\n     *\n     * ```ts\n     * let positon = Vector.ONE;\n     * position.add(Vector.RIGHT.scale(4))\n     * ```\n     */\n    static get RIGHT() {\n        return new Vector(1, 0, 0);\n    }\n    /**\n     * A static left vector for reference .\n     */\n    static get LEFT() {\n        return new Vector(-1, 0, 0);\n    }\n    /**\n     * A static up vector for reference .\n     */\n    static get UP() {\n        return new Vector(0, -1, 0);\n    }\n    /**\n     * A static down vector for reference .\n     */\n    static get DOWN() {\n        return new Vector(0, 1, 0);\n    }\n    /**\n     * A static foward vector for reference .\n     */\n    static get FORWARD() {\n        return new Vector(0, 0, 1);\n    }\n    /**\n     * A static foward vector for reference .\n     */\n    static get BACK() {\n        return new Vector(0, 0, -1);\n    }\n}\nexports.Vector = Vector;\n//# sourceMappingURL=vector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbWF0aGYvdmVjdG9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL21hdGhmL3ZlY3Rvci5qcz9hYTczIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WZWN0b3IgPSB2b2lkIDA7XG5jb25zdCBlYXNlXzEgPSByZXF1aXJlKFwiLi4vZWFzZS9lYXNlXCIpO1xuY29uc3QgbWF0aGZfMSA9IHJlcXVpcmUoXCIuL21hdGhmXCIpO1xuLyoqXG4gKlxuICogQSBiYXNpYyB2ZWN0b3IgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCBmb3IgMmQgb3IgM2QuICBXaGVuIHVzaW5nIGZvciAyZCxcbiAqIHRoZSB6IGRlZmF1bHRzIHRvIDAuXG4gKlxuICogYGBgdHNcbiAqXG4gKiBsZXQgdiA9IG5ldyBWZWN0b3IoMCwwLDApO1xuICogbGV0IHYyID0gbmV3IFZlY3RvcigyLDEsMCk7XG4gKlxuICogdi5hZGQodjIpO1xuICogbGV0IHYzID0gdi5jbG9uZSgpO1xuICogdjMuc2NhbGUoNSk7XG4gKlxuICogdjMuZG90KHYyKTtcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICogVE9ETyAodXhkZXIpOiBBZGQgbWF0cml4IHRyYW5zZm9ybWF0aW9ucy5cbiAqXG4gKiBUT0RPICh1eGRlcik6IEFkZCBtb3JlIHRlc3RzLlxuICpcbiAqIFNvbWUgZ29vZCByZXNvdXJjZSBvbiBWZWN0b3JzIGlmIHlvdSBhcmUgdW5mYW1pbGlhciB3aXRoIHRoZW0uXG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm1hdGhzaXNmdW4uY29tL2FsZ2VicmEvdmVjdG9ycy5odG1sXG4gKiBAc2VlIGh0dHBzOi8vYml0Lmx5LzJ3R0ZLZHZcbiAqXG4gKiBJbnNwaXJ0ZWQgYnk6XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi9tYXN0ZXIvc3JjL21hdGgvVmVjdG9yMy5qc1xuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2Jsb2IvdjMuMTcuMC9zcmMvbWF0aC9WZWN0b3IzLmpzXG4gKiBAc2VlIGh0dHBzOi8vZXZhbncuZ2l0aHViLmlvL2xpZ2h0Z2wuanMvZG9jcy92ZWN0b3IuaHRtbFxuICpcbiAqL1xuY2xhc3MgVmVjdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMCkge1xuICAgICAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgICAgIHRoaXMueSA9IHkgfHwgMDtcbiAgICAgICAgdGhpcy56ID0geiB8fCAwO1xuICAgICAgICB0aGlzLncgPSB3IHx8IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgY2xvbmUgb2YgdGhpcyB2ZWN0b3IuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIHZhciB2ID0gbmV3IFZlY3RvcigwLDEsMCk7XG4gICAgICogdmFyIGNsb25lZFZlY3RvciA9IHYuY2xvbmUoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAdGVzdGVkXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLnopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGNsb25lIG9mIHRoaXMgdmVjdG9yLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiB2YXIgdiA9IG5ldyBWZWN0b3IoMCwxLDApO1xuICAgICAqIHZhciBjbG9uZWRWZWN0b3IgPSBWZWNydG9yMy5jbG9uZSh2KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAdGVzdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNsb25lKHYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3Iodi54LCB2LnksIHYueik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgeCx5LHouXG4gICAgICogQHRlc3RlZFxuICAgICAqL1xuICAgIHNldCh4LCB5LCB6ID0gMCkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmxvb3JzIG91dCB0aGUgaW50ZXJuYWwgdmFsdWVzIHRvIGF2b2lkIHN1YnBpeGVsIHJlbmRlcmluZy5cbiAgICAgKi9cbiAgICBmbG9vcigpIHtcbiAgICAgICAgdGhpcy54ID0gfn50aGlzLng7XG4gICAgICAgIHRoaXMueSA9IH5+dGhpcy55O1xuICAgICAgICB0aGlzLnogPSB+fnRoaXMuejtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGludGVybmFsIHZhbHVlcyB0byBpbnRcbiAgICAgKi9cbiAgICBpbnQoKSB7XG4gICAgICAgIHRoaXMueCA9IHRoaXMueCA+PiAwO1xuICAgICAgICB0aGlzLnkgPSB0aGlzLnkgPj4gMDtcbiAgICAgICAgdGhpcy56ID0gdGhpcy56ID4+IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyB0aGUgZXF1YWxpdHkgb2YgdGhpcyB2ZWN0b3IgYWdhaW5zdCBhbm90aGVyLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiB2YXIgdiA9IG5ldyBWZWN0b3IoMCwxLDApO1xuICAgICAqIHZhciB2MiA9IG5ldyBWZWN0b3IoMCwxLDApO1xuICAgICAqIHYuZXF1YWxzKHYyKTsgLy8gdHJ1ZVxuICAgICAqIGBgYFxuICAgICAqIEB0ZXN0ZWRcbiAgICAgKi9cbiAgICBlcXVhbHModmVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IHZlY3Rvci54ICYmIHRoaXMueSA9PT0gdmVjdG9yLnkgJiYgdGhpcy56ID09PSB2ZWN0b3IuejtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgbWV0aG9kIHRlc3RpbmcgdGhlIGVxdWFsaXR5IG9mIHR3byB2ZWN0b3JzLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiB2YXIgdiA9IG5ldyBWZWN0b3JyMygwLDEsMCk7XG4gICAgICogdmFyIHYyID0gbmV3IFZlY3RvcigwLDEsMCk7XG4gICAgICogVmVjdG9yLmVxdWFscyh2Mik7IC8vIHRydWVcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2MVxuICAgICAqIEBwYXJhbSB2MlxuICAgICAqIEB0ZXN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZXF1YWxzKHYxLCB2Mikge1xuICAgICAgICByZXR1cm4gdjEueCA9PT0gdjIueCAmJiB2MS55ID09PSB2Mi55ICYmIHYxLnogPT09IHYyLno7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjdXJyZW50IHZlY3RvciB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogdmFyIHYgPSBuZXcgVmVjdG9yKDAsMSwwKTtcbiAgICAgKiB2LnRvQXJyYXkoKTsgLy8gWzAsMSwwXVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMuel07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjdXJyZW50IHZlY3RvciB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogdmFyIHYgPSBuZXcgVmVjdG9yKDAsMSwwKTtcbiAgICAgKiB2YXIgYSA9IFZlY3Rvci50b0FycmF5KHYpOy8vIFswLDEsMF1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgdG9BcnJheSh2KSB7XG4gICAgICAgIHJldHVybiBbdi54LCB2LnksIHYuel07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmVjdG9yIGZyb20gYSBzZXQgb2YgYXJyYXlzLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiB2YXIgdiA9IFZlY3Rvci5mcm9tQXJyYXkoWzAsMiwyXSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGZyb21BcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodmFsdWVzWzBdLCB2YWx1ZXNbMV0sIHZhbHVlc1syXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmVjdG9yIGZyb20gc3RhdGljIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogdmFyIHYgPSBWZWN0b3IuY3JlYXRlKDAsMiwyKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHBhcmFtIHpcbiAgICAgKiBAdGVzdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZSh4LCB5LCB6ID0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih4LCB5LCB6KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyAyZCBWZWN0b3Igd2l0aCBhIHNwZWNpZmljIGFuZ2xlIGFuZCBsZW5ndGguXG4gICAgICogVGhpcyBpcyB1c2VmdWwgdG8gY3JlYXRlIGEgZGlyZWN0aW9uYWwgdmVjdG9yLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiBgYGB0c1xuICAgICAqXG4gICAgICogIGxldCBvcmlnaW4gPSBuZXcgVmVjdG9yKDEwLCAyMCk7XG4gICAgICogIC8vIENyZWF0ZSBhIHJheSB0aGF0IGdvZXMgOTAgZGVncmVlcyBkb3duIGluIDEwMCBsZW5ndGguXG4gICAgICogIGxldCByYXkgPSBWZWN0b3IuZnJvbUFuZ2xlKG1hdGhmLmRlZ3JlZVRvUmFkaWFuKDkwKSwgMTAwKTtcbiAgICAgKlxuICAgICAqICAvLyBDb21iaW5lIHRoZSBvcmlnaW4gYW5kIHJheSB0byBnZXQgdGhlIGVuZHBvaW50ICh0aGUgdGlwIG9mIHRoZSByYXkpLlxuICAgICAqICBsZXQgZW5kUG9pbnQgPSBWZWN0b3IuYWRkKG9yaWdpbiwgcmF5KTtcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW5nbGUgQW5nbGUgaW4gcmFkaWFuc1xuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIGxlbmd0aCwgbWFnbml0dWRlIG9mIHRoZSB2ZWN0b3IuIERlZmF1bHRzIHRvIGFcbiAgICAgKiAgICAgc2VtaS1pbmZpbml0ZSBsZW5ndGguXG4gICAgICovXG4gICAgc3RhdGljIGZyb21BbmdsZShhbmdsZSwgbGVuZ3RoID0gMTAwMDAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKGxlbmd0aCAqIE1hdGguY29zKGFuZ2xlKSwgbGVuZ3RoICogTWF0aC5zaW4oYW5nbGUpLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycy5cbiAgICAgKlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIGxldCBhID0gbmV3IFZlY3RvcigxMDAsMjAwKTtcbiAgICAgKiBsZXQgYiA9IG5ldyBWZWN0b3IoMTUwLDI0MCk7XG4gICAgICpcbiAgICAgKiBsZXQgYW5nbGUgPSBWZWN0b3IuYW5nbGUyZChhLCBiKTtcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3RvclxuICAgICAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yXG4gICAgICogQHJldHVybiBUaGUgYW5nbGUgb2YgdGhlIHR3byB2ZWN0b3JzIGluIHJhZGlhbnMuXG4gICAgICovXG4gICAgc3RhdGljIGFuZ2xlMmQoYSwgYikge1xuICAgICAgICBjb25zdCBkeCA9IGEueCAtIGIueCwgZHkgPSBhLnkgLSBiLnk7XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgdGFyZ2V0VmVjdG9yLCB0aGlzIHdpbGwgZmluZCB0aGUgcm90YXRpb24gYW5nbGVzIG9mIGVhY2hcbiAgICAgKiBheGlzIHdoaWNoIHlvdSBjYW4gdGhlbiBsYXRlciB1c2UgdG8gb24gcm90YXRlWCwgcm90YXRlWSwgcm90YXRlWlxuICAgICAqIHZhbHVlcyBvbiBhIG1hdHJpeCBvciByb3RhdGlvbmFsIHZlY3Rvci5cbiAgICAgKlxuICAgICAqXG4gICAgICogQmFzaWMgRXhhbXBsZTpcbiAgICAgKiBgYGB0c1xuICAgICAqXG4gICAgICogbGV0IG9yaWdpbiA9IFZlY3Rvci5aRVJPO1xuICAgICAqIGxldCB0YXJnZXQgPSBuZXcgVmVjdG9yKDEwLDE1LDIwKTtcbiAgICAgKiBsZXQgYW5nbGVzID0gVmVjdG9yLmdldFh5elJvdGF0aW9uVG8ob3JpZ2luLCB0YXJnZXQpO1xuICAgICAqXG4gICAgICogYW5nbGVzWzBdIC8vIDEuOTUuLiAtLSByYWRpYW4geCByb3RhdGlvbiB2YWx1ZVxuICAgICAqIGFuZ2xlc1sxXSAvLyAyLjE2Li4gLS0gcmFkaWFuIHkgcm90YXRpb24gdmFsdWVcbiAgICAgKiBhbmdsZXNbMl0gLy8gMi40MC4uIC0tIHJhZGlhbiB6IHJvdGF0aW9uIHZhbHVlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNlZSBmb3IgYSByZWZlcmVuY2UgYnV0IHRoZSBiZWxvdyBpcyBub3QgdXNpbmcgdGhpczpcbiAgICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80ODUzMjIwNy9nZXQteHl6LXJvdGF0aW9uLWZyb20tcHZlY3RvclxuICAgICAqIEBwYXJhbSB0YXJnZXRWZWN0b3JcbiAgICAgKiBAcmV0dXJuIEFycmF5PG51bWJlcj4gQW4gYXJyYXkgd2l0aCB0aHJlZSBudW1iZXJzLFxuICAgICAqICAgICAgYW5nbGVYLCBhbmdsZVkgYW5kIGFuZ2xlWiBpbiByYWRpYW5zLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRYeXpSb3RhdGlvblRvKG9yaWdpblZlY3RvciwgdGFyZ2V0VmVjdG9yKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgdmVjdG9yIGFuZCB0YXJnZXQgYXMgdGhlIGJhc2lzLlxuICAgICAgICBjb25zdCBkZWx0YSA9IG9yaWdpblZlY3Rvci5jbG9uZSgpLnN1YnRyYWN0KHRhcmdldFZlY3Rvcik7XG4gICAgICAgIGNvbnN0IGFuZ2xlWCA9IE1hdGguYXRhbihkZWx0YS54KTtcbiAgICAgICAgY29uc3QgYW5nbGVZID0gTWF0aC5hdGFuKGRlbHRhLnkpO1xuICAgICAgICBjb25zdCBhbmdsZVogPSBNYXRoLmF0YW4oZGVsdGEueik7XG4gICAgICAgIHJldHVybiBbYW5nbGVYLCBhbmdsZVksIGFuZ2xlWl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIEV1bGFyIHJvdGF0aW9uIGZyb20gb25lIHZlY3RvciB0byBhbm90aGVyLiAgVGhpcyB3aWxsIHlvdVxuICAgICAqIHRoZSBhbmdsZSBkZWx0YSBiZXR3ZWVuIHRoZSB0d28uXG4gICAgICpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbGV0IGV1bGFyVmVjdG9yID0gVmVjdG9yLmdldEV1bGFyUm90YXRpb24ob3JpZ2luLCB0YXJnZXQpO1xuICAgICAqIGV1bGFyVmVjdG9yLnggLy8gZGVncmVlcyBpbiB4IHJvdGF0aW9uXG4gICAgICogZXVsYXJWZWN0b3IueSAvLyBkZWdyZWVzIGluIHkgcm90YXRpb25cbiAgICAgKiBldWxhclZlY3Rvci56IC8vIGRlZ3JlZXMgaW4geiByb3RhdGlvblxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpblZlY3RvclxuICAgICAqIEBwYXJhbSB0YXJnZXRWZWN0b3JcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RXVsYXJSb3RhdGlvblRvKG9yaWdpblZlY3RvciwgdGFyZ2V0VmVjdG9yKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgdmVjdG9yIGFuZCB0YXJnZXQgYXMgdGhlIGJhc2lzLlxuICAgICAgICBjb25zdCBkZWx0YSA9IG9yaWdpblZlY3RvclxuICAgICAgICAgICAgLmNsb25lKClcbiAgICAgICAgICAgIC5ub3JtYWxpemUoKVxuICAgICAgICAgICAgLnN1YnRyYWN0KHRhcmdldFZlY3Rvci5jbG9uZSgpLm5vcm1hbGl6ZSgpKTtcbiAgICAgICAgY29uc3QgYW5nbGVYID0gLU1hdGguYXRhbihkZWx0YS54KTtcbiAgICAgICAgY29uc3QgYW5nbGVZID0gTWF0aC5hdGFuKGRlbHRhLnkpO1xuICAgICAgICBjb25zdCBhbmdsZVogPSAtTWF0aC5hdGFuKGRlbHRhLnopO1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihtYXRoZl8xLm1hdGhmLnJhZGlhblRvRGVncmVlKGFuZ2xlWCksIG1hdGhmXzEubWF0aGYucmFkaWFuVG9EZWdyZWUoYW5nbGVZKSwgbWF0aGZfMS5tYXRoZi5yYWRpYW5Ub0RlZ3JlZShhbmdsZVopKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGlzIHZlY3RvciB0byBhbm90aGVyLlxuICAgICAqL1xuICAgIGFkZCh2KSB7XG4gICAgICAgIHRoaXMueCArPSB2Lng7XG4gICAgICAgIHRoaXMueSArPSB2Lnk7XG4gICAgICAgIHRoaXMueiArPSB2LnogfHwgMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0YXRpYyBhZGQodjIsIHYxKSB7XG4gICAgICAgIGNvbnN0IHggPSB2Mi54ICsgdjEueDtcbiAgICAgICAgY29uc3QgeSA9IHYyLnkgKyB2MS55O1xuICAgICAgICBjb25zdCB6ID0gdjIueiArIHYxLno7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHgsIHksIHopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0aGlzIHZlY3RvciBmcm9tIGFub3RoZXIgLlxuICAgICAqL1xuICAgIHN1YnRyYWN0KHYpIHtcbiAgICAgICAgdGhpcy54IC09IHYueDtcbiAgICAgICAgdGhpcy55IC09IHYueTtcbiAgICAgICAgdGhpcy56IC09IHYueiB8fCAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdGhpcyB2ZWN0b3IgZnJvbSBhbm90aGVyIGFuZCBjcmVhdGUgYSBuZXcgdmVjdG9yLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdWJ0cmFjdCh2MiwgdjEpIHtcbiAgICAgICAgY29uc3QgeCA9IHYyLnggLSB2MS54O1xuICAgICAgICBjb25zdCB5ID0gdjIueSAtIHYxLnk7XG4gICAgICAgIGNvbnN0IHogPSB2Mi56IC0gdjEuejtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoeCwgeSwgeik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHRoaXMgdmVjdG9yIHdpdGggYW5vdGhlci5cbiAgICAgKi9cbiAgICBtdWx0aXBseSh2KSB7XG4gICAgICAgIHRoaXMueCAqPSB2Lng7XG4gICAgICAgIHRoaXMueSAqPSB2Lnk7XG4gICAgICAgIHRoaXMueiAqPSB2LnogfHwgMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpdmlkZSB0aGlzIHZlY3RvciB3aXRoIGFub3RoZXIuXG4gICAgICovXG4gICAgZGl2aWRlKHYpIHtcbiAgICAgICAgdGhpcy54IC89IHYueDtcbiAgICAgICAgdGhpcy55IC89IHYueTtcbiAgICAgICAgdGhpcy56IC89IHYueiB8fCAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NhbGVzIHRoaXMgdmVjdG9yIGJ5IHRoZSBnaXZlbiBzY2FsYXIgdmFsdWUuXG4gICAgICovXG4gICAgc2NhbGUoc2NhbGFyKSB7XG4gICAgICAgIGlmIChpc0Zpbml0ZShzY2FsYXIpKSB7XG4gICAgICAgICAgICB0aGlzLnggKj0gc2NhbGFyO1xuICAgICAgICAgICAgdGhpcy55ICo9IHNjYWxhcjtcbiAgICAgICAgICAgIHRoaXMueiAqPSBzY2FsYXI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IuWkVSTztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBOZWdhdGUgdGhpcyB2ZWN0b3IgYXMgYSAzZCB2ZWN0b3IuXG4gICAgICovXG4gICAgbmVnYXRlKCkge1xuICAgICAgICB0aGlzLnggPSAtdGhpcy54O1xuICAgICAgICB0aGlzLnkgPSAtdGhpcy55O1xuICAgICAgICB0aGlzLnogPSBtYXRoZl8xLm1hdGhmLmFic1plcm8oLXRoaXMueik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGF0aWMgbmVnYXRlKHYpIHtcbiAgICAgICAgY29uc3QgeCA9IC12Lng7XG4gICAgICAgIGNvbnN0IHkgPSAtdi55O1xuICAgICAgICBjb25zdCB6ID0gbWF0aGZfMS5tYXRoZi5hYnNaZXJvKC12LnopO1xuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih4LCB5LCB6KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgYW5vdGhlci5cbiAgICAgKiBAcmV0dXJuIFRoZSBkaXN0YW5jZSBmcm9tIHRoaXMgdmVjdG9yIHRvIGFub3RoZXJcbiAgICAgKi9cbiAgICBkaXN0YW5jZSh2KSB7XG4gICAgICAgIGNvbnN0IGR4ID0gdi54IC0gdGhpcy54O1xuICAgICAgICBjb25zdCBkeSA9IHYueSAtIHRoaXMueTtcbiAgICAgICAgY29uc3QgZHogPSB2LnogLSB0aGlzLnogfHwgMDtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggLyBtYWduaXR1ZGUgb2YgdGhpcyB2ZWN0b3IuXG4gICAgICovXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy54O1xuICAgICAgICBjb25zdCB5ID0gdGhpcy55O1xuICAgICAgICBjb25zdCB6ID0gdGhpcy56O1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBzcXVhcmVkXG4gICAgICovXG4gICAgbGVuZ3RoU3F1YXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbWFnbml0dWRlIG9mIHRoaXMgdmVjdG9yLlxuICAgICAqIEFsaWFzIG9mIFtbVmVjdG9yLmxlbmd0aF1dXG4gICAgICovXG4gICAgbWFnbml0dWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGgoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyB0aGlzIHZlY3Rvci5cbiAgICAgKi9cbiAgICBub3JtYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLng7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLnk7XG4gICAgICAgIGNvbnN0IHogPSB0aGlzLno7XG4gICAgICAgIGxldCBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG4gICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgICAgICB0aGlzLnggPSB4ICogbGVuO1xuICAgICAgICAgICAgdGhpcy55ID0geSAqIGxlbjtcbiAgICAgICAgICAgIHRoaXMueiA9IHogKiBsZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgVmVjdG9yIGFuZCB0aGUgZ2l2ZW4gdmVjdG9yLlxuICAgICAqIEByZXR1cm4gVGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgdmVjdG9yIGFuZCBwcm92aWRlZCB2ZWN0b3IuXG4gICAgICovXG4gICAgZG90KHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcbiAgICB9XG4gICAgY3Jvc3Modikge1xuICAgICAgICBjb25zdCBheCA9IHRoaXMueDtcbiAgICAgICAgY29uc3QgYXkgPSB0aGlzLnk7XG4gICAgICAgIGNvbnN0IGF6ID0gdGhpcy56O1xuICAgICAgICBjb25zdCBieCA9IHYueDtcbiAgICAgICAgY29uc3QgYnkgPSB2Lnk7XG4gICAgICAgIGNvbnN0IGJ6ID0gdi56O1xuICAgICAgICB0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgICAgICAgdGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG4gICAgICAgIHRoaXMueiA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIHRoaXMgdmVjdG9yIGdpdmVuIHRoZSBwcm92aWRlZCBtYXRyaXg0LlxuICAgICAqL1xuICAgIHRyYW5zZm9ybVdpdGhNYXRyaXhJVihtYXRyaXgpIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMueDtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMueTtcbiAgICAgICAgY29uc3QgeiA9IHRoaXMuejtcbiAgICAgICAgY29uc3QgbWF0ID0gbWF0cml4LnZhbHVlO1xuICAgICAgICBjb25zdCB0eCA9IHggKiBtYXRbMF0gKyB5ICogbWF0WzRdICsgeiAqIG1hdFs4XSArIG1hdFsxMl07XG4gICAgICAgIGNvbnN0IHR5ID0geCAqIG1hdFsxXSArIHkgKiBtYXRbNV0gKyB6ICogbWF0WzldICsgbWF0WzEzXTtcbiAgICAgICAgY29uc3QgdHogPSB4ICogbWF0WzJdICsgeSAqIG1hdFs2XSArIHogKiBtYXRbMTBdICsgbWF0WzE0XTtcbiAgICAgICAgbGV0IHR3ID0geCAqIG1hdFszXSArIHkgKiBtYXRbN10gKyB6ICogbWF0WzExXSArIG1hdFsxNV07XG4gICAgICAgIHR3ID0gdHcgfHwgMS4wO1xuICAgICAgICB0aGlzLnggPSB0eCAvIHR3O1xuICAgICAgICB0aGlzLnkgPSB0eSAvIHR3O1xuICAgICAgICB0aGlzLnogPSB0eiAvIHR3O1xuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMueSwgdGhpcy56KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIHRoZSBjdXJyZW50IHZlY3RvciB3aXRoIHRoZSBwcm92aWRlZCBtYXRyaXg0IHRvIGFcbiAgICAgKiAyZC4gIFRoaXMgZWZmZWN0aXZlbHkgdGFrZXMgdGhpcyAzZCB2ZWN0b3IgYW5kIG1ha2VzIGl0IGludG9cbiAgICAgKiB0aGUgY29vcmVzcG9uZGluZyAyZCBjb29yZGluYXRlcyB1c2luZyB0aGUgdHJhbnNmb3JtTWF0cml4LlxuICAgICAqXG4gICAgICogVGhpcyBvcGVyYXRpb24gaXMgdGhlIHNhbWUgYXMgdHJhbnNmb3JtV2l0aE1hdHJpeElWIGV4Y2VwdCB0aGVcbiAgICAgKiB6IGlzIGRyb3BwZWQuXG4gICAgICogQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIHRyYW5zZm9ybVdpdGhNYXRyaXhJVlRvMmQobWF0cml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVdpdGhNYXRyaXhJVihtYXRyaXgpLnNldCh0aGlzLngsIHRoaXMueSwgMCk7XG4gICAgfVxuICAgIC8vIC8qKlxuICAgIC8vICAqIEFkZHMgYSAzZCByb3RhdGlvbi4gIFRoaXMgaXMgTk9UIGEgcm90YXRpb24gYmFzZWQgb24gdGhlIGNlbnRlciBvZiB0aGVcbiAgICAvLyAgKiB0aGlzIHZlY3RvciBidXQgYmFzZWQgZnJvbSBWRUNUT1IuWkVSTy4gIChzbyBhZGRpbmcgYSByb3RhdGlvbiB3aWxsIG1vdmVcbiAgICAvLyAgKiB0aGUgcG9zaXRpb24gbm90IHRoZSBkaXJlY3Rpb24gaXQncyBsb29raW5nKS5cbiAgICAvLyAgKiBodHRwczovL2lrZXJ5b3UuaGF0ZW5hYmxvZy5jb20vZW50cnkvMjAxOC8wMS8wNy8xMDQ3MjlcbiAgICAvLyAgKiBAcGFyYW0gdlxuICAgIC8vICAqIEBwYXJhbSBhbmdsZSBBbmdsZSBpbiByYWRpYW5zLlxuICAgIC8vICAqIFRPRE8gKHV4ZGVyKTogTWF5YmUgbW92ZSB0byB2ZWN0b3ItZG9tIGluc3RlYWQ/XG4gICAgLy8gICovXG4gICAgLy8gcm90YXRlWChhbmdsZTogbnVtYmVyKSB7XG4gICAgLy8gICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAvLyAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIC8vICAgICB0aGlzLnkgPSB0aGlzLnkgKiBjb3MgLSB0aGlzLnogKiBzaW47XG4gICAgLy8gICAgIHRoaXMueiA9IHRoaXMueiAqIGNvcyArIHRoaXMueSAqIHNpbjtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXM7XG4gICAgLy8gfVxuICAgIC8vIC8qKlxuICAgIC8vICAqIEFkZHMgYSAzZCByb3RhdGlvbi4gIFRoaXMgaXMgTk9UIGEgcm90YXRpb24gYmFzZWQgb24gdGhlIGNlbnRlciBvZiB0aGVcbiAgICAvLyAgKiB0aGlzIHZlY3RvciBidXQgYmFzZWQgZnJvbSBWRUNUT1IuWkVSTy4gIChzbyBhZGRpbmcgYSByb3RhdGlvbiB3aWxsIG1vdmVcbiAgICAvLyAgKiB0aGUgcG9zaXRpb24gbm90IHRoZSBkaXJlY3Rpb24gaXQncyBsb29raW5nKS5cbiAgICAvLyAgKiBodHRwczovL2lrZXJ5b3UuaGF0ZW5hYmxvZy5jb20vZW50cnkvMjAxOC8wMS8wNy8xMDQ3MjlcbiAgICAvLyAgKiBAcGFyYW0gdlxuICAgIC8vICAqIEBwYXJhbSBhbmdsZSBBbmdsZSBpbiByYWRpYW5zLlxuICAgIC8vICAqIFRPRE8gKHV4ZGVyKTogTWF5YmUgbW92ZSB0byB2ZWN0b3ItZG9tIGluc3RlYWQ/XG4gICAgLy8gICovXG4gICAgLy8gcm90YXRlWShhbmdsZTogbnVtYmVyKSB7XG4gICAgLy8gICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAvLyAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIC8vICAgICB0aGlzLnggPSB0aGlzLnggKiBjb3MgLSB0aGlzLnogKiBzaW47XG4gICAgLy8gICAgIHRoaXMueiA9IHRoaXMueiAqIGNvcyArIHRoaXMueCAqIHNpbjtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXM7XG4gICAgLy8gfVxuICAgIC8vIC8qKlxuICAgIC8vICAqIEFkZHMgYSAzZCByb3RhdGlvbi4gIFRoaXMgaXMgTk9UIGEgcm90YXRpb24gYmFzZWQgb24gdGhlIGNlbnRlciBvZiB0aGVcbiAgICAvLyAgKiB0aGlzIHZlY3RvciBidXQgYmFzZWQgZnJvbSBWRUNUT1IuWkVSTy4gIChzbyBhZGRpbmcgYSByb3RhdGlvbiB3aWxsIG1vdmVcbiAgICAvLyAgKiB0aGUgcG9zaXRpb24gbm90IHRoZSBkaXJlY3Rpb24gaXQncyBsb29raW5nKS5cbiAgICAvLyAgKiBodHRwczovL2lrZXJ5b3UuaGF0ZW5hYmxvZy5jb20vZW50cnkvMjAxOC8wMS8wNy8xMDQ3MjlcbiAgICAvLyAgKiBAcGFyYW0gdlxuICAgIC8vICAqIEBwYXJhbSBhbmdsZSBBbmdsZSBpbiByYWRpYW5zLlxuICAgIC8vICAqIFRPRE8gKHV4ZGVyKTogTWF5YmUgbW92ZSB0byB2ZWN0b3ItZG9tIGluc3RlYWQ/XG4gICAgLy8gICovXG4gICAgLy8gcm90YXRlWihhbmdsZTogbnVtYmVyKSB7XG4gICAgLy8gICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAvLyAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIC8vICAgICB0aGlzLnggPSB0aGlzLnggKiBjb3MgLSB0aGlzLnkgKiBzaW47XG4gICAgLy8gICAgIHRoaXMueSA9IHRoaXMueSAqIGNvcyArIHRoaXMueCAqIHNpbjtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXM7XG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqIExpbmVhciBpbnRlcnBvbGF0ZXMgdGhpcyB2ZWN0b3IgVE9XQVJEUyB0aGUgcHJvdmlkZWQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSB2XG4gICAgICogQHBhcmFtIHByb2dyZXNzIEEgbnVtYmVyIGJldHdlZW4gMC0xLlxuICAgICAqL1xuICAgIGxlcnAodiwgcHJvZ3Jlc3MgPSAwKSB7XG4gICAgICAgIHRoaXMueCA9IG1hdGhmXzEubWF0aGYubGVycCh0aGlzLngsIHYueCwgcHJvZ3Jlc3MpO1xuICAgICAgICB0aGlzLnkgPSBtYXRoZl8xLm1hdGhmLmxlcnAodGhpcy55LCB2LnksIHByb2dyZXNzKTtcbiAgICAgICAgdGhpcy56ID0gbWF0aGZfMS5tYXRoZi5sZXJwKHRoaXMueiwgdi56LCBwcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIGxlcnAgYnV0IHVzZXMgZXhwb25lbnRpYWwgZGVjYXkuICAgVXNlZnVsIHRvXG4gICAgICogc21vb3RoIG91dCBhbmltYXRpb25zIHdpdGggZGFtcGluZy5cbiAgICAgKiBAcGFyYW0gdlxuICAgICAqIEBwYXJhbSBwcm9ncmVzcyBBIG51bWJlciBiZXR3ZWVuIDAtMS5cbiAgICAgKi9cbiAgICBkYW1wKHYsIHByb2dyZXNzID0gMCwgZGFtcCkge1xuICAgICAgICB0aGlzLnggPSBtYXRoZl8xLm1hdGhmLmRhbXAodGhpcy54LCB2LngsIHByb2dyZXNzLCBkYW1wKTtcbiAgICAgICAgdGhpcy55ID0gbWF0aGZfMS5tYXRoZi5kYW1wKHRoaXMueSwgdi55LCBwcm9ncmVzcywgZGFtcCk7XG4gICAgICAgIHRoaXMueiA9IG1hdGhmXzEubWF0aGYuZGFtcCh0aGlzLnosIHYueiwgcHJvZ3Jlc3MsIGRhbXApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRWFzZSBpbnRlcnBvbGF0ZXMgdGhpcyB2ZWN0b3IgVE9XQVJEUyB0aGUgcHJvdmlkZWQgdmVjdG9yLlxuICAgICAqIEBwYXJhbSB2XG4gICAgICogQHBhcmFtIHByb2dyZXNzIEEgbnVtYmVyIGJldHdlZW4gMC0xLlxuICAgICAqIEBwYXJhbSBlYXNlRnVuY3Rpb24gQW4gZWFzaW5nIGZ1bmN0aW9uLiBTZWUgW1ttYXRoZi5lYXNlXV0uXG4gICAgICovXG4gICAgZWFzZSh2LCBwcm9ncmVzcyA9IDAsIGVhc2VGdW5jdGlvbiA9IGVhc2VfMS5FQVNFLmxpbmVhcikge1xuICAgICAgICB0aGlzLnggPSBtYXRoZl8xLm1hdGhmLmVhc2UodGhpcy54LCB2LngsIHByb2dyZXNzLCBlYXNlRnVuY3Rpb24pO1xuICAgICAgICB0aGlzLnkgPSBtYXRoZl8xLm1hdGhmLmVhc2UodGhpcy55LCB2LnksIHByb2dyZXNzLCBlYXNlRnVuY3Rpb24pO1xuICAgICAgICB0aGlzLnogPSBtYXRoZl8xLm1hdGhmLmVhc2UodGhpcy56LCB2LnosIHByb2dyZXNzLCBlYXNlRnVuY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRWFzZSBpbnRlcnBvbGF0ZXMgYW5kIGVhc2VzIDEgdmVjdG9yIHRvd2FyZHMgYW5vdGhlci5cbiAgICAgKiBAcGFyYW0gdjEgc3RhcnRWZWN0b3JcbiAgICAgKiBAcGFyYW0gdjIgZW5kVmVjdG9yXG4gICAgICogQHBhcmFtIHByb2dyZXNzXG4gICAgICogQHBhcmFtIGVhc2VGdW5jdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBlYXNlKHYxLCB2MiwgcHJvZ3Jlc3MgPSAwLCBlYXNlRnVuY3Rpb24gPSBlYXNlXzEuRUFTRS5saW5lYXIpIHtcbiAgICAgICAgY29uc3QgeCA9IG1hdGhmXzEubWF0aGYuZWFzZSh2MS54LCB2Mi54LCBwcm9ncmVzcywgZWFzZUZ1bmN0aW9uKTtcbiAgICAgICAgY29uc3QgeSA9IG1hdGhmXzEubWF0aGYuZWFzZSh2MS55LCB2Mi55LCBwcm9ncmVzcywgZWFzZUZ1bmN0aW9uKTtcbiAgICAgICAgY29uc3QgeiA9IG1hdGhmXzEubWF0aGYuZWFzZSh2MS56LCB2Mi56LCBwcm9ncmVzcywgZWFzZUZ1bmN0aW9uKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoeCwgeSwgeik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIHZlY3RvciBhIGFuZCB2ZWN0b3IgYiwgdGFrZXMgdGhlIE1hdGgubWluIHZhbHVlcyBvZiB4LHkseiBhbmRcbiAgICAgKiByZXR1cm5zIGEgbmV3IFZlY3Rvci5cbiAgICAgKiBAcGFyYW0gYSBWZWN0b3IgQVxuICAgICAqIEBwYXJhbSBiIFZlY3RvciBCXG4gICAgICovXG4gICAgc3RhdGljIG1pbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKE1hdGgubWluKGEueCwgYi54KSwgTWF0aC5taW4oYS55LCBiLnkpLCBNYXRoLm1pbihhLnosIGIueikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiB2ZWN0b3IgYSBhbmQgdmVjdG9yIGIsIHRha2VzIHRoZSBNYXRoLm1heCB2YWx1ZXMgb2YgeCx5LHogYW5kXG4gICAgICogcmV0dXJucyBhIG5ldyBWZWN0b3IuXG4gICAgICogQHBhcmFtIGEgVmVjdG9yIEFcbiAgICAgKiBAcGFyYW0gYiBWZWN0b3IgQlxuICAgICAqL1xuICAgIHN0YXRpYyBtYXgoYSwgYikge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihNYXRoLm1heChhLngsIGIueCksIE1hdGgubWF4KGEueSwgYi55KSwgTWF0aC5tYXgoYS56LCBiLnopKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBWZWN0b3Igc3RvcmluZyBFdWxlciBkZWdyZWVzLCBjb252ZXJ0cyBpdCB0byByYWRpYW5zLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBsZXQgZXVsZXJWZWN0b3IgPSBuZXcgVmVjdG9yKDkwLCAxODAsIDApO1xuICAgICAqIGxldCByYWRpYW5WZWN0b3IgPSBWZWN0b3IuZXVsZXJWZWN0b3JUb1JhZGlhbnMoZXVsZXJWZWN0b3IpO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGRlZ3JlZVRvUmFkaWFucyh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKG1hdGhmXzEubWF0aGYuZGVncmVlVG9SYWRpYW4odi54KSwgbWF0aGZfMS5tYXRoZi5kZWdyZWVUb1JhZGlhbih2LnkpLCBtYXRoZl8xLm1hdGhmLmRlZ3JlZVRvUmFkaWFuKHYueikpO1xuICAgIH1cbiAgICBkZWdyZWVUb1JhZGlhbnMoKSB7XG4gICAgICAgIHJldHVybiBWZWN0b3IuZGVncmVlVG9SYWRpYW5zKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgYSBnaXZlbiB2ZWN0b3IgYmV0d2VlbiBhIG1pbiBhbmQgbWF4IHZlY3Rvci5cbiAgICAgKiBAcGFyYW0gbWluIFRoZSBtaW4gdmVjdG9yXG4gICAgICogQHBhcmFtIG1heCBUaGUgbWF4IHZlY3RvclxuICAgICAqIEBwYXJhbSB2ZWN0b3IgVGhlIHZlY3RvciB0byBjbGFtcFxuICAgICAqL1xuICAgIHN0YXRpYyBjbGFtcChtaW4sIG1heCwgdmVjdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKG1hdGhmXzEubWF0aGYuY2xhbXAobWluLngsIG1heC54LCB2ZWN0b3IueCksIG1hdGhmXzEubWF0aGYuY2xhbXAobWluLnksIG1heC55LCB2ZWN0b3IueSksIG1hdGhmXzEubWF0aGYuY2xhbXAobWluLnosIG1heC56LCB2ZWN0b3IueikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgRXVsYXIgdmVjdG9yIGZyb20gYSByb3RhdGlvbmFsTWF0cml4LiBUaGlzIGNvbnZlcnNpb24gaXMgYmV0dGVyXG4gICAgICogYXZvaWRlZCBmb3IgZGlmZmVyZW50IHJlYXNvbnMuICBUaGUgcGl0Y2ggKHkpIHdpbGwgYmUgbGltaXRlZCB0byArLTkwLlxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIGFsc28gY2FzZXMgd2hlcmUgYWNjdXJhY3kgc3VmZmVycyBzbyB1c2Ugd2l0aCBjYXV0aW9uLlxuICAgICAqXG4gICAgICogWWF3LCBSb2xsIHdpbGwgYmUgKy0xODAuXG4gICAgICogUGl0Y2ggd2lsbCBiZSArLSA5MC5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogICAvLyBFeGFtcGxlIGNvbnZlcnRzIGEgcXVhdGVybmlvbiBiYWNrIG92ZXIgdG8gZXVsZXIuXG4gICAgICogICBsZXQgcXVhdCA9IG5ldyBRdWF0ZXJuaW9uKDAuMiwgMC4yLCAwLjIsIDAuMSk7XG4gICAgICogICBsZXQgbWF0cml4ID0gTWF0cml4SVYuZnJvbVF1YXRlcm5pb24ocXVhdC5jbG9uZSgpKTtcbiAgICAgKiAgIGxldCBldWxhclZlY3RvciA9IFZlY3Rvci5mcm9tUm90YXRpb25NYXRyaXhJVihtYXRyaXgpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Sb3RhdGlvbk1hdHJpeElWKG0pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gVmVjdG9yLlpFUk87XG4gICAgICAgIGNvbnN0IHRlID0gbS52YWx1ZTtcbiAgICAgICAgY29uc3QgbTExID0gdGVbMF0sIG0xMiA9IHRlWzRdLCBtMTMgPSB0ZVs4XTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGNvbnN0IG0yMSA9IHRlWzFdLCBtMjIgPSB0ZVs1XSwgbTIzID0gdGVbOV07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBjb25zdCBtMzEgPSB0ZVsyXSwgbTMyID0gdGVbNl0sIG0zMyA9IHRlWzEwXTtcbiAgICAgICAgLy8gWFlaIG9yZGVyaW5nXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi9tYXN0ZXIvc3JjL21hdGgvRXVsZXIuanMjTDE0NlxuICAgICAgICByZXN1bHQueSA9IE1hdGguYXNpbihtYXRoZl8xLm1hdGhmLmNsYW1wKC0xLCAxLCBtMTMpKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKG0xMykgPCAwLjk5OTk5OTkpIHtcbiAgICAgICAgICAgIHJlc3VsdC54ID0gTWF0aC5hdGFuMigtbTIzLCBtMzMpO1xuICAgICAgICAgICAgcmVzdWx0LnogPSBNYXRoLmF0YW4yKC1tMTIsIG0xMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQueCA9IE1hdGguYXRhbjIobTMyLCBtMjIpO1xuICAgICAgICAgICAgcmVzdWx0LnogPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC54ID0gbWF0aGZfMS5tYXRoZi5yYWRpYW5Ub0RlZ3JlZShyZXN1bHQueCk7XG4gICAgICAgIC8vIHJlc3VsdC55ID0gbWF0aGYud3JhcChtYXRoZi5yYWRpYW5Ub0RlZ3JlZShyZXN1bHQueSksIC04OS45OTk5LCA4OS45OTk5KTtcbiAgICAgICAgcmVzdWx0LnkgPSBtYXRoZl8xLm1hdGhmLnJhZGlhblRvRGVncmVlKHJlc3VsdC55KTtcbiAgICAgICAgcmVzdWx0LnogPSBtYXRoZl8xLm1hdGhmLnJhZGlhblRvRGVncmVlKHJlc3VsdC56KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgemVybyB2ZWN0b3IuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGxldCBwb3NpdG9uID0gVmVjdG9yLlpFUk87XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGdldCBaRVJPKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAwLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgb25lIHZlY3Rvci5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbGV0IHBvc2l0b24gPSBWZWN0b3IuT05FO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgT05FKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigxLCAxLCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgcmlnaHQgdmVjdG9yIGZvciByZWZlcmVuY2UgLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBsZXQgcG9zaXRvbiA9IFZlY3Rvci5PTkU7XG4gICAgICogcG9zaXRpb24uYWRkKFZlY3Rvci5SSUdIVC5zY2FsZSg0KSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFJJR0hUKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigxLCAwLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgbGVmdCB2ZWN0b3IgZm9yIHJlZmVyZW5jZSAuXG4gICAgICovXG4gICAgc3RhdGljIGdldCBMRUZUKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigtMSwgMCwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc3RhdGljIHVwIHZlY3RvciBmb3IgcmVmZXJlbmNlIC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFVQKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAtMSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc3RhdGljIGRvd24gdmVjdG9yIGZvciByZWZlcmVuY2UgLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgRE9XTigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoMCwgMSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc3RhdGljIGZvd2FyZCB2ZWN0b3IgZm9yIHJlZmVyZW5jZSAuXG4gICAgICovXG4gICAgc3RhdGljIGdldCBGT1JXQVJEKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAwLCAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgZm93YXJkIHZlY3RvciBmb3IgcmVmZXJlbmNlIC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEJBQ0soKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDAsIDAsIC0xKTtcbiAgICB9XG59XG5leHBvcnRzLlZlY3RvciA9IFZlY3Rvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlY3Rvci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/mathf/vector.js\n");

/***/ }),

/***/ "./lib/mathf/wave.js":
/*!***************************!*\
  !*** ./lib/mathf/wave.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Wave = void 0;\n/**\n * A really simple utility class to manage sin, cos waves.\n *\n *\n * ```ts\n *\n * let myWave = new Wave(0.001);\n *\n *\n * new Raf(()=> {\n *   // Update the wave per Raf.\n *   myWave.update();\n *\n *   // Sin value\n *   console.log(myWave.sinWave);\n *   console.log(myWave.cosWave);\n *\n *   // Use the value to do calcutions.\n *   this.x += myWave.sinWave * 10;\n * }).start();\n *\n * ```\n */\nclass Wave {\n    constructor(speed) {\n        this.timer = 0;\n        this.speed = speed;\n    }\n    get sinWave() {\n        return Math.sin(this.timer);\n    }\n    get cosWave() {\n        return Math.cos(this.timer);\n    }\n    update() {\n        this.timer = this.timer + this.speed;\n    }\n}\nexports.Wave = Wave;\n//# sourceMappingURL=wave.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvbWF0aGYvd2F2ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9tYXRoZi93YXZlLmpzPzVjZGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldhdmUgPSB2b2lkIDA7XG4vKipcbiAqIEEgcmVhbGx5IHNpbXBsZSB1dGlsaXR5IGNsYXNzIHRvIG1hbmFnZSBzaW4sIGNvcyB3YXZlcy5cbiAqXG4gKlxuICogYGBgdHNcbiAqXG4gKiBsZXQgbXlXYXZlID0gbmV3IFdhdmUoMC4wMDEpO1xuICpcbiAqXG4gKiBuZXcgUmFmKCgpPT4ge1xuICogICAvLyBVcGRhdGUgdGhlIHdhdmUgcGVyIFJhZi5cbiAqICAgbXlXYXZlLnVwZGF0ZSgpO1xuICpcbiAqICAgLy8gU2luIHZhbHVlXG4gKiAgIGNvbnNvbGUubG9nKG15V2F2ZS5zaW5XYXZlKTtcbiAqICAgY29uc29sZS5sb2cobXlXYXZlLmNvc1dhdmUpO1xuICpcbiAqICAgLy8gVXNlIHRoZSB2YWx1ZSB0byBkbyBjYWxjdXRpb25zLlxuICogICB0aGlzLnggKz0gbXlXYXZlLnNpbldhdmUgKiAxMDtcbiAqIH0pLnN0YXJ0KCk7XG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIFdhdmUge1xuICAgIGNvbnN0cnVjdG9yKHNwZWVkKSB7XG4gICAgICAgIHRoaXMudGltZXIgPSAwO1xuICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgfVxuICAgIGdldCBzaW5XYXZlKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zaW4odGhpcy50aW1lcik7XG4gICAgfVxuICAgIGdldCBjb3NXYXZlKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jb3ModGhpcy50aW1lcik7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy50aW1lciA9IHRoaXMudGltZXIgKyB0aGlzLnNwZWVkO1xuICAgIH1cbn1cbmV4cG9ydHMuV2F2ZSA9IFdhdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YXZlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/mathf/wave.js\n");

/***/ }),

/***/ "./lib/objectf/objectf.js":
/*!********************************!*\
  !*** ./lib/objectf/objectf.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.objectf = void 0;\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst arrayf_1 = __webpack_require__(/*! ../arrayf/arrayf */ \"./lib/arrayf/arrayf.js\");\n/**\n * A class that helps with objects.\n */\nclass objectf {\n    /**\n     * Deep copies an object by looping through it.\n     * @alias arrayf.deepcopy.\n     */\n    static deepCopy(input) {\n        return arrayf_1.arrayf.deepCopy(input);\n    }\n    /**\n     * A quick JSON parse, stringify based copy.\n     * This is fast but will destroy functions, Date etc so\n     * has limited usage.\n     * @param object\n     */\n    static jsonCopy(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    /**\n     * A shallow 1 level equality check of objects.\n     * @param a\n     * @param b\n     */\n    static areEqual(a, b) {\n        const aProps = Object.getOwnPropertyNames(a);\n        const bProps = Object.getOwnPropertyNames(b);\n        // If the length of object isn't equal, we know they are equal.\n        if (aProps.length !== bProps.length) {\n            return false;\n        }\n        for (let i = 0; i < aProps.length; i++) {\n            const propName = aProps[i];\n            if (a[propName] !== b[propName]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Copies an object (shallow).\n     * @param object\n     */\n    static copy(obj) {\n        return Object.assign({}, obj);\n    }\n    /**\n     *\n     * ```\n     * objectf.forEach(myObject, (key:string, value:any)=> {\n     *\n     * })\n     * ```\n     * @param callback\n     */\n    static forEach(obj, callback) {\n        Object.entries(obj).forEach(([key, value]) => {\n            callback(key, value);\n        });\n    }\n}\nexports.objectf = objectf;\n/* eslint-enable */\n//# sourceMappingURL=objectf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvb2JqZWN0Zi9vYmplY3RmLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL29iamVjdGYvb2JqZWN0Zi5qcz82NGRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vYmplY3RmID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3QgYXJyYXlmXzEgPSByZXF1aXJlKFwiLi4vYXJyYXlmL2FycmF5ZlwiKTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGhlbHBzIHdpdGggb2JqZWN0cy5cbiAqL1xuY2xhc3Mgb2JqZWN0ZiB7XG4gICAgLyoqXG4gICAgICogRGVlcCBjb3BpZXMgYW4gb2JqZWN0IGJ5IGxvb3BpbmcgdGhyb3VnaCBpdC5cbiAgICAgKiBAYWxpYXMgYXJyYXlmLmRlZXBjb3B5LlxuICAgICAqL1xuICAgIHN0YXRpYyBkZWVwQ29weShpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlmXzEuYXJyYXlmLmRlZXBDb3B5KGlucHV0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBxdWljayBKU09OIHBhcnNlLCBzdHJpbmdpZnkgYmFzZWQgY29weS5cbiAgICAgKiBUaGlzIGlzIGZhc3QgYnV0IHdpbGwgZGVzdHJveSBmdW5jdGlvbnMsIERhdGUgZXRjIHNvXG4gICAgICogaGFzIGxpbWl0ZWQgdXNhZ2UuXG4gICAgICogQHBhcmFtIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBqc29uQ29weShvYmopIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc2hhbGxvdyAxIGxldmVsIGVxdWFsaXR5IGNoZWNrIG9mIG9iamVjdHMuXG4gICAgICogQHBhcmFtIGFcbiAgICAgKiBAcGFyYW0gYlxuICAgICAqL1xuICAgIHN0YXRpYyBhcmVFcXVhbChhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFQcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGEpO1xuICAgICAgICBjb25zdCBiUHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiKTtcbiAgICAgICAgLy8gSWYgdGhlIGxlbmd0aCBvZiBvYmplY3QgaXNuJ3QgZXF1YWwsIHdlIGtub3cgdGhleSBhcmUgZXF1YWwuXG4gICAgICAgIGlmIChhUHJvcHMubGVuZ3RoICE9PSBiUHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gYVByb3BzW2ldO1xuICAgICAgICAgICAgaWYgKGFbcHJvcE5hbWVdICE9PSBiW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIGFuIG9iamVjdCAoc2hhbGxvdykuXG4gICAgICogQHBhcmFtIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBjb3B5KG9iaikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBvYmplY3RmLmZvckVhY2gobXlPYmplY3QsIChrZXk6c3RyaW5nLCB2YWx1ZTphbnkpPT4ge1xuICAgICAqXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBzdGF0aWMgZm9yRWFjaChvYmosIGNhbGxiYWNrKSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG9iaikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayhrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5vYmplY3RmID0gb2JqZWN0Zjtcbi8qIGVzbGludC1lbmFibGUgKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdGYuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/objectf/objectf.js\n");

/***/ }),

/***/ "./lib/pseudo-3d-canvas/camera.js":
/*!****************************************!*\
  !*** ./lib/pseudo-3d-canvas/camera.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Camera = void 0;\nconst vector_1 = __webpack_require__(/*! ../mathf/vector */ \"./lib/mathf/vector.js\");\n/**\n * @unstable\n */\nclass Camera {\n    constructor() {\n        this.position = vector_1.Vector.ZERO;\n        this.target = vector_1.Vector.ZERO;\n    }\n}\nexports.Camera = Camera;\n//# sourceMappingURL=camera.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvcHNldWRvLTNkLWNhbnZhcy9jYW1lcmEuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvcHNldWRvLTNkLWNhbnZhcy9jYW1lcmEuanM/YWUzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FtZXJhID0gdm9pZCAwO1xuY29uc3QgdmVjdG9yXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvdmVjdG9yXCIpO1xuLyoqXG4gKiBAdW5zdGFibGVcbiAqL1xuY2xhc3MgQ2FtZXJhIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHZlY3Rvcl8xLlZlY3Rvci5aRVJPO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHZlY3Rvcl8xLlZlY3Rvci5aRVJPO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FtZXJhID0gQ2FtZXJhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FtZXJhLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/pseudo-3d-canvas/camera.js\n");

/***/ }),

/***/ "./lib/pseudo-3d-canvas/mesh.js":
/*!**************************************!*\
  !*** ./lib/pseudo-3d-canvas/mesh.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CubeMesh = exports.Mesh = exports.MeshTypes = void 0;\nconst vector_1 = __webpack_require__(/*! ../mathf/vector */ \"./lib/mathf/vector.js\");\nconst matrixIV_1 = __webpack_require__(/*! ../mathf/matrixIV */ \"./lib/mathf/matrixIV.js\");\nvar MeshTypes;\n(function (MeshTypes) {\n    MeshTypes[\"CUBE\"] = \"cube\";\n})(MeshTypes = exports.MeshTypes || (exports.MeshTypes = {}));\n/**\n * @unstable\n */\nclass Mesh {\n    /**\n     * @param verticesCount The number of vertices this mesh should contain.\n     */\n    constructor() {\n        this.name = '';\n        this.vertices = [];\n        this.position = vector_1.Vector.ZERO;\n        this.rotation = vector_1.Vector.ZERO;\n        this.up = vector_1.Vector.ZERO;\n        this.right = vector_1.Vector.ZERO;\n        this.forward = vector_1.Vector.ZERO;\n        this.basisMatrix = matrixIV_1.MatrixIV.IDENTITY;\n        this.color = 'green';\n    }\n    // eslint-disable-next-line\n    size(width, height, depth) {\n        this.up = new vector_1.Vector(0, width, 0);\n        this.right = new vector_1.Vector(height, 0, 0);\n        this.forward = vector_1.Vector.ONE.cross(this.up);\n        // Generate a basis matrix.\n        const basisMatrix = new matrixIV_1.MatrixIV();\n        basisMatrix.setVectorColumn(0, this.right);\n        basisMatrix.setVectorColumn(1, this.up);\n        basisMatrix.setVectorColumn(2, this.forward);\n        this.basisMatrix = basisMatrix;\n    }\n}\nexports.Mesh = Mesh;\n/**\n * Creates a CubeMesh.\n */\nclass CubeMesh extends Mesh {\n    constructor() {\n        super();\n        this.name = MeshTypes.CUBE;\n        this.vertices = [\n            new vector_1.Vector(-1, 1, 1),\n            new vector_1.Vector(1, 1, 1),\n            new vector_1.Vector(-1, -1, 1),\n            new vector_1.Vector(-1, -1, -1),\n            new vector_1.Vector(-1, 1, -1),\n            new vector_1.Vector(1, 1, -1),\n            new vector_1.Vector(1, -1, 1),\n            new vector_1.Vector(1, -1, -1),\n        ];\n    }\n}\nexports.CubeMesh = CubeMesh;\n//# sourceMappingURL=mesh.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvcHNldWRvLTNkLWNhbnZhcy9tZXNoLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3BzZXVkby0zZC1jYW52YXMvbWVzaC5qcz84MGNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DdWJlTWVzaCA9IGV4cG9ydHMuTWVzaCA9IGV4cG9ydHMuTWVzaFR5cGVzID0gdm9pZCAwO1xuY29uc3QgdmVjdG9yXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvdmVjdG9yXCIpO1xuY29uc3QgbWF0cml4SVZfMSA9IHJlcXVpcmUoXCIuLi9tYXRoZi9tYXRyaXhJVlwiKTtcbnZhciBNZXNoVHlwZXM7XG4oZnVuY3Rpb24gKE1lc2hUeXBlcykge1xuICAgIE1lc2hUeXBlc1tcIkNVQkVcIl0gPSBcImN1YmVcIjtcbn0pKE1lc2hUeXBlcyA9IGV4cG9ydHMuTWVzaFR5cGVzIHx8IChleHBvcnRzLk1lc2hUeXBlcyA9IHt9KSk7XG4vKipcbiAqIEB1bnN0YWJsZVxuICovXG5jbGFzcyBNZXNoIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmVydGljZXNDb3VudCBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRoaXMgbWVzaCBzaG91bGQgY29udGFpbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJyc7XG4gICAgICAgIHRoaXMudmVydGljZXMgPSBbXTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHZlY3Rvcl8xLlZlY3Rvci5aRVJPO1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gdmVjdG9yXzEuVmVjdG9yLlpFUk87XG4gICAgICAgIHRoaXMudXAgPSB2ZWN0b3JfMS5WZWN0b3IuWkVSTztcbiAgICAgICAgdGhpcy5yaWdodCA9IHZlY3Rvcl8xLlZlY3Rvci5aRVJPO1xuICAgICAgICB0aGlzLmZvcndhcmQgPSB2ZWN0b3JfMS5WZWN0b3IuWkVSTztcbiAgICAgICAgdGhpcy5iYXNpc01hdHJpeCA9IG1hdHJpeElWXzEuTWF0cml4SVYuSURFTlRJVFk7XG4gICAgICAgIHRoaXMuY29sb3IgPSAnZ3JlZW4nO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBzaXplKHdpZHRoLCBoZWlnaHQsIGRlcHRoKSB7XG4gICAgICAgIHRoaXMudXAgPSBuZXcgdmVjdG9yXzEuVmVjdG9yKDAsIHdpZHRoLCAwKTtcbiAgICAgICAgdGhpcy5yaWdodCA9IG5ldyB2ZWN0b3JfMS5WZWN0b3IoaGVpZ2h0LCAwLCAwKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkID0gdmVjdG9yXzEuVmVjdG9yLk9ORS5jcm9zcyh0aGlzLnVwKTtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSBiYXNpcyBtYXRyaXguXG4gICAgICAgIGNvbnN0IGJhc2lzTWF0cml4ID0gbmV3IG1hdHJpeElWXzEuTWF0cml4SVYoKTtcbiAgICAgICAgYmFzaXNNYXRyaXguc2V0VmVjdG9yQ29sdW1uKDAsIHRoaXMucmlnaHQpO1xuICAgICAgICBiYXNpc01hdHJpeC5zZXRWZWN0b3JDb2x1bW4oMSwgdGhpcy51cCk7XG4gICAgICAgIGJhc2lzTWF0cml4LnNldFZlY3RvckNvbHVtbigyLCB0aGlzLmZvcndhcmQpO1xuICAgICAgICB0aGlzLmJhc2lzTWF0cml4ID0gYmFzaXNNYXRyaXg7XG4gICAgfVxufVxuZXhwb3J0cy5NZXNoID0gTWVzaDtcbi8qKlxuICogQ3JlYXRlcyBhIEN1YmVNZXNoLlxuICovXG5jbGFzcyBDdWJlTWVzaCBleHRlbmRzIE1lc2gge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBNZXNoVHlwZXMuQ1VCRTtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IFtcbiAgICAgICAgICAgIG5ldyB2ZWN0b3JfMS5WZWN0b3IoLTEsIDEsIDEpLFxuICAgICAgICAgICAgbmV3IHZlY3Rvcl8xLlZlY3RvcigxLCAxLCAxKSxcbiAgICAgICAgICAgIG5ldyB2ZWN0b3JfMS5WZWN0b3IoLTEsIC0xLCAxKSxcbiAgICAgICAgICAgIG5ldyB2ZWN0b3JfMS5WZWN0b3IoLTEsIC0xLCAtMSksXG4gICAgICAgICAgICBuZXcgdmVjdG9yXzEuVmVjdG9yKC0xLCAxLCAtMSksXG4gICAgICAgICAgICBuZXcgdmVjdG9yXzEuVmVjdG9yKDEsIDEsIC0xKSxcbiAgICAgICAgICAgIG5ldyB2ZWN0b3JfMS5WZWN0b3IoMSwgLTEsIDEpLFxuICAgICAgICAgICAgbmV3IHZlY3Rvcl8xLlZlY3RvcigxLCAtMSwgLTEpLFxuICAgICAgICBdO1xuICAgIH1cbn1cbmV4cG9ydHMuQ3ViZU1lc2ggPSBDdWJlTWVzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc2guanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/pseudo-3d-canvas/mesh.js\n");

/***/ }),

/***/ "./lib/pseudo-3d-canvas/pseudo-3d-canvas.js":
/*!**************************************************!*\
  !*** ./lib/pseudo-3d-canvas/pseudo-3d-canvas.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Pseudo3dCanvas = void 0;\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst matrixIV_1 = __webpack_require__(/*! ../mathf/matrixIV */ \"./lib/mathf/matrixIV.js\");\nconst vector_1 = __webpack_require__(/*! ../mathf/vector */ \"./lib/mathf/vector.js\");\nconst dom_canvas_1 = __webpack_require__(/*! ../dom/dom-canvas */ \"./lib/dom/dom-canvas.js\");\n/**\n * The main renderer for pseudo3dCanvas.\n *\n * This pseudo3dCanvas particular class, implements the model - view - perspective\n * matrices to achieve pseudo3d onto 2d canvas.\n *\n *\n * @see http://web.archive.org/web/20131222170415/http:/robertokoci.com/world-view-projection-matrix-unveiled/\n * @see https://www.davrous.com/2013/06/13/tutorial-series-learning-how-to-write-a-3d-soft-engine-from-scratch-in-c-typescript-or-javascript/\n * @see http://www.codinglabs.net/article_world_view_projection_matrix.aspx\n * @see https://solarianprogrammer.com/2013/05/22/opengl-101-matrices-projection-view-model/\n * @see https://www.3dgep.com/understanding-the-view-matrix/\n * @unstable\n */\nclass Pseudo3dCanvas {\n    constructor(config) {\n        this.canvasElement = config.canvasElement;\n        this.context = this.canvasElement.getContext('2d');\n        this.canvasElement.width = this.canvasElement.offsetWidth;\n        this.canvasElement.height = this.canvasElement.offsetHeight;\n        this.width = this.canvasElement.offsetWidth;\n        this.height = this.canvasElement.offsetHeight;\n        this.fov = mathf_1.mathf.degreeToRadian(45);\n        this.near = 1;\n        this.aspect = this.width / this.height;\n        this.far = 1000;\n        this.rotationMatrix = matrixIV_1.MatrixIV.IDENTITY;\n        this.translationMatrix = matrixIV_1.MatrixIV.IDENTITY;\n        this.viewMatrix = matrixIV_1.MatrixIV.IDENTITY;\n        this.worldMatrix = matrixIV_1.MatrixIV.IDENTITY;\n        this.transformMatrix = matrixIV_1.MatrixIV.IDENTITY;\n        this.projectionMatrix = matrixIV_1.MatrixIV.IDENTITY;\n    }\n    /**\n     * The render cycle for the pseudo-3d-canvas.\n     *\n     * Takes various 3d meshes that need to be displayed on the screen\n     * and projects them as 2d points.\n     *\n     * This takes on a world - view - projection pattern to creates a\n     * translation matrix and then applies that to each vector point.\n     *\n     *\n     * Note that this order matters.  Using OpenGL right to left multiplication:\n     *\n     * ```ts\n     *\n     * var transformMatrix = projectionMatrix * ViewMatrix * WorldMatrix;\n     * ```\n     *\n     * WorldMatrix = Takes object space to world space\n     * ViewMatrix = Camera matrix - transforms world space to camera space\n     * projectionMatrix = Near or far angle of view.\n     *\n     *\n     * http://web.archive.org/web/20131222170415/http:/robertokoci.com/world-view-projection-matrix-unveiled/\n     *\n     * @param camera\n     * @param meshes\n     */\n    render(camera, meshes) {\n        this.context.clearRect(0, 0, this.width, this.height);\n        // Loop through each mesh.\n        meshes.forEach(mesh => {\n            // This is the main view / camera matrix.\n            this.viewMatrix = new matrixIV_1.MatrixIV().lookAt(camera.position, camera.target, vector_1.Vector.UP);\n            // The main projection matrix.\n            this.projectionMatrix = new matrixIV_1.MatrixIV().perspective(this.fov, this.aspect, this.near, this.far);\n            // The main world or model matrix.  Here we are going to shift the\n            // position of the mesh based on the curren tmesh position.\n            this.translationMatrix = new matrixIV_1.MatrixIV().translate(mesh.position);\n            this.worldMatrix = matrixIV_1.MatrixIV.IDENTITY.multiply(this.translationMatrix);\n            // Create the transform matrix.\n            // ProjectMatrix * ViewMatrix * WorldMatrix\n            this.transformMatrix = this.projectionMatrix\n                .multiply(this.viewMatrix)\n                .multiply(this.worldMatrix);\n            // Now we are going to apply the transformMatrix to each\n            // vertices point in the mesh effectively projecting 3d into\n            // the 2d canvas.\n            mesh.vertices.forEach((v, i) => {\n                // Take each vector point such as 1,1 and first locally,\n                // rotate and move it's position based on the basisMatrix.\n                // The basisMatrix consists of up, right, forward vectors\n                // that define the shape of the mesh and this particular vector.\n                // Apart from the basic position (controled in worldMatrix),\n                // this locally affects the position of each vector which can\n                // be controlled by the mesh size and vector positions.\n                const rotationMatrix = new matrixIV_1.MatrixIV().ypr(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z);\n                const basisMatrix = mesh.basisMatrix.clone().multiply(rotationMatrix);\n                const transformedVector = v.clone().transformWithMatrixIV(basisMatrix);\n                // Apply the transformation to the vector.\n                // These are our final vector coordinates that are normalized\n                // where by the screen is 1x1 with the center in zero position\n                // like webGL.\n                let vector2d = transformedVector\n                    .clone()\n                    .transformWithMatrixIV(this.transformMatrix);\n                // So far the coordinate system is one based on center / center\n                // like webGL.\n                // The vector position remains normalized so we want to\n                // scale/map it to the canvas dimensions.\n                // Scale it and then shift it over half the screen width to center\n                // it.\n                let x = vector2d.x * this.width;\n                x += this.width * 0.5;\n                // Scale it and then shift it over half the screen width to center\n                // it.\n                let y = -vector2d.y * this.height;\n                y += this.height * 0.5;\n                // We get our final vector coordinates on the canvas.\n                vector2d = new vector_1.Vector(x, y).int();\n                // Check if this vector goes out of boundaries in which case,\n                // we don't need to draw it.\n                if (vector2d.x >= 0 &&\n                    vector2d.y >= 0 &&\n                    vector2d.x < this.width &&\n                    vector2d.y < this.height) {\n                    dom_canvas_1.domCanvas.setFillColor(this.context, mesh.color);\n                    dom_canvas_1.domCanvas.setStrokeColor(this.context, mesh.color);\n                    dom_canvas_1.domCanvas.vectorPoint(this.context, vector2d);\n                    dom_canvas_1.domCanvas.quickText(this.context, 'v' + i, vector2d.x, vector2d.y - 4);\n                }\n            });\n        });\n    }\n}\nexports.Pseudo3dCanvas = Pseudo3dCanvas;\n//# sourceMappingURL=pseudo-3d-canvas.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvcHNldWRvLTNkLWNhbnZhcy9wc2V1ZG8tM2QtY2FudmFzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3BzZXVkby0zZC1jYW52YXMvcHNldWRvLTNkLWNhbnZhcy5qcz80NjBmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qc2V1ZG8zZENhbnZhcyA9IHZvaWQgMDtcbmNvbnN0IG1hdGhmXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvbWF0aGZcIik7XG5jb25zdCBtYXRyaXhJVl8xID0gcmVxdWlyZShcIi4uL21hdGhmL21hdHJpeElWXCIpO1xuY29uc3QgdmVjdG9yXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvdmVjdG9yXCIpO1xuY29uc3QgZG9tX2NhbnZhc18xID0gcmVxdWlyZShcIi4uL2RvbS9kb20tY2FudmFzXCIpO1xuLyoqXG4gKiBUaGUgbWFpbiByZW5kZXJlciBmb3IgcHNldWRvM2RDYW52YXMuXG4gKlxuICogVGhpcyBwc2V1ZG8zZENhbnZhcyBwYXJ0aWN1bGFyIGNsYXNzLCBpbXBsZW1lbnRzIHRoZSBtb2RlbCAtIHZpZXcgLSBwZXJzcGVjdGl2ZVxuICogbWF0cmljZXMgdG8gYWNoaWV2ZSBwc2V1ZG8zZCBvbnRvIDJkIGNhbnZhcy5cbiAqXG4gKlxuICogQHNlZSBodHRwOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEzMTIyMjE3MDQxNS9odHRwOi9yb2JlcnRva29jaS5jb20vd29ybGQtdmlldy1wcm9qZWN0aW9uLW1hdHJpeC11bnZlaWxlZC9cbiAqIEBzZWUgaHR0cHM6Ly93d3cuZGF2cm91cy5jb20vMjAxMy8wNi8xMy90dXRvcmlhbC1zZXJpZXMtbGVhcm5pbmctaG93LXRvLXdyaXRlLWEtM2Qtc29mdC1lbmdpbmUtZnJvbS1zY3JhdGNoLWluLWMtdHlwZXNjcmlwdC1vci1qYXZhc2NyaXB0L1xuICogQHNlZSBodHRwOi8vd3d3LmNvZGluZ2xhYnMubmV0L2FydGljbGVfd29ybGRfdmlld19wcm9qZWN0aW9uX21hdHJpeC5hc3B4XG4gKiBAc2VlIGh0dHBzOi8vc29sYXJpYW5wcm9ncmFtbWVyLmNvbS8yMDEzLzA1LzIyL29wZW5nbC0xMDEtbWF0cmljZXMtcHJvamVjdGlvbi12aWV3LW1vZGVsL1xuICogQHNlZSBodHRwczovL3d3dy4zZGdlcC5jb20vdW5kZXJzdGFuZGluZy10aGUtdmlldy1tYXRyaXgvXG4gKiBAdW5zdGFibGVcbiAqL1xuY2xhc3MgUHNldWRvM2RDYW52YXMge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQgPSBjb25maWcuY2FudmFzRWxlbWVudDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXNFbGVtZW50LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudC53aWR0aCA9IHRoaXMuY2FudmFzRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LmhlaWdodCA9IHRoaXMuY2FudmFzRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhc0VsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXNFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgdGhpcy5mb3YgPSBtYXRoZl8xLm1hdGhmLmRlZ3JlZVRvUmFkaWFuKDQ1KTtcbiAgICAgICAgdGhpcy5uZWFyID0gMTtcbiAgICAgICAgdGhpcy5hc3BlY3QgPSB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuZmFyID0gMTAwMDtcbiAgICAgICAgdGhpcy5yb3RhdGlvbk1hdHJpeCA9IG1hdHJpeElWXzEuTWF0cml4SVYuSURFTlRJVFk7XG4gICAgICAgIHRoaXMudHJhbnNsYXRpb25NYXRyaXggPSBtYXRyaXhJVl8xLk1hdHJpeElWLklERU5USVRZO1xuICAgICAgICB0aGlzLnZpZXdNYXRyaXggPSBtYXRyaXhJVl8xLk1hdHJpeElWLklERU5USVRZO1xuICAgICAgICB0aGlzLndvcmxkTWF0cml4ID0gbWF0cml4SVZfMS5NYXRyaXhJVi5JREVOVElUWTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBtYXRyaXhJVl8xLk1hdHJpeElWLklERU5USVRZO1xuICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBtYXRyaXhJVl8xLk1hdHJpeElWLklERU5USVRZO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVuZGVyIGN5Y2xlIGZvciB0aGUgcHNldWRvLTNkLWNhbnZhcy5cbiAgICAgKlxuICAgICAqIFRha2VzIHZhcmlvdXMgM2QgbWVzaGVzIHRoYXQgbmVlZCB0byBiZSBkaXNwbGF5ZWQgb24gdGhlIHNjcmVlblxuICAgICAqIGFuZCBwcm9qZWN0cyB0aGVtIGFzIDJkIHBvaW50cy5cbiAgICAgKlxuICAgICAqIFRoaXMgdGFrZXMgb24gYSB3b3JsZCAtIHZpZXcgLSBwcm9qZWN0aW9uIHBhdHRlcm4gdG8gY3JlYXRlcyBhXG4gICAgICogdHJhbnNsYXRpb24gbWF0cml4IGFuZCB0aGVuIGFwcGxpZXMgdGhhdCB0byBlYWNoIHZlY3RvciBwb2ludC5cbiAgICAgKlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgb3JkZXIgbWF0dGVycy4gIFVzaW5nIE9wZW5HTCByaWdodCB0byBsZWZ0IG11bHRpcGxpY2F0aW9uOlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKlxuICAgICAqIHZhciB0cmFuc2Zvcm1NYXRyaXggPSBwcm9qZWN0aW9uTWF0cml4ICogVmlld01hdHJpeCAqIFdvcmxkTWF0cml4O1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV29ybGRNYXRyaXggPSBUYWtlcyBvYmplY3Qgc3BhY2UgdG8gd29ybGQgc3BhY2VcbiAgICAgKiBWaWV3TWF0cml4ID0gQ2FtZXJhIG1hdHJpeCAtIHRyYW5zZm9ybXMgd29ybGQgc3BhY2UgdG8gY2FtZXJhIHNwYWNlXG4gICAgICogcHJvamVjdGlvbk1hdHJpeCA9IE5lYXIgb3IgZmFyIGFuZ2xlIG9mIHZpZXcuXG4gICAgICpcbiAgICAgKlxuICAgICAqIGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTMxMjIyMTcwNDE1L2h0dHA6L3JvYmVydG9rb2NpLmNvbS93b3JsZC12aWV3LXByb2plY3Rpb24tbWF0cml4LXVudmVpbGVkL1xuICAgICAqXG4gICAgICogQHBhcmFtIGNhbWVyYVxuICAgICAqIEBwYXJhbSBtZXNoZXNcbiAgICAgKi9cbiAgICByZW5kZXIoY2FtZXJhLCBtZXNoZXMpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIG1lc2guXG4gICAgICAgIG1lc2hlcy5mb3JFYWNoKG1lc2ggPT4ge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbWFpbiB2aWV3IC8gY2FtZXJhIG1hdHJpeC5cbiAgICAgICAgICAgIHRoaXMudmlld01hdHJpeCA9IG5ldyBtYXRyaXhJVl8xLk1hdHJpeElWKCkubG9va0F0KGNhbWVyYS5wb3NpdGlvbiwgY2FtZXJhLnRhcmdldCwgdmVjdG9yXzEuVmVjdG9yLlVQKTtcbiAgICAgICAgICAgIC8vIFRoZSBtYWluIHByb2plY3Rpb24gbWF0cml4LlxuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IG1hdHJpeElWXzEuTWF0cml4SVYoKS5wZXJzcGVjdGl2ZSh0aGlzLmZvdiwgdGhpcy5hc3BlY3QsIHRoaXMubmVhciwgdGhpcy5mYXIpO1xuICAgICAgICAgICAgLy8gVGhlIG1haW4gd29ybGQgb3IgbW9kZWwgbWF0cml4LiAgSGVyZSB3ZSBhcmUgZ29pbmcgdG8gc2hpZnQgdGhlXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBvZiB0aGUgbWVzaCBiYXNlZCBvbiB0aGUgY3VycmVuIHRtZXNoIHBvc2l0aW9uLlxuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGlvbk1hdHJpeCA9IG5ldyBtYXRyaXhJVl8xLk1hdHJpeElWKCkudHJhbnNsYXRlKG1lc2gucG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy53b3JsZE1hdHJpeCA9IG1hdHJpeElWXzEuTWF0cml4SVYuSURFTlRJVFkubXVsdGlwbHkodGhpcy50cmFuc2xhdGlvbk1hdHJpeCk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHRyYW5zZm9ybSBtYXRyaXguXG4gICAgICAgICAgICAvLyBQcm9qZWN0TWF0cml4ICogVmlld01hdHJpeCAqIFdvcmxkTWF0cml4XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IHRoaXMucHJvamVjdGlvbk1hdHJpeFxuICAgICAgICAgICAgICAgIC5tdWx0aXBseSh0aGlzLnZpZXdNYXRyaXgpXG4gICAgICAgICAgICAgICAgLm11bHRpcGx5KHRoaXMud29ybGRNYXRyaXgpO1xuICAgICAgICAgICAgLy8gTm93IHdlIGFyZSBnb2luZyB0byBhcHBseSB0aGUgdHJhbnNmb3JtTWF0cml4IHRvIGVhY2hcbiAgICAgICAgICAgIC8vIHZlcnRpY2VzIHBvaW50IGluIHRoZSBtZXNoIGVmZmVjdGl2ZWx5IHByb2plY3RpbmcgM2QgaW50b1xuICAgICAgICAgICAgLy8gdGhlIDJkIGNhbnZhcy5cbiAgICAgICAgICAgIG1lc2gudmVydGljZXMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRha2UgZWFjaCB2ZWN0b3IgcG9pbnQgc3VjaCBhcyAxLDEgYW5kIGZpcnN0IGxvY2FsbHksXG4gICAgICAgICAgICAgICAgLy8gcm90YXRlIGFuZCBtb3ZlIGl0J3MgcG9zaXRpb24gYmFzZWQgb24gdGhlIGJhc2lzTWF0cml4LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBiYXNpc01hdHJpeCBjb25zaXN0cyBvZiB1cCwgcmlnaHQsIGZvcndhcmQgdmVjdG9yc1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgZGVmaW5lIHRoZSBzaGFwZSBvZiB0aGUgbWVzaCBhbmQgdGhpcyBwYXJ0aWN1bGFyIHZlY3Rvci5cbiAgICAgICAgICAgICAgICAvLyBBcGFydCBmcm9tIHRoZSBiYXNpYyBwb3NpdGlvbiAoY29udHJvbGVkIGluIHdvcmxkTWF0cml4KSxcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGxvY2FsbHkgYWZmZWN0cyB0aGUgcG9zaXRpb24gb2YgZWFjaCB2ZWN0b3Igd2hpY2ggY2FuXG4gICAgICAgICAgICAgICAgLy8gYmUgY29udHJvbGxlZCBieSB0aGUgbWVzaCBzaXplIGFuZCB2ZWN0b3IgcG9zaXRpb25zLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdGF0aW9uTWF0cml4ID0gbmV3IG1hdHJpeElWXzEuTWF0cml4SVYoKS55cHIobWVzaC5yb3RhdGlvbi55LCBtZXNoLnJvdGF0aW9uLngsIG1lc2gucm90YXRpb24ueik7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzaXNNYXRyaXggPSBtZXNoLmJhc2lzTWF0cml4LmNsb25lKCkubXVsdGlwbHkocm90YXRpb25NYXRyaXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVmVjdG9yID0gdi5jbG9uZSgpLnRyYW5zZm9ybVdpdGhNYXRyaXhJVihiYXNpc01hdHJpeCk7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSB2ZWN0b3IuXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIG91ciBmaW5hbCB2ZWN0b3IgY29vcmRpbmF0ZXMgdGhhdCBhcmUgbm9ybWFsaXplZFxuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGJ5IHRoZSBzY3JlZW4gaXMgMXgxIHdpdGggdGhlIGNlbnRlciBpbiB6ZXJvIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgLy8gbGlrZSB3ZWJHTC5cbiAgICAgICAgICAgICAgICBsZXQgdmVjdG9yMmQgPSB0cmFuc2Zvcm1lZFZlY3RvclxuICAgICAgICAgICAgICAgICAgICAuY2xvbmUoKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNmb3JtV2l0aE1hdHJpeElWKHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICAgICAgICAgICAgICAvLyBTbyBmYXIgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIGlzIG9uZSBiYXNlZCBvbiBjZW50ZXIgLyBjZW50ZXJcbiAgICAgICAgICAgICAgICAvLyBsaWtlIHdlYkdMLlxuICAgICAgICAgICAgICAgIC8vIFRoZSB2ZWN0b3IgcG9zaXRpb24gcmVtYWlucyBub3JtYWxpemVkIHNvIHdlIHdhbnQgdG9cbiAgICAgICAgICAgICAgICAvLyBzY2FsZS9tYXAgaXQgdG8gdGhlIGNhbnZhcyBkaW1lbnNpb25zLlxuICAgICAgICAgICAgICAgIC8vIFNjYWxlIGl0IGFuZCB0aGVuIHNoaWZ0IGl0IG92ZXIgaGFsZiB0aGUgc2NyZWVuIHdpZHRoIHRvIGNlbnRlclxuICAgICAgICAgICAgICAgIC8vIGl0LlxuICAgICAgICAgICAgICAgIGxldCB4ID0gdmVjdG9yMmQueCAqIHRoaXMud2lkdGg7XG4gICAgICAgICAgICAgICAgeCArPSB0aGlzLndpZHRoICogMC41O1xuICAgICAgICAgICAgICAgIC8vIFNjYWxlIGl0IGFuZCB0aGVuIHNoaWZ0IGl0IG92ZXIgaGFsZiB0aGUgc2NyZWVuIHdpZHRoIHRvIGNlbnRlclxuICAgICAgICAgICAgICAgIC8vIGl0LlxuICAgICAgICAgICAgICAgIGxldCB5ID0gLXZlY3RvcjJkLnkgKiB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgICAgICB5ICs9IHRoaXMuaGVpZ2h0ICogMC41O1xuICAgICAgICAgICAgICAgIC8vIFdlIGdldCBvdXIgZmluYWwgdmVjdG9yIGNvb3JkaW5hdGVzIG9uIHRoZSBjYW52YXMuXG4gICAgICAgICAgICAgICAgdmVjdG9yMmQgPSBuZXcgdmVjdG9yXzEuVmVjdG9yKHgsIHkpLmludCgpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgdmVjdG9yIGdvZXMgb3V0IG9mIGJvdW5kYXJpZXMgaW4gd2hpY2ggY2FzZSxcbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGRyYXcgaXQuXG4gICAgICAgICAgICAgICAgaWYgKHZlY3RvcjJkLnggPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICB2ZWN0b3IyZC55ID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yMmQueCA8IHRoaXMud2lkdGggJiZcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yMmQueSA8IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbV9jYW52YXNfMS5kb21DYW52YXMuc2V0RmlsbENvbG9yKHRoaXMuY29udGV4dCwgbWVzaC5jb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIGRvbV9jYW52YXNfMS5kb21DYW52YXMuc2V0U3Ryb2tlQ29sb3IodGhpcy5jb250ZXh0LCBtZXNoLmNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tX2NhbnZhc18xLmRvbUNhbnZhcy52ZWN0b3JQb2ludCh0aGlzLmNvbnRleHQsIHZlY3RvcjJkKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tX2NhbnZhc18xLmRvbUNhbnZhcy5xdWlja1RleHQodGhpcy5jb250ZXh0LCAndicgKyBpLCB2ZWN0b3IyZC54LCB2ZWN0b3IyZC55IC0gNCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUHNldWRvM2RDYW52YXMgPSBQc2V1ZG8zZENhbnZhcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBzZXVkby0zZC1jYW52YXMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/pseudo-3d-canvas/pseudo-3d-canvas.js\n");

/***/ }),

/***/ "./lib/raf/raf-progress.js":
/*!*********************************!*\
  !*** ./lib/raf/raf-progress.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RafProgress = void 0;\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst raf_1 = __webpack_require__(/*! ./raf */ \"./lib/raf/raf.js\");\nconst __1 = __webpack_require__(/*! .. */ \"./lib/index.js\");\n/**\n * A class that runs Raf for a limited time while a given progress\n * (a value between 0-1) eases.  This class is useful because instead of\n * constanlty runnig raf, it will only run RAF when a progress value is unstable.\n * This class also allows you to register and listen for specific progress\n * values and run callbacks (IE: run a callback when the progress crosses 0.5).\n *\n *\n * Example WITHOUT RafProgress:\n * Consider the following example to understand what RafProgress does.\n * Here we are using an html range input to represent Progress but progresss could\n * be a window scroll, duration, mouse position etc.....a percentage amount:\n * ```ts\n * HTML\n *   <input id=\"range\" type=\"range\" name=\"points\" step=\"0.01\" min=\"0\" max=\"1\" style=\"width: 500px;\">\n *\n * JS\n *  this.range = document.getElementById('range');\n *\n *  // Set the progress to the range value.\n *  this.progress = +this.range.value;\n *\n *  const raf = new Raf(() => {\n *     // Range is a value between 0 and 1.\n *     let progress = +this.range.value;\n *\n *    // Add some ease to the progress to smooth it out.\n *    this.progress = mathf.ease(this.progress, progress, 0.25, EASE.easeInOutQuad);\n *\n *   // Reduce the precision of progress.  We dont need to report progress differences\n *   // of 0.0000001.\n *    this.progress = mathf.round(this.progress, 3);\n *\n *   // Something with progress\n *   // Many manipulate the DOM here.\n *  }).start();\n * ```\n * Here you can see that on each RAF cycle, we check the value of the range and\n * get the progress.  We then apply an ease to that progress and then do\n * something within the RAF loop based on the current progress.\n *\n * This works but the problem is that RAF is constantly running and even if\n * the value of progress is the same as the last raf loop, we still are running\n * RAf and perhaps layout thrashing or performning unncessary calcs.\n *\n *\n * Example WITH RafProgress\n * The above is simplied with this class.\n *\n *\n * ```ts\n *\n * this.range = document.getElementById('range');\n *\n * // Create an instance of raf progress.\n * let rafProgress = new RafProgress((easedProgress, direction)=> {\n *   // DO something here like update the dom.\n *   // This is ONLY called when progress has changed in value.\n *   //..\n * })\n *\n * // Set the initial progress value.\n * rafProgress.setCurrentProgress(+this.range.value)\n *\n * // Optional, set the precision.\n * rafProgress.setPrecision(5);\n *\n * // Now listen to the range input 'input' event.  The input event is basically\n * // fired when the range changes.\n * this.range.addEventListener('input', ()=> {\n *   rafProgress.easeTo(+this.range.value, 0.25, EASE.easeInOutQuad)\n * })\n *\n *\n *\n *\n * // RafProgress is also an event emitter so you can listen to the progressEvent\n * rafProgress.addEventListener('progressChange', (easedProgress, direction)=> {\n *   // Do something.\n * })\n *\n *\n *\n * // Or use alias watch, unwatch\n * var onProgress = (progress)=> {\n *   console.log('hello')\n * }\n * rafProgress.watch(onProgress);\n * rafProgress.unwatch(onProgress);\n *\n * ```\n *\n * # Progress Callbacks\n * Raf progress additionally allows you to register and listen specific\n * progress values and run a callback.\n *\n * ```\n *\n * // Triggers when progress runs from 0.2, 0.4\n * rafProgress.watchFor([0.2, 0.4], callback);\n *\n * // Triggers when 0.2 is crossed .\n * rafProgress.watchFor(0.2, callback);\n *\n * // Remove watchFor\n * rafProgress.unwatchFor(callback);\n *\n * ```\n * @noInheritDoc\n */\nclass RafProgress {\n    /**\n     * @param {Function} progressRafLoop  Optional function to be called on each\n     *    progress update event.\n     * @constructor\n     */\n    constructor(progressRafLoop) {\n        // The current scroll direction.\n        this.direction = 0;\n        /**\n         * The internally known current progress.\n         */\n        this.currentProgress = 0;\n        /**\n         * The number of decimals to use when checking the equality of the\n         * previous progress versus current.\n         */\n        this.precision = 10;\n        /**\n         * The amount of ease to apply.  This gets calculated as per RAF,\n         * how much of the difference between the current value and target\n         * should the current value be updated by.  Therefore, 1 would mean,\n         * the current value would immediately update to the target value after\n         * one RAF cycle.  Use 1 for no ease.\n         */\n        this.easeAmount = 1;\n        /**\n         * The amount of damp to apply. 1 is no damping.\n         */\n        this.damp = 1;\n        /**\n         * A collection of callbacks to be run at specific progress values.\n         */\n        this.rangeWatchers = [];\n        /**\n         * A collection of callbacks to be run when progress is changed.\n         */\n        this.callbacks = [];\n        this.targetProgress = this.currentProgress;\n        this.easingFunction = __1.EASE.linear;\n        if (progressRafLoop) {\n            this.watch(progressRafLoop);\n        }\n        this.raf = new raf_1.Raf(() => {\n            this.rafLoop();\n        });\n    }\n    /**\n     *  Force stops running calculations.\n     */\n    stop() {\n        this.raf.stop();\n    }\n    /**\n     * Sets the FPS of the internal raf loop.\n     */\n    setFps(fps) {\n        this.raf.setFps(fps);\n    }\n    /**\n     * Run calculations.  Normally. you would call easeTo to set the latest\n     * current progress, you may want to call this if forced stopped and want\n     * to restart the raf loop manually.\n     */\n    run() {\n        this.raf.start();\n    }\n    /**\n     * Sets the precision.  Precision is used to check how closely the current\n     * progress is versus the previous progress per RAF cycle.\n     * The lower the number, the less precise.\n     *\n     * Use a lower number if you want want to improve performance since it will\n     * result in calling Raf fewer times.\n     */\n    setPrecision(value) {\n        this.precision = value;\n    }\n    /**\n     * Adds a progress listener.\n     * @param {Function}\n     */\n    watch(callback) {\n        this.callbacks.push(callback);\n    }\n    /**\n     * Removes a progress listener.\n     * @param {Function}\n     */\n    unwatch(callbackToRemove) {\n        this.callbacks = this.callbacks.filter(callback => {\n            return callback === callbackToRemove;\n        });\n    }\n    /**\n     * Sets a callback for a specific range.\n     * @param {number|Array<number>} A specific progress to watch for or\n     *     an array like [0.1, 0.4] specifying the range to be watched.\n     * @param {Function}\n     */\n    watchFor(range, callback) {\n        this.rangeWatchers.push({\n            range: range,\n            callback: callback,\n        });\n    }\n    /**\n     * Removes a given\n     * @param callback\n     */\n    unwatchFor(callback) {\n        this.rangeWatchers = this.rangeWatchers.filter((watcher) => {\n            return watcher.callback !== callback;\n        });\n    }\n    /**\n     * Once raf is starated, updates on each raf cycle if raf is running.\n     * Dirty check for progress and stops raf once the value has stabilized.\n     */\n    rafLoop() {\n        const previousProgress = this.currentProgress;\n        if (typeof this.damp === 'number') {\n            this.currentProgress = mathf_1.mathf.damp(this.currentProgress, this.targetProgress, this.easeAmount, this.damp);\n        }\n        else {\n            this.currentProgress = mathf_1.mathf.ease(this.currentProgress, this.targetProgress, this.easeAmount, this.easingFunction || __1.EASE.linear);\n        }\n        // Reduce the precision of progress.  We dont need to report progress differences\n        // of 0.0000001.\n        this.currentProgress = mathf_1.mathf.toFixed(this.currentProgress, this.precision);\n        // Based on the the precision, we want to make sure we return\n        // a complete 0 or complete 1 as integers at the bounds of the progress.\n        if (this.currentProgress < 0.5) {\n            this.currentProgress = mathf_1.mathf.floorToPrecision(this.currentProgress, this.precision - 1);\n        }\n        else {\n            this.currentProgress = mathf_1.mathf.ceilToPrecision(this.currentProgress, this.precision - 1);\n        }\n        this.direction = mathf_1.mathf.direction(previousProgress, this.currentProgress);\n        // Call callbacks.\n        this.callbacks.forEach(callback => {\n            callback(this.currentProgress, this.direction);\n        });\n        // Loop through watchers.\n        this.rangeWatchers.forEach((watcher) => {\n            let isBetween = false;\n            if (Array.isArray(watcher.range)) {\n                isBetween = mathf_1.mathf.isBetween(this.currentProgress, watcher.range[0], watcher.range[1]);\n            }\n            else {\n                // If we are only watching for a specific value, we used the\n                // previous progress to see if we passed it.\n                isBetween = mathf_1.mathf.isBetween(watcher.range, this.currentProgress, previousProgress);\n            }\n            if (isBetween) {\n                watcher.callback(this.currentProgress, this.direction);\n            }\n        });\n        // Stop RAF if the value of progress has stabilized.\n        if (previousProgress === this.currentProgress) {\n            this.raf.stop();\n        }\n    }\n    /**\n     * Sets the current progress.  This forces an immediate update to\n     * the passed progress.\n     */\n    setCurrentProgress(progress, noClamp = true) {\n        this.currentProgress = noClamp ? progress : mathf_1.mathf.clampAsProgress(progress);\n        this.targetProgress = this.currentProgress;\n        this.easeAmount = 1;\n        // Run the raf loop once.\n        this.raf.start();\n    }\n    /**\n     * Eases the progress to a target value.  Until that value is reached,\n     * the progressRafLoop is called.\n     *\n     * @param {number} targetProgress The progress to get to.\n     * @param {number} easeAmount The amount to ease. This gets calculated as per\n     *     RAF, how much of the difference between the current value and target\n     *     should the current value be updated by.  Therefore, 1 would mean\n     *     no ease. 0.1 would mean a lot of ease.\n     * @param {Function} easingFunction An optional easing funciton.  Defaults to\n     *     linear.\n     * @param {boolean} noClamp Prevent progress clamping.  Allows values outside\n     *      range of 0-1.\n     *\n     */\n    easeTo(targetProgress, easeAmount, easingFunction = __1.EASE.linear, noClamp = false) {\n        this.targetProgress = noClamp\n            ? targetProgress\n            : mathf_1.mathf.clampAsProgress(targetProgress);\n        this.easeAmount = mathf_1.mathf.clampAsPercent(easeAmount);\n        this.easingFunction = easingFunction;\n        this.damp = null;\n        // Start up RAF to make updates and ease to the target progress.\n        // Make sure we force a restart since sometimes, you can get multiple\n        // call to this in the same raf cycle and if stop is called at the end\n        // our animation won't be guaranteed to start.\n        this.raf.start(true);\n    }\n    /**\n     * Similar to easeTo but applied a smoothdamp instead.\n     * @param targetProgress\n     * @param easeAmount\n     * @param damp\n     */\n    dampTo(targetProgress, easeAmount, damp, noClamp = false) {\n        this.targetProgress = noClamp\n            ? targetProgress\n            : mathf_1.mathf.clampAsProgress(targetProgress);\n        this.easeAmount = mathf_1.mathf.clampAsPercent(easeAmount);\n        this.easingFunction = null;\n        this.damp = damp;\n        // Start up RAF to make updates and ease to the target progress.\n        // Make sure we force a restart since sometimes, you can get multiple\n        // call to this in the same raf cycle and if stop is called at the end\n        // our animation won't be guaranteed to start.\n        this.raf.start(true);\n    }\n    /**\n     * Gets the lerp delta - the difference between the current ease and the\n     * targetEase (where it should be if it caught up).\n     */\n    getLerpDelta() {\n        return this.targetProgress - this.currentProgress;\n    }\n    /**\n     * Gets the current scroll direction. 1 is down scroll, -1 is up scroll and\n     * 0 is no scroll (when progress is catching up).\n     */\n    getScrollDirection() {\n        return this.direction;\n    }\n    dispose() {\n        this.raf.dispose();\n        this.callbacks = [];\n        this.rangeWatchers = [];\n    }\n}\nexports.RafProgress = RafProgress;\n//# sourceMappingURL=raf-progress.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvcmFmL3JhZi1wcm9ncmVzcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9yYWYvcmFmLXByb2dyZXNzLmpzP2IzY2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJhZlByb2dyZXNzID0gdm9pZCAwO1xuY29uc3QgbWF0aGZfMSA9IHJlcXVpcmUoXCIuLi9tYXRoZi9tYXRoZlwiKTtcbmNvbnN0IHJhZl8xID0gcmVxdWlyZShcIi4vcmFmXCIpO1xuY29uc3QgX18xID0gcmVxdWlyZShcIi4uXCIpO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgcnVucyBSYWYgZm9yIGEgbGltaXRlZCB0aW1lIHdoaWxlIGEgZ2l2ZW4gcHJvZ3Jlc3NcbiAqIChhIHZhbHVlIGJldHdlZW4gMC0xKSBlYXNlcy4gIFRoaXMgY2xhc3MgaXMgdXNlZnVsIGJlY2F1c2UgaW5zdGVhZCBvZlxuICogY29uc3Rhbmx0eSBydW5uaWcgcmFmLCBpdCB3aWxsIG9ubHkgcnVuIFJBRiB3aGVuIGEgcHJvZ3Jlc3MgdmFsdWUgaXMgdW5zdGFibGUuXG4gKiBUaGlzIGNsYXNzIGFsc28gYWxsb3dzIHlvdSB0byByZWdpc3RlciBhbmQgbGlzdGVuIGZvciBzcGVjaWZpYyBwcm9ncmVzc1xuICogdmFsdWVzIGFuZCBydW4gY2FsbGJhY2tzIChJRTogcnVuIGEgY2FsbGJhY2sgd2hlbiB0aGUgcHJvZ3Jlc3MgY3Jvc3NlcyAwLjUpLlxuICpcbiAqXG4gKiBFeGFtcGxlIFdJVEhPVVQgUmFmUHJvZ3Jlc3M6XG4gKiBDb25zaWRlciB0aGUgZm9sbG93aW5nIGV4YW1wbGUgdG8gdW5kZXJzdGFuZCB3aGF0IFJhZlByb2dyZXNzIGRvZXMuXG4gKiBIZXJlIHdlIGFyZSB1c2luZyBhbiBodG1sIHJhbmdlIGlucHV0IHRvIHJlcHJlc2VudCBQcm9ncmVzcyBidXQgcHJvZ3Jlc3NzIGNvdWxkXG4gKiBiZSBhIHdpbmRvdyBzY3JvbGwsIGR1cmF0aW9uLCBtb3VzZSBwb3NpdGlvbiBldGMuLi4uLmEgcGVyY2VudGFnZSBhbW91bnQ6XG4gKiBgYGB0c1xuICogSFRNTFxuICogICA8aW5wdXQgaWQ9XCJyYW5nZVwiIHR5cGU9XCJyYW5nZVwiIG5hbWU9XCJwb2ludHNcIiBzdGVwPVwiMC4wMVwiIG1pbj1cIjBcIiBtYXg9XCIxXCIgc3R5bGU9XCJ3aWR0aDogNTAwcHg7XCI+XG4gKlxuICogSlNcbiAqICB0aGlzLnJhbmdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JhbmdlJyk7XG4gKlxuICogIC8vIFNldCB0aGUgcHJvZ3Jlc3MgdG8gdGhlIHJhbmdlIHZhbHVlLlxuICogIHRoaXMucHJvZ3Jlc3MgPSArdGhpcy5yYW5nZS52YWx1ZTtcbiAqXG4gKiAgY29uc3QgcmFmID0gbmV3IFJhZigoKSA9PiB7XG4gKiAgICAgLy8gUmFuZ2UgaXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gKiAgICAgbGV0IHByb2dyZXNzID0gK3RoaXMucmFuZ2UudmFsdWU7XG4gKlxuICogICAgLy8gQWRkIHNvbWUgZWFzZSB0byB0aGUgcHJvZ3Jlc3MgdG8gc21vb3RoIGl0IG91dC5cbiAqICAgIHRoaXMucHJvZ3Jlc3MgPSBtYXRoZi5lYXNlKHRoaXMucHJvZ3Jlc3MsIHByb2dyZXNzLCAwLjI1LCBFQVNFLmVhc2VJbk91dFF1YWQpO1xuICpcbiAqICAgLy8gUmVkdWNlIHRoZSBwcmVjaXNpb24gb2YgcHJvZ3Jlc3MuICBXZSBkb250IG5lZWQgdG8gcmVwb3J0IHByb2dyZXNzIGRpZmZlcmVuY2VzXG4gKiAgIC8vIG9mIDAuMDAwMDAwMS5cbiAqICAgIHRoaXMucHJvZ3Jlc3MgPSBtYXRoZi5yb3VuZCh0aGlzLnByb2dyZXNzLCAzKTtcbiAqXG4gKiAgIC8vIFNvbWV0aGluZyB3aXRoIHByb2dyZXNzXG4gKiAgIC8vIE1hbnkgbWFuaXB1bGF0ZSB0aGUgRE9NIGhlcmUuXG4gKiAgfSkuc3RhcnQoKTtcbiAqIGBgYFxuICogSGVyZSB5b3UgY2FuIHNlZSB0aGF0IG9uIGVhY2ggUkFGIGN5Y2xlLCB3ZSBjaGVjayB0aGUgdmFsdWUgb2YgdGhlIHJhbmdlIGFuZFxuICogZ2V0IHRoZSBwcm9ncmVzcy4gIFdlIHRoZW4gYXBwbHkgYW4gZWFzZSB0byB0aGF0IHByb2dyZXNzIGFuZCB0aGVuIGRvXG4gKiBzb21ldGhpbmcgd2l0aGluIHRoZSBSQUYgbG9vcCBiYXNlZCBvbiB0aGUgY3VycmVudCBwcm9ncmVzcy5cbiAqXG4gKiBUaGlzIHdvcmtzIGJ1dCB0aGUgcHJvYmxlbSBpcyB0aGF0IFJBRiBpcyBjb25zdGFudGx5IHJ1bm5pbmcgYW5kIGV2ZW4gaWZcbiAqIHRoZSB2YWx1ZSBvZiBwcm9ncmVzcyBpcyB0aGUgc2FtZSBhcyB0aGUgbGFzdCByYWYgbG9vcCwgd2Ugc3RpbGwgYXJlIHJ1bm5pbmdcbiAqIFJBZiBhbmQgcGVyaGFwcyBsYXlvdXQgdGhyYXNoaW5nIG9yIHBlcmZvcm1uaW5nIHVubmNlc3NhcnkgY2FsY3MuXG4gKlxuICpcbiAqIEV4YW1wbGUgV0lUSCBSYWZQcm9ncmVzc1xuICogVGhlIGFib3ZlIGlzIHNpbXBsaWVkIHdpdGggdGhpcyBjbGFzcy5cbiAqXG4gKlxuICogYGBgdHNcbiAqXG4gKiB0aGlzLnJhbmdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JhbmdlJyk7XG4gKlxuICogLy8gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHJhZiBwcm9ncmVzcy5cbiAqIGxldCByYWZQcm9ncmVzcyA9IG5ldyBSYWZQcm9ncmVzcygoZWFzZWRQcm9ncmVzcywgZGlyZWN0aW9uKT0+IHtcbiAqICAgLy8gRE8gc29tZXRoaW5nIGhlcmUgbGlrZSB1cGRhdGUgdGhlIGRvbS5cbiAqICAgLy8gVGhpcyBpcyBPTkxZIGNhbGxlZCB3aGVuIHByb2dyZXNzIGhhcyBjaGFuZ2VkIGluIHZhbHVlLlxuICogICAvLy4uXG4gKiB9KVxuICpcbiAqIC8vIFNldCB0aGUgaW5pdGlhbCBwcm9ncmVzcyB2YWx1ZS5cbiAqIHJhZlByb2dyZXNzLnNldEN1cnJlbnRQcm9ncmVzcygrdGhpcy5yYW5nZS52YWx1ZSlcbiAqXG4gKiAvLyBPcHRpb25hbCwgc2V0IHRoZSBwcmVjaXNpb24uXG4gKiByYWZQcm9ncmVzcy5zZXRQcmVjaXNpb24oNSk7XG4gKlxuICogLy8gTm93IGxpc3RlbiB0byB0aGUgcmFuZ2UgaW5wdXQgJ2lucHV0JyBldmVudC4gIFRoZSBpbnB1dCBldmVudCBpcyBiYXNpY2FsbHlcbiAqIC8vIGZpcmVkIHdoZW4gdGhlIHJhbmdlIGNoYW5nZXMuXG4gKiB0aGlzLnJhbmdlLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCk9PiB7XG4gKiAgIHJhZlByb2dyZXNzLmVhc2VUbygrdGhpcy5yYW5nZS52YWx1ZSwgMC4yNSwgRUFTRS5lYXNlSW5PdXRRdWFkKVxuICogfSlcbiAqXG4gKlxuICpcbiAqXG4gKiAvLyBSYWZQcm9ncmVzcyBpcyBhbHNvIGFuIGV2ZW50IGVtaXR0ZXIgc28geW91IGNhbiBsaXN0ZW4gdG8gdGhlIHByb2dyZXNzRXZlbnRcbiAqIHJhZlByb2dyZXNzLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzQ2hhbmdlJywgKGVhc2VkUHJvZ3Jlc3MsIGRpcmVjdGlvbik9PiB7XG4gKiAgIC8vIERvIHNvbWV0aGluZy5cbiAqIH0pXG4gKlxuICpcbiAqXG4gKiAvLyBPciB1c2UgYWxpYXMgd2F0Y2gsIHVud2F0Y2hcbiAqIHZhciBvblByb2dyZXNzID0gKHByb2dyZXNzKT0+IHtcbiAqICAgY29uc29sZS5sb2coJ2hlbGxvJylcbiAqIH1cbiAqIHJhZlByb2dyZXNzLndhdGNoKG9uUHJvZ3Jlc3MpO1xuICogcmFmUHJvZ3Jlc3MudW53YXRjaChvblByb2dyZXNzKTtcbiAqXG4gKiBgYGBcbiAqXG4gKiAjIFByb2dyZXNzIENhbGxiYWNrc1xuICogUmFmIHByb2dyZXNzIGFkZGl0aW9uYWxseSBhbGxvd3MgeW91IHRvIHJlZ2lzdGVyIGFuZCBsaXN0ZW4gc3BlY2lmaWNcbiAqIHByb2dyZXNzIHZhbHVlcyBhbmQgcnVuIGEgY2FsbGJhY2suXG4gKlxuICogYGBgXG4gKlxuICogLy8gVHJpZ2dlcnMgd2hlbiBwcm9ncmVzcyBydW5zIGZyb20gMC4yLCAwLjRcbiAqIHJhZlByb2dyZXNzLndhdGNoRm9yKFswLjIsIDAuNF0sIGNhbGxiYWNrKTtcbiAqXG4gKiAvLyBUcmlnZ2VycyB3aGVuIDAuMiBpcyBjcm9zc2VkIC5cbiAqIHJhZlByb2dyZXNzLndhdGNoRm9yKDAuMiwgY2FsbGJhY2spO1xuICpcbiAqIC8vIFJlbW92ZSB3YXRjaEZvclxuICogcmFmUHJvZ3Jlc3MudW53YXRjaEZvcihjYWxsYmFjayk7XG4gKlxuICogYGBgXG4gKiBAbm9Jbmhlcml0RG9jXG4gKi9cbmNsYXNzIFJhZlByb2dyZXNzIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9ncmVzc1JhZkxvb3AgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBlYWNoXG4gICAgICogICAgcHJvZ3Jlc3MgdXBkYXRlIGV2ZW50LlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb2dyZXNzUmFmTG9vcCkge1xuICAgICAgICAvLyBUaGUgY3VycmVudCBzY3JvbGwgZGlyZWN0aW9uLlxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW50ZXJuYWxseSBrbm93biBjdXJyZW50IHByb2dyZXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50UHJvZ3Jlc3MgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBkZWNpbWFscyB0byB1c2Ugd2hlbiBjaGVja2luZyB0aGUgZXF1YWxpdHkgb2YgdGhlXG4gICAgICAgICAqIHByZXZpb3VzIHByb2dyZXNzIHZlcnN1cyBjdXJyZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmVjaXNpb24gPSAxMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2YgZWFzZSB0byBhcHBseS4gIFRoaXMgZ2V0cyBjYWxjdWxhdGVkIGFzIHBlciBSQUYsXG4gICAgICAgICAqIGhvdyBtdWNoIG9mIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgdmFsdWUgYW5kIHRhcmdldFxuICAgICAgICAgKiBzaG91bGQgdGhlIGN1cnJlbnQgdmFsdWUgYmUgdXBkYXRlZCBieS4gIFRoZXJlZm9yZSwgMSB3b3VsZCBtZWFuLFxuICAgICAgICAgKiB0aGUgY3VycmVudCB2YWx1ZSB3b3VsZCBpbW1lZGlhdGVseSB1cGRhdGUgdG8gdGhlIHRhcmdldCB2YWx1ZSBhZnRlclxuICAgICAgICAgKiBvbmUgUkFGIGN5Y2xlLiAgVXNlIDEgZm9yIG5vIGVhc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVhc2VBbW91bnQgPSAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFtb3VudCBvZiBkYW1wIHRvIGFwcGx5LiAxIGlzIG5vIGRhbXBpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhbXAgPSAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byBiZSBydW4gYXQgc3BlY2lmaWMgcHJvZ3Jlc3MgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYW5nZVdhdGNoZXJzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIGJlIHJ1biB3aGVuIHByb2dyZXNzIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLnRhcmdldFByb2dyZXNzID0gdGhpcy5jdXJyZW50UHJvZ3Jlc3M7XG4gICAgICAgIHRoaXMuZWFzaW5nRnVuY3Rpb24gPSBfXzEuRUFTRS5saW5lYXI7XG4gICAgICAgIGlmIChwcm9ncmVzc1JhZkxvb3ApIHtcbiAgICAgICAgICAgIHRoaXMud2F0Y2gocHJvZ3Jlc3NSYWZMb29wKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhZiA9IG5ldyByYWZfMS5SYWYoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yYWZMb29wKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgRm9yY2Ugc3RvcHMgcnVubmluZyBjYWxjdWxhdGlvbnMuXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5yYWYuc3RvcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBGUFMgb2YgdGhlIGludGVybmFsIHJhZiBsb29wLlxuICAgICAqL1xuICAgIHNldEZwcyhmcHMpIHtcbiAgICAgICAgdGhpcy5yYWYuc2V0RnBzKGZwcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biBjYWxjdWxhdGlvbnMuICBOb3JtYWxseS4geW91IHdvdWxkIGNhbGwgZWFzZVRvIHRvIHNldCB0aGUgbGF0ZXN0XG4gICAgICogY3VycmVudCBwcm9ncmVzcywgeW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyBpZiBmb3JjZWQgc3RvcHBlZCBhbmQgd2FudFxuICAgICAqIHRvIHJlc3RhcnQgdGhlIHJhZiBsb29wIG1hbnVhbGx5LlxuICAgICAqL1xuICAgIHJ1bigpIHtcbiAgICAgICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJlY2lzaW9uLiAgUHJlY2lzaW9uIGlzIHVzZWQgdG8gY2hlY2sgaG93IGNsb3NlbHkgdGhlIGN1cnJlbnRcbiAgICAgKiBwcm9ncmVzcyBpcyB2ZXJzdXMgdGhlIHByZXZpb3VzIHByb2dyZXNzIHBlciBSQUYgY3ljbGUuXG4gICAgICogVGhlIGxvd2VyIHRoZSBudW1iZXIsIHRoZSBsZXNzIHByZWNpc2UuXG4gICAgICpcbiAgICAgKiBVc2UgYSBsb3dlciBudW1iZXIgaWYgeW91IHdhbnQgd2FudCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIHNpbmNlIGl0IHdpbGxcbiAgICAgKiByZXN1bHQgaW4gY2FsbGluZyBSYWYgZmV3ZXIgdGltZXMuXG4gICAgICovXG4gICAgc2V0UHJlY2lzaW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJlY2lzaW9uID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBwcm9ncmVzcyBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIHdhdGNoKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgcHJvZ3Jlc3MgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICB1bndhdGNoKGNhbGxiYWNrVG9SZW1vdmUpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrcy5maWx0ZXIoY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrID09PSBjYWxsYmFja1RvUmVtb3ZlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIGNhbGxiYWNrIGZvciBhIHNwZWNpZmljIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfEFycmF5PG51bWJlcj59IEEgc3BlY2lmaWMgcHJvZ3Jlc3MgdG8gd2F0Y2ggZm9yIG9yXG4gICAgICogICAgIGFuIGFycmF5IGxpa2UgWzAuMSwgMC40XSBzcGVjaWZ5aW5nIHRoZSByYW5nZSB0byBiZSB3YXRjaGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgd2F0Y2hGb3IocmFuZ2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucmFuZ2VXYXRjaGVycy5wdXNoKHtcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBnaXZlblxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqL1xuICAgIHVud2F0Y2hGb3IoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5yYW5nZVdhdGNoZXJzID0gdGhpcy5yYW5nZVdhdGNoZXJzLmZpbHRlcigod2F0Y2hlcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHdhdGNoZXIuY2FsbGJhY2sgIT09IGNhbGxiYWNrO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25jZSByYWYgaXMgc3RhcmF0ZWQsIHVwZGF0ZXMgb24gZWFjaCByYWYgY3ljbGUgaWYgcmFmIGlzIHJ1bm5pbmcuXG4gICAgICogRGlydHkgY2hlY2sgZm9yIHByb2dyZXNzIGFuZCBzdG9wcyByYWYgb25jZSB0aGUgdmFsdWUgaGFzIHN0YWJpbGl6ZWQuXG4gICAgICovXG4gICAgcmFmTG9vcCgpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNQcm9ncmVzcyA9IHRoaXMuY3VycmVudFByb2dyZXNzO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb2dyZXNzID0gbWF0aGZfMS5tYXRoZi5kYW1wKHRoaXMuY3VycmVudFByb2dyZXNzLCB0aGlzLnRhcmdldFByb2dyZXNzLCB0aGlzLmVhc2VBbW91bnQsIHRoaXMuZGFtcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9ncmVzcyA9IG1hdGhmXzEubWF0aGYuZWFzZSh0aGlzLmN1cnJlbnRQcm9ncmVzcywgdGhpcy50YXJnZXRQcm9ncmVzcywgdGhpcy5lYXNlQW1vdW50LCB0aGlzLmVhc2luZ0Z1bmN0aW9uIHx8IF9fMS5FQVNFLmxpbmVhcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVkdWNlIHRoZSBwcmVjaXNpb24gb2YgcHJvZ3Jlc3MuICBXZSBkb250IG5lZWQgdG8gcmVwb3J0IHByb2dyZXNzIGRpZmZlcmVuY2VzXG4gICAgICAgIC8vIG9mIDAuMDAwMDAwMS5cbiAgICAgICAgdGhpcy5jdXJyZW50UHJvZ3Jlc3MgPSBtYXRoZl8xLm1hdGhmLnRvRml4ZWQodGhpcy5jdXJyZW50UHJvZ3Jlc3MsIHRoaXMucHJlY2lzaW9uKTtcbiAgICAgICAgLy8gQmFzZWQgb24gdGhlIHRoZSBwcmVjaXNpb24sIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIHJldHVyblxuICAgICAgICAvLyBhIGNvbXBsZXRlIDAgb3IgY29tcGxldGUgMSBhcyBpbnRlZ2VycyBhdCB0aGUgYm91bmRzIG9mIHRoZSBwcm9ncmVzcy5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFByb2dyZXNzIDwgMC41KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9ncmVzcyA9IG1hdGhmXzEubWF0aGYuZmxvb3JUb1ByZWNpc2lvbih0aGlzLmN1cnJlbnRQcm9ncmVzcywgdGhpcy5wcmVjaXNpb24gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb2dyZXNzID0gbWF0aGZfMS5tYXRoZi5jZWlsVG9QcmVjaXNpb24odGhpcy5jdXJyZW50UHJvZ3Jlc3MsIHRoaXMucHJlY2lzaW9uIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBtYXRoZl8xLm1hdGhmLmRpcmVjdGlvbihwcmV2aW91c1Byb2dyZXNzLCB0aGlzLmN1cnJlbnRQcm9ncmVzcyk7XG4gICAgICAgIC8vIENhbGwgY2FsbGJhY2tzLlxuICAgICAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuY3VycmVudFByb2dyZXNzLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggd2F0Y2hlcnMuXG4gICAgICAgIHRoaXMucmFuZ2VXYXRjaGVycy5mb3JFYWNoKCh3YXRjaGVyKSA9PiB7XG4gICAgICAgICAgICBsZXQgaXNCZXR3ZWVuID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh3YXRjaGVyLnJhbmdlKSkge1xuICAgICAgICAgICAgICAgIGlzQmV0d2VlbiA9IG1hdGhmXzEubWF0aGYuaXNCZXR3ZWVuKHRoaXMuY3VycmVudFByb2dyZXNzLCB3YXRjaGVyLnJhbmdlWzBdLCB3YXRjaGVyLnJhbmdlWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBvbmx5IHdhdGNoaW5nIGZvciBhIHNwZWNpZmljIHZhbHVlLCB3ZSB1c2VkIHRoZVxuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIHByb2dyZXNzIHRvIHNlZSBpZiB3ZSBwYXNzZWQgaXQuXG4gICAgICAgICAgICAgICAgaXNCZXR3ZWVuID0gbWF0aGZfMS5tYXRoZi5pc0JldHdlZW4od2F0Y2hlci5yYW5nZSwgdGhpcy5jdXJyZW50UHJvZ3Jlc3MsIHByZXZpb3VzUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQmV0d2Vlbikge1xuICAgICAgICAgICAgICAgIHdhdGNoZXIuY2FsbGJhY2sodGhpcy5jdXJyZW50UHJvZ3Jlc3MsIHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN0b3AgUkFGIGlmIHRoZSB2YWx1ZSBvZiBwcm9ncmVzcyBoYXMgc3RhYmlsaXplZC5cbiAgICAgICAgaWYgKHByZXZpb3VzUHJvZ3Jlc3MgPT09IHRoaXMuY3VycmVudFByb2dyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLnJhZi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBwcm9ncmVzcy4gIFRoaXMgZm9yY2VzIGFuIGltbWVkaWF0ZSB1cGRhdGUgdG9cbiAgICAgKiB0aGUgcGFzc2VkIHByb2dyZXNzLlxuICAgICAqL1xuICAgIHNldEN1cnJlbnRQcm9ncmVzcyhwcm9ncmVzcywgbm9DbGFtcCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvZ3Jlc3MgPSBub0NsYW1wID8gcHJvZ3Jlc3MgOiBtYXRoZl8xLm1hdGhmLmNsYW1wQXNQcm9ncmVzcyhwcm9ncmVzcyk7XG4gICAgICAgIHRoaXMudGFyZ2V0UHJvZ3Jlc3MgPSB0aGlzLmN1cnJlbnRQcm9ncmVzcztcbiAgICAgICAgdGhpcy5lYXNlQW1vdW50ID0gMTtcbiAgICAgICAgLy8gUnVuIHRoZSByYWYgbG9vcCBvbmNlLlxuICAgICAgICB0aGlzLnJhZi5zdGFydCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFYXNlcyB0aGUgcHJvZ3Jlc3MgdG8gYSB0YXJnZXQgdmFsdWUuICBVbnRpbCB0aGF0IHZhbHVlIGlzIHJlYWNoZWQsXG4gICAgICogdGhlIHByb2dyZXNzUmFmTG9vcCBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0UHJvZ3Jlc3MgVGhlIHByb2dyZXNzIHRvIGdldCB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZWFzZUFtb3VudCBUaGUgYW1vdW50IHRvIGVhc2UuIFRoaXMgZ2V0cyBjYWxjdWxhdGVkIGFzIHBlclxuICAgICAqICAgICBSQUYsIGhvdyBtdWNoIG9mIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgdmFsdWUgYW5kIHRhcmdldFxuICAgICAqICAgICBzaG91bGQgdGhlIGN1cnJlbnQgdmFsdWUgYmUgdXBkYXRlZCBieS4gIFRoZXJlZm9yZSwgMSB3b3VsZCBtZWFuXG4gICAgICogICAgIG5vIGVhc2UuIDAuMSB3b3VsZCBtZWFuIGEgbG90IG9mIGVhc2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFzaW5nRnVuY3Rpb24gQW4gb3B0aW9uYWwgZWFzaW5nIGZ1bmNpdG9uLiAgRGVmYXVsdHMgdG9cbiAgICAgKiAgICAgbGluZWFyLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbm9DbGFtcCBQcmV2ZW50IHByb2dyZXNzIGNsYW1waW5nLiAgQWxsb3dzIHZhbHVlcyBvdXRzaWRlXG4gICAgICogICAgICByYW5nZSBvZiAwLTEuXG4gICAgICpcbiAgICAgKi9cbiAgICBlYXNlVG8odGFyZ2V0UHJvZ3Jlc3MsIGVhc2VBbW91bnQsIGVhc2luZ0Z1bmN0aW9uID0gX18xLkVBU0UubGluZWFyLCBub0NsYW1wID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy50YXJnZXRQcm9ncmVzcyA9IG5vQ2xhbXBcbiAgICAgICAgICAgID8gdGFyZ2V0UHJvZ3Jlc3NcbiAgICAgICAgICAgIDogbWF0aGZfMS5tYXRoZi5jbGFtcEFzUHJvZ3Jlc3ModGFyZ2V0UHJvZ3Jlc3MpO1xuICAgICAgICB0aGlzLmVhc2VBbW91bnQgPSBtYXRoZl8xLm1hdGhmLmNsYW1wQXNQZXJjZW50KGVhc2VBbW91bnQpO1xuICAgICAgICB0aGlzLmVhc2luZ0Z1bmN0aW9uID0gZWFzaW5nRnVuY3Rpb247XG4gICAgICAgIHRoaXMuZGFtcCA9IG51bGw7XG4gICAgICAgIC8vIFN0YXJ0IHVwIFJBRiB0byBtYWtlIHVwZGF0ZXMgYW5kIGVhc2UgdG8gdGhlIHRhcmdldCBwcm9ncmVzcy5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGZvcmNlIGEgcmVzdGFydCBzaW5jZSBzb21ldGltZXMsIHlvdSBjYW4gZ2V0IG11bHRpcGxlXG4gICAgICAgIC8vIGNhbGwgdG8gdGhpcyBpbiB0aGUgc2FtZSByYWYgY3ljbGUgYW5kIGlmIHN0b3AgaXMgY2FsbGVkIGF0IHRoZSBlbmRcbiAgICAgICAgLy8gb3VyIGFuaW1hdGlvbiB3b24ndCBiZSBndWFyYW50ZWVkIHRvIHN0YXJ0LlxuICAgICAgICB0aGlzLnJhZi5zdGFydCh0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBlYXNlVG8gYnV0IGFwcGxpZWQgYSBzbW9vdGhkYW1wIGluc3RlYWQuXG4gICAgICogQHBhcmFtIHRhcmdldFByb2dyZXNzXG4gICAgICogQHBhcmFtIGVhc2VBbW91bnRcbiAgICAgKiBAcGFyYW0gZGFtcFxuICAgICAqL1xuICAgIGRhbXBUbyh0YXJnZXRQcm9ncmVzcywgZWFzZUFtb3VudCwgZGFtcCwgbm9DbGFtcCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0UHJvZ3Jlc3MgPSBub0NsYW1wXG4gICAgICAgICAgICA/IHRhcmdldFByb2dyZXNzXG4gICAgICAgICAgICA6IG1hdGhmXzEubWF0aGYuY2xhbXBBc1Byb2dyZXNzKHRhcmdldFByb2dyZXNzKTtcbiAgICAgICAgdGhpcy5lYXNlQW1vdW50ID0gbWF0aGZfMS5tYXRoZi5jbGFtcEFzUGVyY2VudChlYXNlQW1vdW50KTtcbiAgICAgICAgdGhpcy5lYXNpbmdGdW5jdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZGFtcCA9IGRhbXA7XG4gICAgICAgIC8vIFN0YXJ0IHVwIFJBRiB0byBtYWtlIHVwZGF0ZXMgYW5kIGVhc2UgdG8gdGhlIHRhcmdldCBwcm9ncmVzcy5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGZvcmNlIGEgcmVzdGFydCBzaW5jZSBzb21ldGltZXMsIHlvdSBjYW4gZ2V0IG11bHRpcGxlXG4gICAgICAgIC8vIGNhbGwgdG8gdGhpcyBpbiB0aGUgc2FtZSByYWYgY3ljbGUgYW5kIGlmIHN0b3AgaXMgY2FsbGVkIGF0IHRoZSBlbmRcbiAgICAgICAgLy8gb3VyIGFuaW1hdGlvbiB3b24ndCBiZSBndWFyYW50ZWVkIHRvIHN0YXJ0LlxuICAgICAgICB0aGlzLnJhZi5zdGFydCh0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGVycCBkZWx0YSAtIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgZWFzZSBhbmQgdGhlXG4gICAgICogdGFyZ2V0RWFzZSAod2hlcmUgaXQgc2hvdWxkIGJlIGlmIGl0IGNhdWdodCB1cCkuXG4gICAgICovXG4gICAgZ2V0TGVycERlbHRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRQcm9ncmVzcyAtIHRoaXMuY3VycmVudFByb2dyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHNjcm9sbCBkaXJlY3Rpb24uIDEgaXMgZG93biBzY3JvbGwsIC0xIGlzIHVwIHNjcm9sbCBhbmRcbiAgICAgKiAwIGlzIG5vIHNjcm9sbCAod2hlbiBwcm9ncmVzcyBpcyBjYXRjaGluZyB1cCkuXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsRGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb247XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMucmFmLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5yYW5nZVdhdGNoZXJzID0gW107XG4gICAgfVxufVxuZXhwb3J0cy5SYWZQcm9ncmVzcyA9IFJhZlByb2dyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFmLXByb2dyZXNzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/raf/raf-progress.js\n");

/***/ }),

/***/ "./lib/raf/raf-timer.js":
/*!******************************!*\
  !*** ./lib/raf/raf-timer.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RafTimer = void 0;\nconst time_1 = __webpack_require__(/*! ../time/time */ \"./lib/time/time.js\");\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst raf_1 = __webpack_require__(/*! ./raf */ \"./lib/raf/raf.js\");\n/**\n * A Raf based timer.  This class allows you to run RAF for only a\n * set duration and then stop.\n *\n * This can be useful to do things like one time animations.\n *\n * Here is an example of running the rafTimer for 300ms\n * and lerping the x value of the box.\n * ```ts\n * // Box x starting value.\n * box.x = 0;\n *\n * let rafTimer = new RafTimer((progress)=> {\n *   // Called on each raf cycle from when start is called\n *   // for 300ms.\n *\n *   // progress is passed as a value between 0 and 1.\n *   // console.log('progress')\n *\n *\n *   // Will move the box from 0 (starting) to 500\n *   // based on the progress.\n *   box.x = mathf.lerp(box.x, 500, progress);\n *\n *   // or go fancy and add easing to the progress!\n *   // box.x = mathf.ease(box.x, 500, progress, ease.easeInOutSine);\n * })\n *\n * rafTimer.onComplete(()=> {\n *   // Do something on completion.\n * })\n *\n * // Set the duration of the rafTimer 300 and start it.\n * rafTimer.setDuration(300);\n * rafTimer.play();\n *\n *\n * // If you want, slow down the FPS.\n * rafTimer.setFps(10);\n *\n * // Pause if you want.\n * window.setTimeout(()=> {\n *   rafTimer.pause();\n *\n *   // Start playing again from pause point\n *   playButton.addEventListner('click', ()=> {\n *     rafTimer.play();\n *   }, { once: true});\n *\n *   // Reset to beginning\n *   resetButton.addEventListner('click', ()=> {\n *     rafTimer.reset();\n *     rafTimer.play();\n *   }, { once: true});\n *\n * })\n *\n * TODO (uxder); Update this to extend emit emitter.\n *\n * ```\n */\nclass RafTimer {\n    constructor(rafLoop) {\n        /**\n         * The callback to be executed upon each request animation frame.\n         * @type {Function}\n         */\n        this.rafLoop = rafLoop;\n        /**\n         * The internal raf instance\n         * @type {private}\n         */\n        this.raf = new raf_1.Raf(() => {\n            this.animationLoop_();\n        });\n        /**\n         * The internal raf instance\n         * @type {private}\n         */\n        this.duration = 0;\n        /**\n         * The progress of the timer. The amount of percentage\n         * we have elasped, represented in a number between 0-1.\n         */\n        this.progress = 0;\n        /**\n         * The amount of time in ms that has elapsed\n         */\n        this.timeElapsed = 0;\n        /**\n         * The last point in which time was measured.\n         */\n        this.timeSnapshot = 0;\n        /**\n         * Whether raf is active, we are playing .\n         */\n        this.playing = false;\n        // A single complete callback.\n        this.completeCallback = null;\n    }\n    /**\n     * The internal animation loop.\n     */\n    animationLoop_() {\n        // In theory, when playing is false, this loop shouldn't\n        // run but safe guard.\n        if (!this.playing) {\n            return;\n        }\n        // On each raf cycle, we want to calculate\n        // the amount of time that has elapsed since\n        // the last known timeSnapshot (when the time\n        // was recorded).\n        // We add this to the total value of time elapsed.\n        const timeSinceLastTimeSnapshot = time_1.time.timeDiffMs(this.timeSnapshot, time_1.time.now());\n        this.timeElapsed += timeSinceLastTimeSnapshot;\n        this.progress = mathf_1.mathf.clampAsPercent(this.timeElapsed / this.duration);\n        // Update the snapshot.\n        this.timeSnapshot = time_1.time.now();\n        // If we aren't at 100% call the raf loop.\n        if (this.progress < 1) {\n            this.rafLoop && this.rafLoop(this.progress);\n        }\n        else {\n            // Run the main update loop one more time as completion.\n            this.rafLoop && this.rafLoop(1);\n            // Complete\n            this.reset();\n            this.raf.stop();\n            this.completeCallback && this.completeCallback(1);\n        }\n    }\n    /**\n     * Set the duration of the raf loop in ms.\n     * @param duration  The duration in ms.\n     */\n    setDuration(duration) {\n        this.duration = duration;\n    }\n    /**\n     * Sets the fps of raf loop..\n     */\n    setFps(fps) {\n        this.raf.setFps(fps);\n    }\n    onComplete(callback) {\n        this.completeCallback = callback;\n    }\n    /**\n     * Start playing the rafTimer.\n     */\n    play() {\n        if (this.playing) {\n            return;\n        }\n        this.playing = true;\n        this.timeSnapshot = time_1.time.now();\n        this.raf.start();\n    }\n    /**\n     *  Resets the RAF timer.\n     */\n    reset() {\n        this.playing = false;\n        this.raf.stop();\n        this.timeElapsed = 0;\n    }\n    /**\n     *  Pauses the raf Timer.\n     */\n    pause() {\n        this.raf.stop();\n        this.playing = false;\n    }\n    dispose() {\n        this.raf.dispose();\n    }\n}\nexports.RafTimer = RafTimer;\n//# sourceMappingURL=raf-timer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvcmFmL3JhZi10aW1lci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9yYWYvcmFmLXRpbWVyLmpzPzFhNjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJhZlRpbWVyID0gdm9pZCAwO1xuY29uc3QgdGltZV8xID0gcmVxdWlyZShcIi4uL3RpbWUvdGltZVwiKTtcbmNvbnN0IG1hdGhmXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvbWF0aGZcIik7XG5jb25zdCByYWZfMSA9IHJlcXVpcmUoXCIuL3JhZlwiKTtcbi8qKlxuICogQSBSYWYgYmFzZWQgdGltZXIuICBUaGlzIGNsYXNzIGFsbG93cyB5b3UgdG8gcnVuIFJBRiBmb3Igb25seSBhXG4gKiBzZXQgZHVyYXRpb24gYW5kIHRoZW4gc3RvcC5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gZG8gdGhpbmdzIGxpa2Ugb25lIHRpbWUgYW5pbWF0aW9ucy5cbiAqXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgb2YgcnVubmluZyB0aGUgcmFmVGltZXIgZm9yIDMwMG1zXG4gKiBhbmQgbGVycGluZyB0aGUgeCB2YWx1ZSBvZiB0aGUgYm94LlxuICogYGBgdHNcbiAqIC8vIEJveCB4IHN0YXJ0aW5nIHZhbHVlLlxuICogYm94LnggPSAwO1xuICpcbiAqIGxldCByYWZUaW1lciA9IG5ldyBSYWZUaW1lcigocHJvZ3Jlc3MpPT4ge1xuICogICAvLyBDYWxsZWQgb24gZWFjaCByYWYgY3ljbGUgZnJvbSB3aGVuIHN0YXJ0IGlzIGNhbGxlZFxuICogICAvLyBmb3IgMzAwbXMuXG4gKlxuICogICAvLyBwcm9ncmVzcyBpcyBwYXNzZWQgYXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEuXG4gKiAgIC8vIGNvbnNvbGUubG9nKCdwcm9ncmVzcycpXG4gKlxuICpcbiAqICAgLy8gV2lsbCBtb3ZlIHRoZSBib3ggZnJvbSAwIChzdGFydGluZykgdG8gNTAwXG4gKiAgIC8vIGJhc2VkIG9uIHRoZSBwcm9ncmVzcy5cbiAqICAgYm94LnggPSBtYXRoZi5sZXJwKGJveC54LCA1MDAsIHByb2dyZXNzKTtcbiAqXG4gKiAgIC8vIG9yIGdvIGZhbmN5IGFuZCBhZGQgZWFzaW5nIHRvIHRoZSBwcm9ncmVzcyFcbiAqICAgLy8gYm94LnggPSBtYXRoZi5lYXNlKGJveC54LCA1MDAsIHByb2dyZXNzLCBlYXNlLmVhc2VJbk91dFNpbmUpO1xuICogfSlcbiAqXG4gKiByYWZUaW1lci5vbkNvbXBsZXRlKCgpPT4ge1xuICogICAvLyBEbyBzb21ldGhpbmcgb24gY29tcGxldGlvbi5cbiAqIH0pXG4gKlxuICogLy8gU2V0IHRoZSBkdXJhdGlvbiBvZiB0aGUgcmFmVGltZXIgMzAwIGFuZCBzdGFydCBpdC5cbiAqIHJhZlRpbWVyLnNldER1cmF0aW9uKDMwMCk7XG4gKiByYWZUaW1lci5wbGF5KCk7XG4gKlxuICpcbiAqIC8vIElmIHlvdSB3YW50LCBzbG93IGRvd24gdGhlIEZQUy5cbiAqIHJhZlRpbWVyLnNldEZwcygxMCk7XG4gKlxuICogLy8gUGF1c2UgaWYgeW91IHdhbnQuXG4gKiB3aW5kb3cuc2V0VGltZW91dCgoKT0+IHtcbiAqICAgcmFmVGltZXIucGF1c2UoKTtcbiAqXG4gKiAgIC8vIFN0YXJ0IHBsYXlpbmcgYWdhaW4gZnJvbSBwYXVzZSBwb2ludFxuICogICBwbGF5QnV0dG9uLmFkZEV2ZW50TGlzdG5lcignY2xpY2snLCAoKT0+IHtcbiAqICAgICByYWZUaW1lci5wbGF5KCk7XG4gKiAgIH0sIHsgb25jZTogdHJ1ZX0pO1xuICpcbiAqICAgLy8gUmVzZXQgdG8gYmVnaW5uaW5nXG4gKiAgIHJlc2V0QnV0dG9uLmFkZEV2ZW50TGlzdG5lcignY2xpY2snLCAoKT0+IHtcbiAqICAgICByYWZUaW1lci5yZXNldCgpO1xuICogICAgIHJhZlRpbWVyLnBsYXkoKTtcbiAqICAgfSwgeyBvbmNlOiB0cnVlfSk7XG4gKlxuICogfSlcbiAqXG4gKiBUT0RPICh1eGRlcik7IFVwZGF0ZSB0aGlzIHRvIGV4dGVuZCBlbWl0IGVtaXR0ZXIuXG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIFJhZlRpbWVyIHtcbiAgICBjb25zdHJ1Y3RvcihyYWZMb29wKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgdXBvbiBlYWNoIHJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhZkxvb3AgPSByYWZMb29wO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGludGVybmFsIHJhZiBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7cHJpdmF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFmID0gbmV3IHJhZl8xLlJhZigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkxvb3BfKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGludGVybmFsIHJhZiBpbnN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7cHJpdmF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHByb2dyZXNzIG9mIHRoZSB0aW1lci4gVGhlIGFtb3VudCBvZiBwZXJjZW50YWdlXG4gICAgICAgICAqIHdlIGhhdmUgZWxhc3BlZCwgcmVwcmVzZW50ZWQgaW4gYSBudW1iZXIgYmV0d2VlbiAwLTEuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2YgdGltZSBpbiBtcyB0aGF0IGhhcyBlbGFwc2VkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpbWVFbGFwc2VkID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXN0IHBvaW50IGluIHdoaWNoIHRpbWUgd2FzIG1lYXN1cmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aW1lU25hcHNob3QgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciByYWYgaXMgYWN0aXZlLCB3ZSBhcmUgcGxheWluZyAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gQSBzaW5nbGUgY29tcGxldGUgY2FsbGJhY2suXG4gICAgICAgIHRoaXMuY29tcGxldGVDYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCBhbmltYXRpb24gbG9vcC5cbiAgICAgKi9cbiAgICBhbmltYXRpb25Mb29wXygpIHtcbiAgICAgICAgLy8gSW4gdGhlb3J5LCB3aGVuIHBsYXlpbmcgaXMgZmFsc2UsIHRoaXMgbG9vcCBzaG91bGRuJ3RcbiAgICAgICAgLy8gcnVuIGJ1dCBzYWZlIGd1YXJkLlxuICAgICAgICBpZiAoIXRoaXMucGxheWluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9uIGVhY2ggcmFmIGN5Y2xlLCB3ZSB3YW50IHRvIGNhbGN1bGF0ZVxuICAgICAgICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgdGhhdCBoYXMgZWxhcHNlZCBzaW5jZVxuICAgICAgICAvLyB0aGUgbGFzdCBrbm93biB0aW1lU25hcHNob3QgKHdoZW4gdGhlIHRpbWVcbiAgICAgICAgLy8gd2FzIHJlY29yZGVkKS5cbiAgICAgICAgLy8gV2UgYWRkIHRoaXMgdG8gdGhlIHRvdGFsIHZhbHVlIG9mIHRpbWUgZWxhcHNlZC5cbiAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdFRpbWVTbmFwc2hvdCA9IHRpbWVfMS50aW1lLnRpbWVEaWZmTXModGhpcy50aW1lU25hcHNob3QsIHRpbWVfMS50aW1lLm5vdygpKTtcbiAgICAgICAgdGhpcy50aW1lRWxhcHNlZCArPSB0aW1lU2luY2VMYXN0VGltZVNuYXBzaG90O1xuICAgICAgICB0aGlzLnByb2dyZXNzID0gbWF0aGZfMS5tYXRoZi5jbGFtcEFzUGVyY2VudCh0aGlzLnRpbWVFbGFwc2VkIC8gdGhpcy5kdXJhdGlvbik7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc25hcHNob3QuXG4gICAgICAgIHRoaXMudGltZVNuYXBzaG90ID0gdGltZV8xLnRpbWUubm93KCk7XG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCBhdCAxMDAlIGNhbGwgdGhlIHJhZiBsb29wLlxuICAgICAgICBpZiAodGhpcy5wcm9ncmVzcyA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMucmFmTG9vcCAmJiB0aGlzLnJhZkxvb3AodGhpcy5wcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSdW4gdGhlIG1haW4gdXBkYXRlIGxvb3Agb25lIG1vcmUgdGltZSBhcyBjb21wbGV0aW9uLlxuICAgICAgICAgICAgdGhpcy5yYWZMb29wICYmIHRoaXMucmFmTG9vcCgxKTtcbiAgICAgICAgICAgIC8vIENvbXBsZXRlXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnJhZi5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlQ2FsbGJhY2sgJiYgdGhpcy5jb21wbGV0ZUNhbGxiYWNrKDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZHVyYXRpb24gb2YgdGhlIHJhZiBsb29wIGluIG1zLlxuICAgICAqIEBwYXJhbSBkdXJhdGlvbiAgVGhlIGR1cmF0aW9uIGluIG1zLlxuICAgICAqL1xuICAgIHNldER1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZnBzIG9mIHJhZiBsb29wLi5cbiAgICAgKi9cbiAgICBzZXRGcHMoZnBzKSB7XG4gICAgICAgIHRoaXMucmFmLnNldEZwcyhmcHMpO1xuICAgIH1cbiAgICBvbkNvbXBsZXRlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBwbGF5aW5nIHRoZSByYWZUaW1lci5cbiAgICAgKi9cbiAgICBwbGF5KCkge1xuICAgICAgICBpZiAodGhpcy5wbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50aW1lU25hcHNob3QgPSB0aW1lXzEudGltZS5ub3coKTtcbiAgICAgICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFJlc2V0cyB0aGUgUkFGIHRpbWVyLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yYWYuc3RvcCgpO1xuICAgICAgICB0aGlzLnRpbWVFbGFwc2VkID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFBhdXNlcyB0aGUgcmFmIFRpbWVyLlxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnJhZi5zdG9wKCk7XG4gICAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnJhZi5kaXNwb3NlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5SYWZUaW1lciA9IFJhZlRpbWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFmLXRpbWVyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/raf/raf-timer.js\n");

/***/ }),

/***/ "./lib/raf/raf.js":
/*!************************!*\
  !*** ./lib/raf/raf.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Raf = void 0;\nconst time_1 = __webpack_require__(/*! ../time/time */ \"./lib/time/time.js\");\nconst element_visibility_1 = __webpack_require__(/*! ../dom/element-visibility */ \"./lib/dom/element-visibility.js\");\n/**\n * A class that creates a RAF loop and calls a specific callback.  Setting the\n * frame rate will throttle the animation.\n *\n * Example usage;\n * ```ts\n * var raf = new Raf((frame, lastUpdateTime, stop)=> {\n *   console.log('this runs on request animation frame');\n *   // The current FPS.\n *   console.log(raf.getCurrentFps());\n * });\n * raf.start();\n *\n * // Later to stop raf.\n * raf.stop();\n *\n * // Set the FPS\n * raf.setFps(30);\n * raf.start();\n *\n *\n * // Add or remove listeners\n * var onRaf = ()=> {\n *   console.log('hello')\n * }\n * raf.watch(onRaf);\n * raf.unwatch(onRaf);\n *\n * // Clock functions: Delta and elapsed time.\n * var raf2 = new Raf((frame, lastUpdateTime, stop)=> {\n *   // Gets the time when raf started.\n *   const startTime = raf.getStartTime();\n *   // Gets the delta between the last update\n *   const delta = raf.getDelta();\n *   // Time elapsed\n *   const elapsedTime = raf.getElapsedTime();\n * }).start();\n *\n * ```\n *\n * RunWhen option.\n * You can pass a run condition to limit raf only when the condition resolve\n * to true.  This is useful to cull unncessary requests.\n * An example is to use elementVisility to only run RAF when an element is\n * in view and stop raf when it goes out of view.\n *\n *\n * ```ts\n *\n * // Runs only when the window is small.\n * var raf = new Raf(()=> {\n *   console.log('this runs when scren size is less than 1000');\n * });\n * raf.runWhen(()=> { window.innerWidth < 1000});\n * raf.start();\n *\n *\n *\n * // Runs only when myElement is in view.\n * // Option 1: You can use runWhen condition\n *\n *\n * let ev = elementVisibility.inview(myElement);\n * var raf = new Raf(() => {\n *    console.log('a raf that runs when element is in view.');\n * });\n * raf.runWhen(() => {\n *    return ev.state().inview;\n * });\n *\n * // This normally works fine but elementVisibility has a split second to\n * // boot up.\n * raf.start();\n *\n * // if you want to be sure to only run RAF when ev is ready do this:\n * ev.readyPromise.then(()=> {\n *   raf.start();\n * })\n *\n * ```\n *\n * // Runs only when myElement is in view.\n * // Option 2: You can use runWhenElementIsInview option.\n *\n * ```\n * var raf = new Raf(()=> {\n *   ...\n * })\n *\n *\n * // Set element and run when it's ready.\n * raf.runWhenElementIsInview(\n *    document.getElementById(\"myelement\"),\n *    {\n *      rootMargin: '500px 0px 500px 0px'\n *    }\n * ).then(()=> {\n *    raf.start();\n * })\n *\n *\n * ```\n *\n *\n *\n * # Batch read / write.\n * Batch write / read.  To batch write and read, wrap your methods in\n * read and write calls.  Read / Write calls uses the degu raf registry\n * so your reads or writes can get delayed by one raf cycle.\n * ```\n * var raf = new Raf(()=> {\n *    raf.read(()=> {\n *        this.height = element.offsetHeight;\n *    })\n *\n *    raf.write(()=> {\n *        element.style.height = this.height + 20 + 'px';\n *    })\n * })\n *\n * ```\n *\n * You can also create a read / write only raf by passing\n * no rafLoop to the constructor.\n *\n * ```\n * var raf = new Raf();\n *    raf.read(()=> {\n *        this.height = element.offsetHeight;\n *    })\n *\n *    raf.write(()=> {\n *        element.style.height = this.height + 20 + 'px';\n *    })\n *\n * ```\n *\n *\n * If you want read / writes to NOT cull, you can set the\n * read write mode.    This is needed if you pass a rafLoop\n * to the constructor but additionally, want to use the read\n * write outside your loop even when your raf is stopped.\n * ```\n * var raf = new Raf(()=> {\n *    raf.read(()=> {\n *        this.height = element.offsetHeight;\n *    })\n *\n *    raf.write(()=> {\n *        element.style.height = this.height + 20 + 'px';\n *    })\n * })\n *\n * // Raf is stopped.\n * raf.stop();\n *\n * // This won't work.\n * raf.write(()=> {\n * ...\n * })\n *\n *\n * raf.setReadWriteMode(true);\n * // Now it will work even when raf is stopped.\n * raf.write(()=> {\n * ...\n * })\n *\n * ```\n *\n *\n * @noInheritDoc\n * @class\n */\nclass Raf {\n    /**\n     * @param {Function} rafLoop  Optional function to be called on each\n     *     request animation frame.\n     * @constructor\n     */\n    constructor(rafLoop) {\n        this.isReadWriteOnly = false;\n        this.callbacks = [];\n        this.isDisposed = false;\n        /**\n         * The internal reference to request animation frame.\n         * @type {private}\n         */\n        this.raf_ = null;\n        /**\n         * The current animation frame.\n         * @type {number}\n         * @public\n         */\n        this.frame = null;\n        /**\n         * The last updated time.\n         * @type {number}\n         * @public\n         */\n        this.lastUpdateTime = 0;\n        /**\n         * The frame rate. Defaults to 0 in which case RAF is not throttled.\n         * @type {number}\n         */\n        this.fps = 0;\n        /**\n         * The current frame rate.\n         * @type {number}\n         */\n        this.currentFps = 0;\n        /**\n         * Whether raf is looping.\n         * @type {boolean}\n         */\n        this.isPlaying = false;\n        /**\n         * Whether we are already running raf.\n         */\n        this.isRunningRaf = false;\n        /**\n         * A collection of callbacks to be called on raf.\n         * @type {Array<Function>}\n         */\n        this.callbacks = [];\n        /**\n         * An optional condition in which if set and resolved to false,\n         * the raf loop gets cull.ed\n         * @type {Function}\n         */\n        this.runCondition = null;\n        /**\n         * The delta time in ms between the last frame update.\n         */\n        this.delta = 0;\n        /**\n         * The elapsed time instantiation.  This serves as a clock.\n         * Note this is based on seconds not ms.\n         */\n        this.elaspedTime = 0;\n        /**\n         * The last known start time of raf.\n         */\n        this.startTime = 0;\n        if (rafLoop) {\n            this.watch(rafLoop);\n        }\n        else {\n            // If no rafLoop was defined, this raf is being\n            // used for readWrites only.\n            this.isReadWriteOnly = true;\n        }\n        // Register self to global registry.\n        if (window.DEGU_RAF_REGISTRY) {\n            window.DEGU_RAF_REGISTRY.register(this);\n        }\n    }\n    /**\n     * Adds a raf listener\n     * @param\n     */\n    watch(callback) {\n        this.callbacks.push(callback);\n    }\n    /**\n     * Sets the read write mode.\n     * @param value\n     */\n    setReadWriteMode(value) {\n        this.isReadWriteOnly = value;\n    }\n    /**\n     * Adds a one time read callback executed by the global degu raf registry.\n     * This allows you to batch read calls.\n     * @param callback\n     */\n    preRead(callback) {\n        window.DEGU_RAF_REGISTRY &&\n            window.DEGU_RAF_REGISTRY.addOneTimePreRead({\n                callback: callback,\n                raf: this,\n            });\n    }\n    /**\n     * Adds a one time read callback executed by the global degu raf registry.\n     * This allows you to batch read calls.\n     * @param callback\n     */\n    read(callback) {\n        window.DEGU_RAF_REGISTRY &&\n            window.DEGU_RAF_REGISTRY.addOneTimeRead({\n                callback: callback,\n                raf: this,\n            });\n    }\n    /**\n     * Adds a one time write callback executed by the global degu raf registry.\n     * This allows you to batch write calls.\n     * @param callback\n     */\n    write(callback) {\n        window.DEGU_RAF_REGISTRY &&\n            window.DEGU_RAF_REGISTRY.addOneTimeWrite({\n                callback: callback,\n                raf: this,\n            });\n    }\n    /**\n     * Adds a one time post write callback executed by the global degu raf registry.\n     * This allows you to batch post write calls.\n     * @param callback\n     */\n    postWrite(callback) {\n        window.DEGU_RAF_REGISTRY &&\n            window.DEGU_RAF_REGISTRY.addOneTimePostWrite({\n                callback: callback,\n                raf: this,\n            });\n    }\n    /**\n     * Removes a progress listener.\n     * @param {Function}\n     */\n    unwatch(callbackToRemove) {\n        this.callbacks = this.callbacks.filter(callback => {\n            return callback === callbackToRemove;\n        });\n    }\n    /**\n     * Sets a function to execute on each raf loop.  If the condition resolves\n     * to true, the raf loop callbacks will be executed.  If false, the raf\n     * loop is culled.\n     * @param callbackCondition\n     */\n    runWhen(callbackCondition) {\n        this.runCondition = callbackCondition;\n    }\n    /**\n     * Allows you to pass an option to tell this raf to execute only when the\n     * given element is in the viewport.  Optionally pass intersection observer\n     * options.\n     *\n     * Note that this still requires you to start the raf.  You can do this\n     * with the promise that the method returns (resolved when ev is ready)\n     * or at a later time.\n     *\n     * Note it's recommended that you add a rootMargin to your ev settings\n     * if need to do offscreen processing.\n     *\n     * ```\n     * var raf = new Raf(()=> {\n     *   ...\n     * })\n     *\n     *\n     * // Set element and run when it's ready.\n     * raf.runWhenElementIsInview(\n     *    document.getElementById(\"myelement\"),\n     *    {\n     *      rootMargin: '300px 0px 300px 0px'\n     *    }\n     * ).then(()=> {\n     *    raf.start();\n     * })\n     *\n     *\n     * ```\n     *\n     */\n    runWhenElementIsInview(element, intersectionObserverOptions) {\n        // Dispose of any previous instances if this is being called a second\n        // time.\n        this.ev && this.ev.dispose();\n        this.runCondition = null;\n        this.ev = element_visibility_1.elementVisibility.inview(element, intersectionObserverOptions || {});\n        // Set the run when condition.\n        this.runWhen(() => {\n            return this.ev && this.ev.state().inview;\n        });\n        return this.ev.readyPromise;\n    }\n    /**\n     * Sets the fps .\n     */\n    setFps(fps) {\n        this.fps = fps;\n    }\n    /**\n     * Starts the RAF animation loop.\n     * @param {boolean} Whether to force a start.\n     */\n    start(force = false) {\n        if (!force && this.isPlaying) {\n            return;\n        }\n        this.startTime = (typeof performance === 'undefined'\n            ? Date\n            : performance).now();\n        this.animationLoop_();\n        this.isPlaying = true;\n    }\n    /**\n     * Stops the RAF animation loop.\n     */\n    stop() {\n        this.isPlaying = false;\n        window.cancelAnimationFrame(this.raf_);\n        this.isRunningRaf = false;\n    }\n    dispose() {\n        this.ev && this.ev.dispose();\n        this.callbacks = [];\n        this.isDisposed = true;\n        this.stop();\n        // Deregister self to global registry.\n        window.DEGU_RAF_REGISTRY && window.DEGU_RAF_REGISTRY.unregister(this);\n    }\n    /**\n     * Gets the delta in ms between the last executed raf update.\n     * @param inSeconds Whether to acquire the delta time in seconds.  Defaults\n     *   to ms.\n     */\n    getDelta(inSeconds) {\n        if (inSeconds) {\n            return this.delta / 1000;\n        }\n        else {\n            return this.delta;\n        }\n    }\n    /**\n     * Gets the elasped time since raf started.\n     */\n    getElapsedTime() {\n        return this.elaspedTime;\n    }\n    /**\n     * Gets the time (Date) when raf started.\n     */\n    getStartTime() {\n        return this.startTime;\n    }\n    /**\n     * Gets the current frame rate that raf is running at.  Useful for debugging.\n     */\n    getCurrentFps() {\n        return this.currentFps;\n    }\n    /**\n     * The internal animation loop.\n     */\n    animationLoop_() {\n        if (this.isRunningRaf) {\n            return;\n        }\n        this.raf_ = window.requestAnimationFrame((frame) => {\n            this.frame = frame;\n            this.isRunningRaf = false;\n            this.animationLoop_();\n        });\n        this.isRunningRaf = true;\n        if (this.lastUpdateTime) {\n            const current = time_1.time.now();\n            const elapsed = current - this.lastUpdateTime;\n            this.delta = elapsed;\n            this.elaspedTime += elapsed / 1000;\n            const fps = this.fps === 0 ? 0 : 1000 / this.fps;\n            this.currentFps = 1000 / elapsed;\n            if (elapsed > fps) {\n                this.callbacks &&\n                    this.callbacks.forEach(callback => {\n                        const callCallback = () => {\n                            callback(this.frame, this.lastUpdateTime, elapsed, () => {\n                                this.stop();\n                            });\n                        };\n                        if (this.runCondition) {\n                            this.runCondition() && callCallback();\n                        }\n                        else {\n                            callCallback();\n                        }\n                    });\n                this.lastUpdateTime = time_1.time.now();\n            }\n        }\n        if (!this.lastUpdateTime) {\n            this.lastUpdateTime = time_1.time.now();\n        }\n    }\n}\nexports.Raf = Raf;\n/**\n * The idea behind the rafRegistry is to be able to batch read and write\n * raf calls similar to fastDom or toolBox mutate.\n *\n * In order to achieve this performance boosts, read and write calls need\n * to be executed in order and therefore, we need a registry to maintain\n * all raf instances on the page.\n *\n * When instantiated, each RAF adds itself to the registry and can be run / stopped\n * normally.\n *\n * Within it's raf loop, it can call a raf.read(callback); raf.write(callback);\n * which ends up getting executed on the RafRegistry event loop.\n *\n * raf.read(callback) and raf.write(callback) are ONE-time so must be recalled\n * on each raf loop.  It is basically saying, read this on the next raf loop once\n * or write it on the next raf loop.\n *\n * To use this system, simply use add read and write calls in your raf loop.\n *\n *\n * Life cycle:\n * - preread\n * - read\n * - write\n * - postWrite\n *\n * ```\n * var raf = new Raf(()=> {\n *    raf.preRead(()=> {\n *        this.height = element.offsetHeight;\n *    })\n *\n *    raf.read(()=> {\n *        this.height = element.offsetHeight;\n *    })\n *\n *    raf.write(()=> {\n *        element.style.height = this.height + 20 + 'px';\n *    })\n *\n *    // Somewhat rare but executed after all writes.\n *    raf.postWrite(()=> {\n *        element.style.height = this.height + 20 + 'px';\n *    })\n * })\n * ```\n *\n *\n * You may also to use raf.write and raf.read outside a\n * rafLoop.  In this case, you can just pass a null to the constructor.\n *\n * ```\n * var raf = new Raf();\n *\n * // Somewhere\n *  raf.read(()=> {\n *      this.height = element.offsetHeight;\n *  })\n *\n *\n *  raf.write(()=> {\n *      element.style.height = this.height + 20 + 'px';\n *  })\n *\n *\n * ```\n *\n */\nclass RafRegistry {\n    constructor() {\n        this.flushScheduled = false;\n        this.preReads = [];\n        this.reads = [];\n        this.writes = [];\n        this.postWrites = [];\n        this.rafs = [];\n    }\n    static runRafCallbacks(callbacks) {\n        // Keep consistent arrays so that scheduled function can schedule\n        // another function in the same step.\n        // Important so that a read function can call another function that\n        // protects itself in its own read function, in case it is called\n        // through another code execution path.\n        while (callbacks.length) {\n            const registryObject = callbacks.splice(0, 1)[0];\n            if (!registryObject.raf.isDisposed &&\n                (registryObject.raf.isPlaying || registryObject.raf.isReadWriteOnly)) {\n                registryObject.callback();\n            }\n        }\n    }\n    start() {\n        if (this.flushScheduled) {\n            return;\n        }\n        this.flushScheduled = true;\n        requestAnimationFrame(() => {\n            this.runRaf();\n        });\n    }\n    runRaf() {\n        // Open console and add:\n        //\n        // DEGU_RAF_REGISTRY_DEBUG = true;\n        //\n        if (window.DEGU_RAF_REGISTRY_DEBUG) {\n            console.log('Running raf', this.reads.length, this.writes.length);\n        }\n        // Execute preReads.\n        RafRegistry.runRafCallbacks(this.preReads);\n        // Execute reads.\n        RafRegistry.runRafCallbacks(this.reads);\n        // Execute writes.\n        RafRegistry.runRafCallbacks(this.writes);\n        // Execute postWrites.\n        RafRegistry.runRafCallbacks(this.postWrites);\n        this.flushScheduled = false;\n    }\n    /**\n     * Add a single addOneTimePreRead to the batch read / write system.\n     * @param read\n     */\n    addOneTimePreRead(read) {\n        this.preReads.push(read);\n        this.start();\n    }\n    /**\n     * Add a single addOneTimeRead to the batch read / write system.\n     * @param read\n     */\n    addOneTimeRead(read) {\n        this.reads.push(read);\n        this.start();\n    }\n    /**\n     * Add a single addOneTimeWrite to the batch read / write system.\n     * @param read\n     */\n    addOneTimeWrite(write) {\n        this.writes.push(write);\n        this.start();\n    }\n    /**\n     * Add a single addOneTimeWrite to the batch read / write system.\n     * @param read\n     */\n    addOneTimePostWrite(postWrite) {\n        this.postWrites.push(postWrite);\n        this.start();\n    }\n    /**\n     * Gets the count of all active rafs.\n     *\n     * In dev console:\n     * ```\n     * DEGU_RAF_REGISTRY.getActiveRafCount();\n     * ```\n     */\n    getActiveRafCount() {\n        return this.rafs.filter(r => {\n            return r.isPlaying;\n        }).length;\n    }\n    /**\n     * Gets the count of rafs.\n     *\n     * In dev console:\n     * ```\n     * DEGU_RAF_REGISTRY.getRafCount();\n     * ```\n     */\n    getRafCount() {\n        return this.rafs.length;\n    }\n    register(raf) {\n        this.rafs.push(raf);\n    }\n    unregister(raf) {\n        this.rafs = this.rafs.filter(r => {\n            return r === raf;\n        });\n    }\n}\n// Create raf registry as a global.\nif (window && !window.DEGU_RAF_REGISTRY) {\n    window.DEGU_RAF_REGISTRY = new RafRegistry();\n}\n//# sourceMappingURL=raf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvcmFmL3JhZi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi9yYWYvcmFmLmpzPzllNTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJhZiA9IHZvaWQgMDtcbmNvbnN0IHRpbWVfMSA9IHJlcXVpcmUoXCIuLi90aW1lL3RpbWVcIik7XG5jb25zdCBlbGVtZW50X3Zpc2liaWxpdHlfMSA9IHJlcXVpcmUoXCIuLi9kb20vZWxlbWVudC12aXNpYmlsaXR5XCIpO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgY3JlYXRlcyBhIFJBRiBsb29wIGFuZCBjYWxscyBhIHNwZWNpZmljIGNhbGxiYWNrLiAgU2V0dGluZyB0aGVcbiAqIGZyYW1lIHJhdGUgd2lsbCB0aHJvdHRsZSB0aGUgYW5pbWF0aW9uLlxuICpcbiAqIEV4YW1wbGUgdXNhZ2U7XG4gKiBgYGB0c1xuICogdmFyIHJhZiA9IG5ldyBSYWYoKGZyYW1lLCBsYXN0VXBkYXRlVGltZSwgc3RvcCk9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCd0aGlzIHJ1bnMgb24gcmVxdWVzdCBhbmltYXRpb24gZnJhbWUnKTtcbiAqICAgLy8gVGhlIGN1cnJlbnQgRlBTLlxuICogICBjb25zb2xlLmxvZyhyYWYuZ2V0Q3VycmVudEZwcygpKTtcbiAqIH0pO1xuICogcmFmLnN0YXJ0KCk7XG4gKlxuICogLy8gTGF0ZXIgdG8gc3RvcCByYWYuXG4gKiByYWYuc3RvcCgpO1xuICpcbiAqIC8vIFNldCB0aGUgRlBTXG4gKiByYWYuc2V0RnBzKDMwKTtcbiAqIHJhZi5zdGFydCgpO1xuICpcbiAqXG4gKiAvLyBBZGQgb3IgcmVtb3ZlIGxpc3RlbmVyc1xuICogdmFyIG9uUmFmID0gKCk9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdoZWxsbycpXG4gKiB9XG4gKiByYWYud2F0Y2gob25SYWYpO1xuICogcmFmLnVud2F0Y2gob25SYWYpO1xuICpcbiAqIC8vIENsb2NrIGZ1bmN0aW9uczogRGVsdGEgYW5kIGVsYXBzZWQgdGltZS5cbiAqIHZhciByYWYyID0gbmV3IFJhZigoZnJhbWUsIGxhc3RVcGRhdGVUaW1lLCBzdG9wKT0+IHtcbiAqICAgLy8gR2V0cyB0aGUgdGltZSB3aGVuIHJhZiBzdGFydGVkLlxuICogICBjb25zdCBzdGFydFRpbWUgPSByYWYuZ2V0U3RhcnRUaW1lKCk7XG4gKiAgIC8vIEdldHMgdGhlIGRlbHRhIGJldHdlZW4gdGhlIGxhc3QgdXBkYXRlXG4gKiAgIGNvbnN0IGRlbHRhID0gcmFmLmdldERlbHRhKCk7XG4gKiAgIC8vIFRpbWUgZWxhcHNlZFxuICogICBjb25zdCBlbGFwc2VkVGltZSA9IHJhZi5nZXRFbGFwc2VkVGltZSgpO1xuICogfSkuc3RhcnQoKTtcbiAqXG4gKiBgYGBcbiAqXG4gKiBSdW5XaGVuIG9wdGlvbi5cbiAqIFlvdSBjYW4gcGFzcyBhIHJ1biBjb25kaXRpb24gdG8gbGltaXQgcmFmIG9ubHkgd2hlbiB0aGUgY29uZGl0aW9uIHJlc29sdmVcbiAqIHRvIHRydWUuICBUaGlzIGlzIHVzZWZ1bCB0byBjdWxsIHVubmNlc3NhcnkgcmVxdWVzdHMuXG4gKiBBbiBleGFtcGxlIGlzIHRvIHVzZSBlbGVtZW50VmlzaWxpdHkgdG8gb25seSBydW4gUkFGIHdoZW4gYW4gZWxlbWVudCBpc1xuICogaW4gdmlldyBhbmQgc3RvcCByYWYgd2hlbiBpdCBnb2VzIG91dCBvZiB2aWV3LlxuICpcbiAqXG4gKiBgYGB0c1xuICpcbiAqIC8vIFJ1bnMgb25seSB3aGVuIHRoZSB3aW5kb3cgaXMgc21hbGwuXG4gKiB2YXIgcmFmID0gbmV3IFJhZigoKT0+IHtcbiAqICAgY29uc29sZS5sb2coJ3RoaXMgcnVucyB3aGVuIHNjcmVuIHNpemUgaXMgbGVzcyB0aGFuIDEwMDAnKTtcbiAqIH0pO1xuICogcmFmLnJ1bldoZW4oKCk9PiB7IHdpbmRvdy5pbm5lcldpZHRoIDwgMTAwMH0pO1xuICogcmFmLnN0YXJ0KCk7XG4gKlxuICpcbiAqXG4gKiAvLyBSdW5zIG9ubHkgd2hlbiBteUVsZW1lbnQgaXMgaW4gdmlldy5cbiAqIC8vIE9wdGlvbiAxOiBZb3UgY2FuIHVzZSBydW5XaGVuIGNvbmRpdGlvblxuICpcbiAqXG4gKiBsZXQgZXYgPSBlbGVtZW50VmlzaWJpbGl0eS5pbnZpZXcobXlFbGVtZW50KTtcbiAqIHZhciByYWYgPSBuZXcgUmFmKCgpID0+IHtcbiAqICAgIGNvbnNvbGUubG9nKCdhIHJhZiB0aGF0IHJ1bnMgd2hlbiBlbGVtZW50IGlzIGluIHZpZXcuJyk7XG4gKiB9KTtcbiAqIHJhZi5ydW5XaGVuKCgpID0+IHtcbiAqICAgIHJldHVybiBldi5zdGF0ZSgpLmludmlldztcbiAqIH0pO1xuICpcbiAqIC8vIFRoaXMgbm9ybWFsbHkgd29ya3MgZmluZSBidXQgZWxlbWVudFZpc2liaWxpdHkgaGFzIGEgc3BsaXQgc2Vjb25kIHRvXG4gKiAvLyBib290IHVwLlxuICogcmFmLnN0YXJ0KCk7XG4gKlxuICogLy8gaWYgeW91IHdhbnQgdG8gYmUgc3VyZSB0byBvbmx5IHJ1biBSQUYgd2hlbiBldiBpcyByZWFkeSBkbyB0aGlzOlxuICogZXYucmVhZHlQcm9taXNlLnRoZW4oKCk9PiB7XG4gKiAgIHJhZi5zdGFydCgpO1xuICogfSlcbiAqXG4gKiBgYGBcbiAqXG4gKiAvLyBSdW5zIG9ubHkgd2hlbiBteUVsZW1lbnQgaXMgaW4gdmlldy5cbiAqIC8vIE9wdGlvbiAyOiBZb3UgY2FuIHVzZSBydW5XaGVuRWxlbWVudElzSW52aWV3IG9wdGlvbi5cbiAqXG4gKiBgYGBcbiAqIHZhciByYWYgPSBuZXcgUmFmKCgpPT4ge1xuICogICAuLi5cbiAqIH0pXG4gKlxuICpcbiAqIC8vIFNldCBlbGVtZW50IGFuZCBydW4gd2hlbiBpdCdzIHJlYWR5LlxuICogcmFmLnJ1bldoZW5FbGVtZW50SXNJbnZpZXcoXG4gKiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15ZWxlbWVudFwiKSxcbiAqICAgIHtcbiAqICAgICAgcm9vdE1hcmdpbjogJzUwMHB4IDBweCA1MDBweCAwcHgnXG4gKiAgICB9XG4gKiApLnRoZW4oKCk9PiB7XG4gKiAgICByYWYuc3RhcnQoKTtcbiAqIH0pXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICogIyBCYXRjaCByZWFkIC8gd3JpdGUuXG4gKiBCYXRjaCB3cml0ZSAvIHJlYWQuICBUbyBiYXRjaCB3cml0ZSBhbmQgcmVhZCwgd3JhcCB5b3VyIG1ldGhvZHMgaW5cbiAqIHJlYWQgYW5kIHdyaXRlIGNhbGxzLiAgUmVhZCAvIFdyaXRlIGNhbGxzIHVzZXMgdGhlIGRlZ3UgcmFmIHJlZ2lzdHJ5XG4gKiBzbyB5b3VyIHJlYWRzIG9yIHdyaXRlcyBjYW4gZ2V0IGRlbGF5ZWQgYnkgb25lIHJhZiBjeWNsZS5cbiAqIGBgYFxuICogdmFyIHJhZiA9IG5ldyBSYWYoKCk9PiB7XG4gKiAgICByYWYucmVhZCgoKT0+IHtcbiAqICAgICAgICB0aGlzLmhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICogICAgfSlcbiAqXG4gKiAgICByYWYud3JpdGUoKCk9PiB7XG4gKiAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIDIwICsgJ3B4JztcbiAqICAgIH0pXG4gKiB9KVxuICpcbiAqIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBjcmVhdGUgYSByZWFkIC8gd3JpdGUgb25seSByYWYgYnkgcGFzc2luZ1xuICogbm8gcmFmTG9vcCB0byB0aGUgY29uc3RydWN0b3IuXG4gKlxuICogYGBgXG4gKiB2YXIgcmFmID0gbmV3IFJhZigpO1xuICogICAgcmFmLnJlYWQoKCk9PiB7XG4gKiAgICAgICAgdGhpcy5oZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAqICAgIH0pXG4gKlxuICogICAgcmFmLndyaXRlKCgpPT4ge1xuICogICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAyMCArICdweCc7XG4gKiAgICB9KVxuICpcbiAqIGBgYFxuICpcbiAqXG4gKiBJZiB5b3Ugd2FudCByZWFkIC8gd3JpdGVzIHRvIE5PVCBjdWxsLCB5b3UgY2FuIHNldCB0aGVcbiAqIHJlYWQgd3JpdGUgbW9kZS4gICAgVGhpcyBpcyBuZWVkZWQgaWYgeW91IHBhc3MgYSByYWZMb29wXG4gKiB0byB0aGUgY29uc3RydWN0b3IgYnV0IGFkZGl0aW9uYWxseSwgd2FudCB0byB1c2UgdGhlIHJlYWRcbiAqIHdyaXRlIG91dHNpZGUgeW91ciBsb29wIGV2ZW4gd2hlbiB5b3VyIHJhZiBpcyBzdG9wcGVkLlxuICogYGBgXG4gKiB2YXIgcmFmID0gbmV3IFJhZigoKT0+IHtcbiAqICAgIHJhZi5yZWFkKCgpPT4ge1xuICogICAgICAgIHRoaXMuaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gKiAgICB9KVxuICpcbiAqICAgIHJhZi53cml0ZSgoKT0+IHtcbiAqICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgMjAgKyAncHgnO1xuICogICAgfSlcbiAqIH0pXG4gKlxuICogLy8gUmFmIGlzIHN0b3BwZWQuXG4gKiByYWYuc3RvcCgpO1xuICpcbiAqIC8vIFRoaXMgd29uJ3Qgd29yay5cbiAqIHJhZi53cml0ZSgoKT0+IHtcbiAqIC4uLlxuICogfSlcbiAqXG4gKlxuICogcmFmLnNldFJlYWRXcml0ZU1vZGUodHJ1ZSk7XG4gKiAvLyBOb3cgaXQgd2lsbCB3b3JrIGV2ZW4gd2hlbiByYWYgaXMgc3RvcHBlZC5cbiAqIHJhZi53cml0ZSgoKT0+IHtcbiAqIC4uLlxuICogfSlcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICogQG5vSW5oZXJpdERvY1xuICogQGNsYXNzXG4gKi9cbmNsYXNzIFJhZiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmFmTG9vcCAgT3B0aW9uYWwgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGVhY2hcbiAgICAgKiAgICAgcmVxdWVzdCBhbmltYXRpb24gZnJhbWUuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmFmTG9vcCkge1xuICAgICAgICB0aGlzLmlzUmVhZFdyaXRlT25seSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbnRlcm5hbCByZWZlcmVuY2UgdG8gcmVxdWVzdCBhbmltYXRpb24gZnJhbWUuXG4gICAgICAgICAqIEB0eXBlIHtwcml2YXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWZfID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mcmFtZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFzdCB1cGRhdGVkIHRpbWUuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZVRpbWUgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZyYW1lIHJhdGUuIERlZmF1bHRzIHRvIDAgaW4gd2hpY2ggY2FzZSBSQUYgaXMgbm90IHRocm90dGxlZC5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZnBzID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IGZyYW1lIHJhdGUuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRGcHMgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciByYWYgaXMgbG9vcGluZy5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB3ZSBhcmUgYWxyZWFkeSBydW5uaW5nIHJhZi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNSdW5uaW5nUmFmID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIGJlIGNhbGxlZCBvbiByYWYuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxGdW5jdGlvbj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb3B0aW9uYWwgY29uZGl0aW9uIGluIHdoaWNoIGlmIHNldCBhbmQgcmVzb2x2ZWQgdG8gZmFsc2UsXG4gICAgICAgICAqIHRoZSByYWYgbG9vcCBnZXRzIGN1bGwuZWRcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ydW5Db25kaXRpb24gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRlbHRhIHRpbWUgaW4gbXMgYmV0d2VlbiB0aGUgbGFzdCBmcmFtZSB1cGRhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbHRhID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlbGFwc2VkIHRpbWUgaW5zdGFudGlhdGlvbi4gIFRoaXMgc2VydmVzIGFzIGEgY2xvY2suXG4gICAgICAgICAqIE5vdGUgdGhpcyBpcyBiYXNlZCBvbiBzZWNvbmRzIG5vdCBtcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWxhc3BlZFRpbWUgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhc3Qga25vd24gc3RhcnQgdGltZSBvZiByYWYuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgICAgIGlmIChyYWZMb29wKSB7XG4gICAgICAgICAgICB0aGlzLndhdGNoKHJhZkxvb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gcmFmTG9vcCB3YXMgZGVmaW5lZCwgdGhpcyByYWYgaXMgYmVpbmdcbiAgICAgICAgICAgIC8vIHVzZWQgZm9yIHJlYWRXcml0ZXMgb25seS5cbiAgICAgICAgICAgIHRoaXMuaXNSZWFkV3JpdGVPbmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWdpc3RlciBzZWxmIHRvIGdsb2JhbCByZWdpc3RyeS5cbiAgICAgICAgaWYgKHdpbmRvdy5ERUdVX1JBRl9SRUdJU1RSWSkge1xuICAgICAgICAgICAgd2luZG93LkRFR1VfUkFGX1JFR0lTVFJZLnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSByYWYgbGlzdGVuZXJcbiAgICAgKiBAcGFyYW1cbiAgICAgKi9cbiAgICB3YXRjaChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcmVhZCB3cml0ZSBtb2RlLlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFJlYWRXcml0ZU1vZGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pc1JlYWRXcml0ZU9ubHkgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG9uZSB0aW1lIHJlYWQgY2FsbGJhY2sgZXhlY3V0ZWQgYnkgdGhlIGdsb2JhbCBkZWd1IHJhZiByZWdpc3RyeS5cbiAgICAgKiBUaGlzIGFsbG93cyB5b3UgdG8gYmF0Y2ggcmVhZCBjYWxscy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBwcmVSZWFkKGNhbGxiYWNrKSB7XG4gICAgICAgIHdpbmRvdy5ERUdVX1JBRl9SRUdJU1RSWSAmJlxuICAgICAgICAgICAgd2luZG93LkRFR1VfUkFGX1JFR0lTVFJZLmFkZE9uZVRpbWVQcmVSZWFkKHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgcmFmOiB0aGlzLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBvbmUgdGltZSByZWFkIGNhbGxiYWNrIGV4ZWN1dGVkIGJ5IHRoZSBnbG9iYWwgZGVndSByYWYgcmVnaXN0cnkuXG4gICAgICogVGhpcyBhbGxvd3MgeW91IHRvIGJhdGNoIHJlYWQgY2FsbHMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG4gICAgcmVhZChjYWxsYmFjaykge1xuICAgICAgICB3aW5kb3cuREVHVV9SQUZfUkVHSVNUUlkgJiZcbiAgICAgICAgICAgIHdpbmRvdy5ERUdVX1JBRl9SRUdJU1RSWS5hZGRPbmVUaW1lUmVhZCh7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIHJhZjogdGhpcyxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgb25lIHRpbWUgd3JpdGUgY2FsbGJhY2sgZXhlY3V0ZWQgYnkgdGhlIGdsb2JhbCBkZWd1IHJhZiByZWdpc3RyeS5cbiAgICAgKiBUaGlzIGFsbG93cyB5b3UgdG8gYmF0Y2ggd3JpdGUgY2FsbHMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG4gICAgd3JpdGUoY2FsbGJhY2spIHtcbiAgICAgICAgd2luZG93LkRFR1VfUkFGX1JFR0lTVFJZICYmXG4gICAgICAgICAgICB3aW5kb3cuREVHVV9SQUZfUkVHSVNUUlkuYWRkT25lVGltZVdyaXRlKHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgcmFmOiB0aGlzLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBvbmUgdGltZSBwb3N0IHdyaXRlIGNhbGxiYWNrIGV4ZWN1dGVkIGJ5IHRoZSBnbG9iYWwgZGVndSByYWYgcmVnaXN0cnkuXG4gICAgICogVGhpcyBhbGxvd3MgeW91IHRvIGJhdGNoIHBvc3Qgd3JpdGUgY2FsbHMuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG4gICAgcG9zdFdyaXRlKGNhbGxiYWNrKSB7XG4gICAgICAgIHdpbmRvdy5ERUdVX1JBRl9SRUdJU1RSWSAmJlxuICAgICAgICAgICAgd2luZG93LkRFR1VfUkFGX1JFR0lTVFJZLmFkZE9uZVRpbWVQb3N0V3JpdGUoe1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICByYWY6IHRoaXMsXG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHByb2dyZXNzIGxpc3RlbmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgdW53YXRjaChjYWxsYmFja1RvUmVtb3ZlKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MuZmlsdGVyKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayA9PT0gY2FsbGJhY2tUb1JlbW92ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGVhY2ggcmFmIGxvb3AuICBJZiB0aGUgY29uZGl0aW9uIHJlc29sdmVzXG4gICAgICogdG8gdHJ1ZSwgdGhlIHJhZiBsb29wIGNhbGxiYWNrcyB3aWxsIGJlIGV4ZWN1dGVkLiAgSWYgZmFsc2UsIHRoZSByYWZcbiAgICAgKiBsb29wIGlzIGN1bGxlZC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tDb25kaXRpb25cbiAgICAgKi9cbiAgICBydW5XaGVuKGNhbGxiYWNrQ29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMucnVuQ29uZGl0aW9uID0gY2FsbGJhY2tDb25kaXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB5b3UgdG8gcGFzcyBhbiBvcHRpb24gdG8gdGVsbCB0aGlzIHJhZiB0byBleGVjdXRlIG9ubHkgd2hlbiB0aGVcbiAgICAgKiBnaXZlbiBlbGVtZW50IGlzIGluIHRoZSB2aWV3cG9ydC4gIE9wdGlvbmFsbHkgcGFzcyBpbnRlcnNlY3Rpb24gb2JzZXJ2ZXJcbiAgICAgKiBvcHRpb25zLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgc3RpbGwgcmVxdWlyZXMgeW91IHRvIHN0YXJ0IHRoZSByYWYuICBZb3UgY2FuIGRvIHRoaXNcbiAgICAgKiB3aXRoIHRoZSBwcm9taXNlIHRoYXQgdGhlIG1ldGhvZCByZXR1cm5zIChyZXNvbHZlZCB3aGVuIGV2IGlzIHJlYWR5KVxuICAgICAqIG9yIGF0IGEgbGF0ZXIgdGltZS5cbiAgICAgKlxuICAgICAqIE5vdGUgaXQncyByZWNvbW1lbmRlZCB0aGF0IHlvdSBhZGQgYSByb290TWFyZ2luIHRvIHlvdXIgZXYgc2V0dGluZ3NcbiAgICAgKiBpZiBuZWVkIHRvIGRvIG9mZnNjcmVlbiBwcm9jZXNzaW5nLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmFyIHJhZiA9IG5ldyBSYWYoKCk9PiB7XG4gICAgICogICAuLi5cbiAgICAgKiB9KVxuICAgICAqXG4gICAgICpcbiAgICAgKiAvLyBTZXQgZWxlbWVudCBhbmQgcnVuIHdoZW4gaXQncyByZWFkeS5cbiAgICAgKiByYWYucnVuV2hlbkVsZW1lbnRJc0ludmlldyhcbiAgICAgKiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15ZWxlbWVudFwiKSxcbiAgICAgKiAgICB7XG4gICAgICogICAgICByb290TWFyZ2luOiAnMzAwcHggMHB4IDMwMHB4IDBweCdcbiAgICAgKiAgICB9XG4gICAgICogKS50aGVuKCgpPT4ge1xuICAgICAqICAgIHJhZi5zdGFydCgpO1xuICAgICAqIH0pXG4gICAgICpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgcnVuV2hlbkVsZW1lbnRJc0ludmlldyhlbGVtZW50LCBpbnRlcnNlY3Rpb25PYnNlcnZlck9wdGlvbnMpIHtcbiAgICAgICAgLy8gRGlzcG9zZSBvZiBhbnkgcHJldmlvdXMgaW5zdGFuY2VzIGlmIHRoaXMgaXMgYmVpbmcgY2FsbGVkIGEgc2Vjb25kXG4gICAgICAgIC8vIHRpbWUuXG4gICAgICAgIHRoaXMuZXYgJiYgdGhpcy5ldi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMucnVuQ29uZGl0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5ldiA9IGVsZW1lbnRfdmlzaWJpbGl0eV8xLmVsZW1lbnRWaXNpYmlsaXR5LmludmlldyhlbGVtZW50LCBpbnRlcnNlY3Rpb25PYnNlcnZlck9wdGlvbnMgfHwge30pO1xuICAgICAgICAvLyBTZXQgdGhlIHJ1biB3aGVuIGNvbmRpdGlvbi5cbiAgICAgICAgdGhpcy5ydW5XaGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ICYmIHRoaXMuZXYuc3RhdGUoKS5pbnZpZXc7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5ldi5yZWFkeVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGZwcyAuXG4gICAgICovXG4gICAgc2V0RnBzKGZwcykge1xuICAgICAgICB0aGlzLmZwcyA9IGZwcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBSQUYgYW5pbWF0aW9uIGxvb3AuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBXaGV0aGVyIHRvIGZvcmNlIGEgc3RhcnQuXG4gICAgICovXG4gICAgc3RhcnQoZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIWZvcmNlICYmIHRoaXMuaXNQbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSAodHlwZW9mIHBlcmZvcm1hbmNlID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBEYXRlXG4gICAgICAgICAgICA6IHBlcmZvcm1hbmNlKS5ub3coKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25Mb29wXygpO1xuICAgICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBSQUYgYW5pbWF0aW9uIGxvb3AuXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmXyk7XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nUmFmID0gZmFsc2U7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZXYgJiYgdGhpcy5ldi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAvLyBEZXJlZ2lzdGVyIHNlbGYgdG8gZ2xvYmFsIHJlZ2lzdHJ5LlxuICAgICAgICB3aW5kb3cuREVHVV9SQUZfUkVHSVNUUlkgJiYgd2luZG93LkRFR1VfUkFGX1JFR0lTVFJZLnVucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRlbHRhIGluIG1zIGJldHdlZW4gdGhlIGxhc3QgZXhlY3V0ZWQgcmFmIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gaW5TZWNvbmRzIFdoZXRoZXIgdG8gYWNxdWlyZSB0aGUgZGVsdGEgdGltZSBpbiBzZWNvbmRzLiAgRGVmYXVsdHNcbiAgICAgKiAgIHRvIG1zLlxuICAgICAqL1xuICAgIGdldERlbHRhKGluU2Vjb25kcykge1xuICAgICAgICBpZiAoaW5TZWNvbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWx0YSAvIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWx0YTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBlbGFzcGVkIHRpbWUgc2luY2UgcmFmIHN0YXJ0ZWQuXG4gICAgICovXG4gICAgZ2V0RWxhcHNlZFRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsYXNwZWRUaW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0aW1lIChEYXRlKSB3aGVuIHJhZiBzdGFydGVkLlxuICAgICAqL1xuICAgIGdldFN0YXJ0VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRUaW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGZyYW1lIHJhdGUgdGhhdCByYWYgaXMgcnVubmluZyBhdC4gIFVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRGcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRGcHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCBhbmltYXRpb24gbG9vcC5cbiAgICAgKi9cbiAgICBhbmltYXRpb25Mb29wXygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSdW5uaW5nUmFmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYWZfID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoZnJhbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcbiAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nUmFmID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkxvb3BfKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlzUnVubmluZ1JhZiA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmxhc3RVcGRhdGVUaW1lKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGltZV8xLnRpbWUubm93KCk7XG4gICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gY3VycmVudCAtIHRoaXMubGFzdFVwZGF0ZVRpbWU7XG4gICAgICAgICAgICB0aGlzLmRlbHRhID0gZWxhcHNlZDtcbiAgICAgICAgICAgIHRoaXMuZWxhc3BlZFRpbWUgKz0gZWxhcHNlZCAvIDEwMDA7XG4gICAgICAgICAgICBjb25zdCBmcHMgPSB0aGlzLmZwcyA9PT0gMCA/IDAgOiAxMDAwIC8gdGhpcy5mcHM7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGcHMgPSAxMDAwIC8gZWxhcHNlZDtcbiAgICAgICAgICAgIGlmIChlbGFwc2VkID4gZnBzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5mcmFtZSwgdGhpcy5sYXN0VXBkYXRlVGltZSwgZWxhcHNlZCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ydW5Db25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bkNvbmRpdGlvbigpICYmIGNhbGxDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFVwZGF0ZVRpbWUgPSB0aW1lXzEudGltZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubGFzdFVwZGF0ZVRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFVwZGF0ZVRpbWUgPSB0aW1lXzEudGltZS5ub3coKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUmFmID0gUmFmO1xuLyoqXG4gKiBUaGUgaWRlYSBiZWhpbmQgdGhlIHJhZlJlZ2lzdHJ5IGlzIHRvIGJlIGFibGUgdG8gYmF0Y2ggcmVhZCBhbmQgd3JpdGVcbiAqIHJhZiBjYWxscyBzaW1pbGFyIHRvIGZhc3REb20gb3IgdG9vbEJveCBtdXRhdGUuXG4gKlxuICogSW4gb3JkZXIgdG8gYWNoaWV2ZSB0aGlzIHBlcmZvcm1hbmNlIGJvb3N0cywgcmVhZCBhbmQgd3JpdGUgY2FsbHMgbmVlZFxuICogdG8gYmUgZXhlY3V0ZWQgaW4gb3JkZXIgYW5kIHRoZXJlZm9yZSwgd2UgbmVlZCBhIHJlZ2lzdHJ5IHRvIG1haW50YWluXG4gKiBhbGwgcmFmIGluc3RhbmNlcyBvbiB0aGUgcGFnZS5cbiAqXG4gKiBXaGVuIGluc3RhbnRpYXRlZCwgZWFjaCBSQUYgYWRkcyBpdHNlbGYgdG8gdGhlIHJlZ2lzdHJ5IGFuZCBjYW4gYmUgcnVuIC8gc3RvcHBlZFxuICogbm9ybWFsbHkuXG4gKlxuICogV2l0aGluIGl0J3MgcmFmIGxvb3AsIGl0IGNhbiBjYWxsIGEgcmFmLnJlYWQoY2FsbGJhY2spOyByYWYud3JpdGUoY2FsbGJhY2spO1xuICogd2hpY2ggZW5kcyB1cCBnZXR0aW5nIGV4ZWN1dGVkIG9uIHRoZSBSYWZSZWdpc3RyeSBldmVudCBsb29wLlxuICpcbiAqIHJhZi5yZWFkKGNhbGxiYWNrKSBhbmQgcmFmLndyaXRlKGNhbGxiYWNrKSBhcmUgT05FLXRpbWUgc28gbXVzdCBiZSByZWNhbGxlZFxuICogb24gZWFjaCByYWYgbG9vcC4gIEl0IGlzIGJhc2ljYWxseSBzYXlpbmcsIHJlYWQgdGhpcyBvbiB0aGUgbmV4dCByYWYgbG9vcCBvbmNlXG4gKiBvciB3cml0ZSBpdCBvbiB0aGUgbmV4dCByYWYgbG9vcC5cbiAqXG4gKiBUbyB1c2UgdGhpcyBzeXN0ZW0sIHNpbXBseSB1c2UgYWRkIHJlYWQgYW5kIHdyaXRlIGNhbGxzIGluIHlvdXIgcmFmIGxvb3AuXG4gKlxuICpcbiAqIExpZmUgY3ljbGU6XG4gKiAtIHByZXJlYWRcbiAqIC0gcmVhZFxuICogLSB3cml0ZVxuICogLSBwb3N0V3JpdGVcbiAqXG4gKiBgYGBcbiAqIHZhciByYWYgPSBuZXcgUmFmKCgpPT4ge1xuICogICAgcmFmLnByZVJlYWQoKCk9PiB7XG4gKiAgICAgICAgdGhpcy5oZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAqICAgIH0pXG4gKlxuICogICAgcmFmLnJlYWQoKCk9PiB7XG4gKiAgICAgICAgdGhpcy5oZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAqICAgIH0pXG4gKlxuICogICAgcmFmLndyaXRlKCgpPT4ge1xuICogICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAyMCArICdweCc7XG4gKiAgICB9KVxuICpcbiAqICAgIC8vIFNvbWV3aGF0IHJhcmUgYnV0IGV4ZWN1dGVkIGFmdGVyIGFsbCB3cml0ZXMuXG4gKiAgICByYWYucG9zdFdyaXRlKCgpPT4ge1xuICogICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAyMCArICdweCc7XG4gKiAgICB9KVxuICogfSlcbiAqIGBgYFxuICpcbiAqXG4gKiBZb3UgbWF5IGFsc28gdG8gdXNlIHJhZi53cml0ZSBhbmQgcmFmLnJlYWQgb3V0c2lkZSBhXG4gKiByYWZMb29wLiAgSW4gdGhpcyBjYXNlLCB5b3UgY2FuIGp1c3QgcGFzcyBhIG51bGwgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICpcbiAqIGBgYFxuICogdmFyIHJhZiA9IG5ldyBSYWYoKTtcbiAqXG4gKiAvLyBTb21ld2hlcmVcbiAqICByYWYucmVhZCgoKT0+IHtcbiAqICAgICAgdGhpcy5oZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAqICB9KVxuICpcbiAqXG4gKiAgcmFmLndyaXRlKCgpPT4ge1xuICogICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgMjAgKyAncHgnO1xuICogIH0pXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqL1xuY2xhc3MgUmFmUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmZsdXNoU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJlUmVhZHMgPSBbXTtcbiAgICAgICAgdGhpcy5yZWFkcyA9IFtdO1xuICAgICAgICB0aGlzLndyaXRlcyA9IFtdO1xuICAgICAgICB0aGlzLnBvc3RXcml0ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yYWZzID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBydW5SYWZDYWxsYmFja3MoY2FsbGJhY2tzKSB7XG4gICAgICAgIC8vIEtlZXAgY29uc2lzdGVudCBhcnJheXMgc28gdGhhdCBzY2hlZHVsZWQgZnVuY3Rpb24gY2FuIHNjaGVkdWxlXG4gICAgICAgIC8vIGFub3RoZXIgZnVuY3Rpb24gaW4gdGhlIHNhbWUgc3RlcC5cbiAgICAgICAgLy8gSW1wb3J0YW50IHNvIHRoYXQgYSByZWFkIGZ1bmN0aW9uIGNhbiBjYWxsIGFub3RoZXIgZnVuY3Rpb24gdGhhdFxuICAgICAgICAvLyBwcm90ZWN0cyBpdHNlbGYgaW4gaXRzIG93biByZWFkIGZ1bmN0aW9uLCBpbiBjYXNlIGl0IGlzIGNhbGxlZFxuICAgICAgICAvLyB0aHJvdWdoIGFub3RoZXIgY29kZSBleGVjdXRpb24gcGF0aC5cbiAgICAgICAgd2hpbGUgKGNhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJ5T2JqZWN0ID0gY2FsbGJhY2tzLnNwbGljZSgwLCAxKVswXTtcbiAgICAgICAgICAgIGlmICghcmVnaXN0cnlPYmplY3QucmFmLmlzRGlzcG9zZWQgJiZcbiAgICAgICAgICAgICAgICAocmVnaXN0cnlPYmplY3QucmFmLmlzUGxheWluZyB8fCByZWdpc3RyeU9iamVjdC5yYWYuaXNSZWFkV3JpdGVPbmx5KSkge1xuICAgICAgICAgICAgICAgIHJlZ2lzdHJ5T2JqZWN0LmNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmZsdXNoU2NoZWR1bGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbHVzaFNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJ1blJhZigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcnVuUmFmKCkge1xuICAgICAgICAvLyBPcGVuIGNvbnNvbGUgYW5kIGFkZDpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gREVHVV9SQUZfUkVHSVNUUllfREVCVUcgPSB0cnVlO1xuICAgICAgICAvL1xuICAgICAgICBpZiAod2luZG93LkRFR1VfUkFGX1JFR0lTVFJZX0RFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUnVubmluZyByYWYnLCB0aGlzLnJlYWRzLmxlbmd0aCwgdGhpcy53cml0ZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeGVjdXRlIHByZVJlYWRzLlxuICAgICAgICBSYWZSZWdpc3RyeS5ydW5SYWZDYWxsYmFja3ModGhpcy5wcmVSZWFkcyk7XG4gICAgICAgIC8vIEV4ZWN1dGUgcmVhZHMuXG4gICAgICAgIFJhZlJlZ2lzdHJ5LnJ1blJhZkNhbGxiYWNrcyh0aGlzLnJlYWRzKTtcbiAgICAgICAgLy8gRXhlY3V0ZSB3cml0ZXMuXG4gICAgICAgIFJhZlJlZ2lzdHJ5LnJ1blJhZkNhbGxiYWNrcyh0aGlzLndyaXRlcyk7XG4gICAgICAgIC8vIEV4ZWN1dGUgcG9zdFdyaXRlcy5cbiAgICAgICAgUmFmUmVnaXN0cnkucnVuUmFmQ2FsbGJhY2tzKHRoaXMucG9zdFdyaXRlcyk7XG4gICAgICAgIHRoaXMuZmx1c2hTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgc2luZ2xlIGFkZE9uZVRpbWVQcmVSZWFkIHRvIHRoZSBiYXRjaCByZWFkIC8gd3JpdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSByZWFkXG4gICAgICovXG4gICAgYWRkT25lVGltZVByZVJlYWQocmVhZCkge1xuICAgICAgICB0aGlzLnByZVJlYWRzLnB1c2gocmVhZCk7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgc2luZ2xlIGFkZE9uZVRpbWVSZWFkIHRvIHRoZSBiYXRjaCByZWFkIC8gd3JpdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSByZWFkXG4gICAgICovXG4gICAgYWRkT25lVGltZVJlYWQocmVhZCkge1xuICAgICAgICB0aGlzLnJlYWRzLnB1c2gocmVhZCk7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgc2luZ2xlIGFkZE9uZVRpbWVXcml0ZSB0byB0aGUgYmF0Y2ggcmVhZCAvIHdyaXRlIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0gcmVhZFxuICAgICAqL1xuICAgIGFkZE9uZVRpbWVXcml0ZSh3cml0ZSkge1xuICAgICAgICB0aGlzLndyaXRlcy5wdXNoKHdyaXRlKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBzaW5nbGUgYWRkT25lVGltZVdyaXRlIHRvIHRoZSBiYXRjaCByZWFkIC8gd3JpdGUgc3lzdGVtLlxuICAgICAqIEBwYXJhbSByZWFkXG4gICAgICovXG4gICAgYWRkT25lVGltZVBvc3RXcml0ZShwb3N0V3JpdGUpIHtcbiAgICAgICAgdGhpcy5wb3N0V3JpdGVzLnB1c2gocG9zdFdyaXRlKTtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb3VudCBvZiBhbGwgYWN0aXZlIHJhZnMuXG4gICAgICpcbiAgICAgKiBJbiBkZXYgY29uc29sZTpcbiAgICAgKiBgYGBcbiAgICAgKiBERUdVX1JBRl9SRUdJU1RSWS5nZXRBY3RpdmVSYWZDb3VudCgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldEFjdGl2ZVJhZkNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYWZzLmZpbHRlcihyID0+IHtcbiAgICAgICAgICAgIHJldHVybiByLmlzUGxheWluZztcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb3VudCBvZiByYWZzLlxuICAgICAqXG4gICAgICogSW4gZGV2IGNvbnNvbGU6XG4gICAgICogYGBgXG4gICAgICogREVHVV9SQUZfUkVHSVNUUlkuZ2V0UmFmQ291bnQoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXRSYWZDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFmcy5sZW5ndGg7XG4gICAgfVxuICAgIHJlZ2lzdGVyKHJhZikge1xuICAgICAgICB0aGlzLnJhZnMucHVzaChyYWYpO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyKHJhZikge1xuICAgICAgICB0aGlzLnJhZnMgPSB0aGlzLnJhZnMuZmlsdGVyKHIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHIgPT09IHJhZjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8gQ3JlYXRlIHJhZiByZWdpc3RyeSBhcyBhIGdsb2JhbC5cbmlmICh3aW5kb3cgJiYgIXdpbmRvdy5ERUdVX1JBRl9SRUdJU1RSWSkge1xuICAgIHdpbmRvdy5ERUdVX1JBRl9SRUdJU1RSWSA9IG5ldyBSYWZSZWdpc3RyeSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFmLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/raf/raf.js\n");

/***/ }),

/***/ "./lib/setf/setf.js":
/*!**************************!*\
  !*** ./lib/setf/setf.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setf = void 0;\nclass setf {\n    /**\n     * Merge all of the given sets into a single set.\n     */\n    static merge(...sets) {\n        const result = new Set();\n        sets.forEach(set => {\n            set.forEach(value => {\n                result.add(value);\n            });\n        });\n        return result;\n    }\n}\nexports.setf = setf;\n//# sourceMappingURL=setf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvc2V0Zi9zZXRmLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3NldGYvc2V0Zi5qcz8wMzRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXRmID0gdm9pZCAwO1xuY2xhc3Mgc2V0ZiB7XG4gICAgLyoqXG4gICAgICogTWVyZ2UgYWxsIG9mIHRoZSBnaXZlbiBzZXRzIGludG8gYSBzaW5nbGUgc2V0LlxuICAgICAqL1xuICAgIHN0YXRpYyBtZXJnZSguLi5zZXRzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgICAgICAgc2V0cy5mb3JFYWNoKHNldCA9PiB7XG4gICAgICAgICAgICBzZXQuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5zZXRmID0gc2V0Zjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldGYuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/setf/setf.js\n");

/***/ }),

/***/ "./lib/shaders/three-shader-chunks/degu-mathf.js":
/*!*******************************************************!*\
  !*** ./lib/shaders/three-shader-chunks/degu-mathf.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deguMathf = void 0;\n/**\n * Creates a 2d rotation matrix.\n *\n * mat2 mat = deguGetRotationMatrix(rotationInRadians);\n * vec2 rotatedPoint = mat * v_position.xy;\n *\n *    mat2          *      vec2.xy = new rotated position\n * --        ---         ---  --\n * |   c   -s  |    *    |   x  |  = new rotated position.\n * |   s    c  |         |   y  |\n * ---       ---         --    --\n *\n * For example:\n * rotation 0\n * sin(0) = 0, cos(0) = 1\n *  1   0         x      1*x + 0*x     x\n *  0   1    *    y   =  0*y + 1*y  =  y\n * rotation of zero has no effect.\n *\n *\n * rotation 180 degrees (3.14 radian)\n * sin(3.14) = 0, cos(3.14) = -1\n *  -1   0         x      -1*x + 0*x     -x\n *  0   -1    *    y   =  0*y + 1*-y  =  -y\n * rotation makes it 180 flipping x,y so it's correct.\n *\n */\nconst deguGet2dRotationMatrix = `\n   mat2 deguGet2dRotationMatrix(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat2(c, -s, s, c);\n   }\n`;\n/*\n * Returns a mat2 scale matrix.\n *\n * mat2 scaleMat = deguGetScaleMatrix(1.5);\n * mat2 rotateMat = deguGetRotationMatrix(rotationInRadians);\n * vec2 scaledPoint = scaleMat * v_position.xy;\n * vec2 scaledAndRotatedPoint = scaleMat * rotateMat * v_position.xy;\n *\n */\nconst deguGet2dScaleMatrix = `\n  mat2 deguGetScaleMatrix(float scale) {\n      return mat2(scale, 0, 0, scale);\n  }\n`;\n/**\n * A 2d based rotation.\n * pt - The point of rotation\n * theta - the angle in radians\n * @return vec2\n *\n * vec2 myPoints = vec2(0,0.5);\n * // Rotate by 1 radian\n * vec2 rotatedPoints = deguRotate2d(myPoints, 1);\n *\n */\nconst deguRotate2d = `\n   vec2 deguRotate2d(vec2 pt, float theta) {\n       mat2 rotationMatrix = deguGet2dRotationMatrix(theta);\n       return rotationMatrix * pt;\n   }\n`;\n/**\n * Rotations an image.\n * https://www.udemy.com/course/learn-glsl-shaders-from-scratch/learn/lecture/13739174#questions\n * @see glsl-playground20.js for an example.\n * ```\n *   vec2 center = vec2(0.5);\n *   float imageAspect = 300.0 / 448.0;\n *   vec3 backgroundColor = vec3(0.0);\n *   vec3 color = deguRotate2dImage(\n *       u_texture, imageAspect, v_uv, center, u_time, backgroundColor);\n * ```\n */\nconst deguRotate2dImage = `\n   vec3 deguRotate2dImage(sampler2D texture, float aspect, vec2 uv, vec2 center, float theta, vec3 backgroundColor) {\n       // Adjust for the center point.\n       uv -= center;\n\n       mat2 rotationMatrix = deguGet2dRotationMatrix(theta);\n       // Go to square uv coordinates.\n       uv.y /= aspect;\n       // Conduct rotation.\n       uv = rotationMatrix * uv;\n       // Go back to whatever the aspect was.\n       uv.y *= aspect;\n\n       // Adjust back for the center point.\n       uv += center;\n\n       vec3 texel = texture2D(texture, uv).rgb;\n\n       // Determine if this point is within the bounds of the rectangle.\n       // If not, use the background color.\n       vec2 s = step(vec2(0.0), uv) - step(vec2(1.0), uv);\n       float t = s.x * s.y;\n\n       vec3 color = mix(backgroundColor, texel, t);\n\n       return color;\n   }\n`;\n/**\n * Sin returns values between -1 and 1 but we often want 0-1.\n * Allows you to run a normlized sin.  You can combine this\n * with mix to create sin waves of any given range.\n *\n * ```\n *  // These two are the same.\n *  float s = (sin(radians) + 1.0) / 2.0;\n *  float s = normalizedSin(radians);\n *\n * // Use normalized sin to shift values of sin.\n * // Make a sin wave of range -0.2, 0.2\n * float wave = mix(-0.2, 0.2, normalizedSin(currentRadian));\n * ```\n */\nconst normalizedSin = `\n  float normalizedSin(float radians) {\n    return (sin(radians) + 1.0) / 2.0;\n  }\n`;\n/**\n * Raycast algo.\n * @see  http://blog.ruofeidu.com/tutorial-of-ray-casting-ray-tracing-and-ray-marching/\n */\n// eslint-disable-next-line\nconst castRay = `\nbool castRay( const vec3 & ro, const vec3 & rd, float & resT )\n{\n    const float delt = 0.01f;\n    const float mint = 0.001f;\n    const float maxt = 10.0f;\n    for( float t = mint; t < maxt; t += delt )\n    {\n        const vec3 p = ro + rd*t;\n        if( p.y < f( p.x, p.z ) )\n        {\n            resT = t - 0.5f*delt;\n            return true;\n        }\n    }\n    return false;\n}\n`;\n/**\n * Common custom math functions for glsl.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst deguMathf = (three) => {\n    three.ShaderChunk.deguMathf = `\n  ${deguGet2dRotationMatrix}\n  ${deguGet2dScaleMatrix}\n  ${deguRotate2d}\n  ${deguRotate2dImage}\n  ${normalizedSin}\n`;\n};\nexports.deguMathf = deguMathf;\n//# sourceMappingURL=degu-mathf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvc2hhZGVycy90aHJlZS1zaGFkZXItY2h1bmtzL2RlZ3UtbWF0aGYuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvc2hhZGVycy90aHJlZS1zaGFkZXItY2h1bmtzL2RlZ3UtbWF0aGYuanM/YWI0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVndU1hdGhmID0gdm9pZCAwO1xuLyoqXG4gKiBDcmVhdGVzIGEgMmQgcm90YXRpb24gbWF0cml4LlxuICpcbiAqIG1hdDIgbWF0ID0gZGVndUdldFJvdGF0aW9uTWF0cml4KHJvdGF0aW9uSW5SYWRpYW5zKTtcbiAqIHZlYzIgcm90YXRlZFBvaW50ID0gbWF0ICogdl9wb3NpdGlvbi54eTtcbiAqXG4gKiAgICBtYXQyICAgICAgICAgICogICAgICB2ZWMyLnh5ID0gbmV3IHJvdGF0ZWQgcG9zaXRpb25cbiAqIC0tICAgICAgICAtLS0gICAgICAgICAtLS0gIC0tXG4gKiB8ICAgYyAgIC1zICB8ICAgICogICAgfCAgIHggIHwgID0gbmV3IHJvdGF0ZWQgcG9zaXRpb24uXG4gKiB8ICAgcyAgICBjICB8ICAgICAgICAgfCAgIHkgIHxcbiAqIC0tLSAgICAgICAtLS0gICAgICAgICAtLSAgICAtLVxuICpcbiAqIEZvciBleGFtcGxlOlxuICogcm90YXRpb24gMFxuICogc2luKDApID0gMCwgY29zKDApID0gMVxuICogIDEgICAwICAgICAgICAgeCAgICAgIDEqeCArIDAqeCAgICAgeFxuICogIDAgICAxICAgICogICAgeSAgID0gIDAqeSArIDEqeSAgPSAgeVxuICogcm90YXRpb24gb2YgemVybyBoYXMgbm8gZWZmZWN0LlxuICpcbiAqXG4gKiByb3RhdGlvbiAxODAgZGVncmVlcyAoMy4xNCByYWRpYW4pXG4gKiBzaW4oMy4xNCkgPSAwLCBjb3MoMy4xNCkgPSAtMVxuICogIC0xICAgMCAgICAgICAgIHggICAgICAtMSp4ICsgMCp4ICAgICAteFxuICogIDAgICAtMSAgICAqICAgIHkgICA9ICAwKnkgKyAxKi15ICA9ICAteVxuICogcm90YXRpb24gbWFrZXMgaXQgMTgwIGZsaXBwaW5nIHgseSBzbyBpdCdzIGNvcnJlY3QuXG4gKlxuICovXG5jb25zdCBkZWd1R2V0MmRSb3RhdGlvbk1hdHJpeCA9IGBcbiAgIG1hdDIgZGVndUdldDJkUm90YXRpb25NYXRyaXgoZmxvYXQgdGhldGEpIHtcbiAgICBmbG9hdCBzID0gc2luKHRoZXRhKTtcbiAgICBmbG9hdCBjID0gY29zKHRoZXRhKTtcbiAgICByZXR1cm4gbWF0MihjLCAtcywgcywgYyk7XG4gICB9XG5gO1xuLypcbiAqIFJldHVybnMgYSBtYXQyIHNjYWxlIG1hdHJpeC5cbiAqXG4gKiBtYXQyIHNjYWxlTWF0ID0gZGVndUdldFNjYWxlTWF0cml4KDEuNSk7XG4gKiBtYXQyIHJvdGF0ZU1hdCA9IGRlZ3VHZXRSb3RhdGlvbk1hdHJpeChyb3RhdGlvbkluUmFkaWFucyk7XG4gKiB2ZWMyIHNjYWxlZFBvaW50ID0gc2NhbGVNYXQgKiB2X3Bvc2l0aW9uLnh5O1xuICogdmVjMiBzY2FsZWRBbmRSb3RhdGVkUG9pbnQgPSBzY2FsZU1hdCAqIHJvdGF0ZU1hdCAqIHZfcG9zaXRpb24ueHk7XG4gKlxuICovXG5jb25zdCBkZWd1R2V0MmRTY2FsZU1hdHJpeCA9IGBcbiAgbWF0MiBkZWd1R2V0U2NhbGVNYXRyaXgoZmxvYXQgc2NhbGUpIHtcbiAgICAgIHJldHVybiBtYXQyKHNjYWxlLCAwLCAwLCBzY2FsZSk7XG4gIH1cbmA7XG4vKipcbiAqIEEgMmQgYmFzZWQgcm90YXRpb24uXG4gKiBwdCAtIFRoZSBwb2ludCBvZiByb3RhdGlvblxuICogdGhldGEgLSB0aGUgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybiB2ZWMyXG4gKlxuICogdmVjMiBteVBvaW50cyA9IHZlYzIoMCwwLjUpO1xuICogLy8gUm90YXRlIGJ5IDEgcmFkaWFuXG4gKiB2ZWMyIHJvdGF0ZWRQb2ludHMgPSBkZWd1Um90YXRlMmQobXlQb2ludHMsIDEpO1xuICpcbiAqL1xuY29uc3QgZGVndVJvdGF0ZTJkID0gYFxuICAgdmVjMiBkZWd1Um90YXRlMmQodmVjMiBwdCwgZmxvYXQgdGhldGEpIHtcbiAgICAgICBtYXQyIHJvdGF0aW9uTWF0cml4ID0gZGVndUdldDJkUm90YXRpb25NYXRyaXgodGhldGEpO1xuICAgICAgIHJldHVybiByb3RhdGlvbk1hdHJpeCAqIHB0O1xuICAgfVxuYDtcbi8qKlxuICogUm90YXRpb25zIGFuIGltYWdlLlxuICogaHR0cHM6Ly93d3cudWRlbXkuY29tL2NvdXJzZS9sZWFybi1nbHNsLXNoYWRlcnMtZnJvbS1zY3JhdGNoL2xlYXJuL2xlY3R1cmUvMTM3MzkxNzQjcXVlc3Rpb25zXG4gKiBAc2VlIGdsc2wtcGxheWdyb3VuZDIwLmpzIGZvciBhbiBleGFtcGxlLlxuICogYGBgXG4gKiAgIHZlYzIgY2VudGVyID0gdmVjMigwLjUpO1xuICogICBmbG9hdCBpbWFnZUFzcGVjdCA9IDMwMC4wIC8gNDQ4LjA7XG4gKiAgIHZlYzMgYmFja2dyb3VuZENvbG9yID0gdmVjMygwLjApO1xuICogICB2ZWMzIGNvbG9yID0gZGVndVJvdGF0ZTJkSW1hZ2UoXG4gKiAgICAgICB1X3RleHR1cmUsIGltYWdlQXNwZWN0LCB2X3V2LCBjZW50ZXIsIHVfdGltZSwgYmFja2dyb3VuZENvbG9yKTtcbiAqIGBgYFxuICovXG5jb25zdCBkZWd1Um90YXRlMmRJbWFnZSA9IGBcbiAgIHZlYzMgZGVndVJvdGF0ZTJkSW1hZ2Uoc2FtcGxlcjJEIHRleHR1cmUsIGZsb2F0IGFzcGVjdCwgdmVjMiB1diwgdmVjMiBjZW50ZXIsIGZsb2F0IHRoZXRhLCB2ZWMzIGJhY2tncm91bmRDb2xvcikge1xuICAgICAgIC8vIEFkanVzdCBmb3IgdGhlIGNlbnRlciBwb2ludC5cbiAgICAgICB1diAtPSBjZW50ZXI7XG5cbiAgICAgICBtYXQyIHJvdGF0aW9uTWF0cml4ID0gZGVndUdldDJkUm90YXRpb25NYXRyaXgodGhldGEpO1xuICAgICAgIC8vIEdvIHRvIHNxdWFyZSB1diBjb29yZGluYXRlcy5cbiAgICAgICB1di55IC89IGFzcGVjdDtcbiAgICAgICAvLyBDb25kdWN0IHJvdGF0aW9uLlxuICAgICAgIHV2ID0gcm90YXRpb25NYXRyaXggKiB1djtcbiAgICAgICAvLyBHbyBiYWNrIHRvIHdoYXRldmVyIHRoZSBhc3BlY3Qgd2FzLlxuICAgICAgIHV2LnkgKj0gYXNwZWN0O1xuXG4gICAgICAgLy8gQWRqdXN0IGJhY2sgZm9yIHRoZSBjZW50ZXIgcG9pbnQuXG4gICAgICAgdXYgKz0gY2VudGVyO1xuXG4gICAgICAgdmVjMyB0ZXhlbCA9IHRleHR1cmUyRCh0ZXh0dXJlLCB1dikucmdiO1xuXG4gICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgcG9pbnQgaXMgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgICAvLyBJZiBub3QsIHVzZSB0aGUgYmFja2dyb3VuZCBjb2xvci5cbiAgICAgICB2ZWMyIHMgPSBzdGVwKHZlYzIoMC4wKSwgdXYpIC0gc3RlcCh2ZWMyKDEuMCksIHV2KTtcbiAgICAgICBmbG9hdCB0ID0gcy54ICogcy55O1xuXG4gICAgICAgdmVjMyBjb2xvciA9IG1peChiYWNrZ3JvdW5kQ29sb3IsIHRleGVsLCB0KTtcblxuICAgICAgIHJldHVybiBjb2xvcjtcbiAgIH1cbmA7XG4vKipcbiAqIFNpbiByZXR1cm5zIHZhbHVlcyBiZXR3ZWVuIC0xIGFuZCAxIGJ1dCB3ZSBvZnRlbiB3YW50IDAtMS5cbiAqIEFsbG93cyB5b3UgdG8gcnVuIGEgbm9ybWxpemVkIHNpbi4gIFlvdSBjYW4gY29tYmluZSB0aGlzXG4gKiB3aXRoIG1peCB0byBjcmVhdGUgc2luIHdhdmVzIG9mIGFueSBnaXZlbiByYW5nZS5cbiAqXG4gKiBgYGBcbiAqICAvLyBUaGVzZSB0d28gYXJlIHRoZSBzYW1lLlxuICogIGZsb2F0IHMgPSAoc2luKHJhZGlhbnMpICsgMS4wKSAvIDIuMDtcbiAqICBmbG9hdCBzID0gbm9ybWFsaXplZFNpbihyYWRpYW5zKTtcbiAqXG4gKiAvLyBVc2Ugbm9ybWFsaXplZCBzaW4gdG8gc2hpZnQgdmFsdWVzIG9mIHNpbi5cbiAqIC8vIE1ha2UgYSBzaW4gd2F2ZSBvZiByYW5nZSAtMC4yLCAwLjJcbiAqIGZsb2F0IHdhdmUgPSBtaXgoLTAuMiwgMC4yLCBub3JtYWxpemVkU2luKGN1cnJlbnRSYWRpYW4pKTtcbiAqIGBgYFxuICovXG5jb25zdCBub3JtYWxpemVkU2luID0gYFxuICBmbG9hdCBub3JtYWxpemVkU2luKGZsb2F0IHJhZGlhbnMpIHtcbiAgICByZXR1cm4gKHNpbihyYWRpYW5zKSArIDEuMCkgLyAyLjA7XG4gIH1cbmA7XG4vKipcbiAqIFJheWNhc3QgYWxnby5cbiAqIEBzZWUgIGh0dHA6Ly9ibG9nLnJ1b2ZlaWR1LmNvbS90dXRvcmlhbC1vZi1yYXktY2FzdGluZy1yYXktdHJhY2luZy1hbmQtcmF5LW1hcmNoaW5nL1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmNvbnN0IGNhc3RSYXkgPSBgXG5ib29sIGNhc3RSYXkoIGNvbnN0IHZlYzMgJiBybywgY29uc3QgdmVjMyAmIHJkLCBmbG9hdCAmIHJlc1QgKVxue1xuICAgIGNvbnN0IGZsb2F0IGRlbHQgPSAwLjAxZjtcbiAgICBjb25zdCBmbG9hdCBtaW50ID0gMC4wMDFmO1xuICAgIGNvbnN0IGZsb2F0IG1heHQgPSAxMC4wZjtcbiAgICBmb3IoIGZsb2F0IHQgPSBtaW50OyB0IDwgbWF4dDsgdCArPSBkZWx0IClcbiAgICB7XG4gICAgICAgIGNvbnN0IHZlYzMgcCA9IHJvICsgcmQqdDtcbiAgICAgICAgaWYoIHAueSA8IGYoIHAueCwgcC56ICkgKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXNUID0gdCAtIDAuNWYqZGVsdDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmA7XG4vKipcbiAqIENvbW1vbiBjdXN0b20gbWF0aCBmdW5jdGlvbnMgZm9yIGdsc2wuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBkZWd1TWF0aGYgPSAodGhyZWUpID0+IHtcbiAgICB0aHJlZS5TaGFkZXJDaHVuay5kZWd1TWF0aGYgPSBgXG4gICR7ZGVndUdldDJkUm90YXRpb25NYXRyaXh9XG4gICR7ZGVndUdldDJkU2NhbGVNYXRyaXh9XG4gICR7ZGVndVJvdGF0ZTJkfVxuICAke2RlZ3VSb3RhdGUyZEltYWdlfVxuICAke25vcm1hbGl6ZWRTaW59XG5gO1xufTtcbmV4cG9ydHMuZGVndU1hdGhmID0gZGVndU1hdGhmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVndS1tYXRoZi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/shaders/three-shader-chunks/degu-mathf.js\n");

/***/ }),

/***/ "./lib/shaders/three-shader-chunks/noise.js":
/*!**************************************************!*\
  !*** ./lib/shaders/three-shader-chunks/noise.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.noise = void 0;\nconst THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\nconst noise = () => {\n    THREE.ShaderChunk.noise = `\n  //\n  // Description : Array and textureless GLSL 2D/3D/4D simplex\n  //               noise functions.\n  //      Author : Ian McEwan, Ashima Arts.\n  //  Maintainer : stegu\n  //     Lastmod : 20110822 (ijm)\n  //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n  //               Distributed under the MIT License. See LICENSE file.\n  //               https://github.com/ashima/webgl-noise\n  //               https://github.com/stegu/webgl-noise\n  //\n\n  vec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n  }\n\n  vec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n  }\n\n  vec4 permute(vec4 x) {\n       return mod289(((x*34.0)+1.0)*x);\n  }\n\n  // Permutation polynomial (ring size 289 = 17*17)\n  vec3 permute(vec3 x) {\n    return mod289(((x*34.0)+1.0)*x);\n  }\n\n  float permute(float x){\n      return x - floor(x * (1.0 / 289.0)) * 289.0;;\n  }\n\n  vec4 taylorInvSqrt(vec4 r){\n    return 1.79284291400159 - 0.85373472095314 * r;\n  }\n\n  vec2 fade(vec2 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n  }\n\n  vec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n  }\n\n  // Hashed 2-D gradients with an extra rotation.\n  // (The constant 0.0243902439 is 1/41)\n  vec2 rgrad2(vec2 p, float rot) {\n  #if 0\n  // Map from a line to a diamond such that a shift maps to a rotation.\n    float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift\n    u = 4.0 * fract(u) - 2.0;\n    // (This vector could be normalized, exactly or approximately.)\n    return vec2(abs(u)-1.0, abs(abs(u+1.0)-2.0)-1.0);\n  #else\n  // For more isotropic gradients, sin/cos can be used instead.\n    float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift\n    u = fract(u) * 6.28318530718; // 2*pi\n    return vec2(cos(u), sin(u));\n  #endif\n  }\n\n  float snoise(vec3 v){\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n  // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                  dot(p2,x2), dot(p3,x3) ) );\n    }\n\n  // Classic Perlin noise\n  float cnoise(vec2 P){\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n  }\n\n  // Classic Perlin noise, periodic variant\n  float pnoise(vec2 P, vec2 rep){\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n    Pi = mod289(Pi);        // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n  }\n  // Classic Perlin noise\n  float cnoise(vec3 P)\n  {\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n  }\n\n  // Classic Perlin noise, periodic variant\n  float pnoise(vec3 P, vec3 rep)\n  {\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n  }\n\n  float turbulence( vec3 p ) {\n    float w = 100.0;\n    float t = -.5;\n\n    for (float f = 1.0 ; f <= 10.0 ; f++ ){\n      float power = pow( 2.0, f );\n      t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );\n    }\n\n    return t;\n  }\n\n  float turbulence3( vec3 p ) {\n    float w = 100.0;\n    float t = -.5;\n\n    for (float f = 1.0 ; f <= 3.0 ; f++ ){\n      float power = pow( 2.0, f );\n      t += abs( pnoise( vec3( power * p ), vec3( 3.0, 3.0, 3.0 ) ) / power );\n    }\n\n    return t;\n  }\n\n  float turbulence6( vec3 p ) {\n    float w = 100.0;\n    float t = -.5;\n\n    for (float f = 1.0 ; f <= 6.0 ; f++ ){\n      float power = pow( 2.0, f );\n      t += abs( pnoise( vec3( power * p ), vec3( 6.0, 6.0, 6.0 ) ) / power );\n    }\n\n    return t;\n  }\n\n  //\n  // 2-D tiling simplex noise with rotating gradients and analytical derivative.\n  // The first component of the 3-element return vector is the noise value,\n  // and the second and third components are the x and y partial derivatives.\n  //\n  vec3 psrdnoise(vec2 pos, vec2 per, float rot) {\n    // Hack: offset y slightly to hide some rare artifacts\n    pos.y += 0.01;\n    // Skew to hexagonal grid\n    vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n    vec2 i0 = floor(uv);\n    vec2 f0 = fract(uv);\n    // Traversal order\n    vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n    // Unskewed grid points in (x,y) space\n    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n    vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n    // Integer grid point indices in (u,v) space\n    i1 = i0 + i1;\n    vec2 i2 = i0 + vec2(1.0, 1.0);\n\n    // Vectors in unskewed (x,y) coordinates from\n    // each of the simplex corners to the evaluation point\n    vec2 d0 = pos - p0;\n    vec2 d1 = pos - p1;\n    vec2 d2 = pos - p2;\n\n    // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n    // wrap points in (x,y), map to (u,v)\n    vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n    vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n    vec3 iuw = xw + 0.5 * yw;\n    vec3 ivw = yw;\n\n    // Create gradients from indices\n    vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n    vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n    vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n    // Gradients dot vectors to corresponding corners\n    // (The derivatives of this are simply the gradients)\n    vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n    // Radial weights from corners\n    // 0.8 is the square of 2/sqrt(5), the distance from\n    // a grid point to the nearest simplex boundary\n    vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n    // Partial derivatives for analytical gradient computation\n    vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n    vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n    // Set influence of each surflet to zero outside radius sqrt(0.8)\n    if (t.x < 0.0) {\n      dtdx.x = 0.0;\n      dtdy.x = 0.0;\n      t.x = 0.0;\n    }\n    if (t.y < 0.0) {\n      dtdx.y = 0.0;\n      dtdy.y = 0.0;\n      t.y = 0.0;\n    }\n    if (t.z < 0.0) {\n      dtdx.z = 0.0;\n      dtdy.z = 0.0;\n      t.z = 0.0;\n    }\n\n    // Fourth power of t (and third power for derivative)\n    vec3 t2 = t * t;\n    vec3 t4 = t2 * t2;\n    vec3 t3 = t2 * t;\n\n    // Final noise value is:\n    // sum of ((radial weights) times (gradient dot vector from corner))\n    float n = dot(t4, w);\n\n    // Final analytical derivative (gradient of a sum of scalar products)\n    vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n    vec2 dn0 = t4.x * g0 + dt0 * w.x;\n    vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n    vec2 dn1 = t4.y * g1 + dt1 * w.y;\n    vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n    vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n    return 11.0*vec3(n, dn0 + dn1 + dn2);\n  }\n\n  //\n  // 2-D tiling simplex noise with fixed gradients\n  // and analytical derivative.\n  // This function is implemented as a wrapper to \"psrdnoise\",\n  // at the minimal cost of three extra additions.\n  //\n  vec3 psdnoise(vec2 pos, vec2 per) {\n    return psrdnoise(pos, per, 0.0);\n  }\n\n  //\n  // 2-D tiling simplex noise with rotating gradients,\n  // but without the analytical derivative.\n  //\n  float psrnoise(vec2 pos, vec2 per, float rot) {\n    // Offset y slightly to hide some rare artifacts\n    pos.y += 0.001;\n    // Skew to hexagonal grid\n    vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n    vec2 i0 = floor(uv);\n    vec2 f0 = fract(uv);\n    // Traversal order\n    vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n    // Unskewed grid points in (x,y) space\n    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n    vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n    // Integer grid point indices in (u,v) space\n    i1 = i0 + i1;\n    vec2 i2 = i0 + vec2(1.0, 1.0);\n\n    // Vectors in unskewed (x,y) coordinates from\n    // each of the simplex corners to the evaluation point\n    vec2 d0 = pos - p0;\n    vec2 d1 = pos - p1;\n    vec2 d2 = pos - p2;\n\n    // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n    // wrap points in (x,y), map to (u,v)\n    vec3 xw = mod(vec3(p0.x, p1.x, p2.x), per.x);\n    vec3 yw = mod(vec3(p0.y, p1.y, p2.y), per.y);\n    vec3 iuw = xw + 0.5 * yw;\n    vec3 ivw = yw;\n\n    // Create gradients from indices\n    vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n    vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n    vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n    // Gradients dot vectors to corresponding corners\n    // (The derivatives of this are simply the gradients)\n    vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n    // Radial weights from corners\n    // 0.8 is the square of 2/sqrt(5), the distance from\n    // a grid point to the nearest simplex boundary\n    vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n    // Set influence of each surflet to zero outside radius sqrt(0.8)\n    t = max(t, 0.0);\n\n    // Fourth power of t\n    vec3 t2 = t * t;\n    vec3 t4 = t2 * t2;\n\n    // Final noise value is:\n    // sum of ((radial weights) times (gradient dot vector from corner))\n    float n = dot(t4, w);\n\n    // Rescale to cover the range [-1,1] reasonably well\n    return 11.0*n;\n  }\n\n  //\n  // 2-D tiling simplex noise with fixed gradients,\n  // without the analytical derivative.\n  // This function is implemented as a wrapper to \"psrnoise\",\n  // at the minimal cost of three extra additions.\n  //\n  float psnoise(vec2 pos, vec2 per) {\n    return psrnoise(pos, per, 0.0);\n  }\n\n  //\n  // 2-D non-tiling simplex noise with rotating gradients and analytical derivative.\n  // The first component of the 3-element return vector is the noise value,\n  // and the second and third components are the x and y partial derivatives.\n  //\n  vec3 srdnoise(vec2 pos, float rot) {\n    // Offset y slightly to hide some rare artifacts\n    pos.y += 0.001;\n    // Skew to hexagonal grid\n    vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n    vec2 i0 = floor(uv);\n    vec2 f0 = fract(uv);\n    // Traversal order\n    vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n    // Unskewed grid points in (x,y) space\n    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n    vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n    // Integer grid point indices in (u,v) space\n    i1 = i0 + i1;\n    vec2 i2 = i0 + vec2(1.0, 1.0);\n\n    // Vectors in unskewed (x,y) coordinates from\n    // each of the simplex corners to the evaluation point\n    vec2 d0 = pos - p0;\n    vec2 d1 = pos - p1;\n    vec2 d2 = pos - p2;\n\n    vec3 x = vec3(p0.x, p1.x, p2.x);\n    vec3 y = vec3(p0.y, p1.y, p2.y);\n    vec3 iuw = x + 0.5 * y;\n    vec3 ivw = y;\n\n    // Avoid precision issues in permutation\n    iuw = mod289(iuw);\n    ivw = mod289(ivw);\n\n    // Create gradients from indices\n    vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n    vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n    vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n    // Gradients dot vectors to corresponding corners\n    // (The derivatives of this are simply the gradients)\n    vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n    // Radial weights from corners\n    // 0.8 is the square of 2/sqrt(5), the distance from\n    // a grid point to the nearest simplex boundary\n    vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n    // Partial derivatives for analytical gradient computation\n    vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n    vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n    // Set influence of each surflet to zero outside radius sqrt(0.8)\n    if (t.x < 0.0) {\n      dtdx.x = 0.0;\n      dtdy.x = 0.0;\n      t.x = 0.0;\n    }\n    if (t.y < 0.0) {\n      dtdx.y = 0.0;\n      dtdy.y = 0.0;\n      t.y = 0.0;\n    }\n    if (t.z < 0.0) {\n      dtdx.z = 0.0;\n      dtdy.z = 0.0;\n      t.z = 0.0;\n    }\n\n    // Fourth power of t (and third power for derivative)\n    vec3 t2 = t * t;\n    vec3 t4 = t2 * t2;\n    vec3 t3 = t2 * t;\n\n    // Final noise value is:\n    // sum of ((radial weights) times (gradient dot vector from corner))\n    float n = dot(t4, w);\n\n    // Final analytical derivative (gradient of a sum of scalar products)\n    vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n    vec2 dn0 = t4.x * g0 + dt0 * w.x;\n    vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n    vec2 dn1 = t4.y * g1 + dt1 * w.y;\n    vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n    vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n    return 11.0*vec3(n, dn0 + dn1 + dn2);\n  }\n\n  //\n  // 2-D non-tiling simplex noise with fixed gradients and analytical derivative.\n  // This function is implemented as a wrapper to \"srdnoise\",\n  // at the minimal cost of three extra additions.\n  //\n  vec3 sdnoise(vec2 pos) {\n    return srdnoise(pos, 0.0);\n  }\n\n  //\n  // 2-D non-tiling simplex noise with rotating gradients,\n  // without the analytical derivative.\n  //\n  float srnoise(vec2 pos, float rot) {\n    // Offset y slightly to hide some rare artifacts\n    pos.y += 0.001;\n    // Skew to hexagonal grid\n    vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n    vec2 i0 = floor(uv);\n    vec2 f0 = fract(uv);\n    // Traversal order\n    vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n    // Unskewed grid points in (x,y) space\n    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n    vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n    // Integer grid point indices in (u,v) space\n    i1 = i0 + i1;\n    vec2 i2 = i0 + vec2(1.0, 1.0);\n\n    // Vectors in unskewed (x,y) coordinates from\n    // each of the simplex corners to the evaluation point\n    vec2 d0 = pos - p0;\n    vec2 d1 = pos - p1;\n    vec2 d2 = pos - p2;\n\n    // Wrap i0, i1 and i2 to the desired period before gradient hashing:\n    // wrap points in (x,y), map to (u,v)\n    vec3 x = vec3(p0.x, p1.x, p2.x);\n    vec3 y = vec3(p0.y, p1.y, p2.y);\n    vec3 iuw = x + 0.5 * y;\n    vec3 ivw = y;\n\n    // Avoid precision issues in permutation\n    iuw = mod289(iuw);\n    ivw = mod289(ivw);\n\n    // Create gradients from indices\n    vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n    vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n    vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n    // Gradients dot vectors to corresponding corners\n    // (The derivatives of this are simply the gradients)\n    vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n    // Radial weights from corners\n    // 0.8 is the square of 2/sqrt(5), the distance from\n    // a grid point to the nearest simplex boundary\n    vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n    // Set influence of each surflet to zero outside radius sqrt(0.8)\n    t = max(t, 0.0);\n\n    // Fourth power of t\n    vec3 t2 = t * t;\n    vec3 t4 = t2 * t2;\n\n    // Final noise value is:\n    // sum of ((radial weights) times (gradient dot vector from corner))\n    float n = dot(t4, w);\n\n    // Rescale to cover the range [-1,1] reasonably well\n    return 11.0*n;\n  }\n\n  //\n  // 2-D non-tiling simplex noise with fixed gradients,\n  // without the analytical derivative.\n  // This function is implemented as a wrapper to \"srnoise\",\n  // at the minimal cost of three extra additions.\n  // Note: if this kind of noise is all you want, there are faster\n  // GLSL implementations of non-tiling simplex noise out there.\n  // This one is included mainly for completeness and compatibility\n  // with the other functions in the file.\n  //\n  float snoise(vec2 pos) {\n    return srnoise(pos, 0.0);\n  }\n\n  float hash(float x, float y) {\n      return fract(abs(sin(sin(123.321 + x) * (y + 321.123)) * 456.654));\n  }\n\n  float lerp(float a, float b, float t) {\n      return a * (1.0 - t) + b * t;\n  }\n\n  float perlin(float x, float y){\n      float col = 0.0;\n      for (int i = 0; i < 8; i++)\n      {\n          float fx = floor(x);\n          float fy = floor(y);\n          float cx = ceil(x);\n          float cy = ceil(y);\n          float a = hash(fx, fy);\n          float b = hash(fx, cy);\n          float c = hash(cx, fy);\n          float d = hash(cx, cy);\n          col += lerp(lerp(a, b, fract(y)), lerp(c, d, fract(y)), fract(x));\n          col /= 2.0;\n          x /= 2.0;\n          y /= 2.0;\n      }\n      return col;\n  }\n\n  float dperlin(float x, float y){\n      float d = perlin(x, y) * 800.0;\n      return perlin(x + d, y + d);\n  }\n\n  float ddperlin(float x, float y){\n      float d = perlin(x, y) * 800.0;\n      return dperlin(x + d, y + d);\n  }\n\n\n  float random( vec3 pt, float seed ){\n    vec3 scale = vec3( 12.9898, 78.233, 151.7182 );\n    return fract( sin( dot( pt + seed, scale ) ) * 43758.5453 + seed ) ;\n  }\n`;\n};\nexports.noise = noise;\n//# sourceMappingURL=noise.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvc2hhZGVycy90aHJlZS1zaGFkZXItY2h1bmtzL25vaXNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3NoYWRlcnMvdGhyZWUtc2hhZGVyLWNodW5rcy9ub2lzZS5qcz80OTZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub2lzZSA9IHZvaWQgMDtcbmNvbnN0IFRIUkVFID0gcmVxdWlyZShcInRocmVlXCIpO1xuY29uc3Qgbm9pc2UgPSAoKSA9PiB7XG4gICAgVEhSRUUuU2hhZGVyQ2h1bmsubm9pc2UgPSBgXG4gIC8vXG4gIC8vIERlc2NyaXB0aW9uIDogQXJyYXkgYW5kIHRleHR1cmVsZXNzIEdMU0wgMkQvM0QvNEQgc2ltcGxleFxuICAvLyAgICAgICAgICAgICAgIG5vaXNlIGZ1bmN0aW9ucy5cbiAgLy8gICAgICBBdXRob3IgOiBJYW4gTWNFd2FuLCBBc2hpbWEgQXJ0cy5cbiAgLy8gIE1haW50YWluZXIgOiBzdGVndVxuICAvLyAgICAgTGFzdG1vZCA6IDIwMTEwODIyIChpam0pXG4gIC8vICAgICBMaWNlbnNlIDogQ29weXJpZ2h0IChDKSAyMDExIEFzaGltYSBBcnRzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICAvLyAgICAgICAgICAgICAgIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cbiAgLy8gICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vYXNoaW1hL3dlYmdsLW5vaXNlXG4gIC8vICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3N0ZWd1L3dlYmdsLW5vaXNlXG4gIC8vXG5cbiAgdmVjMyBtb2QyODkodmVjMyB4KSB7XG4gICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcbiAgfVxuXG4gIHZlYzQgbW9kMjg5KHZlYzQgeCkge1xuICAgIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLjAgLyAyODkuMCkpICogMjg5LjA7XG4gIH1cblxuICB2ZWM0IHBlcm11dGUodmVjNCB4KSB7XG4gICAgICAgcmV0dXJuIG1vZDI4OSgoKHgqMzQuMCkrMS4wKSp4KTtcbiAgfVxuXG4gIC8vIFBlcm11dGF0aW9uIHBvbHlub21pYWwgKHJpbmcgc2l6ZSAyODkgPSAxNyoxNylcbiAgdmVjMyBwZXJtdXRlKHZlYzMgeCkge1xuICAgIHJldHVybiBtb2QyODkoKCh4KjM0LjApKzEuMCkqeCk7XG4gIH1cblxuICBmbG9hdCBwZXJtdXRlKGZsb2F0IHgpe1xuICAgICAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDs7XG4gIH1cblxuICB2ZWM0IHRheWxvckludlNxcnQodmVjNCByKXtcbiAgICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xuICB9XG5cbiAgdmVjMiBmYWRlKHZlYzIgdCkge1xuICAgIHJldHVybiB0KnQqdCoodCoodCo2LjAtMTUuMCkrMTAuMCk7XG4gIH1cblxuICB2ZWMzIGZhZGUodmVjMyB0KSB7XG4gICAgcmV0dXJuIHQqdCp0Kih0Kih0KjYuMC0xNS4wKSsxMC4wKTtcbiAgfVxuXG4gIC8vIEhhc2hlZCAyLUQgZ3JhZGllbnRzIHdpdGggYW4gZXh0cmEgcm90YXRpb24uXG4gIC8vIChUaGUgY29uc3RhbnQgMC4wMjQzOTAyNDM5IGlzIDEvNDEpXG4gIHZlYzIgcmdyYWQyKHZlYzIgcCwgZmxvYXQgcm90KSB7XG4gICNpZiAwXG4gIC8vIE1hcCBmcm9tIGEgbGluZSB0byBhIGRpYW1vbmQgc3VjaCB0aGF0IGEgc2hpZnQgbWFwcyB0byBhIHJvdGF0aW9uLlxuICAgIGZsb2F0IHUgPSBwZXJtdXRlKHBlcm11dGUocC54KSArIHAueSkgKiAwLjAyNDM5MDI0MzkgKyByb3Q7IC8vIFJvdGF0ZSBieSBzaGlmdFxuICAgIHUgPSA0LjAgKiBmcmFjdCh1KSAtIDIuMDtcbiAgICAvLyAoVGhpcyB2ZWN0b3IgY291bGQgYmUgbm9ybWFsaXplZCwgZXhhY3RseSBvciBhcHByb3hpbWF0ZWx5LilcbiAgICByZXR1cm4gdmVjMihhYnModSktMS4wLCBhYnMoYWJzKHUrMS4wKS0yLjApLTEuMCk7XG4gICNlbHNlXG4gIC8vIEZvciBtb3JlIGlzb3Ryb3BpYyBncmFkaWVudHMsIHNpbi9jb3MgY2FuIGJlIHVzZWQgaW5zdGVhZC5cbiAgICBmbG9hdCB1ID0gcGVybXV0ZShwZXJtdXRlKHAueCkgKyBwLnkpICogMC4wMjQzOTAyNDM5ICsgcm90OyAvLyBSb3RhdGUgYnkgc2hpZnRcbiAgICB1ID0gZnJhY3QodSkgKiA2LjI4MzE4NTMwNzE4OyAvLyAyKnBpXG4gICAgcmV0dXJuIHZlYzIoY29zKHUpLCBzaW4odSkpO1xuICAjZW5kaWZcbiAgfVxuXG4gIGZsb2F0IHNub2lzZSh2ZWMzIHYpe1xuICAgIGNvbnN0IHZlYzIgIEMgPSB2ZWMyKDEuMC82LjAsIDEuMC8zLjApIDtcbiAgICBjb25zdCB2ZWM0ICBEID0gdmVjNCgwLjAsIDAuNSwgMS4wLCAyLjApO1xuXG4gIC8vIEZpcnN0IGNvcm5lclxuICAgIHZlYzMgaSAgPSBmbG9vcih2ICsgZG90KHYsIEMueXl5KSApO1xuICAgIHZlYzMgeDAgPSAgIHYgLSBpICsgZG90KGksIEMueHh4KSA7XG5cbiAgLy8gT3RoZXIgY29ybmVyc1xuICAgIHZlYzMgZyA9IHN0ZXAoeDAueXp4LCB4MC54eXopO1xuICAgIHZlYzMgbCA9IDEuMCAtIGc7XG4gICAgdmVjMyBpMSA9IG1pbiggZy54eXosIGwuenh5ICk7XG4gICAgdmVjMyBpMiA9IG1heCggZy54eXosIGwuenh5ICk7XG5cbiAgICAvLyAgIHgwID0geDAgLSAwLjAgKyAwLjAgKiBDLnh4eDtcbiAgICAvLyAgIHgxID0geDAgLSBpMSAgKyAxLjAgKiBDLnh4eDtcbiAgICAvLyAgIHgyID0geDAgLSBpMiAgKyAyLjAgKiBDLnh4eDtcbiAgICAvLyAgIHgzID0geDAgLSAxLjAgKyAzLjAgKiBDLnh4eDtcbiAgICB2ZWMzIHgxID0geDAgLSBpMSArIEMueHh4O1xuICAgIHZlYzMgeDIgPSB4MCAtIGkyICsgQy55eXk7IC8vIDIuMCpDLnggPSAxLzMgPSBDLnlcbiAgICB2ZWMzIHgzID0geDAgLSBELnl5eTsgICAgICAvLyAtMS4wKzMuMCpDLnggPSAtMC41ID0gLUQueVxuXG4gIC8vIFBlcm11dGF0aW9uc1xuICAgIGkgPSBtb2QyODkoaSk7XG4gICAgdmVjNCBwID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZShcbiAgICAgICAgICAgICAgIGkueiArIHZlYzQoMC4wLCBpMS56LCBpMi56LCAxLjAgKSlcbiAgICAgICAgICAgICArIGkueSArIHZlYzQoMC4wLCBpMS55LCBpMi55LCAxLjAgKSlcbiAgICAgICAgICAgICArIGkueCArIHZlYzQoMC4wLCBpMS54LCBpMi54LCAxLjAgKSk7XG5cbiAgLy8gR3JhZGllbnRzOiA3eDcgcG9pbnRzIG92ZXIgYSBzcXVhcmUsIG1hcHBlZCBvbnRvIGFuIG9jdGFoZWRyb24uXG4gIC8vIFRoZSByaW5nIHNpemUgMTcqMTcgPSAyODkgaXMgY2xvc2UgdG8gYSBtdWx0aXBsZSBvZiA0OSAoNDkqNiA9IDI5NClcbiAgICBmbG9hdCBuXyA9IDAuMTQyODU3MTQyODU3OyAvLyAxLjAvNy4wXG4gICAgdmVjMyAgbnMgPSBuXyAqIEQud3l6IC0gRC54eng7XG5cbiAgICB2ZWM0IGogPSBwIC0gNDkuMCAqIGZsb29yKHAgKiBucy56ICogbnMueik7ICAvLyAgbW9kKHAsNyo3KVxuXG4gICAgdmVjNCB4XyA9IGZsb29yKGogKiBucy56KTtcbiAgICB2ZWM0IHlfID0gZmxvb3IoaiAtIDcuMCAqIHhfICk7ICAgIC8vIG1vZChqLE4pXG5cbiAgICB2ZWM0IHggPSB4XyAqbnMueCArIG5zLnl5eXk7XG4gICAgdmVjNCB5ID0geV8gKm5zLnggKyBucy55eXl5O1xuICAgIHZlYzQgaCA9IDEuMCAtIGFicyh4KSAtIGFicyh5KTtcblxuICAgIHZlYzQgYjAgPSB2ZWM0KCB4Lnh5LCB5Lnh5ICk7XG4gICAgdmVjNCBiMSA9IHZlYzQoIHguencsIHkuencgKTtcblxuICAgIC8vdmVjNCBzMCA9IHZlYzQobGVzc1RoYW4oYjAsMC4wKSkqMi4wIC0gMS4wO1xuICAgIC8vdmVjNCBzMSA9IHZlYzQobGVzc1RoYW4oYjEsMC4wKSkqMi4wIC0gMS4wO1xuICAgIHZlYzQgczAgPSBmbG9vcihiMCkqMi4wICsgMS4wO1xuICAgIHZlYzQgczEgPSBmbG9vcihiMSkqMi4wICsgMS4wO1xuICAgIHZlYzQgc2ggPSAtc3RlcChoLCB2ZWM0KDAuMCkpO1xuXG4gICAgdmVjNCBhMCA9IGIwLnh6eXcgKyBzMC54enl3KnNoLnh4eXkgO1xuICAgIHZlYzQgYTEgPSBiMS54enl3ICsgczEueHp5dypzaC56end3IDtcblxuICAgIHZlYzMgcDAgPSB2ZWMzKGEwLnh5LGgueCk7XG4gICAgdmVjMyBwMSA9IHZlYzMoYTAuencsaC55KTtcbiAgICB2ZWMzIHAyID0gdmVjMyhhMS54eSxoLnopO1xuICAgIHZlYzMgcDMgPSB2ZWMzKGExLnp3LGgudyk7XG5cbiAgLy9Ob3JtYWxpc2UgZ3JhZGllbnRzXG4gICAgdmVjNCBub3JtID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChwMCxwMCksIGRvdChwMSxwMSksIGRvdChwMiwgcDIpLCBkb3QocDMscDMpKSk7XG4gICAgcDAgKj0gbm9ybS54O1xuICAgIHAxICo9IG5vcm0ueTtcbiAgICBwMiAqPSBub3JtLno7XG4gICAgcDMgKj0gbm9ybS53O1xuXG4gIC8vIE1peCBmaW5hbCBub2lzZSB2YWx1ZVxuICAgIHZlYzQgbSA9IG1heCgwLjYgLSB2ZWM0KGRvdCh4MCx4MCksIGRvdCh4MSx4MSksIGRvdCh4Mix4MiksIGRvdCh4Myx4MykpLCAwLjApO1xuICAgIG0gPSBtICogbTtcbiAgICByZXR1cm4gNDIuMCAqIGRvdCggbSptLCB2ZWM0KCBkb3QocDAseDApLCBkb3QocDEseDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdChwMix4MiksIGRvdChwMyx4MykgKSApO1xuICAgIH1cblxuICAvLyBDbGFzc2ljIFBlcmxpbiBub2lzZVxuICBmbG9hdCBjbm9pc2UodmVjMiBQKXtcbiAgICB2ZWM0IFBpID0gZmxvb3IoUC54eXh5KSArIHZlYzQoMC4wLCAwLjAsIDEuMCwgMS4wKTtcbiAgICB2ZWM0IFBmID0gZnJhY3QoUC54eXh5KSAtIHZlYzQoMC4wLCAwLjAsIDEuMCwgMS4wKTtcbiAgICBQaSA9IG1vZDI4OShQaSk7IC8vIFRvIGF2b2lkIHRydW5jYXRpb24gZWZmZWN0cyBpbiBwZXJtdXRhdGlvblxuICAgIHZlYzQgaXggPSBQaS54enh6O1xuICAgIHZlYzQgaXkgPSBQaS55eXd3O1xuICAgIHZlYzQgZnggPSBQZi54enh6O1xuICAgIHZlYzQgZnkgPSBQZi55eXd3O1xuXG4gICAgdmVjNCBpID0gcGVybXV0ZShwZXJtdXRlKGl4KSArIGl5KTtcblxuICAgIHZlYzQgZ3ggPSBmcmFjdChpICogKDEuMCAvIDQxLjApKSAqIDIuMCAtIDEuMCA7XG4gICAgdmVjNCBneSA9IGFicyhneCkgLSAwLjUgO1xuICAgIHZlYzQgdHggPSBmbG9vcihneCArIDAuNSk7XG4gICAgZ3ggPSBneCAtIHR4O1xuXG4gICAgdmVjMiBnMDAgPSB2ZWMyKGd4LngsZ3kueCk7XG4gICAgdmVjMiBnMTAgPSB2ZWMyKGd4LnksZ3kueSk7XG4gICAgdmVjMiBnMDEgPSB2ZWMyKGd4LnosZ3kueik7XG4gICAgdmVjMiBnMTEgPSB2ZWMyKGd4LncsZ3kudyk7XG5cbiAgICB2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMCwgZzAwKSwgZG90KGcwMSwgZzAxKSwgZG90KGcxMCwgZzEwKSwgZG90KGcxMSwgZzExKSkpO1xuICAgIGcwMCAqPSBub3JtLng7XG4gICAgZzAxICo9IG5vcm0ueTtcbiAgICBnMTAgKj0gbm9ybS56O1xuICAgIGcxMSAqPSBub3JtLnc7XG5cbiAgICBmbG9hdCBuMDAgPSBkb3QoZzAwLCB2ZWMyKGZ4LngsIGZ5LngpKTtcbiAgICBmbG9hdCBuMTAgPSBkb3QoZzEwLCB2ZWMyKGZ4LnksIGZ5LnkpKTtcbiAgICBmbG9hdCBuMDEgPSBkb3QoZzAxLCB2ZWMyKGZ4LnosIGZ5LnopKTtcbiAgICBmbG9hdCBuMTEgPSBkb3QoZzExLCB2ZWMyKGZ4LncsIGZ5LncpKTtcblxuICAgIHZlYzIgZmFkZV94eSA9IGZhZGUoUGYueHkpO1xuICAgIHZlYzIgbl94ID0gbWl4KHZlYzIobjAwLCBuMDEpLCB2ZWMyKG4xMCwgbjExKSwgZmFkZV94eS54KTtcbiAgICBmbG9hdCBuX3h5ID0gbWl4KG5feC54LCBuX3gueSwgZmFkZV94eS55KTtcbiAgICByZXR1cm4gMi4zICogbl94eTtcbiAgfVxuXG4gIC8vIENsYXNzaWMgUGVybGluIG5vaXNlLCBwZXJpb2RpYyB2YXJpYW50XG4gIGZsb2F0IHBub2lzZSh2ZWMyIFAsIHZlYzIgcmVwKXtcbiAgICB2ZWM0IFBpID0gZmxvb3IoUC54eXh5KSArIHZlYzQoMC4wLCAwLjAsIDEuMCwgMS4wKTtcbiAgICB2ZWM0IFBmID0gZnJhY3QoUC54eXh5KSAtIHZlYzQoMC4wLCAwLjAsIDEuMCwgMS4wKTtcbiAgICBQaSA9IG1vZChQaSwgcmVwLnh5eHkpOyAvLyBUbyBjcmVhdGUgbm9pc2Ugd2l0aCBleHBsaWNpdCBwZXJpb2RcbiAgICBQaSA9IG1vZDI4OShQaSk7ICAgICAgICAvLyBUbyBhdm9pZCB0cnVuY2F0aW9uIGVmZmVjdHMgaW4gcGVybXV0YXRpb25cbiAgICB2ZWM0IGl4ID0gUGkueHp4ejtcbiAgICB2ZWM0IGl5ID0gUGkueXl3dztcbiAgICB2ZWM0IGZ4ID0gUGYueHp4ejtcbiAgICB2ZWM0IGZ5ID0gUGYueXl3dztcblxuICAgIHZlYzQgaSA9IHBlcm11dGUocGVybXV0ZShpeCkgKyBpeSk7XG5cbiAgICB2ZWM0IGd4ID0gZnJhY3QoaSAqICgxLjAgLyA0MS4wKSkgKiAyLjAgLSAxLjAgO1xuICAgIHZlYzQgZ3kgPSBhYnMoZ3gpIC0gMC41IDtcbiAgICB2ZWM0IHR4ID0gZmxvb3IoZ3ggKyAwLjUpO1xuICAgIGd4ID0gZ3ggLSB0eDtcblxuICAgIHZlYzIgZzAwID0gdmVjMihneC54LGd5LngpO1xuICAgIHZlYzIgZzEwID0gdmVjMihneC55LGd5LnkpO1xuICAgIHZlYzIgZzAxID0gdmVjMihneC56LGd5LnopO1xuICAgIHZlYzIgZzExID0gdmVjMihneC53LGd5LncpO1xuXG4gICAgdmVjNCBub3JtID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChnMDAsIGcwMCksIGRvdChnMDEsIGcwMSksIGRvdChnMTAsIGcxMCksIGRvdChnMTEsIGcxMSkpKTtcbiAgICBnMDAgKj0gbm9ybS54O1xuICAgIGcwMSAqPSBub3JtLnk7XG4gICAgZzEwICo9IG5vcm0uejtcbiAgICBnMTEgKj0gbm9ybS53O1xuXG4gICAgZmxvYXQgbjAwID0gZG90KGcwMCwgdmVjMihmeC54LCBmeS54KSk7XG4gICAgZmxvYXQgbjEwID0gZG90KGcxMCwgdmVjMihmeC55LCBmeS55KSk7XG4gICAgZmxvYXQgbjAxID0gZG90KGcwMSwgdmVjMihmeC56LCBmeS56KSk7XG4gICAgZmxvYXQgbjExID0gZG90KGcxMSwgdmVjMihmeC53LCBmeS53KSk7XG5cbiAgICB2ZWMyIGZhZGVfeHkgPSBmYWRlKFBmLnh5KTtcbiAgICB2ZWMyIG5feCA9IG1peCh2ZWMyKG4wMCwgbjAxKSwgdmVjMihuMTAsIG4xMSksIGZhZGVfeHkueCk7XG4gICAgZmxvYXQgbl94eSA9IG1peChuX3gueCwgbl94LnksIGZhZGVfeHkueSk7XG4gICAgcmV0dXJuIDIuMyAqIG5feHk7XG4gIH1cbiAgLy8gQ2xhc3NpYyBQZXJsaW4gbm9pc2VcbiAgZmxvYXQgY25vaXNlKHZlYzMgUClcbiAge1xuICAgIHZlYzMgUGkwID0gZmxvb3IoUCk7IC8vIEludGVnZXIgcGFydCBmb3IgaW5kZXhpbmdcbiAgICB2ZWMzIFBpMSA9IFBpMCArIHZlYzMoMS4wKTsgLy8gSW50ZWdlciBwYXJ0ICsgMVxuICAgIFBpMCA9IG1vZDI4OShQaTApO1xuICAgIFBpMSA9IG1vZDI4OShQaTEpO1xuICAgIHZlYzMgUGYwID0gZnJhY3QoUCk7IC8vIEZyYWN0aW9uYWwgcGFydCBmb3IgaW50ZXJwb2xhdGlvblxuICAgIHZlYzMgUGYxID0gUGYwIC0gdmVjMygxLjApOyAvLyBGcmFjdGlvbmFsIHBhcnQgLSAxLjBcbiAgICB2ZWM0IGl4ID0gdmVjNChQaTAueCwgUGkxLngsIFBpMC54LCBQaTEueCk7XG4gICAgdmVjNCBpeSA9IHZlYzQoUGkwLnl5LCBQaTEueXkpO1xuICAgIHZlYzQgaXowID0gUGkwLnp6eno7XG4gICAgdmVjNCBpejEgPSBQaTEuenp6ejtcblxuICAgIHZlYzQgaXh5ID0gcGVybXV0ZShwZXJtdXRlKGl4KSArIGl5KTtcbiAgICB2ZWM0IGl4eTAgPSBwZXJtdXRlKGl4eSArIGl6MCk7XG4gICAgdmVjNCBpeHkxID0gcGVybXV0ZShpeHkgKyBpejEpO1xuXG4gICAgdmVjNCBneDAgPSBpeHkwICogKDEuMCAvIDcuMCk7XG4gICAgdmVjNCBneTAgPSBmcmFjdChmbG9vcihneDApICogKDEuMCAvIDcuMCkpIC0gMC41O1xuICAgIGd4MCA9IGZyYWN0KGd4MCk7XG4gICAgdmVjNCBnejAgPSB2ZWM0KDAuNSkgLSBhYnMoZ3gwKSAtIGFicyhneTApO1xuICAgIHZlYzQgc3owID0gc3RlcChnejAsIHZlYzQoMC4wKSk7XG4gICAgZ3gwIC09IHN6MCAqIChzdGVwKDAuMCwgZ3gwKSAtIDAuNSk7XG4gICAgZ3kwIC09IHN6MCAqIChzdGVwKDAuMCwgZ3kwKSAtIDAuNSk7XG5cbiAgICB2ZWM0IGd4MSA9IGl4eTEgKiAoMS4wIC8gNy4wKTtcbiAgICB2ZWM0IGd5MSA9IGZyYWN0KGZsb29yKGd4MSkgKiAoMS4wIC8gNy4wKSkgLSAwLjU7XG4gICAgZ3gxID0gZnJhY3QoZ3gxKTtcbiAgICB2ZWM0IGd6MSA9IHZlYzQoMC41KSAtIGFicyhneDEpIC0gYWJzKGd5MSk7XG4gICAgdmVjNCBzejEgPSBzdGVwKGd6MSwgdmVjNCgwLjApKTtcbiAgICBneDEgLT0gc3oxICogKHN0ZXAoMC4wLCBneDEpIC0gMC41KTtcbiAgICBneTEgLT0gc3oxICogKHN0ZXAoMC4wLCBneTEpIC0gMC41KTtcblxuICAgIHZlYzMgZzAwMCA9IHZlYzMoZ3gwLngsZ3kwLngsZ3owLngpO1xuICAgIHZlYzMgZzEwMCA9IHZlYzMoZ3gwLnksZ3kwLnksZ3owLnkpO1xuICAgIHZlYzMgZzAxMCA9IHZlYzMoZ3gwLnosZ3kwLnosZ3owLnopO1xuICAgIHZlYzMgZzExMCA9IHZlYzMoZ3gwLncsZ3kwLncsZ3owLncpO1xuICAgIHZlYzMgZzAwMSA9IHZlYzMoZ3gxLngsZ3kxLngsZ3oxLngpO1xuICAgIHZlYzMgZzEwMSA9IHZlYzMoZ3gxLnksZ3kxLnksZ3oxLnkpO1xuICAgIHZlYzMgZzAxMSA9IHZlYzMoZ3gxLnosZ3kxLnosZ3oxLnopO1xuICAgIHZlYzMgZzExMSA9IHZlYzMoZ3gxLncsZ3kxLncsZ3oxLncpO1xuXG4gICAgdmVjNCBub3JtMCA9IHRheWxvckludlNxcnQodmVjNChkb3QoZzAwMCwgZzAwMCksIGRvdChnMDEwLCBnMDEwKSwgZG90KGcxMDAsIGcxMDApLCBkb3QoZzExMCwgZzExMCkpKTtcbiAgICBnMDAwICo9IG5vcm0wLng7XG4gICAgZzAxMCAqPSBub3JtMC55O1xuICAgIGcxMDAgKj0gbm9ybTAuejtcbiAgICBnMTEwICo9IG5vcm0wLnc7XG4gICAgdmVjNCBub3JtMSA9IHRheWxvckludlNxcnQodmVjNChkb3QoZzAwMSwgZzAwMSksIGRvdChnMDExLCBnMDExKSwgZG90KGcxMDEsIGcxMDEpLCBkb3QoZzExMSwgZzExMSkpKTtcbiAgICBnMDAxICo9IG5vcm0xLng7XG4gICAgZzAxMSAqPSBub3JtMS55O1xuICAgIGcxMDEgKj0gbm9ybTEuejtcbiAgICBnMTExICo9IG5vcm0xLnc7XG5cbiAgICBmbG9hdCBuMDAwID0gZG90KGcwMDAsIFBmMCk7XG4gICAgZmxvYXQgbjEwMCA9IGRvdChnMTAwLCB2ZWMzKFBmMS54LCBQZjAueXopKTtcbiAgICBmbG9hdCBuMDEwID0gZG90KGcwMTAsIHZlYzMoUGYwLngsIFBmMS55LCBQZjAueikpO1xuICAgIGZsb2F0IG4xMTAgPSBkb3QoZzExMCwgdmVjMyhQZjEueHksIFBmMC56KSk7XG4gICAgZmxvYXQgbjAwMSA9IGRvdChnMDAxLCB2ZWMzKFBmMC54eSwgUGYxLnopKTtcbiAgICBmbG9hdCBuMTAxID0gZG90KGcxMDEsIHZlYzMoUGYxLngsIFBmMC55LCBQZjEueikpO1xuICAgIGZsb2F0IG4wMTEgPSBkb3QoZzAxMSwgdmVjMyhQZjAueCwgUGYxLnl6KSk7XG4gICAgZmxvYXQgbjExMSA9IGRvdChnMTExLCBQZjEpO1xuXG4gICAgdmVjMyBmYWRlX3h5eiA9IGZhZGUoUGYwKTtcbiAgICB2ZWM0IG5feiA9IG1peCh2ZWM0KG4wMDAsIG4xMDAsIG4wMTAsIG4xMTApLCB2ZWM0KG4wMDEsIG4xMDEsIG4wMTEsIG4xMTEpLCBmYWRlX3h5ei56KTtcbiAgICB2ZWMyIG5feXogPSBtaXgobl96Lnh5LCBuX3ouencsIGZhZGVfeHl6LnkpO1xuICAgIGZsb2F0IG5feHl6ID0gbWl4KG5feXoueCwgbl95ei55LCBmYWRlX3h5ei54KTtcbiAgICByZXR1cm4gMi4yICogbl94eXo7XG4gIH1cblxuICAvLyBDbGFzc2ljIFBlcmxpbiBub2lzZSwgcGVyaW9kaWMgdmFyaWFudFxuICBmbG9hdCBwbm9pc2UodmVjMyBQLCB2ZWMzIHJlcClcbiAge1xuICAgIHZlYzMgUGkwID0gbW9kKGZsb29yKFApLCByZXApOyAvLyBJbnRlZ2VyIHBhcnQsIG1vZHVsbyBwZXJpb2RcbiAgICB2ZWMzIFBpMSA9IG1vZChQaTAgKyB2ZWMzKDEuMCksIHJlcCk7IC8vIEludGVnZXIgcGFydCArIDEsIG1vZCBwZXJpb2RcbiAgICBQaTAgPSBtb2QyODkoUGkwKTtcbiAgICBQaTEgPSBtb2QyODkoUGkxKTtcbiAgICB2ZWMzIFBmMCA9IGZyYWN0KFApOyAvLyBGcmFjdGlvbmFsIHBhcnQgZm9yIGludGVycG9sYXRpb25cbiAgICB2ZWMzIFBmMSA9IFBmMCAtIHZlYzMoMS4wKTsgLy8gRnJhY3Rpb25hbCBwYXJ0IC0gMS4wXG4gICAgdmVjNCBpeCA9IHZlYzQoUGkwLngsIFBpMS54LCBQaTAueCwgUGkxLngpO1xuICAgIHZlYzQgaXkgPSB2ZWM0KFBpMC55eSwgUGkxLnl5KTtcbiAgICB2ZWM0IGl6MCA9IFBpMC56enp6O1xuICAgIHZlYzQgaXoxID0gUGkxLnp6eno7XG5cbiAgICB2ZWM0IGl4eSA9IHBlcm11dGUocGVybXV0ZShpeCkgKyBpeSk7XG4gICAgdmVjNCBpeHkwID0gcGVybXV0ZShpeHkgKyBpejApO1xuICAgIHZlYzQgaXh5MSA9IHBlcm11dGUoaXh5ICsgaXoxKTtcblxuICAgIHZlYzQgZ3gwID0gaXh5MCAqICgxLjAgLyA3LjApO1xuICAgIHZlYzQgZ3kwID0gZnJhY3QoZmxvb3IoZ3gwKSAqICgxLjAgLyA3LjApKSAtIDAuNTtcbiAgICBneDAgPSBmcmFjdChneDApO1xuICAgIHZlYzQgZ3owID0gdmVjNCgwLjUpIC0gYWJzKGd4MCkgLSBhYnMoZ3kwKTtcbiAgICB2ZWM0IHN6MCA9IHN0ZXAoZ3owLCB2ZWM0KDAuMCkpO1xuICAgIGd4MCAtPSBzejAgKiAoc3RlcCgwLjAsIGd4MCkgLSAwLjUpO1xuICAgIGd5MCAtPSBzejAgKiAoc3RlcCgwLjAsIGd5MCkgLSAwLjUpO1xuXG4gICAgdmVjNCBneDEgPSBpeHkxICogKDEuMCAvIDcuMCk7XG4gICAgdmVjNCBneTEgPSBmcmFjdChmbG9vcihneDEpICogKDEuMCAvIDcuMCkpIC0gMC41O1xuICAgIGd4MSA9IGZyYWN0KGd4MSk7XG4gICAgdmVjNCBnejEgPSB2ZWM0KDAuNSkgLSBhYnMoZ3gxKSAtIGFicyhneTEpO1xuICAgIHZlYzQgc3oxID0gc3RlcChnejEsIHZlYzQoMC4wKSk7XG4gICAgZ3gxIC09IHN6MSAqIChzdGVwKDAuMCwgZ3gxKSAtIDAuNSk7XG4gICAgZ3kxIC09IHN6MSAqIChzdGVwKDAuMCwgZ3kxKSAtIDAuNSk7XG5cbiAgICB2ZWMzIGcwMDAgPSB2ZWMzKGd4MC54LGd5MC54LGd6MC54KTtcbiAgICB2ZWMzIGcxMDAgPSB2ZWMzKGd4MC55LGd5MC55LGd6MC55KTtcbiAgICB2ZWMzIGcwMTAgPSB2ZWMzKGd4MC56LGd5MC56LGd6MC56KTtcbiAgICB2ZWMzIGcxMTAgPSB2ZWMzKGd4MC53LGd5MC53LGd6MC53KTtcbiAgICB2ZWMzIGcwMDEgPSB2ZWMzKGd4MS54LGd5MS54LGd6MS54KTtcbiAgICB2ZWMzIGcxMDEgPSB2ZWMzKGd4MS55LGd5MS55LGd6MS55KTtcbiAgICB2ZWMzIGcwMTEgPSB2ZWMzKGd4MS56LGd5MS56LGd6MS56KTtcbiAgICB2ZWMzIGcxMTEgPSB2ZWMzKGd4MS53LGd5MS53LGd6MS53KTtcblxuICAgIHZlYzQgbm9ybTAgPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMDAsIGcwMDApLCBkb3QoZzAxMCwgZzAxMCksIGRvdChnMTAwLCBnMTAwKSwgZG90KGcxMTAsIGcxMTApKSk7XG4gICAgZzAwMCAqPSBub3JtMC54O1xuICAgIGcwMTAgKj0gbm9ybTAueTtcbiAgICBnMTAwICo9IG5vcm0wLno7XG4gICAgZzExMCAqPSBub3JtMC53O1xuICAgIHZlYzQgbm9ybTEgPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KGcwMDEsIGcwMDEpLCBkb3QoZzAxMSwgZzAxMSksIGRvdChnMTAxLCBnMTAxKSwgZG90KGcxMTEsIGcxMTEpKSk7XG4gICAgZzAwMSAqPSBub3JtMS54O1xuICAgIGcwMTEgKj0gbm9ybTEueTtcbiAgICBnMTAxICo9IG5vcm0xLno7XG4gICAgZzExMSAqPSBub3JtMS53O1xuXG4gICAgZmxvYXQgbjAwMCA9IGRvdChnMDAwLCBQZjApO1xuICAgIGZsb2F0IG4xMDAgPSBkb3QoZzEwMCwgdmVjMyhQZjEueCwgUGYwLnl6KSk7XG4gICAgZmxvYXQgbjAxMCA9IGRvdChnMDEwLCB2ZWMzKFBmMC54LCBQZjEueSwgUGYwLnopKTtcbiAgICBmbG9hdCBuMTEwID0gZG90KGcxMTAsIHZlYzMoUGYxLnh5LCBQZjAueikpO1xuICAgIGZsb2F0IG4wMDEgPSBkb3QoZzAwMSwgdmVjMyhQZjAueHksIFBmMS56KSk7XG4gICAgZmxvYXQgbjEwMSA9IGRvdChnMTAxLCB2ZWMzKFBmMS54LCBQZjAueSwgUGYxLnopKTtcbiAgICBmbG9hdCBuMDExID0gZG90KGcwMTEsIHZlYzMoUGYwLngsIFBmMS55eikpO1xuICAgIGZsb2F0IG4xMTEgPSBkb3QoZzExMSwgUGYxKTtcblxuICAgIHZlYzMgZmFkZV94eXogPSBmYWRlKFBmMCk7XG4gICAgdmVjNCBuX3ogPSBtaXgodmVjNChuMDAwLCBuMTAwLCBuMDEwLCBuMTEwKSwgdmVjNChuMDAxLCBuMTAxLCBuMDExLCBuMTExKSwgZmFkZV94eXoueik7XG4gICAgdmVjMiBuX3l6ID0gbWl4KG5fei54eSwgbl96Lnp3LCBmYWRlX3h5ei55KTtcbiAgICBmbG9hdCBuX3h5eiA9IG1peChuX3l6LngsIG5feXoueSwgZmFkZV94eXoueCk7XG4gICAgcmV0dXJuIDIuMiAqIG5feHl6O1xuICB9XG5cbiAgZmxvYXQgdHVyYnVsZW5jZSggdmVjMyBwICkge1xuICAgIGZsb2F0IHcgPSAxMDAuMDtcbiAgICBmbG9hdCB0ID0gLS41O1xuXG4gICAgZm9yIChmbG9hdCBmID0gMS4wIDsgZiA8PSAxMC4wIDsgZisrICl7XG4gICAgICBmbG9hdCBwb3dlciA9IHBvdyggMi4wLCBmICk7XG4gICAgICB0ICs9IGFicyggcG5vaXNlKCB2ZWMzKCBwb3dlciAqIHAgKSwgdmVjMyggMTAuMCwgMTAuMCwgMTAuMCApICkgLyBwb3dlciApO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9XG5cbiAgZmxvYXQgdHVyYnVsZW5jZTMoIHZlYzMgcCApIHtcbiAgICBmbG9hdCB3ID0gMTAwLjA7XG4gICAgZmxvYXQgdCA9IC0uNTtcblxuICAgIGZvciAoZmxvYXQgZiA9IDEuMCA7IGYgPD0gMy4wIDsgZisrICl7XG4gICAgICBmbG9hdCBwb3dlciA9IHBvdyggMi4wLCBmICk7XG4gICAgICB0ICs9IGFicyggcG5vaXNlKCB2ZWMzKCBwb3dlciAqIHAgKSwgdmVjMyggMy4wLCAzLjAsIDMuMCApICkgLyBwb3dlciApO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9XG5cbiAgZmxvYXQgdHVyYnVsZW5jZTYoIHZlYzMgcCApIHtcbiAgICBmbG9hdCB3ID0gMTAwLjA7XG4gICAgZmxvYXQgdCA9IC0uNTtcblxuICAgIGZvciAoZmxvYXQgZiA9IDEuMCA7IGYgPD0gNi4wIDsgZisrICl7XG4gICAgICBmbG9hdCBwb3dlciA9IHBvdyggMi4wLCBmICk7XG4gICAgICB0ICs9IGFicyggcG5vaXNlKCB2ZWMzKCBwb3dlciAqIHAgKSwgdmVjMyggNi4wLCA2LjAsIDYuMCApICkgLyBwb3dlciApO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9XG5cbiAgLy9cbiAgLy8gMi1EIHRpbGluZyBzaW1wbGV4IG5vaXNlIHdpdGggcm90YXRpbmcgZ3JhZGllbnRzIGFuZCBhbmFseXRpY2FsIGRlcml2YXRpdmUuXG4gIC8vIFRoZSBmaXJzdCBjb21wb25lbnQgb2YgdGhlIDMtZWxlbWVudCByZXR1cm4gdmVjdG9yIGlzIHRoZSBub2lzZSB2YWx1ZSxcbiAgLy8gYW5kIHRoZSBzZWNvbmQgYW5kIHRoaXJkIGNvbXBvbmVudHMgYXJlIHRoZSB4IGFuZCB5IHBhcnRpYWwgZGVyaXZhdGl2ZXMuXG4gIC8vXG4gIHZlYzMgcHNyZG5vaXNlKHZlYzIgcG9zLCB2ZWMyIHBlciwgZmxvYXQgcm90KSB7XG4gICAgLy8gSGFjazogb2Zmc2V0IHkgc2xpZ2h0bHkgdG8gaGlkZSBzb21lIHJhcmUgYXJ0aWZhY3RzXG4gICAgcG9zLnkgKz0gMC4wMTtcbiAgICAvLyBTa2V3IHRvIGhleGFnb25hbCBncmlkXG4gICAgdmVjMiB1diA9IHZlYzIocG9zLnggKyBwb3MueSowLjUsIHBvcy55KTtcblxuICAgIHZlYzIgaTAgPSBmbG9vcih1dik7XG4gICAgdmVjMiBmMCA9IGZyYWN0KHV2KTtcbiAgICAvLyBUcmF2ZXJzYWwgb3JkZXJcbiAgICB2ZWMyIGkxID0gKGYwLnggPiBmMC55KSA/IHZlYzIoMS4wLCAwLjApIDogdmVjMigwLjAsIDEuMCk7XG5cbiAgICAvLyBVbnNrZXdlZCBncmlkIHBvaW50cyBpbiAoeCx5KSBzcGFjZVxuICAgIHZlYzIgcDAgPSB2ZWMyKGkwLnggLSBpMC55ICogMC41LCBpMC55KTtcbiAgICB2ZWMyIHAxID0gdmVjMihwMC54ICsgaTEueCAtIGkxLnkgKiAwLjUsIHAwLnkgKyBpMS55KTtcbiAgICB2ZWMyIHAyID0gdmVjMihwMC54ICsgMC41LCBwMC55ICsgMS4wKTtcblxuICAgIC8vIEludGVnZXIgZ3JpZCBwb2ludCBpbmRpY2VzIGluICh1LHYpIHNwYWNlXG4gICAgaTEgPSBpMCArIGkxO1xuICAgIHZlYzIgaTIgPSBpMCArIHZlYzIoMS4wLCAxLjApO1xuXG4gICAgLy8gVmVjdG9ycyBpbiB1bnNrZXdlZCAoeCx5KSBjb29yZGluYXRlcyBmcm9tXG4gICAgLy8gZWFjaCBvZiB0aGUgc2ltcGxleCBjb3JuZXJzIHRvIHRoZSBldmFsdWF0aW9uIHBvaW50XG4gICAgdmVjMiBkMCA9IHBvcyAtIHAwO1xuICAgIHZlYzIgZDEgPSBwb3MgLSBwMTtcbiAgICB2ZWMyIGQyID0gcG9zIC0gcDI7XG5cbiAgICAvLyBXcmFwIGkwLCBpMSBhbmQgaTIgdG8gdGhlIGRlc2lyZWQgcGVyaW9kIGJlZm9yZSBncmFkaWVudCBoYXNoaW5nOlxuICAgIC8vIHdyYXAgcG9pbnRzIGluICh4LHkpLCBtYXAgdG8gKHUsdilcbiAgICB2ZWMzIHh3ID0gbW9kKHZlYzMocDAueCwgcDEueCwgcDIueCksIHBlci54KTtcbiAgICB2ZWMzIHl3ID0gbW9kKHZlYzMocDAueSwgcDEueSwgcDIueSksIHBlci55KTtcbiAgICB2ZWMzIGl1dyA9IHh3ICsgMC41ICogeXc7XG4gICAgdmVjMyBpdncgPSB5dztcblxuICAgIC8vIENyZWF0ZSBncmFkaWVudHMgZnJvbSBpbmRpY2VzXG4gICAgdmVjMiBnMCA9IHJncmFkMih2ZWMyKGl1dy54LCBpdncueCksIHJvdCk7XG4gICAgdmVjMiBnMSA9IHJncmFkMih2ZWMyKGl1dy55LCBpdncueSksIHJvdCk7XG4gICAgdmVjMiBnMiA9IHJncmFkMih2ZWMyKGl1dy56LCBpdncueiksIHJvdCk7XG5cbiAgICAvLyBHcmFkaWVudHMgZG90IHZlY3RvcnMgdG8gY29ycmVzcG9uZGluZyBjb3JuZXJzXG4gICAgLy8gKFRoZSBkZXJpdmF0aXZlcyBvZiB0aGlzIGFyZSBzaW1wbHkgdGhlIGdyYWRpZW50cylcbiAgICB2ZWMzIHcgPSB2ZWMzKGRvdChnMCwgZDApLCBkb3QoZzEsIGQxKSwgZG90KGcyLCBkMikpO1xuXG4gICAgLy8gUmFkaWFsIHdlaWdodHMgZnJvbSBjb3JuZXJzXG4gICAgLy8gMC44IGlzIHRoZSBzcXVhcmUgb2YgMi9zcXJ0KDUpLCB0aGUgZGlzdGFuY2UgZnJvbVxuICAgIC8vIGEgZ3JpZCBwb2ludCB0byB0aGUgbmVhcmVzdCBzaW1wbGV4IGJvdW5kYXJ5XG4gICAgdmVjMyB0ID0gMC44IC0gdmVjMyhkb3QoZDAsIGQwKSwgZG90KGQxLCBkMSksIGRvdChkMiwgZDIpKTtcblxuICAgIC8vIFBhcnRpYWwgZGVyaXZhdGl2ZXMgZm9yIGFuYWx5dGljYWwgZ3JhZGllbnQgY29tcHV0YXRpb25cbiAgICB2ZWMzIGR0ZHggPSAtMi4wICogdmVjMyhkMC54LCBkMS54LCBkMi54KTtcbiAgICB2ZWMzIGR0ZHkgPSAtMi4wICogdmVjMyhkMC55LCBkMS55LCBkMi55KTtcblxuICAgIC8vIFNldCBpbmZsdWVuY2Ugb2YgZWFjaCBzdXJmbGV0IHRvIHplcm8gb3V0c2lkZSByYWRpdXMgc3FydCgwLjgpXG4gICAgaWYgKHQueCA8IDAuMCkge1xuICAgICAgZHRkeC54ID0gMC4wO1xuICAgICAgZHRkeS54ID0gMC4wO1xuICAgICAgdC54ID0gMC4wO1xuICAgIH1cbiAgICBpZiAodC55IDwgMC4wKSB7XG4gICAgICBkdGR4LnkgPSAwLjA7XG4gICAgICBkdGR5LnkgPSAwLjA7XG4gICAgICB0LnkgPSAwLjA7XG4gICAgfVxuICAgIGlmICh0LnogPCAwLjApIHtcbiAgICAgIGR0ZHgueiA9IDAuMDtcbiAgICAgIGR0ZHkueiA9IDAuMDtcbiAgICAgIHQueiA9IDAuMDtcbiAgICB9XG5cbiAgICAvLyBGb3VydGggcG93ZXIgb2YgdCAoYW5kIHRoaXJkIHBvd2VyIGZvciBkZXJpdmF0aXZlKVxuICAgIHZlYzMgdDIgPSB0ICogdDtcbiAgICB2ZWMzIHQ0ID0gdDIgKiB0MjtcbiAgICB2ZWMzIHQzID0gdDIgKiB0O1xuXG4gICAgLy8gRmluYWwgbm9pc2UgdmFsdWUgaXM6XG4gICAgLy8gc3VtIG9mICgocmFkaWFsIHdlaWdodHMpIHRpbWVzIChncmFkaWVudCBkb3QgdmVjdG9yIGZyb20gY29ybmVyKSlcbiAgICBmbG9hdCBuID0gZG90KHQ0LCB3KTtcblxuICAgIC8vIEZpbmFsIGFuYWx5dGljYWwgZGVyaXZhdGl2ZSAoZ3JhZGllbnQgb2YgYSBzdW0gb2Ygc2NhbGFyIHByb2R1Y3RzKVxuICAgIHZlYzIgZHQwID0gdmVjMihkdGR4LngsIGR0ZHkueCkgKiA0LjAgKiB0My54O1xuICAgIHZlYzIgZG4wID0gdDQueCAqIGcwICsgZHQwICogdy54O1xuICAgIHZlYzIgZHQxID0gdmVjMihkdGR4LnksIGR0ZHkueSkgKiA0LjAgKiB0My55O1xuICAgIHZlYzIgZG4xID0gdDQueSAqIGcxICsgZHQxICogdy55O1xuICAgIHZlYzIgZHQyID0gdmVjMihkdGR4LnosIGR0ZHkueikgKiA0LjAgKiB0My56O1xuICAgIHZlYzIgZG4yID0gdDQueiAqIGcyICsgZHQyICogdy56O1xuXG4gICAgcmV0dXJuIDExLjAqdmVjMyhuLCBkbjAgKyBkbjEgKyBkbjIpO1xuICB9XG5cbiAgLy9cbiAgLy8gMi1EIHRpbGluZyBzaW1wbGV4IG5vaXNlIHdpdGggZml4ZWQgZ3JhZGllbnRzXG4gIC8vIGFuZCBhbmFseXRpY2FsIGRlcml2YXRpdmUuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgaW1wbGVtZW50ZWQgYXMgYSB3cmFwcGVyIHRvIFwicHNyZG5vaXNlXCIsXG4gIC8vIGF0IHRoZSBtaW5pbWFsIGNvc3Qgb2YgdGhyZWUgZXh0cmEgYWRkaXRpb25zLlxuICAvL1xuICB2ZWMzIHBzZG5vaXNlKHZlYzIgcG9zLCB2ZWMyIHBlcikge1xuICAgIHJldHVybiBwc3Jkbm9pc2UocG9zLCBwZXIsIDAuMCk7XG4gIH1cblxuICAvL1xuICAvLyAyLUQgdGlsaW5nIHNpbXBsZXggbm9pc2Ugd2l0aCByb3RhdGluZyBncmFkaWVudHMsXG4gIC8vIGJ1dCB3aXRob3V0IHRoZSBhbmFseXRpY2FsIGRlcml2YXRpdmUuXG4gIC8vXG4gIGZsb2F0IHBzcm5vaXNlKHZlYzIgcG9zLCB2ZWMyIHBlciwgZmxvYXQgcm90KSB7XG4gICAgLy8gT2Zmc2V0IHkgc2xpZ2h0bHkgdG8gaGlkZSBzb21lIHJhcmUgYXJ0aWZhY3RzXG4gICAgcG9zLnkgKz0gMC4wMDE7XG4gICAgLy8gU2tldyB0byBoZXhhZ29uYWwgZ3JpZFxuICAgIHZlYzIgdXYgPSB2ZWMyKHBvcy54ICsgcG9zLnkqMC41LCBwb3MueSk7XG5cbiAgICB2ZWMyIGkwID0gZmxvb3IodXYpO1xuICAgIHZlYzIgZjAgPSBmcmFjdCh1dik7XG4gICAgLy8gVHJhdmVyc2FsIG9yZGVyXG4gICAgdmVjMiBpMSA9IChmMC54ID4gZjAueSkgPyB2ZWMyKDEuMCwgMC4wKSA6IHZlYzIoMC4wLCAxLjApO1xuXG4gICAgLy8gVW5za2V3ZWQgZ3JpZCBwb2ludHMgaW4gKHgseSkgc3BhY2VcbiAgICB2ZWMyIHAwID0gdmVjMihpMC54IC0gaTAueSAqIDAuNSwgaTAueSk7XG4gICAgdmVjMiBwMSA9IHZlYzIocDAueCArIGkxLnggLSBpMS55ICogMC41LCBwMC55ICsgaTEueSk7XG4gICAgdmVjMiBwMiA9IHZlYzIocDAueCArIDAuNSwgcDAueSArIDEuMCk7XG5cbiAgICAvLyBJbnRlZ2VyIGdyaWQgcG9pbnQgaW5kaWNlcyBpbiAodSx2KSBzcGFjZVxuICAgIGkxID0gaTAgKyBpMTtcbiAgICB2ZWMyIGkyID0gaTAgKyB2ZWMyKDEuMCwgMS4wKTtcblxuICAgIC8vIFZlY3RvcnMgaW4gdW5za2V3ZWQgKHgseSkgY29vcmRpbmF0ZXMgZnJvbVxuICAgIC8vIGVhY2ggb2YgdGhlIHNpbXBsZXggY29ybmVycyB0byB0aGUgZXZhbHVhdGlvbiBwb2ludFxuICAgIHZlYzIgZDAgPSBwb3MgLSBwMDtcbiAgICB2ZWMyIGQxID0gcG9zIC0gcDE7XG4gICAgdmVjMiBkMiA9IHBvcyAtIHAyO1xuXG4gICAgLy8gV3JhcCBpMCwgaTEgYW5kIGkyIHRvIHRoZSBkZXNpcmVkIHBlcmlvZCBiZWZvcmUgZ3JhZGllbnQgaGFzaGluZzpcbiAgICAvLyB3cmFwIHBvaW50cyBpbiAoeCx5KSwgbWFwIHRvICh1LHYpXG4gICAgdmVjMyB4dyA9IG1vZCh2ZWMzKHAwLngsIHAxLngsIHAyLngpLCBwZXIueCk7XG4gICAgdmVjMyB5dyA9IG1vZCh2ZWMzKHAwLnksIHAxLnksIHAyLnkpLCBwZXIueSk7XG4gICAgdmVjMyBpdXcgPSB4dyArIDAuNSAqIHl3O1xuICAgIHZlYzMgaXZ3ID0geXc7XG5cbiAgICAvLyBDcmVhdGUgZ3JhZGllbnRzIGZyb20gaW5kaWNlc1xuICAgIHZlYzIgZzAgPSByZ3JhZDIodmVjMihpdXcueCwgaXZ3LngpLCByb3QpO1xuICAgIHZlYzIgZzEgPSByZ3JhZDIodmVjMihpdXcueSwgaXZ3LnkpLCByb3QpO1xuICAgIHZlYzIgZzIgPSByZ3JhZDIodmVjMihpdXcueiwgaXZ3LnopLCByb3QpO1xuXG4gICAgLy8gR3JhZGllbnRzIGRvdCB2ZWN0b3JzIHRvIGNvcnJlc3BvbmRpbmcgY29ybmVyc1xuICAgIC8vIChUaGUgZGVyaXZhdGl2ZXMgb2YgdGhpcyBhcmUgc2ltcGx5IHRoZSBncmFkaWVudHMpXG4gICAgdmVjMyB3ID0gdmVjMyhkb3QoZzAsIGQwKSwgZG90KGcxLCBkMSksIGRvdChnMiwgZDIpKTtcblxuICAgIC8vIFJhZGlhbCB3ZWlnaHRzIGZyb20gY29ybmVyc1xuICAgIC8vIDAuOCBpcyB0aGUgc3F1YXJlIG9mIDIvc3FydCg1KSwgdGhlIGRpc3RhbmNlIGZyb21cbiAgICAvLyBhIGdyaWQgcG9pbnQgdG8gdGhlIG5lYXJlc3Qgc2ltcGxleCBib3VuZGFyeVxuICAgIHZlYzMgdCA9IDAuOCAtIHZlYzMoZG90KGQwLCBkMCksIGRvdChkMSwgZDEpLCBkb3QoZDIsIGQyKSk7XG5cbiAgICAvLyBTZXQgaW5mbHVlbmNlIG9mIGVhY2ggc3VyZmxldCB0byB6ZXJvIG91dHNpZGUgcmFkaXVzIHNxcnQoMC44KVxuICAgIHQgPSBtYXgodCwgMC4wKTtcblxuICAgIC8vIEZvdXJ0aCBwb3dlciBvZiB0XG4gICAgdmVjMyB0MiA9IHQgKiB0O1xuICAgIHZlYzMgdDQgPSB0MiAqIHQyO1xuXG4gICAgLy8gRmluYWwgbm9pc2UgdmFsdWUgaXM6XG4gICAgLy8gc3VtIG9mICgocmFkaWFsIHdlaWdodHMpIHRpbWVzIChncmFkaWVudCBkb3QgdmVjdG9yIGZyb20gY29ybmVyKSlcbiAgICBmbG9hdCBuID0gZG90KHQ0LCB3KTtcblxuICAgIC8vIFJlc2NhbGUgdG8gY292ZXIgdGhlIHJhbmdlIFstMSwxXSByZWFzb25hYmx5IHdlbGxcbiAgICByZXR1cm4gMTEuMCpuO1xuICB9XG5cbiAgLy9cbiAgLy8gMi1EIHRpbGluZyBzaW1wbGV4IG5vaXNlIHdpdGggZml4ZWQgZ3JhZGllbnRzLFxuICAvLyB3aXRob3V0IHRoZSBhbmFseXRpY2FsIGRlcml2YXRpdmUuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgaW1wbGVtZW50ZWQgYXMgYSB3cmFwcGVyIHRvIFwicHNybm9pc2VcIixcbiAgLy8gYXQgdGhlIG1pbmltYWwgY29zdCBvZiB0aHJlZSBleHRyYSBhZGRpdGlvbnMuXG4gIC8vXG4gIGZsb2F0IHBzbm9pc2UodmVjMiBwb3MsIHZlYzIgcGVyKSB7XG4gICAgcmV0dXJuIHBzcm5vaXNlKHBvcywgcGVyLCAwLjApO1xuICB9XG5cbiAgLy9cbiAgLy8gMi1EIG5vbi10aWxpbmcgc2ltcGxleCBub2lzZSB3aXRoIHJvdGF0aW5nIGdyYWRpZW50cyBhbmQgYW5hbHl0aWNhbCBkZXJpdmF0aXZlLlxuICAvLyBUaGUgZmlyc3QgY29tcG9uZW50IG9mIHRoZSAzLWVsZW1lbnQgcmV0dXJuIHZlY3RvciBpcyB0aGUgbm9pc2UgdmFsdWUsXG4gIC8vIGFuZCB0aGUgc2Vjb25kIGFuZCB0aGlyZCBjb21wb25lbnRzIGFyZSB0aGUgeCBhbmQgeSBwYXJ0aWFsIGRlcml2YXRpdmVzLlxuICAvL1xuICB2ZWMzIHNyZG5vaXNlKHZlYzIgcG9zLCBmbG9hdCByb3QpIHtcbiAgICAvLyBPZmZzZXQgeSBzbGlnaHRseSB0byBoaWRlIHNvbWUgcmFyZSBhcnRpZmFjdHNcbiAgICBwb3MueSArPSAwLjAwMTtcbiAgICAvLyBTa2V3IHRvIGhleGFnb25hbCBncmlkXG4gICAgdmVjMiB1diA9IHZlYzIocG9zLnggKyBwb3MueSowLjUsIHBvcy55KTtcblxuICAgIHZlYzIgaTAgPSBmbG9vcih1dik7XG4gICAgdmVjMiBmMCA9IGZyYWN0KHV2KTtcbiAgICAvLyBUcmF2ZXJzYWwgb3JkZXJcbiAgICB2ZWMyIGkxID0gKGYwLnggPiBmMC55KSA/IHZlYzIoMS4wLCAwLjApIDogdmVjMigwLjAsIDEuMCk7XG5cbiAgICAvLyBVbnNrZXdlZCBncmlkIHBvaW50cyBpbiAoeCx5KSBzcGFjZVxuICAgIHZlYzIgcDAgPSB2ZWMyKGkwLnggLSBpMC55ICogMC41LCBpMC55KTtcbiAgICB2ZWMyIHAxID0gdmVjMihwMC54ICsgaTEueCAtIGkxLnkgKiAwLjUsIHAwLnkgKyBpMS55KTtcbiAgICB2ZWMyIHAyID0gdmVjMihwMC54ICsgMC41LCBwMC55ICsgMS4wKTtcblxuICAgIC8vIEludGVnZXIgZ3JpZCBwb2ludCBpbmRpY2VzIGluICh1LHYpIHNwYWNlXG4gICAgaTEgPSBpMCArIGkxO1xuICAgIHZlYzIgaTIgPSBpMCArIHZlYzIoMS4wLCAxLjApO1xuXG4gICAgLy8gVmVjdG9ycyBpbiB1bnNrZXdlZCAoeCx5KSBjb29yZGluYXRlcyBmcm9tXG4gICAgLy8gZWFjaCBvZiB0aGUgc2ltcGxleCBjb3JuZXJzIHRvIHRoZSBldmFsdWF0aW9uIHBvaW50XG4gICAgdmVjMiBkMCA9IHBvcyAtIHAwO1xuICAgIHZlYzIgZDEgPSBwb3MgLSBwMTtcbiAgICB2ZWMyIGQyID0gcG9zIC0gcDI7XG5cbiAgICB2ZWMzIHggPSB2ZWMzKHAwLngsIHAxLngsIHAyLngpO1xuICAgIHZlYzMgeSA9IHZlYzMocDAueSwgcDEueSwgcDIueSk7XG4gICAgdmVjMyBpdXcgPSB4ICsgMC41ICogeTtcbiAgICB2ZWMzIGl2dyA9IHk7XG5cbiAgICAvLyBBdm9pZCBwcmVjaXNpb24gaXNzdWVzIGluIHBlcm11dGF0aW9uXG4gICAgaXV3ID0gbW9kMjg5KGl1dyk7XG4gICAgaXZ3ID0gbW9kMjg5KGl2dyk7XG5cbiAgICAvLyBDcmVhdGUgZ3JhZGllbnRzIGZyb20gaW5kaWNlc1xuICAgIHZlYzIgZzAgPSByZ3JhZDIodmVjMihpdXcueCwgaXZ3LngpLCByb3QpO1xuICAgIHZlYzIgZzEgPSByZ3JhZDIodmVjMihpdXcueSwgaXZ3LnkpLCByb3QpO1xuICAgIHZlYzIgZzIgPSByZ3JhZDIodmVjMihpdXcueiwgaXZ3LnopLCByb3QpO1xuXG4gICAgLy8gR3JhZGllbnRzIGRvdCB2ZWN0b3JzIHRvIGNvcnJlc3BvbmRpbmcgY29ybmVyc1xuICAgIC8vIChUaGUgZGVyaXZhdGl2ZXMgb2YgdGhpcyBhcmUgc2ltcGx5IHRoZSBncmFkaWVudHMpXG4gICAgdmVjMyB3ID0gdmVjMyhkb3QoZzAsIGQwKSwgZG90KGcxLCBkMSksIGRvdChnMiwgZDIpKTtcblxuICAgIC8vIFJhZGlhbCB3ZWlnaHRzIGZyb20gY29ybmVyc1xuICAgIC8vIDAuOCBpcyB0aGUgc3F1YXJlIG9mIDIvc3FydCg1KSwgdGhlIGRpc3RhbmNlIGZyb21cbiAgICAvLyBhIGdyaWQgcG9pbnQgdG8gdGhlIG5lYXJlc3Qgc2ltcGxleCBib3VuZGFyeVxuICAgIHZlYzMgdCA9IDAuOCAtIHZlYzMoZG90KGQwLCBkMCksIGRvdChkMSwgZDEpLCBkb3QoZDIsIGQyKSk7XG5cbiAgICAvLyBQYXJ0aWFsIGRlcml2YXRpdmVzIGZvciBhbmFseXRpY2FsIGdyYWRpZW50IGNvbXB1dGF0aW9uXG4gICAgdmVjMyBkdGR4ID0gLTIuMCAqIHZlYzMoZDAueCwgZDEueCwgZDIueCk7XG4gICAgdmVjMyBkdGR5ID0gLTIuMCAqIHZlYzMoZDAueSwgZDEueSwgZDIueSk7XG5cbiAgICAvLyBTZXQgaW5mbHVlbmNlIG9mIGVhY2ggc3VyZmxldCB0byB6ZXJvIG91dHNpZGUgcmFkaXVzIHNxcnQoMC44KVxuICAgIGlmICh0LnggPCAwLjApIHtcbiAgICAgIGR0ZHgueCA9IDAuMDtcbiAgICAgIGR0ZHkueCA9IDAuMDtcbiAgICAgIHQueCA9IDAuMDtcbiAgICB9XG4gICAgaWYgKHQueSA8IDAuMCkge1xuICAgICAgZHRkeC55ID0gMC4wO1xuICAgICAgZHRkeS55ID0gMC4wO1xuICAgICAgdC55ID0gMC4wO1xuICAgIH1cbiAgICBpZiAodC56IDwgMC4wKSB7XG4gICAgICBkdGR4LnogPSAwLjA7XG4gICAgICBkdGR5LnogPSAwLjA7XG4gICAgICB0LnogPSAwLjA7XG4gICAgfVxuXG4gICAgLy8gRm91cnRoIHBvd2VyIG9mIHQgKGFuZCB0aGlyZCBwb3dlciBmb3IgZGVyaXZhdGl2ZSlcbiAgICB2ZWMzIHQyID0gdCAqIHQ7XG4gICAgdmVjMyB0NCA9IHQyICogdDI7XG4gICAgdmVjMyB0MyA9IHQyICogdDtcblxuICAgIC8vIEZpbmFsIG5vaXNlIHZhbHVlIGlzOlxuICAgIC8vIHN1bSBvZiAoKHJhZGlhbCB3ZWlnaHRzKSB0aW1lcyAoZ3JhZGllbnQgZG90IHZlY3RvciBmcm9tIGNvcm5lcikpXG4gICAgZmxvYXQgbiA9IGRvdCh0NCwgdyk7XG5cbiAgICAvLyBGaW5hbCBhbmFseXRpY2FsIGRlcml2YXRpdmUgKGdyYWRpZW50IG9mIGEgc3VtIG9mIHNjYWxhciBwcm9kdWN0cylcbiAgICB2ZWMyIGR0MCA9IHZlYzIoZHRkeC54LCBkdGR5LngpICogNC4wICogdDMueDtcbiAgICB2ZWMyIGRuMCA9IHQ0LnggKiBnMCArIGR0MCAqIHcueDtcbiAgICB2ZWMyIGR0MSA9IHZlYzIoZHRkeC55LCBkdGR5LnkpICogNC4wICogdDMueTtcbiAgICB2ZWMyIGRuMSA9IHQ0LnkgKiBnMSArIGR0MSAqIHcueTtcbiAgICB2ZWMyIGR0MiA9IHZlYzIoZHRkeC56LCBkdGR5LnopICogNC4wICogdDMuejtcbiAgICB2ZWMyIGRuMiA9IHQ0LnogKiBnMiArIGR0MiAqIHcuejtcblxuICAgIHJldHVybiAxMS4wKnZlYzMobiwgZG4wICsgZG4xICsgZG4yKTtcbiAgfVxuXG4gIC8vXG4gIC8vIDItRCBub24tdGlsaW5nIHNpbXBsZXggbm9pc2Ugd2l0aCBmaXhlZCBncmFkaWVudHMgYW5kIGFuYWx5dGljYWwgZGVyaXZhdGl2ZS5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBpbXBsZW1lbnRlZCBhcyBhIHdyYXBwZXIgdG8gXCJzcmRub2lzZVwiLFxuICAvLyBhdCB0aGUgbWluaW1hbCBjb3N0IG9mIHRocmVlIGV4dHJhIGFkZGl0aW9ucy5cbiAgLy9cbiAgdmVjMyBzZG5vaXNlKHZlYzIgcG9zKSB7XG4gICAgcmV0dXJuIHNyZG5vaXNlKHBvcywgMC4wKTtcbiAgfVxuXG4gIC8vXG4gIC8vIDItRCBub24tdGlsaW5nIHNpbXBsZXggbm9pc2Ugd2l0aCByb3RhdGluZyBncmFkaWVudHMsXG4gIC8vIHdpdGhvdXQgdGhlIGFuYWx5dGljYWwgZGVyaXZhdGl2ZS5cbiAgLy9cbiAgZmxvYXQgc3Jub2lzZSh2ZWMyIHBvcywgZmxvYXQgcm90KSB7XG4gICAgLy8gT2Zmc2V0IHkgc2xpZ2h0bHkgdG8gaGlkZSBzb21lIHJhcmUgYXJ0aWZhY3RzXG4gICAgcG9zLnkgKz0gMC4wMDE7XG4gICAgLy8gU2tldyB0byBoZXhhZ29uYWwgZ3JpZFxuICAgIHZlYzIgdXYgPSB2ZWMyKHBvcy54ICsgcG9zLnkqMC41LCBwb3MueSk7XG5cbiAgICB2ZWMyIGkwID0gZmxvb3IodXYpO1xuICAgIHZlYzIgZjAgPSBmcmFjdCh1dik7XG4gICAgLy8gVHJhdmVyc2FsIG9yZGVyXG4gICAgdmVjMiBpMSA9IChmMC54ID4gZjAueSkgPyB2ZWMyKDEuMCwgMC4wKSA6IHZlYzIoMC4wLCAxLjApO1xuXG4gICAgLy8gVW5za2V3ZWQgZ3JpZCBwb2ludHMgaW4gKHgseSkgc3BhY2VcbiAgICB2ZWMyIHAwID0gdmVjMihpMC54IC0gaTAueSAqIDAuNSwgaTAueSk7XG4gICAgdmVjMiBwMSA9IHZlYzIocDAueCArIGkxLnggLSBpMS55ICogMC41LCBwMC55ICsgaTEueSk7XG4gICAgdmVjMiBwMiA9IHZlYzIocDAueCArIDAuNSwgcDAueSArIDEuMCk7XG5cbiAgICAvLyBJbnRlZ2VyIGdyaWQgcG9pbnQgaW5kaWNlcyBpbiAodSx2KSBzcGFjZVxuICAgIGkxID0gaTAgKyBpMTtcbiAgICB2ZWMyIGkyID0gaTAgKyB2ZWMyKDEuMCwgMS4wKTtcblxuICAgIC8vIFZlY3RvcnMgaW4gdW5za2V3ZWQgKHgseSkgY29vcmRpbmF0ZXMgZnJvbVxuICAgIC8vIGVhY2ggb2YgdGhlIHNpbXBsZXggY29ybmVycyB0byB0aGUgZXZhbHVhdGlvbiBwb2ludFxuICAgIHZlYzIgZDAgPSBwb3MgLSBwMDtcbiAgICB2ZWMyIGQxID0gcG9zIC0gcDE7XG4gICAgdmVjMiBkMiA9IHBvcyAtIHAyO1xuXG4gICAgLy8gV3JhcCBpMCwgaTEgYW5kIGkyIHRvIHRoZSBkZXNpcmVkIHBlcmlvZCBiZWZvcmUgZ3JhZGllbnQgaGFzaGluZzpcbiAgICAvLyB3cmFwIHBvaW50cyBpbiAoeCx5KSwgbWFwIHRvICh1LHYpXG4gICAgdmVjMyB4ID0gdmVjMyhwMC54LCBwMS54LCBwMi54KTtcbiAgICB2ZWMzIHkgPSB2ZWMzKHAwLnksIHAxLnksIHAyLnkpO1xuICAgIHZlYzMgaXV3ID0geCArIDAuNSAqIHk7XG4gICAgdmVjMyBpdncgPSB5O1xuXG4gICAgLy8gQXZvaWQgcHJlY2lzaW9uIGlzc3VlcyBpbiBwZXJtdXRhdGlvblxuICAgIGl1dyA9IG1vZDI4OShpdXcpO1xuICAgIGl2dyA9IG1vZDI4OShpdncpO1xuXG4gICAgLy8gQ3JlYXRlIGdyYWRpZW50cyBmcm9tIGluZGljZXNcbiAgICB2ZWMyIGcwID0gcmdyYWQyKHZlYzIoaXV3LngsIGl2dy54KSwgcm90KTtcbiAgICB2ZWMyIGcxID0gcmdyYWQyKHZlYzIoaXV3LnksIGl2dy55KSwgcm90KTtcbiAgICB2ZWMyIGcyID0gcmdyYWQyKHZlYzIoaXV3LnosIGl2dy56KSwgcm90KTtcblxuICAgIC8vIEdyYWRpZW50cyBkb3QgdmVjdG9ycyB0byBjb3JyZXNwb25kaW5nIGNvcm5lcnNcbiAgICAvLyAoVGhlIGRlcml2YXRpdmVzIG9mIHRoaXMgYXJlIHNpbXBseSB0aGUgZ3JhZGllbnRzKVxuICAgIHZlYzMgdyA9IHZlYzMoZG90KGcwLCBkMCksIGRvdChnMSwgZDEpLCBkb3QoZzIsIGQyKSk7XG5cbiAgICAvLyBSYWRpYWwgd2VpZ2h0cyBmcm9tIGNvcm5lcnNcbiAgICAvLyAwLjggaXMgdGhlIHNxdWFyZSBvZiAyL3NxcnQoNSksIHRoZSBkaXN0YW5jZSBmcm9tXG4gICAgLy8gYSBncmlkIHBvaW50IHRvIHRoZSBuZWFyZXN0IHNpbXBsZXggYm91bmRhcnlcbiAgICB2ZWMzIHQgPSAwLjggLSB2ZWMzKGRvdChkMCwgZDApLCBkb3QoZDEsIGQxKSwgZG90KGQyLCBkMikpO1xuXG4gICAgLy8gU2V0IGluZmx1ZW5jZSBvZiBlYWNoIHN1cmZsZXQgdG8gemVybyBvdXRzaWRlIHJhZGl1cyBzcXJ0KDAuOClcbiAgICB0ID0gbWF4KHQsIDAuMCk7XG5cbiAgICAvLyBGb3VydGggcG93ZXIgb2YgdFxuICAgIHZlYzMgdDIgPSB0ICogdDtcbiAgICB2ZWMzIHQ0ID0gdDIgKiB0MjtcblxuICAgIC8vIEZpbmFsIG5vaXNlIHZhbHVlIGlzOlxuICAgIC8vIHN1bSBvZiAoKHJhZGlhbCB3ZWlnaHRzKSB0aW1lcyAoZ3JhZGllbnQgZG90IHZlY3RvciBmcm9tIGNvcm5lcikpXG4gICAgZmxvYXQgbiA9IGRvdCh0NCwgdyk7XG5cbiAgICAvLyBSZXNjYWxlIHRvIGNvdmVyIHRoZSByYW5nZSBbLTEsMV0gcmVhc29uYWJseSB3ZWxsXG4gICAgcmV0dXJuIDExLjAqbjtcbiAgfVxuXG4gIC8vXG4gIC8vIDItRCBub24tdGlsaW5nIHNpbXBsZXggbm9pc2Ugd2l0aCBmaXhlZCBncmFkaWVudHMsXG4gIC8vIHdpdGhvdXQgdGhlIGFuYWx5dGljYWwgZGVyaXZhdGl2ZS5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBpbXBsZW1lbnRlZCBhcyBhIHdyYXBwZXIgdG8gXCJzcm5vaXNlXCIsXG4gIC8vIGF0IHRoZSBtaW5pbWFsIGNvc3Qgb2YgdGhyZWUgZXh0cmEgYWRkaXRpb25zLlxuICAvLyBOb3RlOiBpZiB0aGlzIGtpbmQgb2Ygbm9pc2UgaXMgYWxsIHlvdSB3YW50LCB0aGVyZSBhcmUgZmFzdGVyXG4gIC8vIEdMU0wgaW1wbGVtZW50YXRpb25zIG9mIG5vbi10aWxpbmcgc2ltcGxleCBub2lzZSBvdXQgdGhlcmUuXG4gIC8vIFRoaXMgb25lIGlzIGluY2x1ZGVkIG1haW5seSBmb3IgY29tcGxldGVuZXNzIGFuZCBjb21wYXRpYmlsaXR5XG4gIC8vIHdpdGggdGhlIG90aGVyIGZ1bmN0aW9ucyBpbiB0aGUgZmlsZS5cbiAgLy9cbiAgZmxvYXQgc25vaXNlKHZlYzIgcG9zKSB7XG4gICAgcmV0dXJuIHNybm9pc2UocG9zLCAwLjApO1xuICB9XG5cbiAgZmxvYXQgaGFzaChmbG9hdCB4LCBmbG9hdCB5KSB7XG4gICAgICByZXR1cm4gZnJhY3QoYWJzKHNpbihzaW4oMTIzLjMyMSArIHgpICogKHkgKyAzMjEuMTIzKSkgKiA0NTYuNjU0KSk7XG4gIH1cblxuICBmbG9hdCBsZXJwKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHQpIHtcbiAgICAgIHJldHVybiBhICogKDEuMCAtIHQpICsgYiAqIHQ7XG4gIH1cblxuICBmbG9hdCBwZXJsaW4oZmxvYXQgeCwgZmxvYXQgeSl7XG4gICAgICBmbG9hdCBjb2wgPSAwLjA7XG4gICAgICBmb3IgKGludCBpID0gMDsgaSA8IDg7IGkrKylcbiAgICAgIHtcbiAgICAgICAgICBmbG9hdCBmeCA9IGZsb29yKHgpO1xuICAgICAgICAgIGZsb2F0IGZ5ID0gZmxvb3IoeSk7XG4gICAgICAgICAgZmxvYXQgY3ggPSBjZWlsKHgpO1xuICAgICAgICAgIGZsb2F0IGN5ID0gY2VpbCh5KTtcbiAgICAgICAgICBmbG9hdCBhID0gaGFzaChmeCwgZnkpO1xuICAgICAgICAgIGZsb2F0IGIgPSBoYXNoKGZ4LCBjeSk7XG4gICAgICAgICAgZmxvYXQgYyA9IGhhc2goY3gsIGZ5KTtcbiAgICAgICAgICBmbG9hdCBkID0gaGFzaChjeCwgY3kpO1xuICAgICAgICAgIGNvbCArPSBsZXJwKGxlcnAoYSwgYiwgZnJhY3QoeSkpLCBsZXJwKGMsIGQsIGZyYWN0KHkpKSwgZnJhY3QoeCkpO1xuICAgICAgICAgIGNvbCAvPSAyLjA7XG4gICAgICAgICAgeCAvPSAyLjA7XG4gICAgICAgICAgeSAvPSAyLjA7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sO1xuICB9XG5cbiAgZmxvYXQgZHBlcmxpbihmbG9hdCB4LCBmbG9hdCB5KXtcbiAgICAgIGZsb2F0IGQgPSBwZXJsaW4oeCwgeSkgKiA4MDAuMDtcbiAgICAgIHJldHVybiBwZXJsaW4oeCArIGQsIHkgKyBkKTtcbiAgfVxuXG4gIGZsb2F0IGRkcGVybGluKGZsb2F0IHgsIGZsb2F0IHkpe1xuICAgICAgZmxvYXQgZCA9IHBlcmxpbih4LCB5KSAqIDgwMC4wO1xuICAgICAgcmV0dXJuIGRwZXJsaW4oeCArIGQsIHkgKyBkKTtcbiAgfVxuXG5cbiAgZmxvYXQgcmFuZG9tKCB2ZWMzIHB0LCBmbG9hdCBzZWVkICl7XG4gICAgdmVjMyBzY2FsZSA9IHZlYzMoIDEyLjk4OTgsIDc4LjIzMywgMTUxLjcxODIgKTtcbiAgICByZXR1cm4gZnJhY3QoIHNpbiggZG90KCBwdCArIHNlZWQsIHNjYWxlICkgKSAqIDQzNzU4LjU0NTMgKyBzZWVkICkgO1xuICB9XG5gO1xufTtcbmV4cG9ydHMubm9pc2UgPSBub2lzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vaXNlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/shaders/three-shader-chunks/noise.js\n");

/***/ }),

/***/ "./lib/string/css-unit.js":
/*!********************************!*\
  !*** ./lib/string/css-unit.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cssUnit = exports.CssUnitObjectTypes = void 0;\nconst is_1 = __webpack_require__(/*! ../is/is */ \"./lib/is/is.js\");\nconst color_1 = __webpack_require__(/*! ../mathf/color */ \"./lib/mathf/color.js\");\n/**\n * The different types of structures that can be passed.\n * @see https://css-tricks.com/converting-color-spaces-in-javascript/\n */\nvar CssUnitObjectTypes;\n(function (CssUnitObjectTypes) {\n    /**\n     * A number.\n     */\n    CssUnitObjectTypes[\"number\"] = \"num\";\n    /**\n     * A standard numerical value + unit such as '1px' or '10%'\n     */\n    CssUnitObjectTypes[\"unit\"] = \"unit\";\n    /**\n     * A css hex unit such as '#FFFFFF'\n     */\n    CssUnitObjectTypes[\"cssHex\"] = \"cssHex\";\n    /**\n     * A css rgba unit such as 'rgba(255, 255, 255, 0.3)'\n     */\n    CssUnitObjectTypes[\"rgba\"] = \"rgba\";\n    /**\n     * A css rgb unit such as 'rgba(255, 255, 255)'\n     */\n    CssUnitObjectTypes[\"rgb\"] = \"rgb\";\n})(CssUnitObjectTypes = exports.CssUnitObjectTypes || (exports.CssUnitObjectTypes = {}));\n/**\n * A class that helps parsing of css units.\n *\n *\n * ```ts\n *\n * cssUnit.parse('10%').unit // %\n * cssUnit.parse('10%').type // unit\n * cssUnit.parse('10%').valueType // number\n * cssUnit.parse('10%').value // 10\n *\n *\n *\n * let rgba = 'rgba(255, 255, 255, 0.3)'\n * cssUnit.parse(rgba).unit // null\n * cssUnit.parse(rgba).type // rgba\n * cssUnit.parse(rgba).value // Return ColorRgba\n * cssUnit.parse(rgba).value.r // 255\n * cssUnit.parse(rgba).value.g // 255\n * cssUnit.parse(rgba).value.b // 255\n * cssUnit.parse(rgba).value.a // a\n *\n *\n * let hex = '#FFFFFF'\n * cssUnit.parse(rgba).unit // null\n * cssUnit.parse(rgba).type // cssHex\n * cssUnit.parse(rgba).originalValue // '#FFFFFF'\n * cssUnit.parse(rgba).value // Return ColorRgba (we use rgba as the centeral unit)\n * cssUnit.parse(rgba).value.r // 255\n * cssUnit.parse(rgba).value.g // 255\n * cssUnit.parse(rgba).value.b // 255\n * cssUnit.parse(rgba).value.a // a\n *\n * let rgba = 'rgb(255, 255, 255)'\n * cssUnit.parse(rgba).unit // null\n * cssUnit.parse(rgba).type // rgba\n * cssUnit.parse(rgba).value // Return ColorRgba\n *\n * ```\n */\nclass cssUnit {\n    /**\n     * Takes a css unit value like '10px' or '20vw' and parses it into\n     * a CssUnitObject.\n     * @param css\n     */\n    static parse(css) {\n        // const value = css.match(/-?\\d+/g);\n        const value = css.replace(/[a-zA-Z%]+/g, '');\n        const unit = css.match(/[a-zA-Z%]+/g);\n        const result = {\n            value: null,\n            unit: null,\n            type: null,\n            valueType: null,\n            originalValue: css,\n        };\n        if (is_1.is.cssRgba(css)) {\n            result.type = CssUnitObjectTypes.rgba;\n            result.value = color_1.color.cssToRgba(css);\n            result.valueType = CssUnitObjectTypes.rgba;\n        }\n        else if (is_1.is.cssRgb(css)) {\n            result.type = CssUnitObjectTypes.rgb;\n            result.value = color_1.color.cssToRgba(css);\n            result.valueType = CssUnitObjectTypes.rgba;\n        }\n        else if (is_1.is.cssHex(css)) {\n            result.value = color_1.color.cssToRgba(css);\n            result.type = CssUnitObjectTypes.cssHex;\n            result.valueType = CssUnitObjectTypes.rgba;\n        }\n        else {\n            result.value = value ? +value : null;\n            result.unit = unit ? unit[0] : null;\n            result.type = CssUnitObjectTypes.unit;\n            result.valueType = CssUnitObjectTypes.number;\n        }\n        result.originalValue = css;\n        return result;\n    }\n}\nexports.cssUnit = cssUnit;\n//# sourceMappingURL=css-unit.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvc3RyaW5nL2Nzcy11bml0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3N0cmluZy9jc3MtdW5pdC5qcz9kZTY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jc3NVbml0ID0gZXhwb3J0cy5Dc3NVbml0T2JqZWN0VHlwZXMgPSB2b2lkIDA7XG5jb25zdCBpc18xID0gcmVxdWlyZShcIi4uL2lzL2lzXCIpO1xuY29uc3QgY29sb3JfMSA9IHJlcXVpcmUoXCIuLi9tYXRoZi9jb2xvclwiKTtcbi8qKlxuICogVGhlIGRpZmZlcmVudCB0eXBlcyBvZiBzdHJ1Y3R1cmVzIHRoYXQgY2FuIGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9jb252ZXJ0aW5nLWNvbG9yLXNwYWNlcy1pbi1qYXZhc2NyaXB0L1xuICovXG52YXIgQ3NzVW5pdE9iamVjdFR5cGVzO1xuKGZ1bmN0aW9uIChDc3NVbml0T2JqZWN0VHlwZXMpIHtcbiAgICAvKipcbiAgICAgKiBBIG51bWJlci5cbiAgICAgKi9cbiAgICBDc3NVbml0T2JqZWN0VHlwZXNbXCJudW1iZXJcIl0gPSBcIm51bVwiO1xuICAgIC8qKlxuICAgICAqIEEgc3RhbmRhcmQgbnVtZXJpY2FsIHZhbHVlICsgdW5pdCBzdWNoIGFzICcxcHgnIG9yICcxMCUnXG4gICAgICovXG4gICAgQ3NzVW5pdE9iamVjdFR5cGVzW1widW5pdFwiXSA9IFwidW5pdFwiO1xuICAgIC8qKlxuICAgICAqIEEgY3NzIGhleCB1bml0IHN1Y2ggYXMgJyNGRkZGRkYnXG4gICAgICovXG4gICAgQ3NzVW5pdE9iamVjdFR5cGVzW1wiY3NzSGV4XCJdID0gXCJjc3NIZXhcIjtcbiAgICAvKipcbiAgICAgKiBBIGNzcyByZ2JhIHVuaXQgc3VjaCBhcyAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpJ1xuICAgICAqL1xuICAgIENzc1VuaXRPYmplY3RUeXBlc1tcInJnYmFcIl0gPSBcInJnYmFcIjtcbiAgICAvKipcbiAgICAgKiBBIGNzcyByZ2IgdW5pdCBzdWNoIGFzICdyZ2JhKDI1NSwgMjU1LCAyNTUpJ1xuICAgICAqL1xuICAgIENzc1VuaXRPYmplY3RUeXBlc1tcInJnYlwiXSA9IFwicmdiXCI7XG59KShDc3NVbml0T2JqZWN0VHlwZXMgPSBleHBvcnRzLkNzc1VuaXRPYmplY3RUeXBlcyB8fCAoZXhwb3J0cy5Dc3NVbml0T2JqZWN0VHlwZXMgPSB7fSkpO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgaGVscHMgcGFyc2luZyBvZiBjc3MgdW5pdHMuXG4gKlxuICpcbiAqIGBgYHRzXG4gKlxuICogY3NzVW5pdC5wYXJzZSgnMTAlJykudW5pdCAvLyAlXG4gKiBjc3NVbml0LnBhcnNlKCcxMCUnKS50eXBlIC8vIHVuaXRcbiAqIGNzc1VuaXQucGFyc2UoJzEwJScpLnZhbHVlVHlwZSAvLyBudW1iZXJcbiAqIGNzc1VuaXQucGFyc2UoJzEwJScpLnZhbHVlIC8vIDEwXG4gKlxuICpcbiAqXG4gKiBsZXQgcmdiYSA9ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyknXG4gKiBjc3NVbml0LnBhcnNlKHJnYmEpLnVuaXQgLy8gbnVsbFxuICogY3NzVW5pdC5wYXJzZShyZ2JhKS50eXBlIC8vIHJnYmFcbiAqIGNzc1VuaXQucGFyc2UocmdiYSkudmFsdWUgLy8gUmV0dXJuIENvbG9yUmdiYVxuICogY3NzVW5pdC5wYXJzZShyZ2JhKS52YWx1ZS5yIC8vIDI1NVxuICogY3NzVW5pdC5wYXJzZShyZ2JhKS52YWx1ZS5nIC8vIDI1NVxuICogY3NzVW5pdC5wYXJzZShyZ2JhKS52YWx1ZS5iIC8vIDI1NVxuICogY3NzVW5pdC5wYXJzZShyZ2JhKS52YWx1ZS5hIC8vIGFcbiAqXG4gKlxuICogbGV0IGhleCA9ICcjRkZGRkZGJ1xuICogY3NzVW5pdC5wYXJzZShyZ2JhKS51bml0IC8vIG51bGxcbiAqIGNzc1VuaXQucGFyc2UocmdiYSkudHlwZSAvLyBjc3NIZXhcbiAqIGNzc1VuaXQucGFyc2UocmdiYSkub3JpZ2luYWxWYWx1ZSAvLyAnI0ZGRkZGRidcbiAqIGNzc1VuaXQucGFyc2UocmdiYSkudmFsdWUgLy8gUmV0dXJuIENvbG9yUmdiYSAod2UgdXNlIHJnYmEgYXMgdGhlIGNlbnRlcmFsIHVuaXQpXG4gKiBjc3NVbml0LnBhcnNlKHJnYmEpLnZhbHVlLnIgLy8gMjU1XG4gKiBjc3NVbml0LnBhcnNlKHJnYmEpLnZhbHVlLmcgLy8gMjU1XG4gKiBjc3NVbml0LnBhcnNlKHJnYmEpLnZhbHVlLmIgLy8gMjU1XG4gKiBjc3NVbml0LnBhcnNlKHJnYmEpLnZhbHVlLmEgLy8gYVxuICpcbiAqIGxldCByZ2JhID0gJ3JnYigyNTUsIDI1NSwgMjU1KSdcbiAqIGNzc1VuaXQucGFyc2UocmdiYSkudW5pdCAvLyBudWxsXG4gKiBjc3NVbml0LnBhcnNlKHJnYmEpLnR5cGUgLy8gcmdiYVxuICogY3NzVW5pdC5wYXJzZShyZ2JhKS52YWx1ZSAvLyBSZXR1cm4gQ29sb3JSZ2JhXG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIGNzc1VuaXQge1xuICAgIC8qKlxuICAgICAqIFRha2VzIGEgY3NzIHVuaXQgdmFsdWUgbGlrZSAnMTBweCcgb3IgJzIwdncnIGFuZCBwYXJzZXMgaXQgaW50b1xuICAgICAqIGEgQ3NzVW5pdE9iamVjdC5cbiAgICAgKiBAcGFyYW0gY3NzXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlKGNzcykge1xuICAgICAgICAvLyBjb25zdCB2YWx1ZSA9IGNzcy5tYXRjaCgvLT9cXGQrL2cpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNzcy5yZXBsYWNlKC9bYS16QS1aJV0rL2csICcnKTtcbiAgICAgICAgY29uc3QgdW5pdCA9IGNzcy5tYXRjaCgvW2EtekEtWiVdKy9nKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICB1bml0OiBudWxsLFxuICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgIHZhbHVlVHlwZTogbnVsbCxcbiAgICAgICAgICAgIG9yaWdpbmFsVmFsdWU6IGNzcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzXzEuaXMuY3NzUmdiYShjc3MpKSB7XG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IENzc1VuaXRPYmplY3RUeXBlcy5yZ2JhO1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gY29sb3JfMS5jb2xvci5jc3NUb1JnYmEoY3NzKTtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZVR5cGUgPSBDc3NVbml0T2JqZWN0VHlwZXMucmdiYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc18xLmlzLmNzc1JnYihjc3MpKSB7XG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IENzc1VuaXRPYmplY3RUeXBlcy5yZ2I7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSBjb2xvcl8xLmNvbG9yLmNzc1RvUmdiYShjc3MpO1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlVHlwZSA9IENzc1VuaXRPYmplY3RUeXBlcy5yZ2JhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzXzEuaXMuY3NzSGV4KGNzcykpIHtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IGNvbG9yXzEuY29sb3IuY3NzVG9SZ2JhKGNzcyk7XG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IENzc1VuaXRPYmplY3RUeXBlcy5jc3NIZXg7XG4gICAgICAgICAgICByZXN1bHQudmFsdWVUeXBlID0gQ3NzVW5pdE9iamVjdFR5cGVzLnJnYmE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSB2YWx1ZSA/ICt2YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICByZXN1bHQudW5pdCA9IHVuaXQgPyB1bml0WzBdIDogbnVsbDtcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gQ3NzVW5pdE9iamVjdFR5cGVzLnVuaXQ7XG4gICAgICAgICAgICByZXN1bHQudmFsdWVUeXBlID0gQ3NzVW5pdE9iamVjdFR5cGVzLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQub3JpZ2luYWxWYWx1ZSA9IGNzcztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLmNzc1VuaXQgPSBjc3NVbml0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3NzLXVuaXQuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/string/css-unit.js\n");

/***/ }),

/***/ "./lib/threef/scene-renderer.js":
/*!**************************************!*\
  !*** ./lib/threef/scene-renderer.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SceneRenderer = exports.SceneResizingAlgo = void 0;\nconst THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\nconst three_inspector_1 = __webpack_require__(/*! ./three-inspector */ \"./lib/threef/three-inspector.js\");\nconst element_visibility_1 = __webpack_require__(/*! ../dom/element-visibility */ \"./lib/dom/element-visibility.js\");\nconst dom_watcher_1 = __webpack_require__(/*! ../dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\nconst __1 = __webpack_require__(/*! .. */ \"./lib/index.js\");\nvar SceneResizingAlgo;\n(function (SceneResizingAlgo) {\n    /**\n     * This is most commonly used three.js aspect ratio based resizing but\n     * doesn't really work great on mobile if you are using the full viewport.\n     *\n     * Basically doing:\n     *  camera.aspect = aspect;\n     *  camera.updateProjectionMatrix();\n     *\n     * Basically, the camera will project out objects to the aspect ratio\n     * of the dom element.  It contains Y but clips X.\n     *\n     * Thinking in terms of css, you can think of this similar to a\n     * background-size: contain for height only and background-cover for width.\n     *\n     * Using this, as you resize your scene, the tops and bottom will never be\n     * clipped but the sides can be clipped.  All of this is relative to\n     * how you setup your scene as well (camera position, object positions etc)\n     *\n     * Nuthsell:\n     * - If you resize the height, your object will go down in size.\n     * - If you resize the width, your objects will not change in size.\n     * - Resizing is based on a NDC 0,0 coordinates.\n     */\n    SceneResizingAlgo[\"standardAspect\"] = \"standardAspect\";\n    /**\n     * An algo that attempts to recreate a similar effect as background: contain\n     * but it's based on zoom.  This require you to pass the resizeScalar value\n     * which in this case would be used to multiply the zoom value.\n     *\n     * This is a less preferred method so consider using 'contain' instead.\n     *\n     * Nuthsell:\n     * - If you resize the height, your object will go down in size.\n     * - If you resize the width, your objects will go down in size by changing\n     *   the camera zoom.\n     * - Resizing is based on a NDC 0,0 coordinates.\n     * - resizingScalar can be passed to adust the zoom levels.\n     */\n    SceneResizingAlgo[\"resizeWithZoom\"] = \"resizeWithZoom\";\n    /**\n     * This algo can be useful because it calculates the FOV\n     * based on a scalar value.\n     *\n     * This is useful in two scenerios.\n     * 1) You want to force an absolute size for your objects.\n     *    By passing a resizingScalar that doesn't change,\n     *    the projection will always be of a consistent size regardless\n     *    of the canvas size.\n     *\n     *    The easiest way to describe this is to image a window in your house.\n     *    The window would be the canvas size (scene size).  By using a resizingScalar,\n     *    you can basically create a scene where your house window size might\n     *    change but what is projected out the window is exaclty the same size.\n     *    It more like peaking into another world without the world changing.\n     *\n     *    To use this, set your resizingAlgo to 'resizeWithFov' and also pass\n     *    a resizingScalar (something like 200 or 1000).  When you do this,\n     *    you'll notice that your objects are always the same size.\n     *\n     *    If you have breakpoints in your project, could could change the\n     *    resizingScalar based on your breakpoints and the objects in your scene,\n     *    will nicely resizing and you have control over how it looks.\n     *\n     * 2) Knowing the characteristics described in 1,\n     *    you can make a responsive scene by changing adjusting the resizingScalar.\n     *    The basis of how it scales can change depending on how you want to\n     *    adjust the scalar.\n     *\n     *    This provides you with the ability to resize the scene objects based on\n     *    axis\n     *    - x (element.offsetWidth)\n     *    - y (element.offsetHeight)\n     *    - x or y (Math.min(element.offsetWidth, element.offsetHeight))\n     *\n     * ```ts\n     *  const scene = new THREE.Scene();\n     *  const element = document.getElementById('my-element');\n     *  sceneRenderer.addScene({\n     *    resizingAlgo: 'resizingWithFov',\n     *    domElement: element,\n     *    // Update the scalar prior to resizing.\n     *    onBeforeResize: ()=> {\n     *     // Resizing the objects in your scene based on the current width of the\n     *     // dom element.\n     *     // If you do this, the objects will get smaller as you narrow your browser.\n     *     // (or the element width gets smaller)\n     *     scene.userData.resizingScalar = element.offsetWidth * 0.2\n     *\n     *\n     *     // Resizing the objects in your scene based on the current height of the\n     *     // dom element.\n     *     // If you do this, the objects will get smaller as you shorten your browser\n     *     // (or the element height gets smaller).\n     *     scene.userData.resizingScalar = element.offsetHeight * 0.2;\n     *\n     *\n     *     // Resize both in x and y scales.\n     *     scene.userData.resizingScalar = Math.min(element.offsetHeight, element.offsetWidth) * 0.2;\n     *   }\n     * })\n     *\n     * ```\n     */\n    SceneResizingAlgo[\"resizeWithFov\"] = \"resizeWithFov\";\n    /**\n     * An algo that \"attempts\" to recreate contain type effects.\n     * Read below on the Resizing Algo section for more information on\n     * this algo.\n     */\n    SceneResizingAlgo[\"contain\"] = \"contain\";\n    /**\n     * An algo that \"attempts\" to recreate cover type effects.\n     * Read below on the Resizing Algo section for more information on\n     * this algo.\n     */\n    SceneResizingAlgo[\"cover\"] = \"cover\";\n    /**\n     * Indicates that scene-renders should not attempt to resize and fix\n     * camera aspect on resizing.  This will be handled manually.  Scene\n     * defaults to manual if nothing is specified for resizingAlgo.\n     *\n     *\n     * An example of manually handing the resizing.\n     * ```\n     *\n     *       this.sceneRenderer.addScene({\n     *           resizingAlgo: 'manual',\n     *           scene: scene,\n     *           camera: camera,\n     *           domElement: element,\n     *           onResize() {\n     *               camera.aspect = element.offsetWidth / element.offsetHeight;\n     *               camera.updateProjectionMatrix();\n     *           }\n     *       });\n     *\n     * ```\n     */\n    SceneResizingAlgo[\"manual\"] = \"manual\";\n})(SceneResizingAlgo = exports.SceneResizingAlgo || (exports.SceneResizingAlgo = {}));\n/**\n * A class that attempts to get around max webGL context issues by having a\n * single renderer on the page.\n *\n * At a high level the issue is that you can't have more than 8 or so webGL\n * contexts as a general browser limitation.  Each context also can't share\n * resources.   So on pages where you might want to have like multiple webGL\n * canvases, you hit a road block.\n *\n * The solution here is to have a single canvas that covers the entire page (100vw x 100vh)\n * This single renderer would accept three.js scenes, which each define\n * a root html element to indicate the size and position to render.\n *\n * These scenes get reigstered to the sceneRenderer which upon calling,\n * sceneRenderer, will check the location of each registered scene dom element\n * and render it at the right place.\n *\n * This means that you could potentially export out a single gltf file with\n * multiple scenes and load it once to render on various DOM elements allowing\n * you to recycle geometry and avoid the webGL context limitations.\n *\n * For example usage, see:\n * @see /examples/three-scene-renderer.js\n * @see /examples/three-scene-renderer2.js\n *\n *\n * A high level example:\n *\n * ```\n * // Create an instance of SceneRenderer\n * this.sceneRenderer = new SceneRenderer({});\n *\n * // Add as many scenes as you like.\n *  this.sceneRenderer.addScene({\n *      // The resizing algo.\n *      resizingAlgo: 'resizeWithFov',\n *      resizingScalar: 1.0,\n *      scene: scene,\n *      camera: camera,\n *      // The dom element that this scene should render and size to.\n *      domElement: document.getElementById('my-element'),\n *      onBeforeRender: (renderer, scene, camera)=> {\n *           // Add some animations or whatever you need on render.\n *           scene.children[ 0 ].rotation.y = Date.now() * 0.001;\n *      },\n *      onAfterRender: (renderer, scene, camera)=> {\n *          // This is used for clean up.  For example, you may\n *          // have had a need to alter the settings of the renderer.\n *          // You would clean up here.\n *      }\n *      onBeforeResize: (renderer, scene, camera)=> {\n *         // Gets fired prior to resizing algo gets calculated.\n *\n *         // Update any of your scene options.\n *         scene.userData.resizingScalar = 2.0;\n *      },\n *      onResize(renderer, scene, camera) {\n *         // Gets fired after resizing algo gets calculated.\n *         // Depending on the algo you use, the camera.fov and aspect\n *         // would have been altered by this stage.\n *         // If you need access to pre alter values, then use\n *         // onBeforeResize\n *      }\n *     });\n *  });\n *\n * // Whereever you have RAF setup,\n * this.sceneRenderer.render();\n *\n * // Later dispose to clean up.\n * this.sceneRenderer.dispose();\n *\n * ```\n *\n *\n * ## Resizing Algos\n * There are various resizing algos available.  The current recommendation is\n * to use 'contain' or 'cover' where possible as this has been designed to most closely\n * reflect how css background-contain would work.\n *\n * You can also specify your own logic by setting resizingAlgo to 'manual'.\n *\n *\n * Using 'Contain' algo\n * The resizingAlgo contain accepts a few parameters.  Because in a 3d scene,\n * size is really relative to the current camera position and object sizes,\n * it is up to you to define the \"bounds\" of which should be contained in\n * your scene.  This is different per project but is specified in webGL world\n * scale.\n *\n * Contain requires the following resizing options:\n * - scalarX - a float representing the horizontal scale of the bounding box\n * - scalarY - a float representing the vertical scalar of the bounding box.\n *\n * The easiest way to figure out what values to use is to imagine\n * a box with an image on your screen and basically, you are defining\n * that box size and telling the scene-renderer to never crop that image (contain).\n *\n * Start with the shape you want to draw.  If you say wanted a\n * tall image, perhaps it's like 1200x1800 pixels.  Try using\n * those values but reducing it by a factor of 1000 (for example).\n *\n * scaleX: 1200 / 1000\n * scaleY: 1800 / 1000\n *\n * The actual values of scaleX and scaleY will depend on your scene\n * object sizes and what you need.  What scaleX and scaleY define\n * are the relative size of the area that should be contained.\n *\n * As a side note you can also achieve a quick \"contain\" effect\n * by using the 'resizeWithFov' option and passing a single resizingScalar.\n *\n * useFov\n * By default, size adjustments are performed by changing the camera zoom level.\n * This has an added benefit of correctly resizing text if you are calculating\n * text scale using threef.toDomCoordinates method.  It also doesn't skew\n * perspective.\n *\n * If you don't want to adjust zoom for some reason, you can opt to change\n * scene size by alterning the useFov to a true value.  This will adjust the\n * camera FOV as needed.  If your scene is orthographic or 2d based, you won't\n * see a difference but in 3d scene it will alter and skew perspective.\n *\n * Alignment options:\n * By default, without any alignment options, your scene\n * will scale at center / center point.  However, you\n * can define it so that it scales aligned to top, bottom,\n * left or right similar to how it would work in css.\n *\n * top - a value between 0-1 to note the vertical position of the final box\n * bottom - a value between 0-1 to note the vertical position of the final box\n * left - a value between 0-1 to note the horizontal position of the final box\n * right - a value between 0-1 to note the horizontal position of the final box\n *\n * top / bottom can't exist together\n * left / right can't exist together\n *\n * An example of using 'contain' algo\n *\n * ```ts\n *  this.sceneRenderer.addScene({\n *      // The resizing algo.\n *      resizingAlgo: 'contain',\n *      resizingOptions: {\n *           useFov: false, // Whether to use FOV instead of zoom\n *           scalarX: 2.6,\n *           scalarY: 3.8,\n *           top: 0 // Align this to the top\n *           left: 0 // Align this to the left\n *      },\n *     });\n *  });\n * ```\n *\n *\n * Using 'Cover' algo\n * Cover works in a very similar way to contain, you need to specify your\n * scalarX and scalarY values to tell scene-renderer to respect that box to\n * calculate the cover values.  You can specify top, bottom, left and right\n * values to cover scale from the specific axis.\n *\n * ```ts\n *  this.sceneRenderer.addScene({\n *      // The resizing algo.\n *      resizingAlgo: 'cover',\n *      resizingOptions: {\n *           useFov: false, // Whether to use FOV instead of zoom\n *           scalarX: 2.6,\n *           scalarY: 3.8,\n *           top: 0 // Align this to the top\n *           left: 0 // Align this to the left\n *      },\n *     });\n *  });\n *\n *\n * Advanced Resizing\n *\n *\n * Here is an example of changing scalar and aspect ratio,\n * based on your mobile versus desktop layout.\n *\n * ```ts\n *\n *  const sizeScalar = 0.2;\n *  this.sceneRenderer.addScene({\n *      // The resizing algo.\n *      resizingAlgo: 'cover',\n *      // Required - you should define the resizing options.\n *      resizingOptions: {\n *         scalarX: null,\n *         scalarY: null,\n *         top: null,\n *      },\n *      onBeforeResize: (renderer, scene, camera)=> {\n *         if(window.innerWidth < 800) {\n *             scene.userData.resizingOptions.scalarX = 400 * sizeScalar;\n *             scene.userData.resizingOptions.scalarY = 800 * sizeScalar;\n *             scene.userData.resizingOptions.top = 0;\n *         } else {\n *             scene.userData.resizingOptions.scalarX = 1920 * sizeScalar;\n *             scene.userData.resizingOptions.scalarY = 1080 * sizeScalar;\n *             scene.userData.resizingOptions.top = 0.5;\n *         }\n *      },\n *     });\n *  });\n *\n * ```\n *\n * ### Applying Degu Shader Chunks\n *\n * You can apply shader chunks as follows:\n * ```\n *import {deguShape2d} from\n * 'degu/lib/shaders/three-shader-chunks/degu-shape2d';\n *import {deguMathf} from\n * 'degu/lib/shaders/three-shader-chunks/degu-mathf';\n *   // Apply shader chunks.\n *   deguMathf(this.sceneRenderer.getThree());\n *   deguShape2d(this.sceneRenderer.getThree());\n *\n * ```\n *\n *\n *\n * @see examples/three-scene-renderer2.html for examples of the resizign strategies.\n *\n *\n * @see https://stackoverflow.com/questions/41919341/is-there-a-limit-to-the-number-of-three-webglrenderer-instances-in-a-page\n * @see https://stackoverflow.com/questions/30608723/is-it-possible-to-enable-unbounded-number-of-renderers-in-three-js/30633132#30633132\n * @see https://threejs.org/examples/webgl_multiple_elements.html\n */\nclass SceneRenderer {\n    constructor(config) {\n        /**\n         * The last known root element width (usually window size)\n         */\n        this.width = 0;\n        /**\n         * The last known root element height (usually window size)\n         */\n        this.height = 0;\n        this.watcher = new dom_watcher_1.DomWatcher();\n        this.watcher.add({\n            element: window,\n            callback: this.onResize.bind(this),\n            eventOptions: { passive: true },\n            on: 'smartResize',\n        });\n        this.useAbsolutePositioning = !!config.useAbsolutePositioning;\n        this.rootElement = config.rootElement || document.body;\n        this.dpr = window.devicePixelRatio || 1;\n        this.scenes = [];\n        // Generate canvas.\n        this.zIndex = 0;\n        this.canvas = document.createElement('canvas');\n        this.canvas.style.pointerEvents = 'none';\n        if (this.useAbsolutePositioning) {\n            this.canvas.style.position = 'absolute';\n        }\n        else {\n            this.canvas.style.position = 'fixed';\n        }\n        this.canvas.style.left = '0px';\n        this.canvas.style.top = '0px';\n        this.setZIndex(this.zIndex);\n        this.rootElement.append(this.canvas);\n        // Initial renderer setup.\n        this.renderer = new THREE.WebGLRenderer(config.rendererOptions || {\n            canvas: this.canvas,\n            antialias: true,\n            alpha: true,\n        });\n        // Set to transparency.\n        this.renderer.setClearColor(0xffffff, 0);\n        this.renderer.setPixelRatio(this.dpr);\n        this.onResize();\n    }\n    /**\n     * Gets the THREE object.\n     */\n    getThree() {\n        return THREE;\n    }\n    /**\n     * Forces a resize event on the scene-renderer.\n     */\n    resize() {\n        this.onResize();\n    }\n    /**\n     * Handles resizing events.\n     */\n    onResize() {\n        this.width = window.innerWidth;\n        this.height = window.innerHeight;\n        this.scenes.forEach((scene) => {\n            const element = scene.userData.domElement;\n            scene.userData.onBeforeResize &&\n                scene.userData.onBeforeResize(this.getRenderer(), scene, scene.userData.camera);\n            // Now for each, figure out the right resizing strategy.\n            const camera = scene.userData.camera;\n            const h = element.offsetHeight;\n            const w = element.offsetWidth;\n            const aspect = w / h;\n            // Contain zoom algo.\n            if (scene.userData.resizingAlgo === SceneResizingAlgo.resizeWithZoom) {\n                const scalar = scene.userData.resizingScalar || 1.0;\n                if (aspect <= 1) {\n                    camera.zoom = aspect * scalar;\n                }\n                else {\n                    camera.zoom = 1;\n                }\n                camera.aspect = aspect;\n                camera.updateProjectionMatrix();\n            }\n            // Standard Aspect algo\n            if (scene.userData.resizingAlgo === SceneResizingAlgo.standardAspect) {\n                camera.aspect = aspect;\n                camera.updateProjectionMatrix();\n            }\n            // Resize with FOV\n            // Uses resizingScalar.\n            if (scene.userData.resizingAlgo === SceneResizingAlgo.resizeWithFov) {\n                const z = scene.userData.resizingScalar || 1.0;\n                camera.fov = Math.atan(h / 2 / z) * 2 * THREE.Math.RAD2DEG;\n                camera.aspect = aspect;\n                camera.updateProjectionMatrix();\n            }\n            // \"Contain\"  Algo.\n            // Uses resizingOptions\n            if (scene.userData.resizingAlgo === SceneResizingAlgo.contain) {\n                if (!scene.userData.resizingOptions ||\n                    !scene.userData.resizingOptions.scalarX ||\n                    !scene.userData.resizingOptions.scalarY) {\n                    throw new Error('Requested contain algo without the correct resizing options');\n                }\n                // Fake contain.  Control the x,y scalar values to control\n                // resize points.\n                const scalarX = scene.userData.resizingOptions.scalarX;\n                const scalarY = scene.userData.resizingOptions.scalarY;\n                // Based on the provided scalars, implement a basic\n                // contain algo adjusting FOV.  Now this box area will\n                // be contained.\n                const hFov = Math.atan(h / 2 / (w * scalarY)) * 2 * THREE.Math.RAD2DEG;\n                const vFov = Math.atan(h / 2 / (h * scalarX)) * 2 * THREE.Math.RAD2DEG;\n                const virtualFov = Math.max(vFov, hFov);\n                // Use Fov\n                if (scene.userData.resizingOptions.useFov) {\n                    camera.fov = virtualFov;\n                }\n                else {\n                    // Use zoom\n                    camera.zoom = camera.fov / virtualFov;\n                }\n                // Calculate the virtual aspect ratio.\n                let virtualBox;\n                const virtualBoxAspect = scalarY / scalarX;\n                // Default Camera offsets in pixels.\n                let xOffset = 0;\n                let yOffset = 0;\n                // Offset options\n                let top = scene.userData.resizingOptions.top;\n                let bottom = scene.userData.resizingOptions.bottom;\n                let left = scene.userData.resizingOptions.left;\n                let right = scene.userData.resizingOptions.right;\n                // Vertical offset calculations\n                if (__1.is.defined(top) || __1.is.defined(bottom)) {\n                    // Create a virtual box based on the provided aspects.\n                    virtualBox = {\n                        width: w,\n                        height: w * virtualBoxAspect,\n                    };\n                    const diffY = Math.max(0, (h - virtualBox.height) / 2);\n                    if (__1.is.defined(top)) {\n                        // A top value ranging from 0-1 would actually\n                        // be an offset from the top of the scene to\n                        // the vertical center of the scene.  In order\n                        // to make this work more like a traditional css format\n                        // where 0 is the top and 1 is fully put the bounding\n                        // box a the bottom, we double the value.\n                        top *= 2;\n                        yOffset = diffY * (1 - top);\n                    }\n                    if (__1.is.defined(bottom)) {\n                        bottom *= 2;\n                        yOffset = -diffY * (1 - bottom);\n                    }\n                }\n                // Horizontal offset calculations\n                if (__1.is.defined(left) || __1.is.defined(right)) {\n                    // Create a virtual box based on the provided aspects.\n                    virtualBox = {\n                        width: h / virtualBoxAspect,\n                        height: h,\n                    };\n                    const diffX = Math.max(0, (w - virtualBox.width) / 2);\n                    if (__1.is.defined(left)) {\n                        left *= 2;\n                        xOffset = diffX * (1 - left);\n                    }\n                    if (__1.is.defined(right)) {\n                        right *= 2;\n                        xOffset = -diffX * (1 - right);\n                    }\n                }\n                // Apply camera offsets\n                camera.setViewOffset(w, h, xOffset, yOffset, w, h);\n                // Update camera aspect\n                camera.aspect = aspect;\n                camera.updateProjectionMatrix();\n            }\n            // \"Cover\"  Algo.\n            // Uses resizingOptions\n            if (scene.userData.resizingAlgo === SceneResizingAlgo.cover) {\n                if (!scene.userData.resizingOptions ||\n                    !scene.userData.resizingOptions.scalarX ||\n                    !scene.userData.resizingOptions.scalarY) {\n                    throw new Error('Requested cover algo without the correct resizing options');\n                }\n                const scalarX = scene.userData.resizingOptions.scalarX;\n                const scalarY = scene.userData.resizingOptions.scalarY;\n                let virtualBox;\n                const virtualBoxAspect = scalarY / scalarX;\n                // Based on the provided scalars, implement a basic\n                // cover algo adjusting FOV.  Now this box area will\n                // be cover with center / center.\n                const hFov = Math.atan(h / 2 / (w * scalarY)) * 2 * THREE.Math.RAD2DEG;\n                const vFov = Math.atan(h / 2 / (h * scalarX)) * 2 * THREE.Math.RAD2DEG;\n                const virtualFov = Math.min(vFov, hFov);\n                // Use Fov\n                if (scene.userData.resizingOptions.useFov) {\n                    camera.fov = virtualFov;\n                }\n                else {\n                    // Use zoom\n                    camera.zoom = camera.fov / virtualFov;\n                }\n                // Offset options\n                let xOffset = 0;\n                let yOffset = 0;\n                let top = scene.userData.resizingOptions.top;\n                let bottom = scene.userData.resizingOptions.bottom;\n                let left = scene.userData.resizingOptions.left;\n                let right = scene.userData.resizingOptions.right;\n                // Vertical offset calculations\n                if (__1.is.defined(top) || __1.is.defined(bottom)) {\n                    // Create a virtual box based on the provided aspects.\n                    virtualBox = {\n                        width: h / virtualBoxAspect,\n                        height: h,\n                    };\n                    // Calculate the approximate virutal box cover box scale.\n                    const coverBox = __1.mathf.calculateBackgroundCover({ width: w, height: h }, virtualBox);\n                    const diffY = Math.max(0, (coverBox.height - h) / 2);\n                    if (__1.is.defined(top)) {\n                        top *= 2;\n                        yOffset = -diffY * (1 - top);\n                    }\n                    if (__1.is.defined(bottom)) {\n                        bottom *= 2;\n                        yOffset = diffY * (1 - bottom);\n                    }\n                }\n                // Horizontal offset calculations\n                if (__1.is.defined(left) || __1.is.defined(right)) {\n                    // Create a virtual box based on the provided aspects.\n                    virtualBox = {\n                        width: w,\n                        height: w * virtualBoxAspect,\n                    };\n                    const coverBox = __1.mathf.calculateBackgroundCover({ width: w, height: h }, virtualBox);\n                    const diffX = Math.max(0, (coverBox.width - w) / 2);\n                    if (__1.is.defined(left)) {\n                        left *= 2;\n                        xOffset = -diffX * (1 - left);\n                    }\n                    if (__1.is.defined(right)) {\n                        right *= 2;\n                        xOffset = diffX * (1 - right);\n                    }\n                }\n                camera.setViewOffset(w, h, xOffset, yOffset, w, h);\n                camera.aspect = aspect;\n                camera.updateProjectionMatrix();\n            }\n            scene.userData.onResize &&\n                scene.userData.onResize(this.getRenderer(), scene, scene.userData.camera);\n        });\n        this.renderer.setSize(this.width, this.height);\n        this.render();\n    }\n    /**\n     * Updates the z-index of the main renderer canvas.\n     */\n    setZIndex(zIndex) {\n        this.zIndex = zIndex;\n        this.canvas.style.zIndex = this.zIndex + '';\n    }\n    /**\n     * Returns the last known size of root canvas.  Usually this is usually the window size\n     * since the main renderer canvas covers the whole page.\n     */\n    getSize() {\n        return {\n            width: this.width,\n            height: this.height,\n            aspect: this.width / this.height,\n        };\n    }\n    /**\n     * Add a THREE.Scene to be rendered when the given domElement is visible\n     * in the scene.\n     */\n    addScene(sceneConfig, forceResize = false) {\n        if (!sceneConfig.domElement || !sceneConfig.scene || !sceneConfig.camera) {\n            console.warn('SceneRenderer could not register scene.  It is missing either the scene, camere or domElement');\n            return;\n        }\n        const scene = sceneConfig.scene;\n        if (sceneConfig.debug) {\n            this.setupDebugging(sceneConfig);\n        }\n        // Set the scene config data to the scene.\n        scene.userData = sceneConfig;\n        // Add ev to able to later check if the associated domElement is visible\n        // in the viewport.\n        scene.userData.ev = element_visibility_1.elementVisibility.inview(sceneConfig.domElement);\n        this.scenes.push(scene);\n        // Run init.\n        scene.userData.onInit &&\n            scene.userData.onInit(this.getRenderer(), scene, scene.userData.camera);\n        if (forceResize) {\n            window.setTimeout(() => {\n                this.resize();\n            });\n        }\n    }\n    /**\n     * Sets up debugging via GUIF.\n     * @param scene\n     */\n    setupDebugging(sceneConfig) {\n        const scene = sceneConfig.scene;\n        const axesHelper = new THREE.AxesHelper(50);\n        scene.add(axesHelper);\n        new three_inspector_1.ThreeInspector(sceneConfig.domElement);\n    }\n    /**\n     * Gets the internal webGLRenderer.\n     */\n    getRenderer() {\n        return this.renderer;\n    }\n    /**\n     * Renders out each scene.\n     */\n    render() {\n        // See note on: https://stackoverflow.com/questions/30608723/is-it-possible-to-enable-unbounded-number-of-renderers-in-three-js/30633132#30633132\n        // Rather than using fixed, this keeps the canvas in sync.\n        if (this.useAbsolutePositioning) {\n            this.canvas.style.transform = `translateY(${window.scrollY}px)`;\n        }\n        this.renderer.setScissorTest(false);\n        this.renderer.clear();\n        this.renderer.setScissorTest(true);\n        // Go through each scene and it's position and render it out in\n        // pieces.\n        this.scenes.forEach((scene) => {\n            // If the scene is out of view, cull.\n            if (!scene.userData.ev.state().inview) {\n                return;\n            }\n            const element = scene.userData.domElement;\n            // Get the element position relative to the page's viewport\n            const rect = element.getBoundingClientRect();\n            // set the viewport\n            const width = rect.right - rect.left;\n            const height = rect.bottom - rect.top;\n            const left = rect.left;\n            const bottom = this.renderer.domElement.clientHeight - rect.bottom;\n            this.renderer.setViewport(left, bottom, width, height);\n            this.renderer.setScissor(left, bottom, width, height);\n            scene.userData.onBeforeRender &&\n                scene.userData.onBeforeRender(this.getRenderer(), scene, scene.userData.camera);\n            this.renderer.render(scene, scene.userData.camera);\n            scene.userData.onAfterRender &&\n                scene.userData.onAfterRender(this.getRenderer(), scene, scene.userData.camera);\n        });\n    }\n    dispose() {\n        var _a;\n        // Clean up scenes.\n        this.scenes.forEach((scene) => {\n            // Dispose element visiblity.\n            scene.userData.ev.dispose();\n            // Remove dom association.\n            scene.userData.element = null;\n            scene.userData.onDispose && scene.userData.onDispose();\n        });\n        // Remove canvas from rootElement.\n        (_a = this.canvas.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this.canvas);\n    }\n}\nexports.SceneRenderer = SceneRenderer;\n//# sourceMappingURL=scene-renderer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvdGhyZWVmL3NjZW5lLXJlbmRlcmVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3RocmVlZi9zY2VuZS1yZW5kZXJlci5qcz8yMTdkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TY2VuZVJlbmRlcmVyID0gZXhwb3J0cy5TY2VuZVJlc2l6aW5nQWxnbyA9IHZvaWQgMDtcbmNvbnN0IFRIUkVFID0gcmVxdWlyZShcInRocmVlXCIpO1xuY29uc3QgdGhyZWVfaW5zcGVjdG9yXzEgPSByZXF1aXJlKFwiLi90aHJlZS1pbnNwZWN0b3JcIik7XG5jb25zdCBlbGVtZW50X3Zpc2liaWxpdHlfMSA9IHJlcXVpcmUoXCIuLi9kb20vZWxlbWVudC12aXNpYmlsaXR5XCIpO1xuY29uc3QgZG9tX3dhdGNoZXJfMSA9IHJlcXVpcmUoXCIuLi9kb20vZG9tLXdhdGNoZXJcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi5cIik7XG52YXIgU2NlbmVSZXNpemluZ0FsZ287XG4oZnVuY3Rpb24gKFNjZW5lUmVzaXppbmdBbGdvKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgdGhyZWUuanMgYXNwZWN0IHJhdGlvIGJhc2VkIHJlc2l6aW5nIGJ1dFxuICAgICAqIGRvZXNuJ3QgcmVhbGx5IHdvcmsgZ3JlYXQgb24gbW9iaWxlIGlmIHlvdSBhcmUgdXNpbmcgdGhlIGZ1bGwgdmlld3BvcnQuXG4gICAgICpcbiAgICAgKiBCYXNpY2FsbHkgZG9pbmc6XG4gICAgICogIGNhbWVyYS5hc3BlY3QgPSBhc3BlY3Q7XG4gICAgICogIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICpcbiAgICAgKiBCYXNpY2FsbHksIHRoZSBjYW1lcmEgd2lsbCBwcm9qZWN0IG91dCBvYmplY3RzIHRvIHRoZSBhc3BlY3QgcmF0aW9cbiAgICAgKiBvZiB0aGUgZG9tIGVsZW1lbnQuICBJdCBjb250YWlucyBZIGJ1dCBjbGlwcyBYLlxuICAgICAqXG4gICAgICogVGhpbmtpbmcgaW4gdGVybXMgb2YgY3NzLCB5b3UgY2FuIHRoaW5rIG9mIHRoaXMgc2ltaWxhciB0byBhXG4gICAgICogYmFja2dyb3VuZC1zaXplOiBjb250YWluIGZvciBoZWlnaHQgb25seSBhbmQgYmFja2dyb3VuZC1jb3ZlciBmb3Igd2lkdGguXG4gICAgICpcbiAgICAgKiBVc2luZyB0aGlzLCBhcyB5b3UgcmVzaXplIHlvdXIgc2NlbmUsIHRoZSB0b3BzIGFuZCBib3R0b20gd2lsbCBuZXZlciBiZVxuICAgICAqIGNsaXBwZWQgYnV0IHRoZSBzaWRlcyBjYW4gYmUgY2xpcHBlZC4gIEFsbCBvZiB0aGlzIGlzIHJlbGF0aXZlIHRvXG4gICAgICogaG93IHlvdSBzZXR1cCB5b3VyIHNjZW5lIGFzIHdlbGwgKGNhbWVyYSBwb3NpdGlvbiwgb2JqZWN0IHBvc2l0aW9ucyBldGMpXG4gICAgICpcbiAgICAgKiBOdXRoc2VsbDpcbiAgICAgKiAtIElmIHlvdSByZXNpemUgdGhlIGhlaWdodCwgeW91ciBvYmplY3Qgd2lsbCBnbyBkb3duIGluIHNpemUuXG4gICAgICogLSBJZiB5b3UgcmVzaXplIHRoZSB3aWR0aCwgeW91ciBvYmplY3RzIHdpbGwgbm90IGNoYW5nZSBpbiBzaXplLlxuICAgICAqIC0gUmVzaXppbmcgaXMgYmFzZWQgb24gYSBOREMgMCwwIGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIFNjZW5lUmVzaXppbmdBbGdvW1wic3RhbmRhcmRBc3BlY3RcIl0gPSBcInN0YW5kYXJkQXNwZWN0XCI7XG4gICAgLyoqXG4gICAgICogQW4gYWxnbyB0aGF0IGF0dGVtcHRzIHRvIHJlY3JlYXRlIGEgc2ltaWxhciBlZmZlY3QgYXMgYmFja2dyb3VuZDogY29udGFpblxuICAgICAqIGJ1dCBpdCdzIGJhc2VkIG9uIHpvb20uICBUaGlzIHJlcXVpcmUgeW91IHRvIHBhc3MgdGhlIHJlc2l6ZVNjYWxhciB2YWx1ZVxuICAgICAqIHdoaWNoIGluIHRoaXMgY2FzZSB3b3VsZCBiZSB1c2VkIHRvIG11bHRpcGx5IHRoZSB6b29tIHZhbHVlLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGxlc3MgcHJlZmVycmVkIG1ldGhvZCBzbyBjb25zaWRlciB1c2luZyAnY29udGFpbicgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIE51dGhzZWxsOlxuICAgICAqIC0gSWYgeW91IHJlc2l6ZSB0aGUgaGVpZ2h0LCB5b3VyIG9iamVjdCB3aWxsIGdvIGRvd24gaW4gc2l6ZS5cbiAgICAgKiAtIElmIHlvdSByZXNpemUgdGhlIHdpZHRoLCB5b3VyIG9iamVjdHMgd2lsbCBnbyBkb3duIGluIHNpemUgYnkgY2hhbmdpbmdcbiAgICAgKiAgIHRoZSBjYW1lcmEgem9vbS5cbiAgICAgKiAtIFJlc2l6aW5nIGlzIGJhc2VkIG9uIGEgTkRDIDAsMCBjb29yZGluYXRlcy5cbiAgICAgKiAtIHJlc2l6aW5nU2NhbGFyIGNhbiBiZSBwYXNzZWQgdG8gYWR1c3QgdGhlIHpvb20gbGV2ZWxzLlxuICAgICAqL1xuICAgIFNjZW5lUmVzaXppbmdBbGdvW1wicmVzaXplV2l0aFpvb21cIl0gPSBcInJlc2l6ZVdpdGhab29tXCI7XG4gICAgLyoqXG4gICAgICogVGhpcyBhbGdvIGNhbiBiZSB1c2VmdWwgYmVjYXVzZSBpdCBjYWxjdWxhdGVzIHRoZSBGT1ZcbiAgICAgKiBiYXNlZCBvbiBhIHNjYWxhciB2YWx1ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGluIHR3byBzY2VuZXJpb3MuXG4gICAgICogMSkgWW91IHdhbnQgdG8gZm9yY2UgYW4gYWJzb2x1dGUgc2l6ZSBmb3IgeW91ciBvYmplY3RzLlxuICAgICAqICAgIEJ5IHBhc3NpbmcgYSByZXNpemluZ1NjYWxhciB0aGF0IGRvZXNuJ3QgY2hhbmdlLFxuICAgICAqICAgIHRoZSBwcm9qZWN0aW9uIHdpbGwgYWx3YXlzIGJlIG9mIGEgY29uc2lzdGVudCBzaXplIHJlZ2FyZGxlc3NcbiAgICAgKiAgICBvZiB0aGUgY2FudmFzIHNpemUuXG4gICAgICpcbiAgICAgKiAgICBUaGUgZWFzaWVzdCB3YXkgdG8gZGVzY3JpYmUgdGhpcyBpcyB0byBpbWFnZSBhIHdpbmRvdyBpbiB5b3VyIGhvdXNlLlxuICAgICAqICAgIFRoZSB3aW5kb3cgd291bGQgYmUgdGhlIGNhbnZhcyBzaXplIChzY2VuZSBzaXplKS4gIEJ5IHVzaW5nIGEgcmVzaXppbmdTY2FsYXIsXG4gICAgICogICAgeW91IGNhbiBiYXNpY2FsbHkgY3JlYXRlIGEgc2NlbmUgd2hlcmUgeW91ciBob3VzZSB3aW5kb3cgc2l6ZSBtaWdodFxuICAgICAqICAgIGNoYW5nZSBidXQgd2hhdCBpcyBwcm9qZWN0ZWQgb3V0IHRoZSB3aW5kb3cgaXMgZXhhY2x0eSB0aGUgc2FtZSBzaXplLlxuICAgICAqICAgIEl0IG1vcmUgbGlrZSBwZWFraW5nIGludG8gYW5vdGhlciB3b3JsZCB3aXRob3V0IHRoZSB3b3JsZCBjaGFuZ2luZy5cbiAgICAgKlxuICAgICAqICAgIFRvIHVzZSB0aGlzLCBzZXQgeW91ciByZXNpemluZ0FsZ28gdG8gJ3Jlc2l6ZVdpdGhGb3YnIGFuZCBhbHNvIHBhc3NcbiAgICAgKiAgICBhIHJlc2l6aW5nU2NhbGFyIChzb21ldGhpbmcgbGlrZSAyMDAgb3IgMTAwMCkuICBXaGVuIHlvdSBkbyB0aGlzLFxuICAgICAqICAgIHlvdSdsbCBub3RpY2UgdGhhdCB5b3VyIG9iamVjdHMgYXJlIGFsd2F5cyB0aGUgc2FtZSBzaXplLlxuICAgICAqXG4gICAgICogICAgSWYgeW91IGhhdmUgYnJlYWtwb2ludHMgaW4geW91ciBwcm9qZWN0LCBjb3VsZCBjb3VsZCBjaGFuZ2UgdGhlXG4gICAgICogICAgcmVzaXppbmdTY2FsYXIgYmFzZWQgb24geW91ciBicmVha3BvaW50cyBhbmQgdGhlIG9iamVjdHMgaW4geW91ciBzY2VuZSxcbiAgICAgKiAgICB3aWxsIG5pY2VseSByZXNpemluZyBhbmQgeW91IGhhdmUgY29udHJvbCBvdmVyIGhvdyBpdCBsb29rcy5cbiAgICAgKlxuICAgICAqIDIpIEtub3dpbmcgdGhlIGNoYXJhY3RlcmlzdGljcyBkZXNjcmliZWQgaW4gMSxcbiAgICAgKiAgICB5b3UgY2FuIG1ha2UgYSByZXNwb25zaXZlIHNjZW5lIGJ5IGNoYW5naW5nIGFkanVzdGluZyB0aGUgcmVzaXppbmdTY2FsYXIuXG4gICAgICogICAgVGhlIGJhc2lzIG9mIGhvdyBpdCBzY2FsZXMgY2FuIGNoYW5nZSBkZXBlbmRpbmcgb24gaG93IHlvdSB3YW50IHRvXG4gICAgICogICAgYWRqdXN0IHRoZSBzY2FsYXIuXG4gICAgICpcbiAgICAgKiAgICBUaGlzIHByb3ZpZGVzIHlvdSB3aXRoIHRoZSBhYmlsaXR5IHRvIHJlc2l6ZSB0aGUgc2NlbmUgb2JqZWN0cyBiYXNlZCBvblxuICAgICAqICAgIGF4aXNcbiAgICAgKiAgICAtIHggKGVsZW1lbnQub2Zmc2V0V2lkdGgpXG4gICAgICogICAgLSB5IChlbGVtZW50Lm9mZnNldEhlaWdodClcbiAgICAgKiAgICAtIHggb3IgeSAoTWF0aC5taW4oZWxlbWVudC5vZmZzZXRXaWR0aCwgZWxlbWVudC5vZmZzZXRIZWlnaHQpKVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiAgY29uc3Qgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICAgKiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteS1lbGVtZW50Jyk7XG4gICAgICogIHNjZW5lUmVuZGVyZXIuYWRkU2NlbmUoe1xuICAgICAqICAgIHJlc2l6aW5nQWxnbzogJ3Jlc2l6aW5nV2l0aEZvdicsXG4gICAgICogICAgZG9tRWxlbWVudDogZWxlbWVudCxcbiAgICAgKiAgICAvLyBVcGRhdGUgdGhlIHNjYWxhciBwcmlvciB0byByZXNpemluZy5cbiAgICAgKiAgICBvbkJlZm9yZVJlc2l6ZTogKCk9PiB7XG4gICAgICogICAgIC8vIFJlc2l6aW5nIHRoZSBvYmplY3RzIGluIHlvdXIgc2NlbmUgYmFzZWQgb24gdGhlIGN1cnJlbnQgd2lkdGggb2YgdGhlXG4gICAgICogICAgIC8vIGRvbSBlbGVtZW50LlxuICAgICAqICAgICAvLyBJZiB5b3UgZG8gdGhpcywgdGhlIG9iamVjdHMgd2lsbCBnZXQgc21hbGxlciBhcyB5b3UgbmFycm93IHlvdXIgYnJvd3Nlci5cbiAgICAgKiAgICAgLy8gKG9yIHRoZSBlbGVtZW50IHdpZHRoIGdldHMgc21hbGxlcilcbiAgICAgKiAgICAgc2NlbmUudXNlckRhdGEucmVzaXppbmdTY2FsYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoICogMC4yXG4gICAgICpcbiAgICAgKlxuICAgICAqICAgICAvLyBSZXNpemluZyB0aGUgb2JqZWN0cyBpbiB5b3VyIHNjZW5lIGJhc2VkIG9uIHRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGVcbiAgICAgKiAgICAgLy8gZG9tIGVsZW1lbnQuXG4gICAgICogICAgIC8vIElmIHlvdSBkbyB0aGlzLCB0aGUgb2JqZWN0cyB3aWxsIGdldCBzbWFsbGVyIGFzIHlvdSBzaG9ydGVuIHlvdXIgYnJvd3NlclxuICAgICAqICAgICAvLyAob3IgdGhlIGVsZW1lbnQgaGVpZ2h0IGdldHMgc21hbGxlcikuXG4gICAgICogICAgIHNjZW5lLnVzZXJEYXRhLnJlc2l6aW5nU2NhbGFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgKiAwLjI7XG4gICAgICpcbiAgICAgKlxuICAgICAqICAgICAvLyBSZXNpemUgYm90aCBpbiB4IGFuZCB5IHNjYWxlcy5cbiAgICAgKiAgICAgc2NlbmUudXNlckRhdGEucmVzaXppbmdTY2FsYXIgPSBNYXRoLm1pbihlbGVtZW50Lm9mZnNldEhlaWdodCwgZWxlbWVudC5vZmZzZXRXaWR0aCkgKiAwLjI7XG4gICAgICogICB9XG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFNjZW5lUmVzaXppbmdBbGdvW1wicmVzaXplV2l0aEZvdlwiXSA9IFwicmVzaXplV2l0aEZvdlwiO1xuICAgIC8qKlxuICAgICAqIEFuIGFsZ28gdGhhdCBcImF0dGVtcHRzXCIgdG8gcmVjcmVhdGUgY29udGFpbiB0eXBlIGVmZmVjdHMuXG4gICAgICogUmVhZCBiZWxvdyBvbiB0aGUgUmVzaXppbmcgQWxnbyBzZWN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uXG4gICAgICogdGhpcyBhbGdvLlxuICAgICAqL1xuICAgIFNjZW5lUmVzaXppbmdBbGdvW1wiY29udGFpblwiXSA9IFwiY29udGFpblwiO1xuICAgIC8qKlxuICAgICAqIEFuIGFsZ28gdGhhdCBcImF0dGVtcHRzXCIgdG8gcmVjcmVhdGUgY292ZXIgdHlwZSBlZmZlY3RzLlxuICAgICAqIFJlYWQgYmVsb3cgb24gdGhlIFJlc2l6aW5nIEFsZ28gc2VjdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvblxuICAgICAqIHRoaXMgYWxnby5cbiAgICAgKi9cbiAgICBTY2VuZVJlc2l6aW5nQWxnb1tcImNvdmVyXCJdID0gXCJjb3ZlclwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IHNjZW5lLXJlbmRlcnMgc2hvdWxkIG5vdCBhdHRlbXB0IHRvIHJlc2l6ZSBhbmQgZml4XG4gICAgICogY2FtZXJhIGFzcGVjdCBvbiByZXNpemluZy4gIFRoaXMgd2lsbCBiZSBoYW5kbGVkIG1hbnVhbGx5LiAgU2NlbmVcbiAgICAgKiBkZWZhdWx0cyB0byBtYW51YWwgaWYgbm90aGluZyBpcyBzcGVjaWZpZWQgZm9yIHJlc2l6aW5nQWxnby5cbiAgICAgKlxuICAgICAqXG4gICAgICogQW4gZXhhbXBsZSBvZiBtYW51YWxseSBoYW5kaW5nIHRoZSByZXNpemluZy5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICAgICAgIHRoaXMuc2NlbmVSZW5kZXJlci5hZGRTY2VuZSh7XG4gICAgICogICAgICAgICAgIHJlc2l6aW5nQWxnbzogJ21hbnVhbCcsXG4gICAgICogICAgICAgICAgIHNjZW5lOiBzY2VuZSxcbiAgICAgKiAgICAgICAgICAgY2FtZXJhOiBjYW1lcmEsXG4gICAgICogICAgICAgICAgIGRvbUVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICogICAgICAgICAgIG9uUmVzaXplKCkge1xuICAgICAqICAgICAgICAgICAgICAgY2FtZXJhLmFzcGVjdCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLyBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgKiAgICAgICAgICAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICogICAgICAgICAgIH1cbiAgICAgKiAgICAgICB9KTtcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFNjZW5lUmVzaXppbmdBbGdvW1wibWFudWFsXCJdID0gXCJtYW51YWxcIjtcbn0pKFNjZW5lUmVzaXppbmdBbGdvID0gZXhwb3J0cy5TY2VuZVJlc2l6aW5nQWxnbyB8fCAoZXhwb3J0cy5TY2VuZVJlc2l6aW5nQWxnbyA9IHt9KSk7XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBhdHRlbXB0cyB0byBnZXQgYXJvdW5kIG1heCB3ZWJHTCBjb250ZXh0IGlzc3VlcyBieSBoYXZpbmcgYVxuICogc2luZ2xlIHJlbmRlcmVyIG9uIHRoZSBwYWdlLlxuICpcbiAqIEF0IGEgaGlnaCBsZXZlbCB0aGUgaXNzdWUgaXMgdGhhdCB5b3UgY2FuJ3QgaGF2ZSBtb3JlIHRoYW4gOCBvciBzbyB3ZWJHTFxuICogY29udGV4dHMgYXMgYSBnZW5lcmFsIGJyb3dzZXIgbGltaXRhdGlvbi4gIEVhY2ggY29udGV4dCBhbHNvIGNhbid0IHNoYXJlXG4gKiByZXNvdXJjZXMuICAgU28gb24gcGFnZXMgd2hlcmUgeW91IG1pZ2h0IHdhbnQgdG8gaGF2ZSBsaWtlIG11bHRpcGxlIHdlYkdMXG4gKiBjYW52YXNlcywgeW91IGhpdCBhIHJvYWQgYmxvY2suXG4gKlxuICogVGhlIHNvbHV0aW9uIGhlcmUgaXMgdG8gaGF2ZSBhIHNpbmdsZSBjYW52YXMgdGhhdCBjb3ZlcnMgdGhlIGVudGlyZSBwYWdlICgxMDB2dyB4IDEwMHZoKVxuICogVGhpcyBzaW5nbGUgcmVuZGVyZXIgd291bGQgYWNjZXB0IHRocmVlLmpzIHNjZW5lcywgd2hpY2ggZWFjaCBkZWZpbmVcbiAqIGEgcm9vdCBodG1sIGVsZW1lbnQgdG8gaW5kaWNhdGUgdGhlIHNpemUgYW5kIHBvc2l0aW9uIHRvIHJlbmRlci5cbiAqXG4gKiBUaGVzZSBzY2VuZXMgZ2V0IHJlaWdzdGVyZWQgdG8gdGhlIHNjZW5lUmVuZGVyZXIgd2hpY2ggdXBvbiBjYWxsaW5nLFxuICogc2NlbmVSZW5kZXJlciwgd2lsbCBjaGVjayB0aGUgbG9jYXRpb24gb2YgZWFjaCByZWdpc3RlcmVkIHNjZW5lIGRvbSBlbGVtZW50XG4gKiBhbmQgcmVuZGVyIGl0IGF0IHRoZSByaWdodCBwbGFjZS5cbiAqXG4gKiBUaGlzIG1lYW5zIHRoYXQgeW91IGNvdWxkIHBvdGVudGlhbGx5IGV4cG9ydCBvdXQgYSBzaW5nbGUgZ2x0ZiBmaWxlIHdpdGhcbiAqIG11bHRpcGxlIHNjZW5lcyBhbmQgbG9hZCBpdCBvbmNlIHRvIHJlbmRlciBvbiB2YXJpb3VzIERPTSBlbGVtZW50cyBhbGxvd2luZ1xuICogeW91IHRvIHJlY3ljbGUgZ2VvbWV0cnkgYW5kIGF2b2lkIHRoZSB3ZWJHTCBjb250ZXh0IGxpbWl0YXRpb25zLlxuICpcbiAqIEZvciBleGFtcGxlIHVzYWdlLCBzZWU6XG4gKiBAc2VlIC9leGFtcGxlcy90aHJlZS1zY2VuZS1yZW5kZXJlci5qc1xuICogQHNlZSAvZXhhbXBsZXMvdGhyZWUtc2NlbmUtcmVuZGVyZXIyLmpzXG4gKlxuICpcbiAqIEEgaGlnaCBsZXZlbCBleGFtcGxlOlxuICpcbiAqIGBgYFxuICogLy8gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIFNjZW5lUmVuZGVyZXJcbiAqIHRoaXMuc2NlbmVSZW5kZXJlciA9IG5ldyBTY2VuZVJlbmRlcmVyKHt9KTtcbiAqXG4gKiAvLyBBZGQgYXMgbWFueSBzY2VuZXMgYXMgeW91IGxpa2UuXG4gKiAgdGhpcy5zY2VuZVJlbmRlcmVyLmFkZFNjZW5lKHtcbiAqICAgICAgLy8gVGhlIHJlc2l6aW5nIGFsZ28uXG4gKiAgICAgIHJlc2l6aW5nQWxnbzogJ3Jlc2l6ZVdpdGhGb3YnLFxuICogICAgICByZXNpemluZ1NjYWxhcjogMS4wLFxuICogICAgICBzY2VuZTogc2NlbmUsXG4gKiAgICAgIGNhbWVyYTogY2FtZXJhLFxuICogICAgICAvLyBUaGUgZG9tIGVsZW1lbnQgdGhhdCB0aGlzIHNjZW5lIHNob3VsZCByZW5kZXIgYW5kIHNpemUgdG8uXG4gKiAgICAgIGRvbUVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteS1lbGVtZW50JyksXG4gKiAgICAgIG9uQmVmb3JlUmVuZGVyOiAocmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEpPT4ge1xuICogICAgICAgICAgIC8vIEFkZCBzb21lIGFuaW1hdGlvbnMgb3Igd2hhdGV2ZXIgeW91IG5lZWQgb24gcmVuZGVyLlxuICogICAgICAgICAgIHNjZW5lLmNoaWxkcmVuWyAwIF0ucm90YXRpb24ueSA9IERhdGUubm93KCkgKiAwLjAwMTtcbiAqICAgICAgfSxcbiAqICAgICAgb25BZnRlclJlbmRlcjogKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhKT0+IHtcbiAqICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZCBmb3IgY2xlYW4gdXAuICBGb3IgZXhhbXBsZSwgeW91IG1heVxuICogICAgICAgICAgLy8gaGF2ZSBoYWQgYSBuZWVkIHRvIGFsdGVyIHRoZSBzZXR0aW5ncyBvZiB0aGUgcmVuZGVyZXIuXG4gKiAgICAgICAgICAvLyBZb3Ugd291bGQgY2xlYW4gdXAgaGVyZS5cbiAqICAgICAgfVxuICogICAgICBvbkJlZm9yZVJlc2l6ZTogKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhKT0+IHtcbiAqICAgICAgICAgLy8gR2V0cyBmaXJlZCBwcmlvciB0byByZXNpemluZyBhbGdvIGdldHMgY2FsY3VsYXRlZC5cbiAqXG4gKiAgICAgICAgIC8vIFVwZGF0ZSBhbnkgb2YgeW91ciBzY2VuZSBvcHRpb25zLlxuICogICAgICAgICBzY2VuZS51c2VyRGF0YS5yZXNpemluZ1NjYWxhciA9IDIuMDtcbiAqICAgICAgfSxcbiAqICAgICAgb25SZXNpemUocmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEpIHtcbiAqICAgICAgICAgLy8gR2V0cyBmaXJlZCBhZnRlciByZXNpemluZyBhbGdvIGdldHMgY2FsY3VsYXRlZC5cbiAqICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBhbGdvIHlvdSB1c2UsIHRoZSBjYW1lcmEuZm92IGFuZCBhc3BlY3RcbiAqICAgICAgICAgLy8gd291bGQgaGF2ZSBiZWVuIGFsdGVyZWQgYnkgdGhpcyBzdGFnZS5cbiAqICAgICAgICAgLy8gSWYgeW91IG5lZWQgYWNjZXNzIHRvIHByZSBhbHRlciB2YWx1ZXMsIHRoZW4gdXNlXG4gKiAgICAgICAgIC8vIG9uQmVmb3JlUmVzaXplXG4gKiAgICAgIH1cbiAqICAgICB9KTtcbiAqICB9KTtcbiAqXG4gKiAvLyBXaGVyZWV2ZXIgeW91IGhhdmUgUkFGIHNldHVwLFxuICogdGhpcy5zY2VuZVJlbmRlcmVyLnJlbmRlcigpO1xuICpcbiAqIC8vIExhdGVyIGRpc3Bvc2UgdG8gY2xlYW4gdXAuXG4gKiB0aGlzLnNjZW5lUmVuZGVyZXIuZGlzcG9zZSgpO1xuICpcbiAqIGBgYFxuICpcbiAqXG4gKiAjIyBSZXNpemluZyBBbGdvc1xuICogVGhlcmUgYXJlIHZhcmlvdXMgcmVzaXppbmcgYWxnb3MgYXZhaWxhYmxlLiAgVGhlIGN1cnJlbnQgcmVjb21tZW5kYXRpb24gaXNcbiAqIHRvIHVzZSAnY29udGFpbicgb3IgJ2NvdmVyJyB3aGVyZSBwb3NzaWJsZSBhcyB0aGlzIGhhcyBiZWVuIGRlc2lnbmVkIHRvIG1vc3QgY2xvc2VseVxuICogcmVmbGVjdCBob3cgY3NzIGJhY2tncm91bmQtY29udGFpbiB3b3VsZCB3b3JrLlxuICpcbiAqIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IHlvdXIgb3duIGxvZ2ljIGJ5IHNldHRpbmcgcmVzaXppbmdBbGdvIHRvICdtYW51YWwnLlxuICpcbiAqXG4gKiBVc2luZyAnQ29udGFpbicgYWxnb1xuICogVGhlIHJlc2l6aW5nQWxnbyBjb250YWluIGFjY2VwdHMgYSBmZXcgcGFyYW1ldGVycy4gIEJlY2F1c2UgaW4gYSAzZCBzY2VuZSxcbiAqIHNpemUgaXMgcmVhbGx5IHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGNhbWVyYSBwb3NpdGlvbiBhbmQgb2JqZWN0IHNpemVzLFxuICogaXQgaXMgdXAgdG8geW91IHRvIGRlZmluZSB0aGUgXCJib3VuZHNcIiBvZiB3aGljaCBzaG91bGQgYmUgY29udGFpbmVkIGluXG4gKiB5b3VyIHNjZW5lLiAgVGhpcyBpcyBkaWZmZXJlbnQgcGVyIHByb2plY3QgYnV0IGlzIHNwZWNpZmllZCBpbiB3ZWJHTCB3b3JsZFxuICogc2NhbGUuXG4gKlxuICogQ29udGFpbiByZXF1aXJlcyB0aGUgZm9sbG93aW5nIHJlc2l6aW5nIG9wdGlvbnM6XG4gKiAtIHNjYWxhclggLSBhIGZsb2F0IHJlcHJlc2VudGluZyB0aGUgaG9yaXpvbnRhbCBzY2FsZSBvZiB0aGUgYm91bmRpbmcgYm94XG4gKiAtIHNjYWxhclkgLSBhIGZsb2F0IHJlcHJlc2VudGluZyB0aGUgdmVydGljYWwgc2NhbGFyIG9mIHRoZSBib3VuZGluZyBib3guXG4gKlxuICogVGhlIGVhc2llc3Qgd2F5IHRvIGZpZ3VyZSBvdXQgd2hhdCB2YWx1ZXMgdG8gdXNlIGlzIHRvIGltYWdpbmVcbiAqIGEgYm94IHdpdGggYW4gaW1hZ2Ugb24geW91ciBzY3JlZW4gYW5kIGJhc2ljYWxseSwgeW91IGFyZSBkZWZpbmluZ1xuICogdGhhdCBib3ggc2l6ZSBhbmQgdGVsbGluZyB0aGUgc2NlbmUtcmVuZGVyZXIgdG8gbmV2ZXIgY3JvcCB0aGF0IGltYWdlIChjb250YWluKS5cbiAqXG4gKiBTdGFydCB3aXRoIHRoZSBzaGFwZSB5b3Ugd2FudCB0byBkcmF3LiAgSWYgeW91IHNheSB3YW50ZWQgYVxuICogdGFsbCBpbWFnZSwgcGVyaGFwcyBpdCdzIGxpa2UgMTIwMHgxODAwIHBpeGVscy4gIFRyeSB1c2luZ1xuICogdGhvc2UgdmFsdWVzIGJ1dCByZWR1Y2luZyBpdCBieSBhIGZhY3RvciBvZiAxMDAwIChmb3IgZXhhbXBsZSkuXG4gKlxuICogc2NhbGVYOiAxMjAwIC8gMTAwMFxuICogc2NhbGVZOiAxODAwIC8gMTAwMFxuICpcbiAqIFRoZSBhY3R1YWwgdmFsdWVzIG9mIHNjYWxlWCBhbmQgc2NhbGVZIHdpbGwgZGVwZW5kIG9uIHlvdXIgc2NlbmVcbiAqIG9iamVjdCBzaXplcyBhbmQgd2hhdCB5b3UgbmVlZC4gIFdoYXQgc2NhbGVYIGFuZCBzY2FsZVkgZGVmaW5lXG4gKiBhcmUgdGhlIHJlbGF0aXZlIHNpemUgb2YgdGhlIGFyZWEgdGhhdCBzaG91bGQgYmUgY29udGFpbmVkLlxuICpcbiAqIEFzIGEgc2lkZSBub3RlIHlvdSBjYW4gYWxzbyBhY2hpZXZlIGEgcXVpY2sgXCJjb250YWluXCIgZWZmZWN0XG4gKiBieSB1c2luZyB0aGUgJ3Jlc2l6ZVdpdGhGb3YnIG9wdGlvbiBhbmQgcGFzc2luZyBhIHNpbmdsZSByZXNpemluZ1NjYWxhci5cbiAqXG4gKiB1c2VGb3ZcbiAqIEJ5IGRlZmF1bHQsIHNpemUgYWRqdXN0bWVudHMgYXJlIHBlcmZvcm1lZCBieSBjaGFuZ2luZyB0aGUgY2FtZXJhIHpvb20gbGV2ZWwuXG4gKiBUaGlzIGhhcyBhbiBhZGRlZCBiZW5lZml0IG9mIGNvcnJlY3RseSByZXNpemluZyB0ZXh0IGlmIHlvdSBhcmUgY2FsY3VsYXRpbmdcbiAqIHRleHQgc2NhbGUgdXNpbmcgdGhyZWVmLnRvRG9tQ29vcmRpbmF0ZXMgbWV0aG9kLiAgSXQgYWxzbyBkb2Vzbid0IHNrZXdcbiAqIHBlcnNwZWN0aXZlLlxuICpcbiAqIElmIHlvdSBkb24ndCB3YW50IHRvIGFkanVzdCB6b29tIGZvciBzb21lIHJlYXNvbiwgeW91IGNhbiBvcHQgdG8gY2hhbmdlXG4gKiBzY2VuZSBzaXplIGJ5IGFsdGVybmluZyB0aGUgdXNlRm92IHRvIGEgdHJ1ZSB2YWx1ZS4gIFRoaXMgd2lsbCBhZGp1c3QgdGhlXG4gKiBjYW1lcmEgRk9WIGFzIG5lZWRlZC4gIElmIHlvdXIgc2NlbmUgaXMgb3J0aG9ncmFwaGljIG9yIDJkIGJhc2VkLCB5b3Ugd29uJ3RcbiAqIHNlZSBhIGRpZmZlcmVuY2UgYnV0IGluIDNkIHNjZW5lIGl0IHdpbGwgYWx0ZXIgYW5kIHNrZXcgcGVyc3BlY3RpdmUuXG4gKlxuICogQWxpZ25tZW50IG9wdGlvbnM6XG4gKiBCeSBkZWZhdWx0LCB3aXRob3V0IGFueSBhbGlnbm1lbnQgb3B0aW9ucywgeW91ciBzY2VuZVxuICogd2lsbCBzY2FsZSBhdCBjZW50ZXIgLyBjZW50ZXIgcG9pbnQuICBIb3dldmVyLCB5b3VcbiAqIGNhbiBkZWZpbmUgaXQgc28gdGhhdCBpdCBzY2FsZXMgYWxpZ25lZCB0byB0b3AsIGJvdHRvbSxcbiAqIGxlZnQgb3IgcmlnaHQgc2ltaWxhciB0byBob3cgaXQgd291bGQgd29yayBpbiBjc3MuXG4gKlxuICogdG9wIC0gYSB2YWx1ZSBiZXR3ZWVuIDAtMSB0byBub3RlIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgZmluYWwgYm94XG4gKiBib3R0b20gLSBhIHZhbHVlIGJldHdlZW4gMC0xIHRvIG5vdGUgdGhlIHZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBmaW5hbCBib3hcbiAqIGxlZnQgLSBhIHZhbHVlIGJldHdlZW4gMC0xIHRvIG5vdGUgdGhlIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGZpbmFsIGJveFxuICogcmlnaHQgLSBhIHZhbHVlIGJldHdlZW4gMC0xIHRvIG5vdGUgdGhlIGhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGZpbmFsIGJveFxuICpcbiAqIHRvcCAvIGJvdHRvbSBjYW4ndCBleGlzdCB0b2dldGhlclxuICogbGVmdCAvIHJpZ2h0IGNhbid0IGV4aXN0IHRvZ2V0aGVyXG4gKlxuICogQW4gZXhhbXBsZSBvZiB1c2luZyAnY29udGFpbicgYWxnb1xuICpcbiAqIGBgYHRzXG4gKiAgdGhpcy5zY2VuZVJlbmRlcmVyLmFkZFNjZW5lKHtcbiAqICAgICAgLy8gVGhlIHJlc2l6aW5nIGFsZ28uXG4gKiAgICAgIHJlc2l6aW5nQWxnbzogJ2NvbnRhaW4nLFxuICogICAgICByZXNpemluZ09wdGlvbnM6IHtcbiAqICAgICAgICAgICB1c2VGb3Y6IGZhbHNlLCAvLyBXaGV0aGVyIHRvIHVzZSBGT1YgaW5zdGVhZCBvZiB6b29tXG4gKiAgICAgICAgICAgc2NhbGFyWDogMi42LFxuICogICAgICAgICAgIHNjYWxhclk6IDMuOCxcbiAqICAgICAgICAgICB0b3A6IDAgLy8gQWxpZ24gdGhpcyB0byB0aGUgdG9wXG4gKiAgICAgICAgICAgbGVmdDogMCAvLyBBbGlnbiB0aGlzIHRvIHRoZSBsZWZ0XG4gKiAgICAgIH0sXG4gKiAgICAgfSk7XG4gKiAgfSk7XG4gKiBgYGBcbiAqXG4gKlxuICogVXNpbmcgJ0NvdmVyJyBhbGdvXG4gKiBDb3ZlciB3b3JrcyBpbiBhIHZlcnkgc2ltaWxhciB3YXkgdG8gY29udGFpbiwgeW91IG5lZWQgdG8gc3BlY2lmeSB5b3VyXG4gKiBzY2FsYXJYIGFuZCBzY2FsYXJZIHZhbHVlcyB0byB0ZWxsIHNjZW5lLXJlbmRlcmVyIHRvIHJlc3BlY3QgdGhhdCBib3ggdG9cbiAqIGNhbGN1bGF0ZSB0aGUgY292ZXIgdmFsdWVzLiAgWW91IGNhbiBzcGVjaWZ5IHRvcCwgYm90dG9tLCBsZWZ0IGFuZCByaWdodFxuICogdmFsdWVzIHRvIGNvdmVyIHNjYWxlIGZyb20gdGhlIHNwZWNpZmljIGF4aXMuXG4gKlxuICogYGBgdHNcbiAqICB0aGlzLnNjZW5lUmVuZGVyZXIuYWRkU2NlbmUoe1xuICogICAgICAvLyBUaGUgcmVzaXppbmcgYWxnby5cbiAqICAgICAgcmVzaXppbmdBbGdvOiAnY292ZXInLFxuICogICAgICByZXNpemluZ09wdGlvbnM6IHtcbiAqICAgICAgICAgICB1c2VGb3Y6IGZhbHNlLCAvLyBXaGV0aGVyIHRvIHVzZSBGT1YgaW5zdGVhZCBvZiB6b29tXG4gKiAgICAgICAgICAgc2NhbGFyWDogMi42LFxuICogICAgICAgICAgIHNjYWxhclk6IDMuOCxcbiAqICAgICAgICAgICB0b3A6IDAgLy8gQWxpZ24gdGhpcyB0byB0aGUgdG9wXG4gKiAgICAgICAgICAgbGVmdDogMCAvLyBBbGlnbiB0aGlzIHRvIHRoZSBsZWZ0XG4gKiAgICAgIH0sXG4gKiAgICAgfSk7XG4gKiAgfSk7XG4gKlxuICpcbiAqIEFkdmFuY2VkIFJlc2l6aW5nXG4gKlxuICpcbiAqIEhlcmUgaXMgYW4gZXhhbXBsZSBvZiBjaGFuZ2luZyBzY2FsYXIgYW5kIGFzcGVjdCByYXRpbyxcbiAqIGJhc2VkIG9uIHlvdXIgbW9iaWxlIHZlcnN1cyBkZXNrdG9wIGxheW91dC5cbiAqXG4gKiBgYGB0c1xuICpcbiAqICBjb25zdCBzaXplU2NhbGFyID0gMC4yO1xuICogIHRoaXMuc2NlbmVSZW5kZXJlci5hZGRTY2VuZSh7XG4gKiAgICAgIC8vIFRoZSByZXNpemluZyBhbGdvLlxuICogICAgICByZXNpemluZ0FsZ286ICdjb3ZlcicsXG4gKiAgICAgIC8vIFJlcXVpcmVkIC0geW91IHNob3VsZCBkZWZpbmUgdGhlIHJlc2l6aW5nIG9wdGlvbnMuXG4gKiAgICAgIHJlc2l6aW5nT3B0aW9uczoge1xuICogICAgICAgICBzY2FsYXJYOiBudWxsLFxuICogICAgICAgICBzY2FsYXJZOiBudWxsLFxuICogICAgICAgICB0b3A6IG51bGwsXG4gKiAgICAgIH0sXG4gKiAgICAgIG9uQmVmb3JlUmVzaXplOiAocmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEpPT4ge1xuICogICAgICAgICBpZih3aW5kb3cuaW5uZXJXaWR0aCA8IDgwMCkge1xuICogICAgICAgICAgICAgc2NlbmUudXNlckRhdGEucmVzaXppbmdPcHRpb25zLnNjYWxhclggPSA0MDAgKiBzaXplU2NhbGFyO1xuICogICAgICAgICAgICAgc2NlbmUudXNlckRhdGEucmVzaXppbmdPcHRpb25zLnNjYWxhclkgPSA4MDAgKiBzaXplU2NhbGFyO1xuICogICAgICAgICAgICAgc2NlbmUudXNlckRhdGEucmVzaXppbmdPcHRpb25zLnRvcCA9IDA7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgICBzY2VuZS51c2VyRGF0YS5yZXNpemluZ09wdGlvbnMuc2NhbGFyWCA9IDE5MjAgKiBzaXplU2NhbGFyO1xuICogICAgICAgICAgICAgc2NlbmUudXNlckRhdGEucmVzaXppbmdPcHRpb25zLnNjYWxhclkgPSAxMDgwICogc2l6ZVNjYWxhcjtcbiAqICAgICAgICAgICAgIHNjZW5lLnVzZXJEYXRhLnJlc2l6aW5nT3B0aW9ucy50b3AgPSAwLjU7XG4gKiAgICAgICAgIH1cbiAqICAgICAgfSxcbiAqICAgICB9KTtcbiAqICB9KTtcbiAqXG4gKiBgYGBcbiAqXG4gKiAjIyMgQXBwbHlpbmcgRGVndSBTaGFkZXIgQ2h1bmtzXG4gKlxuICogWW91IGNhbiBhcHBseSBzaGFkZXIgY2h1bmtzIGFzIGZvbGxvd3M6XG4gKiBgYGBcbiAqaW1wb3J0IHtkZWd1U2hhcGUyZH0gZnJvbVxuICogJ2RlZ3UvbGliL3NoYWRlcnMvdGhyZWUtc2hhZGVyLWNodW5rcy9kZWd1LXNoYXBlMmQnO1xuICppbXBvcnQge2RlZ3VNYXRoZn0gZnJvbVxuICogJ2RlZ3UvbGliL3NoYWRlcnMvdGhyZWUtc2hhZGVyLWNodW5rcy9kZWd1LW1hdGhmJztcbiAqICAgLy8gQXBwbHkgc2hhZGVyIGNodW5rcy5cbiAqICAgZGVndU1hdGhmKHRoaXMuc2NlbmVSZW5kZXJlci5nZXRUaHJlZSgpKTtcbiAqICAgZGVndVNoYXBlMmQodGhpcy5zY2VuZVJlbmRlcmVyLmdldFRocmVlKCkpO1xuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICogQHNlZSBleGFtcGxlcy90aHJlZS1zY2VuZS1yZW5kZXJlcjIuaHRtbCBmb3IgZXhhbXBsZXMgb2YgdGhlIHJlc2l6aWduIHN0cmF0ZWdpZXMuXG4gKlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDE5MTkzNDEvaXMtdGhlcmUtYS1saW1pdC10by10aGUtbnVtYmVyLW9mLXRocmVlLXdlYmdscmVuZGVyZXItaW5zdGFuY2VzLWluLWEtcGFnZVxuICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMDYwODcyMy9pcy1pdC1wb3NzaWJsZS10by1lbmFibGUtdW5ib3VuZGVkLW51bWJlci1vZi1yZW5kZXJlcnMtaW4tdGhyZWUtanMvMzA2MzMxMzIjMzA2MzMxMzJcbiAqIEBzZWUgaHR0cHM6Ly90aHJlZWpzLm9yZy9leGFtcGxlcy93ZWJnbF9tdWx0aXBsZV9lbGVtZW50cy5odG1sXG4gKi9cbmNsYXNzIFNjZW5lUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxhc3Qga25vd24gcm9vdCBlbGVtZW50IHdpZHRoICh1c3VhbGx5IHdpbmRvdyBzaXplKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGFzdCBrbm93biByb290IGVsZW1lbnQgaGVpZ2h0ICh1c3VhbGx5IHdpbmRvdyBzaXplKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLndhdGNoZXIgPSBuZXcgZG9tX3dhdGNoZXJfMS5Eb21XYXRjaGVyKCk7XG4gICAgICAgIHRoaXMud2F0Y2hlci5hZGQoe1xuICAgICAgICAgICAgZWxlbWVudDogd2luZG93LFxuICAgICAgICAgICAgY2FsbGJhY2s6IHRoaXMub25SZXNpemUuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGV2ZW50T3B0aW9uczogeyBwYXNzaXZlOiB0cnVlIH0sXG4gICAgICAgICAgICBvbjogJ3NtYXJ0UmVzaXplJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXNlQWJzb2x1dGVQb3NpdGlvbmluZyA9ICEhY29uZmlnLnVzZUFic29sdXRlUG9zaXRpb25pbmc7XG4gICAgICAgIHRoaXMucm9vdEVsZW1lbnQgPSBjb25maWcucm9vdEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgdGhpcy5kcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICB0aGlzLnNjZW5lcyA9IFtdO1xuICAgICAgICAvLyBHZW5lcmF0ZSBjYW52YXMuXG4gICAgICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgaWYgKHRoaXMudXNlQWJzb2x1dGVQb3NpdGlvbmluZykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgIHRoaXMuc2V0WkluZGV4KHRoaXMuekluZGV4KTtcbiAgICAgICAgdGhpcy5yb290RWxlbWVudC5hcHBlbmQodGhpcy5jYW52YXMpO1xuICAgICAgICAvLyBJbml0aWFsIHJlbmRlcmVyIHNldHVwLlxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoY29uZmlnLnJlbmRlcmVyT3B0aW9ucyB8fCB7XG4gICAgICAgICAgICBjYW52YXM6IHRoaXMuY2FudmFzLFxuICAgICAgICAgICAgYW50aWFsaWFzOiB0cnVlLFxuICAgICAgICAgICAgYWxwaGE6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTZXQgdG8gdHJhbnNwYXJlbmN5LlxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHhmZmZmZmYsIDApO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFBpeGVsUmF0aW8odGhpcy5kcHIpO1xuICAgICAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFRIUkVFIG9iamVjdC5cbiAgICAgKi9cbiAgICBnZXRUaHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIFRIUkVFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgYSByZXNpemUgZXZlbnQgb24gdGhlIHNjZW5lLXJlbmRlcmVyLlxuICAgICAqL1xuICAgIHJlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHJlc2l6aW5nIGV2ZW50cy5cbiAgICAgKi9cbiAgICBvblJlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgdGhpcy5zY2VuZXMuZm9yRWFjaCgoc2NlbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzY2VuZS51c2VyRGF0YS5kb21FbGVtZW50O1xuICAgICAgICAgICAgc2NlbmUudXNlckRhdGEub25CZWZvcmVSZXNpemUgJiZcbiAgICAgICAgICAgICAgICBzY2VuZS51c2VyRGF0YS5vbkJlZm9yZVJlc2l6ZSh0aGlzLmdldFJlbmRlcmVyKCksIHNjZW5lLCBzY2VuZS51c2VyRGF0YS5jYW1lcmEpO1xuICAgICAgICAgICAgLy8gTm93IGZvciBlYWNoLCBmaWd1cmUgb3V0IHRoZSByaWdodCByZXNpemluZyBzdHJhdGVneS5cbiAgICAgICAgICAgIGNvbnN0IGNhbWVyYSA9IHNjZW5lLnVzZXJEYXRhLmNhbWVyYTtcbiAgICAgICAgICAgIGNvbnN0IGggPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHcgPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgY29uc3QgYXNwZWN0ID0gdyAvIGg7XG4gICAgICAgICAgICAvLyBDb250YWluIHpvb20gYWxnby5cbiAgICAgICAgICAgIGlmIChzY2VuZS51c2VyRGF0YS5yZXNpemluZ0FsZ28gPT09IFNjZW5lUmVzaXppbmdBbGdvLnJlc2l6ZVdpdGhab29tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGFyID0gc2NlbmUudXNlckRhdGEucmVzaXppbmdTY2FsYXIgfHwgMS4wO1xuICAgICAgICAgICAgICAgIGlmIChhc3BlY3QgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjYW1lcmEuem9vbSA9IGFzcGVjdCAqIHNjYWxhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbWVyYS56b29tID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FtZXJhLmFzcGVjdCA9IGFzcGVjdDtcbiAgICAgICAgICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RhbmRhcmQgQXNwZWN0IGFsZ29cbiAgICAgICAgICAgIGlmIChzY2VuZS51c2VyRGF0YS5yZXNpemluZ0FsZ28gPT09IFNjZW5lUmVzaXppbmdBbGdvLnN0YW5kYXJkQXNwZWN0KSB7XG4gICAgICAgICAgICAgICAgY2FtZXJhLmFzcGVjdCA9IGFzcGVjdDtcbiAgICAgICAgICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVzaXplIHdpdGggRk9WXG4gICAgICAgICAgICAvLyBVc2VzIHJlc2l6aW5nU2NhbGFyLlxuICAgICAgICAgICAgaWYgKHNjZW5lLnVzZXJEYXRhLnJlc2l6aW5nQWxnbyA9PT0gU2NlbmVSZXNpemluZ0FsZ28ucmVzaXplV2l0aEZvdikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBzY2VuZS51c2VyRGF0YS5yZXNpemluZ1NjYWxhciB8fCAxLjA7XG4gICAgICAgICAgICAgICAgY2FtZXJhLmZvdiA9IE1hdGguYXRhbihoIC8gMiAvIHopICogMiAqIFRIUkVFLk1hdGguUkFEMkRFRztcbiAgICAgICAgICAgICAgICBjYW1lcmEuYXNwZWN0ID0gYXNwZWN0O1xuICAgICAgICAgICAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBcIkNvbnRhaW5cIiAgQWxnby5cbiAgICAgICAgICAgIC8vIFVzZXMgcmVzaXppbmdPcHRpb25zXG4gICAgICAgICAgICBpZiAoc2NlbmUudXNlckRhdGEucmVzaXppbmdBbGdvID09PSBTY2VuZVJlc2l6aW5nQWxnby5jb250YWluKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzY2VuZS51c2VyRGF0YS5yZXNpemluZ09wdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAgICAgIXNjZW5lLnVzZXJEYXRhLnJlc2l6aW5nT3B0aW9ucy5zY2FsYXJYIHx8XG4gICAgICAgICAgICAgICAgICAgICFzY2VuZS51c2VyRGF0YS5yZXNpemluZ09wdGlvbnMuc2NhbGFyWSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3RlZCBjb250YWluIGFsZ28gd2l0aG91dCB0aGUgY29ycmVjdCByZXNpemluZyBvcHRpb25zJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZha2UgY29udGFpbi4gIENvbnRyb2wgdGhlIHgseSBzY2FsYXIgdmFsdWVzIHRvIGNvbnRyb2xcbiAgICAgICAgICAgICAgICAvLyByZXNpemUgcG9pbnRzLlxuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxhclggPSBzY2VuZS51c2VyRGF0YS5yZXNpemluZ09wdGlvbnMuc2NhbGFyWDtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsYXJZID0gc2NlbmUudXNlckRhdGEucmVzaXppbmdPcHRpb25zLnNjYWxhclk7XG4gICAgICAgICAgICAgICAgLy8gQmFzZWQgb24gdGhlIHByb3ZpZGVkIHNjYWxhcnMsIGltcGxlbWVudCBhIGJhc2ljXG4gICAgICAgICAgICAgICAgLy8gY29udGFpbiBhbGdvIGFkanVzdGluZyBGT1YuICBOb3cgdGhpcyBib3ggYXJlYSB3aWxsXG4gICAgICAgICAgICAgICAgLy8gYmUgY29udGFpbmVkLlxuICAgICAgICAgICAgICAgIGNvbnN0IGhGb3YgPSBNYXRoLmF0YW4oaCAvIDIgLyAodyAqIHNjYWxhclkpKSAqIDIgKiBUSFJFRS5NYXRoLlJBRDJERUc7XG4gICAgICAgICAgICAgICAgY29uc3QgdkZvdiA9IE1hdGguYXRhbihoIC8gMiAvIChoICogc2NhbGFyWCkpICogMiAqIFRIUkVFLk1hdGguUkFEMkRFRztcbiAgICAgICAgICAgICAgICBjb25zdCB2aXJ0dWFsRm92ID0gTWF0aC5tYXgodkZvdiwgaEZvdik7XG4gICAgICAgICAgICAgICAgLy8gVXNlIEZvdlxuICAgICAgICAgICAgICAgIGlmIChzY2VuZS51c2VyRGF0YS5yZXNpemluZ09wdGlvbnMudXNlRm92KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbWVyYS5mb3YgPSB2aXJ0dWFsRm92O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHpvb21cbiAgICAgICAgICAgICAgICAgICAgY2FtZXJhLnpvb20gPSBjYW1lcmEuZm92IC8gdmlydHVhbEZvdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB2aXJ0dWFsIGFzcGVjdCByYXRpby5cbiAgICAgICAgICAgICAgICBsZXQgdmlydHVhbEJveDtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXJ0dWFsQm94QXNwZWN0ID0gc2NhbGFyWSAvIHNjYWxhclg7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBDYW1lcmEgb2Zmc2V0cyBpbiBwaXhlbHMuXG4gICAgICAgICAgICAgICAgbGV0IHhPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCB5T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAvLyBPZmZzZXQgb3B0aW9uc1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSBzY2VuZS51c2VyRGF0YS5yZXNpemluZ09wdGlvbnMudG9wO1xuICAgICAgICAgICAgICAgIGxldCBib3R0b20gPSBzY2VuZS51c2VyRGF0YS5yZXNpemluZ09wdGlvbnMuYm90dG9tO1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gc2NlbmUudXNlckRhdGEucmVzaXppbmdPcHRpb25zLmxlZnQ7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0gc2NlbmUudXNlckRhdGEucmVzaXppbmdPcHRpb25zLnJpZ2h0O1xuICAgICAgICAgICAgICAgIC8vIFZlcnRpY2FsIG9mZnNldCBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoX18xLmlzLmRlZmluZWQodG9wKSB8fCBfXzEuaXMuZGVmaW5lZChib3R0b20pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHZpcnR1YWwgYm94IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBhc3BlY3RzLlxuICAgICAgICAgICAgICAgICAgICB2aXJ0dWFsQm94ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHcgKiB2aXJ0dWFsQm94QXNwZWN0LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmWSA9IE1hdGgubWF4KDAsIChoIC0gdmlydHVhbEJveC5oZWlnaHQpIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfXzEuaXMuZGVmaW5lZCh0b3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHRvcCB2YWx1ZSByYW5naW5nIGZyb20gMC0xIHdvdWxkIGFjdHVhbGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiZSBhbiBvZmZzZXQgZnJvbSB0aGUgdG9wIG9mIHRoZSBzY2VuZSB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHZlcnRpY2FsIGNlbnRlciBvZiB0aGUgc2NlbmUuICBJbiBvcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gbWFrZSB0aGlzIHdvcmsgbW9yZSBsaWtlIGEgdHJhZGl0aW9uYWwgY3NzIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlcmUgMCBpcyB0aGUgdG9wIGFuZCAxIGlzIGZ1bGx5IHB1dCB0aGUgYm91bmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJveCBhIHRoZSBib3R0b20sIHdlIGRvdWJsZSB0aGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgKj0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlPZmZzZXQgPSBkaWZmWSAqICgxIC0gdG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoX18xLmlzLmRlZmluZWQoYm90dG9tKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tICo9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB5T2Zmc2V0ID0gLWRpZmZZICogKDEgLSBib3R0b20pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgb2Zmc2V0IGNhbGN1bGF0aW9uc1xuICAgICAgICAgICAgICAgIGlmIChfXzEuaXMuZGVmaW5lZChsZWZ0KSB8fCBfXzEuaXMuZGVmaW5lZChyaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdmlydHVhbCBib3ggYmFzZWQgb24gdGhlIHByb3ZpZGVkIGFzcGVjdHMuXG4gICAgICAgICAgICAgICAgICAgIHZpcnR1YWxCb3ggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaCAvIHZpcnR1YWxCb3hBc3BlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZYID0gTWF0aC5tYXgoMCwgKHcgLSB2aXJ0dWFsQm94LndpZHRoKSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX18xLmlzLmRlZmluZWQobGVmdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgKj0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhPZmZzZXQgPSBkaWZmWCAqICgxIC0gbGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9fMS5pcy5kZWZpbmVkKHJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgKj0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhPZmZzZXQgPSAtZGlmZlggKiAoMSAtIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBcHBseSBjYW1lcmEgb2Zmc2V0c1xuICAgICAgICAgICAgICAgIGNhbWVyYS5zZXRWaWV3T2Zmc2V0KHcsIGgsIHhPZmZzZXQsIHlPZmZzZXQsIHcsIGgpO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjYW1lcmEgYXNwZWN0XG4gICAgICAgICAgICAgICAgY2FtZXJhLmFzcGVjdCA9IGFzcGVjdDtcbiAgICAgICAgICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gXCJDb3ZlclwiICBBbGdvLlxuICAgICAgICAgICAgLy8gVXNlcyByZXNpemluZ09wdGlvbnNcbiAgICAgICAgICAgIGlmIChzY2VuZS51c2VyRGF0YS5yZXNpemluZ0FsZ28gPT09IFNjZW5lUmVzaXppbmdBbGdvLmNvdmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzY2VuZS51c2VyRGF0YS5yZXNpemluZ09wdGlvbnMgfHxcbiAgICAgICAgICAgICAgICAgICAgIXNjZW5lLnVzZXJEYXRhLnJlc2l6aW5nT3B0aW9ucy5zY2FsYXJYIHx8XG4gICAgICAgICAgICAgICAgICAgICFzY2VuZS51c2VyRGF0YS5yZXNpemluZ09wdGlvbnMuc2NhbGFyWSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3RlZCBjb3ZlciBhbGdvIHdpdGhvdXQgdGhlIGNvcnJlY3QgcmVzaXppbmcgb3B0aW9ucycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsYXJYID0gc2NlbmUudXNlckRhdGEucmVzaXppbmdPcHRpb25zLnNjYWxhclg7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGFyWSA9IHNjZW5lLnVzZXJEYXRhLnJlc2l6aW5nT3B0aW9ucy5zY2FsYXJZO1xuICAgICAgICAgICAgICAgIGxldCB2aXJ0dWFsQm94O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpcnR1YWxCb3hBc3BlY3QgPSBzY2FsYXJZIC8gc2NhbGFyWDtcbiAgICAgICAgICAgICAgICAvLyBCYXNlZCBvbiB0aGUgcHJvdmlkZWQgc2NhbGFycywgaW1wbGVtZW50IGEgYmFzaWNcbiAgICAgICAgICAgICAgICAvLyBjb3ZlciBhbGdvIGFkanVzdGluZyBGT1YuICBOb3cgdGhpcyBib3ggYXJlYSB3aWxsXG4gICAgICAgICAgICAgICAgLy8gYmUgY292ZXIgd2l0aCBjZW50ZXIgLyBjZW50ZXIuXG4gICAgICAgICAgICAgICAgY29uc3QgaEZvdiA9IE1hdGguYXRhbihoIC8gMiAvICh3ICogc2NhbGFyWSkpICogMiAqIFRIUkVFLk1hdGguUkFEMkRFRztcbiAgICAgICAgICAgICAgICBjb25zdCB2Rm92ID0gTWF0aC5hdGFuKGggLyAyIC8gKGggKiBzY2FsYXJYKSkgKiAyICogVEhSRUUuTWF0aC5SQUQyREVHO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpcnR1YWxGb3YgPSBNYXRoLm1pbih2Rm92LCBoRm92KTtcbiAgICAgICAgICAgICAgICAvLyBVc2UgRm92XG4gICAgICAgICAgICAgICAgaWYgKHNjZW5lLnVzZXJEYXRhLnJlc2l6aW5nT3B0aW9ucy51c2VGb3YpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FtZXJhLmZvdiA9IHZpcnR1YWxGb3Y7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2Ugem9vbVxuICAgICAgICAgICAgICAgICAgICBjYW1lcmEuem9vbSA9IGNhbWVyYS5mb3YgLyB2aXJ0dWFsRm92O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPZmZzZXQgb3B0aW9uc1xuICAgICAgICAgICAgICAgIGxldCB4T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgeU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHRvcCA9IHNjZW5lLnVzZXJEYXRhLnJlc2l6aW5nT3B0aW9ucy50b3A7XG4gICAgICAgICAgICAgICAgbGV0IGJvdHRvbSA9IHNjZW5lLnVzZXJEYXRhLnJlc2l6aW5nT3B0aW9ucy5ib3R0b207XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQgPSBzY2VuZS51c2VyRGF0YS5yZXNpemluZ09wdGlvbnMubGVmdDtcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSBzY2VuZS51c2VyRGF0YS5yZXNpemluZ09wdGlvbnMucmlnaHQ7XG4gICAgICAgICAgICAgICAgLy8gVmVydGljYWwgb2Zmc2V0IGNhbGN1bGF0aW9uc1xuICAgICAgICAgICAgICAgIGlmIChfXzEuaXMuZGVmaW5lZCh0b3ApIHx8IF9fMS5pcy5kZWZpbmVkKGJvdHRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdmlydHVhbCBib3ggYmFzZWQgb24gdGhlIHByb3ZpZGVkIGFzcGVjdHMuXG4gICAgICAgICAgICAgICAgICAgIHZpcnR1YWxCb3ggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaCAvIHZpcnR1YWxCb3hBc3BlY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYXBwcm94aW1hdGUgdmlydXRhbCBib3ggY292ZXIgYm94IHNjYWxlLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3ZlckJveCA9IF9fMS5tYXRoZi5jYWxjdWxhdGVCYWNrZ3JvdW5kQ292ZXIoeyB3aWR0aDogdywgaGVpZ2h0OiBoIH0sIHZpcnR1YWxCb3gpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmWSA9IE1hdGgubWF4KDAsIChjb3ZlckJveC5oZWlnaHQgLSBoKSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX18xLmlzLmRlZmluZWQodG9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wICo9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB5T2Zmc2V0ID0gLWRpZmZZICogKDEgLSB0b3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfXzEuaXMuZGVmaW5lZChib3R0b20pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gKj0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlPZmZzZXQgPSBkaWZmWSAqICgxIC0gYm90dG9tKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIb3Jpem9udGFsIG9mZnNldCBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoX18xLmlzLmRlZmluZWQobGVmdCkgfHwgX18xLmlzLmRlZmluZWQocmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHZpcnR1YWwgYm94IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBhc3BlY3RzLlxuICAgICAgICAgICAgICAgICAgICB2aXJ0dWFsQm94ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHcgKiB2aXJ0dWFsQm94QXNwZWN0LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3ZlckJveCA9IF9fMS5tYXRoZi5jYWxjdWxhdGVCYWNrZ3JvdW5kQ292ZXIoeyB3aWR0aDogdywgaGVpZ2h0OiBoIH0sIHZpcnR1YWxCb3gpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmWCA9IE1hdGgubWF4KDAsIChjb3ZlckJveC53aWR0aCAtIHcpIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfXzEuaXMuZGVmaW5lZChsZWZ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCAqPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgeE9mZnNldCA9IC1kaWZmWCAqICgxIC0gbGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9fMS5pcy5kZWZpbmVkKHJpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgKj0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhPZmZzZXQgPSBkaWZmWCAqICgxIC0gcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbWVyYS5zZXRWaWV3T2Zmc2V0KHcsIGgsIHhPZmZzZXQsIHlPZmZzZXQsIHcsIGgpO1xuICAgICAgICAgICAgICAgIGNhbWVyYS5hc3BlY3QgPSBhc3BlY3Q7XG4gICAgICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjZW5lLnVzZXJEYXRhLm9uUmVzaXplICYmXG4gICAgICAgICAgICAgICAgc2NlbmUudXNlckRhdGEub25SZXNpemUodGhpcy5nZXRSZW5kZXJlcigpLCBzY2VuZSwgc2NlbmUudXNlckRhdGEuY2FtZXJhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHotaW5kZXggb2YgdGhlIG1haW4gcmVuZGVyZXIgY2FudmFzLlxuICAgICAqL1xuICAgIHNldFpJbmRleCh6SW5kZXgpIHtcbiAgICAgICAgdGhpcy56SW5kZXggPSB6SW5kZXg7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleCA9IHRoaXMuekluZGV4ICsgJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhc3Qga25vd24gc2l6ZSBvZiByb290IGNhbnZhcy4gIFVzdWFsbHkgdGhpcyBpcyB1c3VhbGx5IHRoZSB3aW5kb3cgc2l6ZVxuICAgICAqIHNpbmNlIHRoZSBtYWluIHJlbmRlcmVyIGNhbnZhcyBjb3ZlcnMgdGhlIHdob2xlIHBhZ2UuXG4gICAgICovXG4gICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIGFzcGVjdDogdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBUSFJFRS5TY2VuZSB0byBiZSByZW5kZXJlZCB3aGVuIHRoZSBnaXZlbiBkb21FbGVtZW50IGlzIHZpc2libGVcbiAgICAgKiBpbiB0aGUgc2NlbmUuXG4gICAgICovXG4gICAgYWRkU2NlbmUoc2NlbmVDb25maWcsIGZvcmNlUmVzaXplID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFzY2VuZUNvbmZpZy5kb21FbGVtZW50IHx8ICFzY2VuZUNvbmZpZy5zY2VuZSB8fCAhc2NlbmVDb25maWcuY2FtZXJhKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1NjZW5lUmVuZGVyZXIgY291bGQgbm90IHJlZ2lzdGVyIHNjZW5lLiAgSXQgaXMgbWlzc2luZyBlaXRoZXIgdGhlIHNjZW5lLCBjYW1lcmUgb3IgZG9tRWxlbWVudCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjZW5lID0gc2NlbmVDb25maWcuc2NlbmU7XG4gICAgICAgIGlmIChzY2VuZUNvbmZpZy5kZWJ1Zykge1xuICAgICAgICAgICAgdGhpcy5zZXR1cERlYnVnZ2luZyhzY2VuZUNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSBzY2VuZSBjb25maWcgZGF0YSB0byB0aGUgc2NlbmUuXG4gICAgICAgIHNjZW5lLnVzZXJEYXRhID0gc2NlbmVDb25maWc7XG4gICAgICAgIC8vIEFkZCBldiB0byBhYmxlIHRvIGxhdGVyIGNoZWNrIGlmIHRoZSBhc3NvY2lhdGVkIGRvbUVsZW1lbnQgaXMgdmlzaWJsZVxuICAgICAgICAvLyBpbiB0aGUgdmlld3BvcnQuXG4gICAgICAgIHNjZW5lLnVzZXJEYXRhLmV2ID0gZWxlbWVudF92aXNpYmlsaXR5XzEuZWxlbWVudFZpc2liaWxpdHkuaW52aWV3KHNjZW5lQ29uZmlnLmRvbUVsZW1lbnQpO1xuICAgICAgICB0aGlzLnNjZW5lcy5wdXNoKHNjZW5lKTtcbiAgICAgICAgLy8gUnVuIGluaXQuXG4gICAgICAgIHNjZW5lLnVzZXJEYXRhLm9uSW5pdCAmJlxuICAgICAgICAgICAgc2NlbmUudXNlckRhdGEub25Jbml0KHRoaXMuZ2V0UmVuZGVyZXIoKSwgc2NlbmUsIHNjZW5lLnVzZXJEYXRhLmNhbWVyYSk7XG4gICAgICAgIGlmIChmb3JjZVJlc2l6ZSkge1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGRlYnVnZ2luZyB2aWEgR1VJRi5cbiAgICAgKiBAcGFyYW0gc2NlbmVcbiAgICAgKi9cbiAgICBzZXR1cERlYnVnZ2luZyhzY2VuZUNvbmZpZykge1xuICAgICAgICBjb25zdCBzY2VuZSA9IHNjZW5lQ29uZmlnLnNjZW5lO1xuICAgICAgICBjb25zdCBheGVzSGVscGVyID0gbmV3IFRIUkVFLkF4ZXNIZWxwZXIoNTApO1xuICAgICAgICBzY2VuZS5hZGQoYXhlc0hlbHBlcik7XG4gICAgICAgIG5ldyB0aHJlZV9pbnNwZWN0b3JfMS5UaHJlZUluc3BlY3RvcihzY2VuZUNvbmZpZy5kb21FbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW50ZXJuYWwgd2ViR0xSZW5kZXJlci5cbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgb3V0IGVhY2ggc2NlbmUuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvLyBTZWUgbm90ZSBvbjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzA2MDg3MjMvaXMtaXQtcG9zc2libGUtdG8tZW5hYmxlLXVuYm91bmRlZC1udW1iZXItb2YtcmVuZGVyZXJzLWluLXRocmVlLWpzLzMwNjMzMTMyIzMwNjMzMTMyXG4gICAgICAgIC8vIFJhdGhlciB0aGFuIHVzaW5nIGZpeGVkLCB0aGlzIGtlZXBzIHRoZSBjYW52YXMgaW4gc3luYy5cbiAgICAgICAgaWYgKHRoaXMudXNlQWJzb2x1dGVQb3NpdGlvbmluZykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoJHt3aW5kb3cuc2Nyb2xsWX1weClgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2Npc3NvclRlc3QoZmFsc2UpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2Npc3NvclRlc3QodHJ1ZSk7XG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBzY2VuZSBhbmQgaXQncyBwb3NpdGlvbiBhbmQgcmVuZGVyIGl0IG91dCBpblxuICAgICAgICAvLyBwaWVjZXMuXG4gICAgICAgIHRoaXMuc2NlbmVzLmZvckVhY2goKHNjZW5lKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2NlbmUgaXMgb3V0IG9mIHZpZXcsIGN1bGwuXG4gICAgICAgICAgICBpZiAoIXNjZW5lLnVzZXJEYXRhLmV2LnN0YXRlKCkuaW52aWV3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHNjZW5lLnVzZXJEYXRhLmRvbUVsZW1lbnQ7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGVsZW1lbnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHBhZ2UncyB2aWV3cG9ydFxuICAgICAgICAgICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHJlY3QubGVmdDtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudC5jbGllbnRIZWlnaHQgLSByZWN0LmJvdHRvbTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0Vmlld3BvcnQobGVmdCwgYm90dG9tLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2Npc3NvcihsZWZ0LCBib3R0b20sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgc2NlbmUudXNlckRhdGEub25CZWZvcmVSZW5kZXIgJiZcbiAgICAgICAgICAgICAgICBzY2VuZS51c2VyRGF0YS5vbkJlZm9yZVJlbmRlcih0aGlzLmdldFJlbmRlcmVyKCksIHNjZW5lLCBzY2VuZS51c2VyRGF0YS5jYW1lcmEpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIoc2NlbmUsIHNjZW5lLnVzZXJEYXRhLmNhbWVyYSk7XG4gICAgICAgICAgICBzY2VuZS51c2VyRGF0YS5vbkFmdGVyUmVuZGVyICYmXG4gICAgICAgICAgICAgICAgc2NlbmUudXNlckRhdGEub25BZnRlclJlbmRlcih0aGlzLmdldFJlbmRlcmVyKCksIHNjZW5lLCBzY2VuZS51c2VyRGF0YS5jYW1lcmEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBDbGVhbiB1cCBzY2VuZXMuXG4gICAgICAgIHRoaXMuc2NlbmVzLmZvckVhY2goKHNjZW5lKSA9PiB7XG4gICAgICAgICAgICAvLyBEaXNwb3NlIGVsZW1lbnQgdmlzaWJsaXR5LlxuICAgICAgICAgICAgc2NlbmUudXNlckRhdGEuZXYuZGlzcG9zZSgpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGRvbSBhc3NvY2lhdGlvbi5cbiAgICAgICAgICAgIHNjZW5lLnVzZXJEYXRhLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgc2NlbmUudXNlckRhdGEub25EaXNwb3NlICYmIHNjZW5lLnVzZXJEYXRhLm9uRGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVtb3ZlIGNhbnZhcyBmcm9tIHJvb3RFbGVtZW50LlxuICAgICAgICAoX2EgPSB0aGlzLmNhbnZhcy5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NlbmVSZW5kZXJlciA9IFNjZW5lUmVuZGVyZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2VuZS1yZW5kZXJlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/threef/scene-renderer.js\n");

/***/ }),

/***/ "./lib/threef/three-inspector.js":
/*!***************************************!*\
  !*** ./lib/threef/three-inspector.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ThreeInspector = void 0;\nconst datguif_1 = __webpack_require__(/*! ../datguif/datguif */ \"./lib/datguif/datguif.js\");\n/**\n * A class that setups guif with a three.js scene.\n */\nclass ThreeInspector {\n    constructor(element) {\n        console.log('setting up new GUI');\n        // Setup GUIF.\n        const gui = new datguif_1.Datguif({\n            load: JSON,\n            autoPlace: false,\n        });\n        element.appendChild(gui.getGui().domElement);\n        gui.addFolder('Renderer', 'Settings');\n        // gui.addFolder('Camera', 'Settings');\n        // gui.addObjectToFolder(\n        //     'Camera',\n        //     camera,\n        //     [\n        //         { keyName: 'fov', min: 0, max: 50, step: 0.01, callback: ()=> {\n        //             camera.updateProjectionMatrix();\n        //         } },\n        //         { keyName: 'zoom', min: 0, max: 10, step: 0.0001, callback: ()=> {\n        //             camera.updateProjectionMatrix();\n        //         } },\n        //     ]\n        // );\n        gui.addFolder('Objects');\n    }\n}\nexports.ThreeInspector = ThreeInspector;\n//# sourceMappingURL=three-inspector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvdGhyZWVmL3RocmVlLWluc3BlY3Rvci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi90aHJlZWYvdGhyZWUtaW5zcGVjdG9yLmpzP2MxOTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRocmVlSW5zcGVjdG9yID0gdm9pZCAwO1xuY29uc3QgZGF0Z3VpZl8xID0gcmVxdWlyZShcIi4uL2RhdGd1aWYvZGF0Z3VpZlwiKTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IHNldHVwcyBndWlmIHdpdGggYSB0aHJlZS5qcyBzY2VuZS5cbiAqL1xuY2xhc3MgVGhyZWVJbnNwZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3NldHRpbmcgdXAgbmV3IEdVSScpO1xuICAgICAgICAvLyBTZXR1cCBHVUlGLlxuICAgICAgICBjb25zdCBndWkgPSBuZXcgZGF0Z3VpZl8xLkRhdGd1aWYoe1xuICAgICAgICAgICAgbG9hZDogSlNPTixcbiAgICAgICAgICAgIGF1dG9QbGFjZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGd1aS5nZXRHdWkoKS5kb21FbGVtZW50KTtcbiAgICAgICAgZ3VpLmFkZEZvbGRlcignUmVuZGVyZXInLCAnU2V0dGluZ3MnKTtcbiAgICAgICAgLy8gZ3VpLmFkZEZvbGRlcignQ2FtZXJhJywgJ1NldHRpbmdzJyk7XG4gICAgICAgIC8vIGd1aS5hZGRPYmplY3RUb0ZvbGRlcihcbiAgICAgICAgLy8gICAgICdDYW1lcmEnLFxuICAgICAgICAvLyAgICAgY2FtZXJhLFxuICAgICAgICAvLyAgICAgW1xuICAgICAgICAvLyAgICAgICAgIHsga2V5TmFtZTogJ2ZvdicsIG1pbjogMCwgbWF4OiA1MCwgc3RlcDogMC4wMSwgY2FsbGJhY2s6ICgpPT4ge1xuICAgICAgICAvLyAgICAgICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICAvLyAgICAgICAgIH0gfSxcbiAgICAgICAgLy8gICAgICAgICB7IGtleU5hbWU6ICd6b29tJywgbWluOiAwLCBtYXg6IDEwLCBzdGVwOiAwLjAwMDEsIGNhbGxiYWNrOiAoKT0+IHtcbiAgICAgICAgLy8gICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgLy8gICAgICAgICB9IH0sXG4gICAgICAgIC8vICAgICBdXG4gICAgICAgIC8vICk7XG4gICAgICAgIGd1aS5hZGRGb2xkZXIoJ09iamVjdHMnKTtcbiAgICB9XG59XG5leHBvcnRzLlRocmVlSW5zcGVjdG9yID0gVGhyZWVJbnNwZWN0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJlZS1pbnNwZWN0b3IuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/threef/three-inspector.js\n");

/***/ }),

/***/ "./lib/threef/threef.js":
/*!******************************!*\
  !*** ./lib/threef/threef.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.threef = void 0;\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst THREE = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst __1 = __webpack_require__(/*! .. */ \"./lib/index.js\");\nconst defer_1 = __webpack_require__(/*! ../func/defer */ \"./lib/func/defer.js\");\n/**\n * A bunch of util for three.js\n */\nclass threef {\n    /**\n     * GLTF + Animation Marker Export loader.\n     *\n     * Loads the gltf file and also the associated animation marker\n     * export and appends it to the gltf object.\n     *\n     * ```\n     * import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\n     * import {DRACOLoader} from 'three/examples/jsm/loaders/DRACOLoader';\n     *\n     *   // Create instance of three glft loader.\n     *   const gltfLoader = new GLTFLoader();\n     *\n     *   // Optional: Provide a DRACOLoader instance to decode compressed mesh data\n     *   var dracoLoader = new THREE.DRACOLoader();\n     *   dracoLoader.setDecoderPath( '/examples/js/libs/draco/' );\n     *   gltfLoader.setDRACOLoader( dracoLoader );\n     *\n     *\n     *   threef.load({\n     *     gltfPath: 'public/dev/gltf/test1.gltf',\n     *     // Optional animation marker path.\n     *     animationMarkerPath: 'public/dev/gltf/test1.gltf',\n     *     gltfLoader: gltfLoader\n     *   }).then((gltf) => {\n     *       // gltf.animationMarkers is available.\n     *       // Everything else works the same as the three gltf loader.\n     *   });\n     *\n     *   // Call again to load something else with the same loader.\n     *   threef.load({\n     *     gltfPath: 'public/dev/gltf/test2.gltf',\n     *     animationMarkerPath: 'public/dev/gltf/test2.gltf',\n     *     gltfLoader: gltfLoader\n     *   }).then((gltf) => {\n     *       // gltf.animationMarkers is available.\n     *       // Everything else works the same as the three gltf loader.\n     *   });\n     * ```\n     *\n     * @see https://threejs.org/docs/#examples/en/loaders/GLTFLoader\n     * @see https://github.com/mrdoob/three.js/tree/dev/examples/js/libs/draco#readme\n     */\n    static loadGltf(config) {\n        const defer = new defer_1.Defer();\n        // Start loading gltf.\n        let gltfData = {};\n        const gltfFetch = new Promise(resolve => {\n            config.gltfLoader.load(config.gltfPath, (gltf) => {\n                gltfData = gltf;\n                resolve({});\n            });\n        });\n        let animationMarkerData = {};\n        const markerFetch = new Promise(resolve => {\n            if (!config.animationMarkerPath) {\n                animationMarkerData = {};\n                resolve({});\n            }\n            else {\n                // Load the animation export\n                fetch(config.animationMarkerPath)\n                    .then(response => {\n                    return response.json();\n                })\n                    .then((markerData) => {\n                    animationMarkerData = markerData;\n                    resolve({});\n                });\n            }\n        });\n        // Merge out the data.\n        Promise.all([gltfFetch, markerFetch]).then(() => {\n            gltfData['animationMarkers'] = animationMarkerData;\n            defer.resolve(gltfData);\n        });\n        return defer.getPromise();\n    }\n    /**\n     * Given a three.js Mesh / Object3d, calculates the current position and maps that to the\n     * DOM x, y, z position and considers camera position.\n     *\n     * The returning x,y values are in pixels.\n     * x / canvasWidth or y / canvasHeight would give you the percentage values.\n     *\n     * @see three-object-viewer11.html for examples and also three-object-viewer11.blend\n     *\n     * @param object The three.js object to base the position off of.\n     * @param camera The currently active camera.\n     * @param width The canvas width\n     * @param height The canvas width\n     * @param scalar? An optional scalar value.  You can pass a value like 1 to tell\n     *   the dom element to scale along with the camera movement.  We can't do this\n     *   automatically, since we have no reference to what scale 1 should be\n     *   when the camera is a certain distance from the object.\n     *\n     *\n     * Inspired by:\n     * - https://ics.media/tutorial-three/position_project/\n     * - https://threejsfundamentals.org/threejs/lessons/threejs-align-html-elements-to-3d.html\n     * - https://stackoverflow.com/questions/27409074/converting-3d-position-to-2d-screen-position-r69\n     * - https://stackoverflow.com/questions/46667395/three-js-vector3-to-2d-screen-coordinate-with-rotated-scene\n     * - https://gist.github.com/ChiChou/a671a0bbe514364255f9\n     * - https://github.com/mrdoob/three.js/blob/master/examples/js/renderers/CSS3DRenderer.js#L6-L31\n     * - https://github.com/mrdoob/three.js/blob/master/examples/js/renderers/CSS3DRenderer.js#L254\n     */\n    static toDomCoordinates(object, camera, width, height, scalar) {\n        const v = new THREE.Vector3();\n        // Get the position of the center of the object.\n        object.updateWorldMatrix(true, false);\n        object.getWorldPosition(v);\n        // Convert -1 - 1 world space to dom based 0-1 range.\n        // Get the normalized screen coordinate of that position\n        // x and y will be in the -1 to +1 range with x = -1 being\n        // on the left and y = -1 being on the bottom\n        v.project(camera);\n        const x = (v.x * 0.5 + 0.5) * width;\n        const y = (v.y * -0.5 + 0.5) * height;\n        let z = 1;\n        if (__1.is.defined(scalar)) {\n            // Since the canvas scales based on height, use that as the basis.\n            z = (v.z * -0.5 + 0.5) * height;\n            z *= scalar;\n            z *= camera.zoom || 1.0;\n        }\n        return new THREE.Vector3(x, y, z);\n    }\n    /**\n     * Converts a Three local Vec3 position to exact screen coordinates.\n     * @param position\n     * @param camera\n     * @param width\n     * @param height\n     */\n    static toScreenXY(position, camera, width, height) {\n        const pos = position.clone();\n        const mat4 = new THREE.Matrix4();\n        mat4.multiply(camera.projectionMatrix);\n        mat4.multiply(camera.matrixWorldInverse);\n        // mat4.multiplyVector3(pos);\n        pos.applyMatrix4(mat4);\n        return {\n            x: ((pos.x + 1) * width) / 2,\n            y: ((-pos.y + 1) * height) / 2,\n            z: pos.z,\n        };\n    }\n    /**\n     * Gets the bounding rect in pixel values of a given object.\n     * This basically, allows you to calculate the width / height of a given\n     * object in screen space.  It will also get you x,y coordinates of the bounding\n     * box around your object.\n     *\n     * Imagine a cube on your screen\n     * and you want to know the pixel width and height it occupies on the screen.\n     * This makes sense if you are looking head on but what happens if the\n     * camera is at an angle or the object is rotated.\n     * Or you might want the approximate width and height of a sphere or\n     * actual screen height and width of a human model when the camera is looking from a\n     * top angle.\n     *\n     * This method will allow you to do that.\n     *\n     * It will start by drawing a Box3d cube (boundingBox) around the object.\n     * It will then convert the Box3d into a square of 2d coordinate.\n     * Using that square, it will then calculate the screenXY coordinates of each\n     * corner of the cube.\n     * It will then calculate the width and height this object occupies on\n     * the screen based on these values.\n     *\n     *\n     * If working on this method, since calculations can be involved, it is helpful\n     * to pass in the current working scene to debug the corners.\n     * ```\n     *\n     * const box = three.toDomBoudingRect(\n     *   myObject, camera, canvas.offsetWidth, canvas.offsetHeight,\n     *   {\n     *     scalar: 1, // For z scaling factor\n     *     scene: scene, // Pass in your scene to debug the corner.\n     *   }\n     * )\n     *\n     * box.width --> The pixel width on the screen.\n     * box.height --> The pixel height on the screen.\n     * box.topLeft --> The top left corner of the bounding box.\n     *\n     * ```\n     *\n     */\n    static toDomBoundingRect(object, camera, width, height, options) {\n        const box = new THREE.Box3().setFromObject(object);\n        // Get box corners.\n        const corners = {\n            '000': {\n                color: 0xffffff,\n                vec: new THREE.Vector3().set(box.min.x, box.min.y, box.min.z), // 000\n            },\n            '001': {\n                color: 0x0fff00,\n                vec: new THREE.Vector3().set(box.min.x, box.min.y, box.max.z), // 001\n            },\n            '010': {\n                color: 0xff00f7,\n                vec: new THREE.Vector3().set(box.min.x, box.max.y, box.min.z), // 010\n            },\n            '011': {\n                color: 0x9d9d9d,\n                vec: new THREE.Vector3().set(box.min.x, box.max.y, box.max.z), // 011\n            },\n            '100': {\n                color: 0x003eff,\n                vec: new THREE.Vector3().set(box.max.x, box.min.y, box.min.z), // 100\n            },\n            '101': {\n                color: 0xf3ff00,\n                vec: new THREE.Vector3().set(box.max.x, box.min.y, box.max.z), // 101\n            },\n            '110': {\n                color: 0xff0000,\n                vec: new THREE.Vector3().set(box.max.x, box.max.y, box.min.z), // 110\n            },\n            '111': {\n                color: 0x000000,\n                vec: new THREE.Vector3().set(box.max.x, box.max.y, box.max.z), // 111\n            },\n        };\n        // Generate an array of the XY screen coordinate of every single corner\n        // of the box3d.\n        const cornerPositions = [];\n        for (const key of Object.keys(corners)) {\n            const corner = corners[key];\n            const xy = threef.toScreenXY(corner.vec, camera, width, height);\n            cornerPositions.push(xy);\n        }\n        const center = threef.toScreenXY(object.position, camera, width, height);\n        // console.log(object.position, camera);\n        const xs = cornerPositions.map(xy => {\n            return xy.x;\n        });\n        const ys = cornerPositions.map(xy => {\n            return xy.y;\n        });\n        const scene = options && options.scene;\n        const scalar = options && options.scalar;\n        // This is our virtual 2d square from the 3d cube.  This is a square\n        // drawn over the box3d bounding box, representing the space\n        // this object takes up on the screen.\n        const minX = Math.min(...xs);\n        const maxX = Math.max(...xs);\n        const minY = Math.min(...ys);\n        const maxY = Math.max(...ys);\n        // Based on there, we can calculate the size.\n        const finalSize = {\n            width: maxX - minX,\n            height: maxY - minY,\n        };\n        // Calculate relative depth (z)\n        let z = 1;\n        if (scalar) {\n            const v = new THREE.Vector3();\n            object.updateWorldMatrix(true, false);\n            object.getWorldPosition(v);\n            v.project(camera);\n            // Since the canvas scales based on height, use that as the basis.\n            z = (v.z * -0.5 + 0.5) * height;\n            z *= scalar;\n            z *= camera['zoom'] || 1.0;\n        }\n        // Calcualte the corners of the box from top left clockwise.\n        center.z = z;\n        const corner1 = new THREE.Vector3(minX, minY, z);\n        const corner2 = new THREE.Vector3(maxX, minY, z);\n        const corner3 = new THREE.Vector3(minX, maxY, z);\n        const corner4 = new THREE.Vector3(minX, maxY, z);\n        // If a scene has been passed, add\n        if (scene) {\n            object.visible = false;\n            // TODO (uxder): This doesn't exist on mesh according to docs.\n            // Need to investigate if we can just remove this.\n            object['alwaysInvisible'] = true;\n            for (const key of Object.keys(corners)) {\n                const corner = corners[key];\n                const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);\n                const material = new THREE.MeshBasicMaterial({ color: corner.color });\n                const cube = new THREE.Mesh(geometry, material);\n                cube.position.set(corner.vec.x, corner.vec.y, corner.vec.z);\n                scene.add(cube);\n            }\n        }\n        return {\n            topLeft: corner1,\n            topRight: corner2,\n            center: center,\n            bottomLeft: corner3,\n            bottomRight: corner4,\n            width: finalSize.width,\n            height: finalSize.height,\n        };\n    }\n    /**\n     * Converts from the blender coordinate system over to three (XYZ).\n     * This assumes that within blender, you are using the XYZ Euler rotation\n     * settings.\n     *\n     * If your settings are off, it's likely the object your exported\n     * has rotations.  Select your object to Apply -> Rotation & Scale\n     * in blender.\n     *\n     * Example:\n     * ```\n     *  threef.blenderToThreeCoordinates({\n     *     x: mathf.degreeToRadian(51.9),\n     *     y: mathf.degreeToRadian(192),\n     *     z: mathf.degreeToRadian(200)\n     * }),\n     * ```\n     * @param object Object contains x,y,z\n     */\n    static blenderToThreeEuler(euler) {\n        return {\n            x: -euler.x,\n            y: euler.z,\n            z: -euler.y,\n        };\n    }\n    /**\n     * Converts blender coords to three.js\n     * ```\n     * targetPosition = threef.blenderToThreeVec3({\n     *   // Specify in blender coords\n     *   x: 0,\n     *   y: 0,\n     *   z: 1.0,\n     * });\n     *\n     * ```\n     * @param vec3\n     */\n    static blenderToThreeVec3(vec3) {\n        return {\n            x: -vec3.x,\n            y: vec3.z,\n            z: -vec3.y,\n        };\n    }\n    /**\n     * Given a three.js object, calculates the euler rotation over to values that can\n     * be applied via css.  Note this return euler rotations in radians (THREE.Euler).\n     * @param object\n     * @param camera\n     * @param width\n     * @param height\n     */\n    static toDomRotation(object, camera) {\n        // Get the local transform values.\n        const q = new THREE.Quaternion();\n        // object.updateWorldMatrix(true, false);\n        object.getWorldQuaternion(q);\n        // Convert coordinate system.\n        q.x = -q.x;\n        q.z = -q.z;\n        // Get the camera rotation (world)\n        const cq = new THREE.Quaternion();\n        // camera.updateWorldMatrix(true, false);\n        camera.getWorldQuaternion(cq);\n        // Convert coordinate system.\n        cq.y = -cq.y;\n        // Combine the camera and object rotation\n        cq.multiply(q);\n        const euler = new THREE.Euler();\n        euler.setFromQuaternion(cq.normalize());\n        //   Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n        // euler.reorder(\"ZYX\")\n        return euler;\n    }\n    /**\n     * Gets the visible height at a specific depth given a three.js camera.\n     *\n     * Example:\n     * You have a 100x100x100 cube and want to know the \"pixel\" size it is\n     * rendered at when it's at a depth of 200.\n     * ```\n     * // Add 50 to account for size from the center of cube.\n     * const depth = (cube.position.z + 50) - camera.position.z;\n     *\n     * const visibleSize = threef.getVisibleHeightAndWidthAtDepth(depth, camera);\n     *\n     * // So relative to the height, how much does the cube take up.\n     * const heightScalar = 100 / visibleSize.height;\n     *\n     * // Now normalize that to the size in pixels.\n     * const heightInPixels = canvasSize.height * heightScalar;\n     * ```\n     * @untested\n     * @experimental\n     * @dontuse\n     * @hidden\n     */\n    /*\n      static getVisibleHeightAndWidthAtDepth(distance: number, camera: THREE.Camera): any {\n          var vFOV = camera['fov'] * Math.PI / 180;\n          var height = 2 * Math.tan(vFOV / 2) * distance;\n          var width = height * camera['aspect'];\n          return {\n              width: width,\n              height: height,\n          };\n      }\n      */\n    /**\n     * Given a known size of an object, calculate the actual size it is rendered\n     * on the screen (pixel).\n     *\n     * ```\n     * const pixelSize = threef.convertObjectSizeToPixel(\n     *    cube.geometry.parameters.width,\n     *    cube.geometry.parameters.height,\n     *    cube.geometry.parameters.depth,\n     *    camera,\n     *    canvasWidth, canvasHeight\n     * );\n     *\n     * console.log(pixelSize.width); // The actual rendered size of the cube in pixels\n     * console.log(pixelSize.height); // The actual rendered size of the cube in pixels.\n     *\n     * ```\n     *\n     * @untested\n     * @experimental\n     * @dontuse\n     * @hidden\n     */\n    /*\n      static convertObjectSizeToPixels(\n          width: number, height: number, depth: number, zPosition: number,\n          camera: THREE.Camera,\n          sceneWidth: number, sceneHeight: number): any {\n  \n          // First calculate the z distance from the cam to object considering the\n          // depth (z size) of the object.\n          const zDepth = (zPosition + depth) - camera.position.z;\n          const visibleSize = threef.getVisibleHeightAndWidthAtDepth(zDepth, camera);\n          const heightScalar = height / visibleSize.height;\n          const heightInPixels = sceneHeight * heightScalar;\n          const widthScalar = width / visibleSize.height;\n          const widthInPixels = sceneWidth * widthScalar;\n  \n          return {\n              width: widthInPixels,\n              height: heightInPixels,\n          }\n      }\n      */\n    /**\n     * Provides the ability to convert a vec3 into another coordinate system\n     * as needed given the mapping.\n     *\n     * Mapping supports the following strings: x,y,z,-x,-y,-z\n     *\n     * Example:\n     * ```\n     * threef.convertCoordinateSystem(\n     *    new THREE.Vector3(1, 2, 3),\n     *   ['-y', 'z', 'x']\n     * );  // x -> -2, y -> 3, z -> 1\n     *\n     * This internally converts the Vector3 using this logic:\n     *  x -> -y, y -> z, z-> x\n     * ```\n     *\n     * @param vec3\n     * @param orientation\n     */\n    static convertCoordinateSystem(vec3, map) {\n        const x = map[0].toLowerCase().split('');\n        const xFactor = x[0] === '-' ? -1 : 1;\n        const xValue = x[0] === '-' ? x[1] : x[0];\n        const y = map[1].toLowerCase().split('');\n        const yFactor = y[0] === '-' ? -1 : 1;\n        const yValue = y[0] === '-' ? y[1] : y[0];\n        const z = map[2].toLowerCase().split('');\n        const zFactor = z[0] === '-' ? -1 : 1;\n        const zValue = z[0] === '-' ? z[1] : z[0];\n        return new THREE.Vector3(\n        // TODO (uxder): Figure out type fix here.\n        vec3[xValue] * xFactor, vec3[yValue] * yFactor, vec3[zValue] * zFactor);\n    }\n    /**\n     * Sets the FOV as camera on a DOM element.\n     * @param element\n     * @param camera\n     */\n    static setFov(element, camera) {\n        const fov = (0.5 / Math.tan((camera['fov'] * Math.PI) / 360)) * element.offsetHeight;\n        element.style.perspectiveOrigin = '50% 50%';\n        element.style.perspective = fov + 'px';\n    }\n    /**\n     * Given vector and euler rotations, applies transforms to an html element.\n     * This works if your dom element is absolutely positions with the canvas.\n     *\n     * Given:\n     *```\n     * .text {\n     *   position: absolute;\n     * }\n     * <div style=\"position: relative; height: 100vh; width: 100vw\">\n     *   <canvas></canvas>\n     *   <div class=\"text\">Hello hello</div>\n     * </div>\n     * ```\n     *\n     * You would do:\n     *\n     * ```\n     *   const domCoordinates = threef.toDomCoordinates(\n     *       threeObject, threeCamara, canvasWidth, canvasHeight, 0.5\n     *   );\n     *   const domRotation = threef.toDomRotation(\n     *      threeObject, threeCamera, canvasWidth, canvasHeight\n     *   );\n     *\n     *   // Set the position and rotation of myDomElement to match the threeObject\n     *   threef.applyVectorToDom(myDomElement, domCoordinates, domRotation);\n     *\n     *   // Set the position, rotation only of myDomElement to match the threeObject without scaling\n     *   domCoodinates.z = 1; // No scaling.\n     *   threef.applyVectorToDom(myDomElement, domCoordinates, domRotation);\n     *\n     *   // Set the position only of myDomElement to match the threeObject\n     *   // This results in a billboarding effect.\n     *   threef.applyVectorToDom(myDomElement, domCoordinates);\n     * ```\n     */\n    static applyVectorToDom(element, v, euler) {\n        if (euler) {\n            const deg = {\n                x: mathf_1.mathf.radianToDegree(euler.x),\n                y: mathf_1.mathf.radianToDegree(euler.y),\n                z: mathf_1.mathf.radianToDegree(euler.z),\n            };\n            if (v) {\n                element.style.transform = `translate(-50%, -50%) translate(${v.x}px, ${v.y}px) rotateX(${deg.x}deg) rotateY(${deg.y}deg) rotateZ(${deg.z}deg) scale(${v.z})`;\n            }\n            else {\n                element.style.transform = `rotateX(${deg.x}deg) rotateY(${deg.y}deg) rotateZ(${deg.z}deg)`;\n            }\n        }\n        else {\n            element.style.transform = `translate(-50%, -50%) translate(${v === null || v === void 0 ? void 0 : v.x}px, ${v === null || v === void 0 ? void 0 : v.y}px) scale(${v === null || v === void 0 ? void 0 : v.z})`;\n        }\n    }\n    /**\n     * Given an array THREE.AnimationClips, does a search for an animation\n     * clip of the given name.\n     */\n    static getAnimationByName(name, animationClips) {\n        return animationClips.filter((animationClip) => {\n            return animationClip.name === name;\n        })[0];\n    }\n    /**\n     * Traverses the current scene checking for match conditions.\n     *\n     * ```ts\n     * // Look for any meshes that are of the name 'hohoho' or 'hohoho2'.\n     * // and change the anistropy to 100.\n     *\n     * threef.traverseSceneFor(\n     *   // Test condition\n     *   (threeObject)=> {\n     *      return\n     *         (threeObject instance of THREE.MESH) &&\n     *         ~['hohoho', 'hohoho2'].indexOf(threeObject.name)\n     *   },\n     *   (threeObject)=> {\n     *      threeObject.material.map.anistropy = 100;\n     *      threeObject.material.needsUpdate = true;\n     *   },\n     *   myScene\n     * )\n     *\n     *\n     * ```\n     */\n    static traverseSceneFor(matchCondition, execution, scene) {\n        scene.traverse(child => {\n            if (matchCondition(child)) {\n                execution(child);\n            }\n        });\n    }\n    /**\n     * Given a list of names, looks through the objects in the scenes\n     * and returns a dictionary of them so they can be quickly accessed\n     * at a later time.\n     *\n     * ```ts\n     * // Specify the types of objects you want.\n     * const typeMap = {\n     *     // Normally just pass a string for the \"object\" type\n     *     mesh: 'Mesh',\n     *     // Pass array for multiple\n     *     myStuff: ['Mesh', 'PointLight'],\n     *     // Custom search logic.\n     *     materials: (object, type) => {\n     *         return object.material\n     *     },\n     *     lights: (object, type)=> {\n     *         return ~type.toLowerCase().indexOf('light');\n     *      }\n     *     pointLight: 'PointLight',\n     *     cameras: 'PerspectiveCamera',\n     * }\n     * const objectDictionary = threef.makeObjectDictionaryFromScene(\n     *   scene, typeMap\n     * );\n     *\n     * ```\n     *\n     * Based on your typemap, a dictionary is returns with that type of\n     * object contained.\n     *\n     * ```\n     * objectDictionary.byName['myObject1']; // Your THREE object\n     * objectDictionary.byName['myPointlight1']; // Your THREE pointlight.\n     *\n     * // All text markers.\n     * // By convention, text markers are any object that starts with the\n     * // naming 'text-marker' (IE: text-marker1, text-marker2 etc.)\n     * objectDictionary.textMarkers;\n     *\n     * objectDictionary.mesh; // All your meshes\n     * objectDictionary.materials; // All your materials\n     * objectDictionary.lights; // All your lights\n     *\n     * ```\n     *\n     * @param name\n     * @param THREE.Scene\n     */\n    static createObjectDictionaryFromScene(scene, mapping) {\n        const dictionary = {\n            // Stores objects by name.\n            byName: {},\n            textMarkers: [],\n        };\n        for (const key of Object.keys(mapping)) {\n            dictionary[key] = [];\n        }\n        scene.traverse(child => {\n            dictionary.byName[child.name] = child;\n            if (child.name.startsWith('text-')) {\n                dictionary.textMarkers.push(child);\n            }\n            // Check if this object matches a specific mapping.\n            for (const key of Object.keys(mapping)) {\n                const value = mapping[key];\n                if (__1.is.string(value)) {\n                    if (child.type === value) {\n                        dictionary[key].push(child);\n                    }\n                }\n                if (__1.is.array(value)) {\n                    if (~value.indexOf(child.type)) {\n                        dictionary[key].push(child);\n                    }\n                }\n                if (__1.is.function(value)) {\n                    if (value(child, child.type)) {\n                        dictionary[key].push(child);\n                    }\n                }\n            }\n        });\n        return dictionary;\n    }\n    static findSceneByName(name, scenes) {\n        const scene = scenes.filter(scene => {\n            return scene.name === name;\n        })[0];\n        return scene;\n    }\n}\nexports.threef = threef;\n/* eslint-enable */\n//# sourceMappingURL=threef.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvdGhyZWVmL3RocmVlZi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi90aHJlZWYvdGhyZWVmLmpzPzY1YjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRocmVlZiA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IFRIUkVFID0gcmVxdWlyZShcInRocmVlXCIpO1xuY29uc3QgbWF0aGZfMSA9IHJlcXVpcmUoXCIuLi9tYXRoZi9tYXRoZlwiKTtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLlwiKTtcbmNvbnN0IGRlZmVyXzEgPSByZXF1aXJlKFwiLi4vZnVuYy9kZWZlclwiKTtcbi8qKlxuICogQSBidW5jaCBvZiB1dGlsIGZvciB0aHJlZS5qc1xuICovXG5jbGFzcyB0aHJlZWYge1xuICAgIC8qKlxuICAgICAqIEdMVEYgKyBBbmltYXRpb24gTWFya2VyIEV4cG9ydCBsb2FkZXIuXG4gICAgICpcbiAgICAgKiBMb2FkcyB0aGUgZ2x0ZiBmaWxlIGFuZCBhbHNvIHRoZSBhc3NvY2lhdGVkIGFuaW1hdGlvbiBtYXJrZXJcbiAgICAgKiBleHBvcnQgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGdsdGYgb2JqZWN0LlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogaW1wb3J0IHsgR0xURkxvYWRlciB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0dMVEZMb2FkZXInO1xuICAgICAqIGltcG9ydCB7RFJBQ09Mb2FkZXJ9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9sb2FkZXJzL0RSQUNPTG9hZGVyJztcbiAgICAgKlxuICAgICAqICAgLy8gQ3JlYXRlIGluc3RhbmNlIG9mIHRocmVlIGdsZnQgbG9hZGVyLlxuICAgICAqICAgY29uc3QgZ2x0ZkxvYWRlciA9IG5ldyBHTFRGTG9hZGVyKCk7XG4gICAgICpcbiAgICAgKiAgIC8vIE9wdGlvbmFsOiBQcm92aWRlIGEgRFJBQ09Mb2FkZXIgaW5zdGFuY2UgdG8gZGVjb2RlIGNvbXByZXNzZWQgbWVzaCBkYXRhXG4gICAgICogICB2YXIgZHJhY29Mb2FkZXIgPSBuZXcgVEhSRUUuRFJBQ09Mb2FkZXIoKTtcbiAgICAgKiAgIGRyYWNvTG9hZGVyLnNldERlY29kZXJQYXRoKCAnL2V4YW1wbGVzL2pzL2xpYnMvZHJhY28vJyApO1xuICAgICAqICAgZ2x0ZkxvYWRlci5zZXREUkFDT0xvYWRlciggZHJhY29Mb2FkZXIgKTtcbiAgICAgKlxuICAgICAqXG4gICAgICogICB0aHJlZWYubG9hZCh7XG4gICAgICogICAgIGdsdGZQYXRoOiAncHVibGljL2Rldi9nbHRmL3Rlc3QxLmdsdGYnLFxuICAgICAqICAgICAvLyBPcHRpb25hbCBhbmltYXRpb24gbWFya2VyIHBhdGguXG4gICAgICogICAgIGFuaW1hdGlvbk1hcmtlclBhdGg6ICdwdWJsaWMvZGV2L2dsdGYvdGVzdDEuZ2x0ZicsXG4gICAgICogICAgIGdsdGZMb2FkZXI6IGdsdGZMb2FkZXJcbiAgICAgKiAgIH0pLnRoZW4oKGdsdGYpID0+IHtcbiAgICAgKiAgICAgICAvLyBnbHRmLmFuaW1hdGlvbk1hcmtlcnMgaXMgYXZhaWxhYmxlLlxuICAgICAqICAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSB3b3JrcyB0aGUgc2FtZSBhcyB0aGUgdGhyZWUgZ2x0ZiBsb2FkZXIuXG4gICAgICogICB9KTtcbiAgICAgKlxuICAgICAqICAgLy8gQ2FsbCBhZ2FpbiB0byBsb2FkIHNvbWV0aGluZyBlbHNlIHdpdGggdGhlIHNhbWUgbG9hZGVyLlxuICAgICAqICAgdGhyZWVmLmxvYWQoe1xuICAgICAqICAgICBnbHRmUGF0aDogJ3B1YmxpYy9kZXYvZ2x0Zi90ZXN0Mi5nbHRmJyxcbiAgICAgKiAgICAgYW5pbWF0aW9uTWFya2VyUGF0aDogJ3B1YmxpYy9kZXYvZ2x0Zi90ZXN0Mi5nbHRmJyxcbiAgICAgKiAgICAgZ2x0ZkxvYWRlcjogZ2x0ZkxvYWRlclxuICAgICAqICAgfSkudGhlbigoZ2x0ZikgPT4ge1xuICAgICAqICAgICAgIC8vIGdsdGYuYW5pbWF0aW9uTWFya2VycyBpcyBhdmFpbGFibGUuXG4gICAgICogICAgICAgLy8gRXZlcnl0aGluZyBlbHNlIHdvcmtzIHRoZSBzYW1lIGFzIHRoZSB0aHJlZSBnbHRmIGxvYWRlci5cbiAgICAgKiAgIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL3RocmVlanMub3JnL2RvY3MvI2V4YW1wbGVzL2VuL2xvYWRlcnMvR0xURkxvYWRlclxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy90cmVlL2Rldi9leGFtcGxlcy9qcy9saWJzL2RyYWNvI3JlYWRtZVxuICAgICAqL1xuICAgIHN0YXRpYyBsb2FkR2x0Zihjb25maWcpIHtcbiAgICAgICAgY29uc3QgZGVmZXIgPSBuZXcgZGVmZXJfMS5EZWZlcigpO1xuICAgICAgICAvLyBTdGFydCBsb2FkaW5nIGdsdGYuXG4gICAgICAgIGxldCBnbHRmRGF0YSA9IHt9O1xuICAgICAgICBjb25zdCBnbHRmRmV0Y2ggPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGNvbmZpZy5nbHRmTG9hZGVyLmxvYWQoY29uZmlnLmdsdGZQYXRoLCAoZ2x0ZikgPT4ge1xuICAgICAgICAgICAgICAgIGdsdGZEYXRhID0gZ2x0ZjtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHt9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGFuaW1hdGlvbk1hcmtlckRhdGEgPSB7fTtcbiAgICAgICAgY29uc3QgbWFya2VyRmV0Y2ggPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGlmICghY29uZmlnLmFuaW1hdGlvbk1hcmtlclBhdGgpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25NYXJrZXJEYXRhID0ge307XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMb2FkIHRoZSBhbmltYXRpb24gZXhwb3J0XG4gICAgICAgICAgICAgICAgZmV0Y2goY29uZmlnLmFuaW1hdGlvbk1hcmtlclBhdGgpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigobWFya2VyRGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25NYXJrZXJEYXRhID0gbWFya2VyRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7fSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBNZXJnZSBvdXQgdGhlIGRhdGEuXG4gICAgICAgIFByb21pc2UuYWxsKFtnbHRmRmV0Y2gsIG1hcmtlckZldGNoXSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBnbHRmRGF0YVsnYW5pbWF0aW9uTWFya2VycyddID0gYW5pbWF0aW9uTWFya2VyRGF0YTtcbiAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoZ2x0ZkRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVyLmdldFByb21pc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSB0aHJlZS5qcyBNZXNoIC8gT2JqZWN0M2QsIGNhbGN1bGF0ZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIG1hcHMgdGhhdCB0byB0aGVcbiAgICAgKiBET00geCwgeSwgeiBwb3NpdGlvbiBhbmQgY29uc2lkZXJzIGNhbWVyYSBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm5pbmcgeCx5IHZhbHVlcyBhcmUgaW4gcGl4ZWxzLlxuICAgICAqIHggLyBjYW52YXNXaWR0aCBvciB5IC8gY2FudmFzSGVpZ2h0IHdvdWxkIGdpdmUgeW91IHRoZSBwZXJjZW50YWdlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzZWUgdGhyZWUtb2JqZWN0LXZpZXdlcjExLmh0bWwgZm9yIGV4YW1wbGVzIGFuZCBhbHNvIHRocmVlLW9iamVjdC12aWV3ZXIxMS5ibGVuZFxuICAgICAqXG4gICAgICogQHBhcmFtIG9iamVjdCBUaGUgdGhyZWUuanMgb2JqZWN0IHRvIGJhc2UgdGhlIHBvc2l0aW9uIG9mZiBvZi5cbiAgICAgKiBAcGFyYW0gY2FtZXJhIFRoZSBjdXJyZW50bHkgYWN0aXZlIGNhbWVyYS5cbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIGNhbnZhcyB3aWR0aFxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGNhbnZhcyB3aWR0aFxuICAgICAqIEBwYXJhbSBzY2FsYXI/IEFuIG9wdGlvbmFsIHNjYWxhciB2YWx1ZS4gIFlvdSBjYW4gcGFzcyBhIHZhbHVlIGxpa2UgMSB0byB0ZWxsXG4gICAgICogICB0aGUgZG9tIGVsZW1lbnQgdG8gc2NhbGUgYWxvbmcgd2l0aCB0aGUgY2FtZXJhIG1vdmVtZW50LiAgV2UgY2FuJ3QgZG8gdGhpc1xuICAgICAqICAgYXV0b21hdGljYWxseSwgc2luY2Ugd2UgaGF2ZSBubyByZWZlcmVuY2UgdG8gd2hhdCBzY2FsZSAxIHNob3VsZCBiZVxuICAgICAqICAgd2hlbiB0aGUgY2FtZXJhIGlzIGEgY2VydGFpbiBkaXN0YW5jZSBmcm9tIHRoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEluc3BpcmVkIGJ5OlxuICAgICAqIC0gaHR0cHM6Ly9pY3MubWVkaWEvdHV0b3JpYWwtdGhyZWUvcG9zaXRpb25fcHJvamVjdC9cbiAgICAgKiAtIGh0dHBzOi8vdGhyZWVqc2Z1bmRhbWVudGFscy5vcmcvdGhyZWVqcy9sZXNzb25zL3RocmVlanMtYWxpZ24taHRtbC1lbGVtZW50cy10by0zZC5odG1sXG4gICAgICogLSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzQwOTA3NC9jb252ZXJ0aW5nLTNkLXBvc2l0aW9uLXRvLTJkLXNjcmVlbi1wb3NpdGlvbi1yNjlcbiAgICAgKiAtIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ2NjY3Mzk1L3RocmVlLWpzLXZlY3RvcjMtdG8tMmQtc2NyZWVuLWNvb3JkaW5hdGUtd2l0aC1yb3RhdGVkLXNjZW5lXG4gICAgICogLSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9DaGlDaG91L2E2NzFhMGJiZTUxNDM2NDI1NWY5XG4gICAgICogLSBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL2pzL3JlbmRlcmVycy9DU1MzRFJlbmRlcmVyLmpzI0w2LUwzMVxuICAgICAqIC0gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iL21hc3Rlci9leGFtcGxlcy9qcy9yZW5kZXJlcnMvQ1NTM0RSZW5kZXJlci5qcyNMMjU0XG4gICAgICovXG4gICAgc3RhdGljIHRvRG9tQ29vcmRpbmF0ZXMob2JqZWN0LCBjYW1lcmEsIHdpZHRoLCBoZWlnaHQsIHNjYWxhcikge1xuICAgICAgICBjb25zdCB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgLy8gR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSBvYmplY3QuXG4gICAgICAgIG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG4gICAgICAgIG9iamVjdC5nZXRXb3JsZFBvc2l0aW9uKHYpO1xuICAgICAgICAvLyBDb252ZXJ0IC0xIC0gMSB3b3JsZCBzcGFjZSB0byBkb20gYmFzZWQgMC0xIHJhbmdlLlxuICAgICAgICAvLyBHZXQgdGhlIG5vcm1hbGl6ZWQgc2NyZWVuIGNvb3JkaW5hdGUgb2YgdGhhdCBwb3NpdGlvblxuICAgICAgICAvLyB4IGFuZCB5IHdpbGwgYmUgaW4gdGhlIC0xIHRvICsxIHJhbmdlIHdpdGggeCA9IC0xIGJlaW5nXG4gICAgICAgIC8vIG9uIHRoZSBsZWZ0IGFuZCB5ID0gLTEgYmVpbmcgb24gdGhlIGJvdHRvbVxuICAgICAgICB2LnByb2plY3QoY2FtZXJhKTtcbiAgICAgICAgY29uc3QgeCA9ICh2LnggKiAwLjUgKyAwLjUpICogd2lkdGg7XG4gICAgICAgIGNvbnN0IHkgPSAodi55ICogLTAuNSArIDAuNSkgKiBoZWlnaHQ7XG4gICAgICAgIGxldCB6ID0gMTtcbiAgICAgICAgaWYgKF9fMS5pcy5kZWZpbmVkKHNjYWxhcikpIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBjYW52YXMgc2NhbGVzIGJhc2VkIG9uIGhlaWdodCwgdXNlIHRoYXQgYXMgdGhlIGJhc2lzLlxuICAgICAgICAgICAgeiA9ICh2LnogKiAtMC41ICsgMC41KSAqIGhlaWdodDtcbiAgICAgICAgICAgIHogKj0gc2NhbGFyO1xuICAgICAgICAgICAgeiAqPSBjYW1lcmEuem9vbSB8fCAxLjA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKHgsIHksIHopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIFRocmVlIGxvY2FsIFZlYzMgcG9zaXRpb24gdG8gZXhhY3Qgc2NyZWVuIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBjYW1lcmFcbiAgICAgKiBAcGFyYW0gd2lkdGhcbiAgICAgKiBAcGFyYW0gaGVpZ2h0XG4gICAgICovXG4gICAgc3RhdGljIHRvU2NyZWVuWFkocG9zaXRpb24sIGNhbWVyYSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBjb25zdCBwb3MgPSBwb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICBjb25zdCBtYXQ0ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgICAgbWF0NC5tdWx0aXBseShjYW1lcmEucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgICAgIG1hdDQubXVsdGlwbHkoY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSk7XG4gICAgICAgIC8vIG1hdDQubXVsdGlwbHlWZWN0b3IzKHBvcyk7XG4gICAgICAgIHBvcy5hcHBseU1hdHJpeDQobWF0NCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAoKHBvcy54ICsgMSkgKiB3aWR0aCkgLyAyLFxuICAgICAgICAgICAgeTogKCgtcG9zLnkgKyAxKSAqIGhlaWdodCkgLyAyLFxuICAgICAgICAgICAgejogcG9zLnosXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGJvdW5kaW5nIHJlY3QgaW4gcGl4ZWwgdmFsdWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIFRoaXMgYmFzaWNhbGx5LCBhbGxvd3MgeW91IHRvIGNhbGN1bGF0ZSB0aGUgd2lkdGggLyBoZWlnaHQgb2YgYSBnaXZlblxuICAgICAqIG9iamVjdCBpbiBzY3JlZW4gc3BhY2UuICBJdCB3aWxsIGFsc28gZ2V0IHlvdSB4LHkgY29vcmRpbmF0ZXMgb2YgdGhlIGJvdW5kaW5nXG4gICAgICogYm94IGFyb3VuZCB5b3VyIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEltYWdpbmUgYSBjdWJlIG9uIHlvdXIgc2NyZWVuXG4gICAgICogYW5kIHlvdSB3YW50IHRvIGtub3cgdGhlIHBpeGVsIHdpZHRoIGFuZCBoZWlnaHQgaXQgb2NjdXBpZXMgb24gdGhlIHNjcmVlbi5cbiAgICAgKiBUaGlzIG1ha2VzIHNlbnNlIGlmIHlvdSBhcmUgbG9va2luZyBoZWFkIG9uIGJ1dCB3aGF0IGhhcHBlbnMgaWYgdGhlXG4gICAgICogY2FtZXJhIGlzIGF0IGFuIGFuZ2xlIG9yIHRoZSBvYmplY3QgaXMgcm90YXRlZC5cbiAgICAgKiBPciB5b3UgbWlnaHQgd2FudCB0aGUgYXBwcm94aW1hdGUgd2lkdGggYW5kIGhlaWdodCBvZiBhIHNwaGVyZSBvclxuICAgICAqIGFjdHVhbCBzY3JlZW4gaGVpZ2h0IGFuZCB3aWR0aCBvZiBhIGh1bWFuIG1vZGVsIHdoZW4gdGhlIGNhbWVyYSBpcyBsb29raW5nIGZyb20gYVxuICAgICAqIHRvcCBhbmdsZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYWxsb3cgeW91IHRvIGRvIHRoYXQuXG4gICAgICpcbiAgICAgKiBJdCB3aWxsIHN0YXJ0IGJ5IGRyYXdpbmcgYSBCb3gzZCBjdWJlIChib3VuZGluZ0JveCkgYXJvdW5kIHRoZSBvYmplY3QuXG4gICAgICogSXQgd2lsbCB0aGVuIGNvbnZlcnQgdGhlIEJveDNkIGludG8gYSBzcXVhcmUgb2YgMmQgY29vcmRpbmF0ZS5cbiAgICAgKiBVc2luZyB0aGF0IHNxdWFyZSwgaXQgd2lsbCB0aGVuIGNhbGN1bGF0ZSB0aGUgc2NyZWVuWFkgY29vcmRpbmF0ZXMgb2YgZWFjaFxuICAgICAqIGNvcm5lciBvZiB0aGUgY3ViZS5cbiAgICAgKiBJdCB3aWxsIHRoZW4gY2FsY3VsYXRlIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IHRoaXMgb2JqZWN0IG9jY3VwaWVzIG9uXG4gICAgICogdGhlIHNjcmVlbiBiYXNlZCBvbiB0aGVzZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKlxuICAgICAqIElmIHdvcmtpbmcgb24gdGhpcyBtZXRob2QsIHNpbmNlIGNhbGN1bGF0aW9ucyBjYW4gYmUgaW52b2x2ZWQsIGl0IGlzIGhlbHBmdWxcbiAgICAgKiB0byBwYXNzIGluIHRoZSBjdXJyZW50IHdvcmtpbmcgc2NlbmUgdG8gZGVidWcgdGhlIGNvcm5lcnMuXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBjb25zdCBib3ggPSB0aHJlZS50b0RvbUJvdWRpbmdSZWN0KFxuICAgICAqICAgbXlPYmplY3QsIGNhbWVyYSwgY2FudmFzLm9mZnNldFdpZHRoLCBjYW52YXMub2Zmc2V0SGVpZ2h0LFxuICAgICAqICAge1xuICAgICAqICAgICBzY2FsYXI6IDEsIC8vIEZvciB6IHNjYWxpbmcgZmFjdG9yXG4gICAgICogICAgIHNjZW5lOiBzY2VuZSwgLy8gUGFzcyBpbiB5b3VyIHNjZW5lIHRvIGRlYnVnIHRoZSBjb3JuZXIuXG4gICAgICogICB9XG4gICAgICogKVxuICAgICAqXG4gICAgICogYm94LndpZHRoIC0tPiBUaGUgcGl4ZWwgd2lkdGggb24gdGhlIHNjcmVlbi5cbiAgICAgKiBib3guaGVpZ2h0IC0tPiBUaGUgcGl4ZWwgaGVpZ2h0IG9uIHRoZSBzY3JlZW4uXG4gICAgICogYm94LnRvcExlZnQgLS0+IFRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHRvRG9tQm91bmRpbmdSZWN0KG9iamVjdCwgY2FtZXJhLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGJveCA9IG5ldyBUSFJFRS5Cb3gzKCkuc2V0RnJvbU9iamVjdChvYmplY3QpO1xuICAgICAgICAvLyBHZXQgYm94IGNvcm5lcnMuXG4gICAgICAgIGNvbnN0IGNvcm5lcnMgPSB7XG4gICAgICAgICAgICAnMDAwJzoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAweGZmZmZmZixcbiAgICAgICAgICAgICAgICB2ZWM6IG5ldyBUSFJFRS5WZWN0b3IzKCkuc2V0KGJveC5taW4ueCwgYm94Lm1pbi55LCBib3gubWluLnopLCAvLyAwMDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnMDAxJzoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAweDBmZmYwMCxcbiAgICAgICAgICAgICAgICB2ZWM6IG5ldyBUSFJFRS5WZWN0b3IzKCkuc2V0KGJveC5taW4ueCwgYm94Lm1pbi55LCBib3gubWF4LnopLCAvLyAwMDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnMDEwJzoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAweGZmMDBmNyxcbiAgICAgICAgICAgICAgICB2ZWM6IG5ldyBUSFJFRS5WZWN0b3IzKCkuc2V0KGJveC5taW4ueCwgYm94Lm1heC55LCBib3gubWluLnopLCAvLyAwMTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnMDExJzoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAweDlkOWQ5ZCxcbiAgICAgICAgICAgICAgICB2ZWM6IG5ldyBUSFJFRS5WZWN0b3IzKCkuc2V0KGJveC5taW4ueCwgYm94Lm1heC55LCBib3gubWF4LnopLCAvLyAwMTFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnMTAwJzoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAweDAwM2VmZixcbiAgICAgICAgICAgICAgICB2ZWM6IG5ldyBUSFJFRS5WZWN0b3IzKCkuc2V0KGJveC5tYXgueCwgYm94Lm1pbi55LCBib3gubWluLnopLCAvLyAxMDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnMTAxJzoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAweGYzZmYwMCxcbiAgICAgICAgICAgICAgICB2ZWM6IG5ldyBUSFJFRS5WZWN0b3IzKCkuc2V0KGJveC5tYXgueCwgYm94Lm1pbi55LCBib3gubWF4LnopLCAvLyAxMDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnMTEwJzoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAweGZmMDAwMCxcbiAgICAgICAgICAgICAgICB2ZWM6IG5ldyBUSFJFRS5WZWN0b3IzKCkuc2V0KGJveC5tYXgueCwgYm94Lm1heC55LCBib3gubWluLnopLCAvLyAxMTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnMTExJzoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAweDAwMDAwMCxcbiAgICAgICAgICAgICAgICB2ZWM6IG5ldyBUSFJFRS5WZWN0b3IzKCkuc2V0KGJveC5tYXgueCwgYm94Lm1heC55LCBib3gubWF4LnopLCAvLyAxMTFcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIC8vIEdlbmVyYXRlIGFuIGFycmF5IG9mIHRoZSBYWSBzY3JlZW4gY29vcmRpbmF0ZSBvZiBldmVyeSBzaW5nbGUgY29ybmVyXG4gICAgICAgIC8vIG9mIHRoZSBib3gzZC5cbiAgICAgICAgY29uc3QgY29ybmVyUG9zaXRpb25zID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvcm5lcnMpKSB7XG4gICAgICAgICAgICBjb25zdCBjb3JuZXIgPSBjb3JuZXJzW2tleV07XG4gICAgICAgICAgICBjb25zdCB4eSA9IHRocmVlZi50b1NjcmVlblhZKGNvcm5lci52ZWMsIGNhbWVyYSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBjb3JuZXJQb3NpdGlvbnMucHVzaCh4eSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhyZWVmLnRvU2NyZWVuWFkob2JqZWN0LnBvc2l0aW9uLCBjYW1lcmEsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhvYmplY3QucG9zaXRpb24sIGNhbWVyYSk7XG4gICAgICAgIGNvbnN0IHhzID0gY29ybmVyUG9zaXRpb25zLm1hcCh4eSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geHkueDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHlzID0gY29ybmVyUG9zaXRpb25zLm1hcCh4eSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geHkueTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gb3B0aW9ucyAmJiBvcHRpb25zLnNjZW5lO1xuICAgICAgICBjb25zdCBzY2FsYXIgPSBvcHRpb25zICYmIG9wdGlvbnMuc2NhbGFyO1xuICAgICAgICAvLyBUaGlzIGlzIG91ciB2aXJ0dWFsIDJkIHNxdWFyZSBmcm9tIHRoZSAzZCBjdWJlLiAgVGhpcyBpcyBhIHNxdWFyZVxuICAgICAgICAvLyBkcmF3biBvdmVyIHRoZSBib3gzZCBib3VuZGluZyBib3gsIHJlcHJlc2VudGluZyB0aGUgc3BhY2VcbiAgICAgICAgLy8gdGhpcyBvYmplY3QgdGFrZXMgdXAgb24gdGhlIHNjcmVlbi5cbiAgICAgICAgY29uc3QgbWluWCA9IE1hdGgubWluKC4uLnhzKTtcbiAgICAgICAgY29uc3QgbWF4WCA9IE1hdGgubWF4KC4uLnhzKTtcbiAgICAgICAgY29uc3QgbWluWSA9IE1hdGgubWluKC4uLnlzKTtcbiAgICAgICAgY29uc3QgbWF4WSA9IE1hdGgubWF4KC4uLnlzKTtcbiAgICAgICAgLy8gQmFzZWQgb24gdGhlcmUsIHdlIGNhbiBjYWxjdWxhdGUgdGhlIHNpemUuXG4gICAgICAgIGNvbnN0IGZpbmFsU2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICAgICAgICAgIGhlaWdodDogbWF4WSAtIG1pblksXG4gICAgICAgIH07XG4gICAgICAgIC8vIENhbGN1bGF0ZSByZWxhdGl2ZSBkZXB0aCAoeilcbiAgICAgICAgbGV0IHogPSAxO1xuICAgICAgICBpZiAoc2NhbGFyKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgICAgIG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICBvYmplY3QuZ2V0V29ybGRQb3NpdGlvbih2KTtcbiAgICAgICAgICAgIHYucHJvamVjdChjYW1lcmEpO1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIGNhbnZhcyBzY2FsZXMgYmFzZWQgb24gaGVpZ2h0LCB1c2UgdGhhdCBhcyB0aGUgYmFzaXMuXG4gICAgICAgICAgICB6ID0gKHYueiAqIC0wLjUgKyAwLjUpICogaGVpZ2h0O1xuICAgICAgICAgICAgeiAqPSBzY2FsYXI7XG4gICAgICAgICAgICB6ICo9IGNhbWVyYVsnem9vbSddIHx8IDEuMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWFsdGUgdGhlIGNvcm5lcnMgb2YgdGhlIGJveCBmcm9tIHRvcCBsZWZ0IGNsb2Nrd2lzZS5cbiAgICAgICAgY2VudGVyLnogPSB6O1xuICAgICAgICBjb25zdCBjb3JuZXIxID0gbmV3IFRIUkVFLlZlY3RvcjMobWluWCwgbWluWSwgeik7XG4gICAgICAgIGNvbnN0IGNvcm5lcjIgPSBuZXcgVEhSRUUuVmVjdG9yMyhtYXhYLCBtaW5ZLCB6KTtcbiAgICAgICAgY29uc3QgY29ybmVyMyA9IG5ldyBUSFJFRS5WZWN0b3IzKG1pblgsIG1heFksIHopO1xuICAgICAgICBjb25zdCBjb3JuZXI0ID0gbmV3IFRIUkVFLlZlY3RvcjMobWluWCwgbWF4WSwgeik7XG4gICAgICAgIC8vIElmIGEgc2NlbmUgaGFzIGJlZW4gcGFzc2VkLCBhZGRcbiAgICAgICAgaWYgKHNjZW5lKSB7XG4gICAgICAgICAgICBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVE9ETyAodXhkZXIpOiBUaGlzIGRvZXNuJ3QgZXhpc3Qgb24gbWVzaCBhY2NvcmRpbmcgdG8gZG9jcy5cbiAgICAgICAgICAgIC8vIE5lZWQgdG8gaW52ZXN0aWdhdGUgaWYgd2UgY2FuIGp1c3QgcmVtb3ZlIHRoaXMuXG4gICAgICAgICAgICBvYmplY3RbJ2Fsd2F5c0ludmlzaWJsZSddID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvcm5lcnMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ybmVyID0gY29ybmVyc1trZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KDAuMSwgMC4xLCAwLjEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IGNvcm5lci5jb2xvciB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdWJlID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICAgICAgICBjdWJlLnBvc2l0aW9uLnNldChjb3JuZXIudmVjLngsIGNvcm5lci52ZWMueSwgY29ybmVyLnZlYy56KTtcbiAgICAgICAgICAgICAgICBzY2VuZS5hZGQoY3ViZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcExlZnQ6IGNvcm5lcjEsXG4gICAgICAgICAgICB0b3BSaWdodDogY29ybmVyMixcbiAgICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgICAgYm90dG9tTGVmdDogY29ybmVyMyxcbiAgICAgICAgICAgIGJvdHRvbVJpZ2h0OiBjb3JuZXI0LFxuICAgICAgICAgICAgd2lkdGg6IGZpbmFsU2l6ZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZmluYWxTaXplLmhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgZnJvbSB0aGUgYmxlbmRlciBjb29yZGluYXRlIHN5c3RlbSBvdmVyIHRvIHRocmVlIChYWVopLlxuICAgICAqIFRoaXMgYXNzdW1lcyB0aGF0IHdpdGhpbiBibGVuZGVyLCB5b3UgYXJlIHVzaW5nIHRoZSBYWVogRXVsZXIgcm90YXRpb25cbiAgICAgKiBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIElmIHlvdXIgc2V0dGluZ3MgYXJlIG9mZiwgaXQncyBsaWtlbHkgdGhlIG9iamVjdCB5b3VyIGV4cG9ydGVkXG4gICAgICogaGFzIHJvdGF0aW9ucy4gIFNlbGVjdCB5b3VyIG9iamVjdCB0byBBcHBseSAtPiBSb3RhdGlvbiAmIFNjYWxlXG4gICAgICogaW4gYmxlbmRlci5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogYGBgXG4gICAgICogIHRocmVlZi5ibGVuZGVyVG9UaHJlZUNvb3JkaW5hdGVzKHtcbiAgICAgKiAgICAgeDogbWF0aGYuZGVncmVlVG9SYWRpYW4oNTEuOSksXG4gICAgICogICAgIHk6IG1hdGhmLmRlZ3JlZVRvUmFkaWFuKDE5MiksXG4gICAgICogICAgIHo6IG1hdGhmLmRlZ3JlZVRvUmFkaWFuKDIwMClcbiAgICAgKiB9KSxcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gb2JqZWN0IE9iamVjdCBjb250YWlucyB4LHkselxuICAgICAqL1xuICAgIHN0YXRpYyBibGVuZGVyVG9UaHJlZUV1bGVyKGV1bGVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAtZXVsZXIueCxcbiAgICAgICAgICAgIHk6IGV1bGVyLnosXG4gICAgICAgICAgICB6OiAtZXVsZXIueSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYmxlbmRlciBjb29yZHMgdG8gdGhyZWUuanNcbiAgICAgKiBgYGBcbiAgICAgKiB0YXJnZXRQb3NpdGlvbiA9IHRocmVlZi5ibGVuZGVyVG9UaHJlZVZlYzMoe1xuICAgICAqICAgLy8gU3BlY2lmeSBpbiBibGVuZGVyIGNvb3Jkc1xuICAgICAqICAgeDogMCxcbiAgICAgKiAgIHk6IDAsXG4gICAgICogICB6OiAxLjAsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gdmVjM1xuICAgICAqL1xuICAgIHN0YXRpYyBibGVuZGVyVG9UaHJlZVZlYzModmVjMykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogLXZlYzMueCxcbiAgICAgICAgICAgIHk6IHZlYzMueixcbiAgICAgICAgICAgIHo6IC12ZWMzLnksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgdGhyZWUuanMgb2JqZWN0LCBjYWxjdWxhdGVzIHRoZSBldWxlciByb3RhdGlvbiBvdmVyIHRvIHZhbHVlcyB0aGF0IGNhblxuICAgICAqIGJlIGFwcGxpZWQgdmlhIGNzcy4gIE5vdGUgdGhpcyByZXR1cm4gZXVsZXIgcm90YXRpb25zIGluIHJhZGlhbnMgKFRIUkVFLkV1bGVyKS5cbiAgICAgKiBAcGFyYW0gb2JqZWN0XG4gICAgICogQHBhcmFtIGNhbWVyYVxuICAgICAqIEBwYXJhbSB3aWR0aFxuICAgICAqIEBwYXJhbSBoZWlnaHRcbiAgICAgKi9cbiAgICBzdGF0aWMgdG9Eb21Sb3RhdGlvbihvYmplY3QsIGNhbWVyYSkge1xuICAgICAgICAvLyBHZXQgdGhlIGxvY2FsIHRyYW5zZm9ybSB2YWx1ZXMuXG4gICAgICAgIGNvbnN0IHEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICAgICAgICAvLyBvYmplY3QudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuICAgICAgICBvYmplY3QuZ2V0V29ybGRRdWF0ZXJuaW9uKHEpO1xuICAgICAgICAvLyBDb252ZXJ0IGNvb3JkaW5hdGUgc3lzdGVtLlxuICAgICAgICBxLnggPSAtcS54O1xuICAgICAgICBxLnogPSAtcS56O1xuICAgICAgICAvLyBHZXQgdGhlIGNhbWVyYSByb3RhdGlvbiAod29ybGQpXG4gICAgICAgIGNvbnN0IGNxID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgICAgICAgLy8gY2FtZXJhLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcbiAgICAgICAgY2FtZXJhLmdldFdvcmxkUXVhdGVybmlvbihjcSk7XG4gICAgICAgIC8vIENvbnZlcnQgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICAgIGNxLnkgPSAtY3EueTtcbiAgICAgICAgLy8gQ29tYmluZSB0aGUgY2FtZXJhIGFuZCBvYmplY3Qgcm90YXRpb25cbiAgICAgICAgY3EubXVsdGlwbHkocSk7XG4gICAgICAgIGNvbnN0IGV1bGVyID0gbmV3IFRIUkVFLkV1bGVyKCk7XG4gICAgICAgIGV1bGVyLnNldEZyb21RdWF0ZXJuaW9uKGNxLm5vcm1hbGl6ZSgpKTtcbiAgICAgICAgLy8gICBFdWxlci5Sb3RhdGlvbk9yZGVycyA9IFsgJ1hZWicsICdZWlgnLCAnWlhZJywgJ1haWScsICdZWFonLCAnWllYJyBdO1xuICAgICAgICAvLyBldWxlci5yZW9yZGVyKFwiWllYXCIpXG4gICAgICAgIHJldHVybiBldWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmlzaWJsZSBoZWlnaHQgYXQgYSBzcGVjaWZpYyBkZXB0aCBnaXZlbiBhIHRocmVlLmpzIGNhbWVyYS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogWW91IGhhdmUgYSAxMDB4MTAweDEwMCBjdWJlIGFuZCB3YW50IHRvIGtub3cgdGhlIFwicGl4ZWxcIiBzaXplIGl0IGlzXG4gICAgICogcmVuZGVyZWQgYXQgd2hlbiBpdCdzIGF0IGEgZGVwdGggb2YgMjAwLlxuICAgICAqIGBgYFxuICAgICAqIC8vIEFkZCA1MCB0byBhY2NvdW50IGZvciBzaXplIGZyb20gdGhlIGNlbnRlciBvZiBjdWJlLlxuICAgICAqIGNvbnN0IGRlcHRoID0gKGN1YmUucG9zaXRpb24ueiArIDUwKSAtIGNhbWVyYS5wb3NpdGlvbi56O1xuICAgICAqXG4gICAgICogY29uc3QgdmlzaWJsZVNpemUgPSB0aHJlZWYuZ2V0VmlzaWJsZUhlaWdodEFuZFdpZHRoQXREZXB0aChkZXB0aCwgY2FtZXJhKTtcbiAgICAgKlxuICAgICAqIC8vIFNvIHJlbGF0aXZlIHRvIHRoZSBoZWlnaHQsIGhvdyBtdWNoIGRvZXMgdGhlIGN1YmUgdGFrZSB1cC5cbiAgICAgKiBjb25zdCBoZWlnaHRTY2FsYXIgPSAxMDAgLyB2aXNpYmxlU2l6ZS5oZWlnaHQ7XG4gICAgICpcbiAgICAgKiAvLyBOb3cgbm9ybWFsaXplIHRoYXQgdG8gdGhlIHNpemUgaW4gcGl4ZWxzLlxuICAgICAqIGNvbnN0IGhlaWdodEluUGl4ZWxzID0gY2FudmFzU2l6ZS5oZWlnaHQgKiBoZWlnaHRTY2FsYXI7XG4gICAgICogYGBgXG4gICAgICogQHVudGVzdGVkXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqIEBkb250dXNlXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIC8qXG4gICAgICBzdGF0aWMgZ2V0VmlzaWJsZUhlaWdodEFuZFdpZHRoQXREZXB0aChkaXN0YW5jZTogbnVtYmVyLCBjYW1lcmE6IFRIUkVFLkNhbWVyYSk6IGFueSB7XG4gICAgICAgICAgdmFyIHZGT1YgPSBjYW1lcmFbJ2ZvdiddICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gMiAqIE1hdGgudGFuKHZGT1YgLyAyKSAqIGRpc3RhbmNlO1xuICAgICAgICAgIHZhciB3aWR0aCA9IGhlaWdodCAqIGNhbWVyYVsnYXNwZWN0J107XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgICAgKi9cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGtub3duIHNpemUgb2YgYW4gb2JqZWN0LCBjYWxjdWxhdGUgdGhlIGFjdHVhbCBzaXplIGl0IGlzIHJlbmRlcmVkXG4gICAgICogb24gdGhlIHNjcmVlbiAocGl4ZWwpLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgcGl4ZWxTaXplID0gdGhyZWVmLmNvbnZlcnRPYmplY3RTaXplVG9QaXhlbChcbiAgICAgKiAgICBjdWJlLmdlb21ldHJ5LnBhcmFtZXRlcnMud2lkdGgsXG4gICAgICogICAgY3ViZS5nZW9tZXRyeS5wYXJhbWV0ZXJzLmhlaWdodCxcbiAgICAgKiAgICBjdWJlLmdlb21ldHJ5LnBhcmFtZXRlcnMuZGVwdGgsXG4gICAgICogICAgY2FtZXJhLFxuICAgICAqICAgIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHRcbiAgICAgKiApO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cocGl4ZWxTaXplLndpZHRoKTsgLy8gVGhlIGFjdHVhbCByZW5kZXJlZCBzaXplIG9mIHRoZSBjdWJlIGluIHBpeGVsc1xuICAgICAqIGNvbnNvbGUubG9nKHBpeGVsU2l6ZS5oZWlnaHQpOyAvLyBUaGUgYWN0dWFsIHJlbmRlcmVkIHNpemUgb2YgdGhlIGN1YmUgaW4gcGl4ZWxzLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAdW50ZXN0ZWRcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICogQGRvbnR1c2VcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgLypcbiAgICAgIHN0YXRpYyBjb252ZXJ0T2JqZWN0U2l6ZVRvUGl4ZWxzKFxuICAgICAgICAgIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBkZXB0aDogbnVtYmVyLCB6UG9zaXRpb246IG51bWJlcixcbiAgICAgICAgICBjYW1lcmE6IFRIUkVFLkNhbWVyYSxcbiAgICAgICAgICBzY2VuZVdpZHRoOiBudW1iZXIsIHNjZW5lSGVpZ2h0OiBudW1iZXIpOiBhbnkge1xuICBcbiAgICAgICAgICAvLyBGaXJzdCBjYWxjdWxhdGUgdGhlIHogZGlzdGFuY2UgZnJvbSB0aGUgY2FtIHRvIG9iamVjdCBjb25zaWRlcmluZyB0aGVcbiAgICAgICAgICAvLyBkZXB0aCAoeiBzaXplKSBvZiB0aGUgb2JqZWN0LlxuICAgICAgICAgIGNvbnN0IHpEZXB0aCA9ICh6UG9zaXRpb24gKyBkZXB0aCkgLSBjYW1lcmEucG9zaXRpb24uejtcbiAgICAgICAgICBjb25zdCB2aXNpYmxlU2l6ZSA9IHRocmVlZi5nZXRWaXNpYmxlSGVpZ2h0QW5kV2lkdGhBdERlcHRoKHpEZXB0aCwgY2FtZXJhKTtcbiAgICAgICAgICBjb25zdCBoZWlnaHRTY2FsYXIgPSBoZWlnaHQgLyB2aXNpYmxlU2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0SW5QaXhlbHMgPSBzY2VuZUhlaWdodCAqIGhlaWdodFNjYWxhcjtcbiAgICAgICAgICBjb25zdCB3aWR0aFNjYWxhciA9IHdpZHRoIC8gdmlzaWJsZVNpemUuaGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IHdpZHRoSW5QaXhlbHMgPSBzY2VuZVdpZHRoICogd2lkdGhTY2FsYXI7XG4gIFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHdpZHRoOiB3aWR0aEluUGl4ZWxzLFxuICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodEluUGl4ZWxzLFxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgICovXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gY29udmVydCBhIHZlYzMgaW50byBhbm90aGVyIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICogYXMgbmVlZGVkIGdpdmVuIHRoZSBtYXBwaW5nLlxuICAgICAqXG4gICAgICogTWFwcGluZyBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHN0cmluZ3M6IHgseSx6LC14LC15LC16XG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqIGBgYFxuICAgICAqIHRocmVlZi5jb252ZXJ0Q29vcmRpbmF0ZVN5c3RlbShcbiAgICAgKiAgICBuZXcgVEhSRUUuVmVjdG9yMygxLCAyLCAzKSxcbiAgICAgKiAgIFsnLXknLCAneicsICd4J11cbiAgICAgKiApOyAgLy8geCAtPiAtMiwgeSAtPiAzLCB6IC0+IDFcbiAgICAgKlxuICAgICAqIFRoaXMgaW50ZXJuYWxseSBjb252ZXJ0cyB0aGUgVmVjdG9yMyB1c2luZyB0aGlzIGxvZ2ljOlxuICAgICAqICB4IC0+IC15LCB5IC0+IHosIHotPiB4XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmVjM1xuICAgICAqIEBwYXJhbSBvcmllbnRhdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBjb252ZXJ0Q29vcmRpbmF0ZVN5c3RlbSh2ZWMzLCBtYXApIHtcbiAgICAgICAgY29uc3QgeCA9IG1hcFswXS50b0xvd2VyQ2FzZSgpLnNwbGl0KCcnKTtcbiAgICAgICAgY29uc3QgeEZhY3RvciA9IHhbMF0gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgY29uc3QgeFZhbHVlID0geFswXSA9PT0gJy0nID8geFsxXSA6IHhbMF07XG4gICAgICAgIGNvbnN0IHkgPSBtYXBbMV0udG9Mb3dlckNhc2UoKS5zcGxpdCgnJyk7XG4gICAgICAgIGNvbnN0IHlGYWN0b3IgPSB5WzBdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICAgIGNvbnN0IHlWYWx1ZSA9IHlbMF0gPT09ICctJyA/IHlbMV0gOiB5WzBdO1xuICAgICAgICBjb25zdCB6ID0gbWFwWzJdLnRvTG93ZXJDYXNlKCkuc3BsaXQoJycpO1xuICAgICAgICBjb25zdCB6RmFjdG9yID0gelswXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICBjb25zdCB6VmFsdWUgPSB6WzBdID09PSAnLScgPyB6WzFdIDogelswXTtcbiAgICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICAvLyBUT0RPICh1eGRlcik6IEZpZ3VyZSBvdXQgdHlwZSBmaXggaGVyZS5cbiAgICAgICAgdmVjM1t4VmFsdWVdICogeEZhY3RvciwgdmVjM1t5VmFsdWVdICogeUZhY3RvciwgdmVjM1t6VmFsdWVdICogekZhY3Rvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIEZPViBhcyBjYW1lcmEgb24gYSBET00gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSBjYW1lcmFcbiAgICAgKi9cbiAgICBzdGF0aWMgc2V0Rm92KGVsZW1lbnQsIGNhbWVyYSkge1xuICAgICAgICBjb25zdCBmb3YgPSAoMC41IC8gTWF0aC50YW4oKGNhbWVyYVsnZm92J10gKiBNYXRoLlBJKSAvIDM2MCkpICogZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUucGVyc3BlY3RpdmVPcmlnaW4gPSAnNTAlIDUwJSc7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUucGVyc3BlY3RpdmUgPSBmb3YgKyAncHgnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiB2ZWN0b3IgYW5kIGV1bGVyIHJvdGF0aW9ucywgYXBwbGllcyB0cmFuc2Zvcm1zIHRvIGFuIGh0bWwgZWxlbWVudC5cbiAgICAgKiBUaGlzIHdvcmtzIGlmIHlvdXIgZG9tIGVsZW1lbnQgaXMgYWJzb2x1dGVseSBwb3NpdGlvbnMgd2l0aCB0aGUgY2FudmFzLlxuICAgICAqXG4gICAgICogR2l2ZW46XG4gICAgICpgYGBcbiAgICAgKiAudGV4dCB7XG4gICAgICogICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICogfVxuICAgICAqIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogcmVsYXRpdmU7IGhlaWdodDogMTAwdmg7IHdpZHRoOiAxMDB2d1wiPlxuICAgICAqICAgPGNhbnZhcz48L2NhbnZhcz5cbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJ0ZXh0XCI+SGVsbG8gaGVsbG88L2Rpdj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSB3b3VsZCBkbzpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICAgY29uc3QgZG9tQ29vcmRpbmF0ZXMgPSB0aHJlZWYudG9Eb21Db29yZGluYXRlcyhcbiAgICAgKiAgICAgICB0aHJlZU9iamVjdCwgdGhyZWVDYW1hcmEsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQsIDAuNVxuICAgICAqICAgKTtcbiAgICAgKiAgIGNvbnN0IGRvbVJvdGF0aW9uID0gdGhyZWVmLnRvRG9tUm90YXRpb24oXG4gICAgICogICAgICB0aHJlZU9iamVjdCwgdGhyZWVDYW1lcmEsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHRcbiAgICAgKiAgICk7XG4gICAgICpcbiAgICAgKiAgIC8vIFNldCB0aGUgcG9zaXRpb24gYW5kIHJvdGF0aW9uIG9mIG15RG9tRWxlbWVudCB0byBtYXRjaCB0aGUgdGhyZWVPYmplY3RcbiAgICAgKiAgIHRocmVlZi5hcHBseVZlY3RvclRvRG9tKG15RG9tRWxlbWVudCwgZG9tQ29vcmRpbmF0ZXMsIGRvbVJvdGF0aW9uKTtcbiAgICAgKlxuICAgICAqICAgLy8gU2V0IHRoZSBwb3NpdGlvbiwgcm90YXRpb24gb25seSBvZiBteURvbUVsZW1lbnQgdG8gbWF0Y2ggdGhlIHRocmVlT2JqZWN0IHdpdGhvdXQgc2NhbGluZ1xuICAgICAqICAgZG9tQ29vZGluYXRlcy56ID0gMTsgLy8gTm8gc2NhbGluZy5cbiAgICAgKiAgIHRocmVlZi5hcHBseVZlY3RvclRvRG9tKG15RG9tRWxlbWVudCwgZG9tQ29vcmRpbmF0ZXMsIGRvbVJvdGF0aW9uKTtcbiAgICAgKlxuICAgICAqICAgLy8gU2V0IHRoZSBwb3NpdGlvbiBvbmx5IG9mIG15RG9tRWxlbWVudCB0byBtYXRjaCB0aGUgdGhyZWVPYmplY3RcbiAgICAgKiAgIC8vIFRoaXMgcmVzdWx0cyBpbiBhIGJpbGxib2FyZGluZyBlZmZlY3QuXG4gICAgICogICB0aHJlZWYuYXBwbHlWZWN0b3JUb0RvbShteURvbUVsZW1lbnQsIGRvbUNvb3JkaW5hdGVzKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlWZWN0b3JUb0RvbShlbGVtZW50LCB2LCBldWxlcikge1xuICAgICAgICBpZiAoZXVsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZyA9IHtcbiAgICAgICAgICAgICAgICB4OiBtYXRoZl8xLm1hdGhmLnJhZGlhblRvRGVncmVlKGV1bGVyLngpLFxuICAgICAgICAgICAgICAgIHk6IG1hdGhmXzEubWF0aGYucmFkaWFuVG9EZWdyZWUoZXVsZXIueSksXG4gICAgICAgICAgICAgICAgejogbWF0aGZfMS5tYXRoZi5yYWRpYW5Ub0RlZ3JlZShldWxlci56KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgtNTAlLCAtNTAlKSB0cmFuc2xhdGUoJHt2Lnh9cHgsICR7di55fXB4KSByb3RhdGVYKCR7ZGVnLnh9ZGVnKSByb3RhdGVZKCR7ZGVnLnl9ZGVnKSByb3RhdGVaKCR7ZGVnLnp9ZGVnKSBzY2FsZSgke3Yuen0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHJvdGF0ZVgoJHtkZWcueH1kZWcpIHJvdGF0ZVkoJHtkZWcueX1kZWcpIHJvdGF0ZVooJHtkZWcuen1kZWcpYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgtNTAlLCAtNTAlKSB0cmFuc2xhdGUoJHt2ID09PSBudWxsIHx8IHYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHYueH1weCwgJHt2ID09PSBudWxsIHx8IHYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHYueX1weCkgc2NhbGUoJHt2ID09PSBudWxsIHx8IHYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHYuen0pYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBUSFJFRS5BbmltYXRpb25DbGlwcywgZG9lcyBhIHNlYXJjaCBmb3IgYW4gYW5pbWF0aW9uXG4gICAgICogY2xpcCBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QW5pbWF0aW9uQnlOYW1lKG5hbWUsIGFuaW1hdGlvbkNsaXBzKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb25DbGlwcy5maWx0ZXIoKGFuaW1hdGlvbkNsaXApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25DbGlwLm5hbWUgPT09IG5hbWU7XG4gICAgICAgIH0pWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIGN1cnJlbnQgc2NlbmUgY2hlY2tpbmcgZm9yIG1hdGNoIGNvbmRpdGlvbnMuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIC8vIExvb2sgZm9yIGFueSBtZXNoZXMgdGhhdCBhcmUgb2YgdGhlIG5hbWUgJ2hvaG9obycgb3IgJ2hvaG9obzInLlxuICAgICAqIC8vIGFuZCBjaGFuZ2UgdGhlIGFuaXN0cm9weSB0byAxMDAuXG4gICAgICpcbiAgICAgKiB0aHJlZWYudHJhdmVyc2VTY2VuZUZvcihcbiAgICAgKiAgIC8vIFRlc3QgY29uZGl0aW9uXG4gICAgICogICAodGhyZWVPYmplY3QpPT4ge1xuICAgICAqICAgICAgcmV0dXJuXG4gICAgICogICAgICAgICAodGhyZWVPYmplY3QgaW5zdGFuY2Ugb2YgVEhSRUUuTUVTSCkgJiZcbiAgICAgKiAgICAgICAgIH5bJ2hvaG9obycsICdob2hvaG8yJ10uaW5kZXhPZih0aHJlZU9iamVjdC5uYW1lKVxuICAgICAqICAgfSxcbiAgICAgKiAgICh0aHJlZU9iamVjdCk9PiB7XG4gICAgICogICAgICB0aHJlZU9iamVjdC5tYXRlcmlhbC5tYXAuYW5pc3Ryb3B5ID0gMTAwO1xuICAgICAqICAgICAgdGhyZWVPYmplY3QubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAqICAgfSxcbiAgICAgKiAgIG15U2NlbmVcbiAgICAgKiApXG4gICAgICpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyB0cmF2ZXJzZVNjZW5lRm9yKG1hdGNoQ29uZGl0aW9uLCBleGVjdXRpb24sIHNjZW5lKSB7XG4gICAgICAgIHNjZW5lLnRyYXZlcnNlKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGlmIChtYXRjaENvbmRpdGlvbihjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRpb24oY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBsaXN0IG9mIG5hbWVzLCBsb29rcyB0aHJvdWdoIHRoZSBvYmplY3RzIGluIHRoZSBzY2VuZXNcbiAgICAgKiBhbmQgcmV0dXJucyBhIGRpY3Rpb25hcnkgb2YgdGhlbSBzbyB0aGV5IGNhbiBiZSBxdWlja2x5IGFjY2Vzc2VkXG4gICAgICogYXQgYSBsYXRlciB0aW1lLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiAvLyBTcGVjaWZ5IHRoZSB0eXBlcyBvZiBvYmplY3RzIHlvdSB3YW50LlxuICAgICAqIGNvbnN0IHR5cGVNYXAgPSB7XG4gICAgICogICAgIC8vIE5vcm1hbGx5IGp1c3QgcGFzcyBhIHN0cmluZyBmb3IgdGhlIFwib2JqZWN0XCIgdHlwZVxuICAgICAqICAgICBtZXNoOiAnTWVzaCcsXG4gICAgICogICAgIC8vIFBhc3MgYXJyYXkgZm9yIG11bHRpcGxlXG4gICAgICogICAgIG15U3R1ZmY6IFsnTWVzaCcsICdQb2ludExpZ2h0J10sXG4gICAgICogICAgIC8vIEN1c3RvbSBzZWFyY2ggbG9naWMuXG4gICAgICogICAgIG1hdGVyaWFsczogKG9iamVjdCwgdHlwZSkgPT4ge1xuICAgICAqICAgICAgICAgcmV0dXJuIG9iamVjdC5tYXRlcmlhbFxuICAgICAqICAgICB9LFxuICAgICAqICAgICBsaWdodHM6IChvYmplY3QsIHR5cGUpPT4ge1xuICAgICAqICAgICAgICAgcmV0dXJuIH50eXBlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignbGlnaHQnKTtcbiAgICAgKiAgICAgIH1cbiAgICAgKiAgICAgcG9pbnRMaWdodDogJ1BvaW50TGlnaHQnLFxuICAgICAqICAgICBjYW1lcmFzOiAnUGVyc3BlY3RpdmVDYW1lcmEnLFxuICAgICAqIH1cbiAgICAgKiBjb25zdCBvYmplY3REaWN0aW9uYXJ5ID0gdGhyZWVmLm1ha2VPYmplY3REaWN0aW9uYXJ5RnJvbVNjZW5lKFxuICAgICAqICAgc2NlbmUsIHR5cGVNYXBcbiAgICAgKiApO1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBCYXNlZCBvbiB5b3VyIHR5cGVtYXAsIGEgZGljdGlvbmFyeSBpcyByZXR1cm5zIHdpdGggdGhhdCB0eXBlIG9mXG4gICAgICogb2JqZWN0IGNvbnRhaW5lZC5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIG9iamVjdERpY3Rpb25hcnkuYnlOYW1lWydteU9iamVjdDEnXTsgLy8gWW91ciBUSFJFRSBvYmplY3RcbiAgICAgKiBvYmplY3REaWN0aW9uYXJ5LmJ5TmFtZVsnbXlQb2ludGxpZ2h0MSddOyAvLyBZb3VyIFRIUkVFIHBvaW50bGlnaHQuXG4gICAgICpcbiAgICAgKiAvLyBBbGwgdGV4dCBtYXJrZXJzLlxuICAgICAqIC8vIEJ5IGNvbnZlbnRpb24sIHRleHQgbWFya2VycyBhcmUgYW55IG9iamVjdCB0aGF0IHN0YXJ0cyB3aXRoIHRoZVxuICAgICAqIC8vIG5hbWluZyAndGV4dC1tYXJrZXInIChJRTogdGV4dC1tYXJrZXIxLCB0ZXh0LW1hcmtlcjIgZXRjLilcbiAgICAgKiBvYmplY3REaWN0aW9uYXJ5LnRleHRNYXJrZXJzO1xuICAgICAqXG4gICAgICogb2JqZWN0RGljdGlvbmFyeS5tZXNoOyAvLyBBbGwgeW91ciBtZXNoZXNcbiAgICAgKiBvYmplY3REaWN0aW9uYXJ5Lm1hdGVyaWFsczsgLy8gQWxsIHlvdXIgbWF0ZXJpYWxzXG4gICAgICogb2JqZWN0RGljdGlvbmFyeS5saWdodHM7IC8vIEFsbCB5b3VyIGxpZ2h0c1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqIEBwYXJhbSBUSFJFRS5TY2VuZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVPYmplY3REaWN0aW9uYXJ5RnJvbVNjZW5lKHNjZW5lLCBtYXBwaW5nKSB7XG4gICAgICAgIGNvbnN0IGRpY3Rpb25hcnkgPSB7XG4gICAgICAgICAgICAvLyBTdG9yZXMgb2JqZWN0cyBieSBuYW1lLlxuICAgICAgICAgICAgYnlOYW1lOiB7fSxcbiAgICAgICAgICAgIHRleHRNYXJrZXJzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWFwcGluZykpIHtcbiAgICAgICAgICAgIGRpY3Rpb25hcnlba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHNjZW5lLnRyYXZlcnNlKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGRpY3Rpb25hcnkuYnlOYW1lW2NoaWxkLm5hbWVdID0gY2hpbGQ7XG4gICAgICAgICAgICBpZiAoY2hpbGQubmFtZS5zdGFydHNXaXRoKCd0ZXh0LScpKSB7XG4gICAgICAgICAgICAgICAgZGljdGlvbmFyeS50ZXh0TWFya2Vycy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgb2JqZWN0IG1hdGNoZXMgYSBzcGVjaWZpYyBtYXBwaW5nLlxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWFwcGluZykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1hcHBpbmdba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoX18xLmlzLnN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5W2tleV0ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF9fMS5pcy5hcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKH52YWx1ZS5pbmRleE9mKGNoaWxkLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5W2tleV0ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF9fMS5pcy5mdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKGNoaWxkLCBjaGlsZC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGljdGlvbmFyeVtrZXldLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRpY3Rpb25hcnk7XG4gICAgfVxuICAgIHN0YXRpYyBmaW5kU2NlbmVCeU5hbWUobmFtZSwgc2NlbmVzKSB7XG4gICAgICAgIGNvbnN0IHNjZW5lID0gc2NlbmVzLmZpbHRlcihzY2VuZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc2NlbmUubmFtZSA9PT0gbmFtZTtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHJldHVybiBzY2VuZTtcbiAgICB9XG59XG5leHBvcnRzLnRocmVlZiA9IHRocmVlZjtcbi8qIGVzbGludC1lbmFibGUgKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRocmVlZi5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/threef/threef.js\n");

/***/ }),

/***/ "./lib/time/fps.js":
/*!*************************!*\
  !*** ./lib/time/fps.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Fps = void 0;\nconst time_1 = __webpack_require__(/*! ../time/time */ \"./lib/time/time.js\");\n/**\n * A class that helps with time with fps.\n *\n *\n * ```ts\n *\n * class myClass {\n *    contructor() {\n *       this.fps = new Fps(30);\n *       draw();\n *    }\n *\n *    draw() {\n *        // Keep loop going.\n *        requestAnimationFrame(draw);\n *\n *        // Can run would return true when it is okay to execute limiting\n *        // the calls to 30 FPS.\n *        if(this.fps.canRun()) {\n *          // Do some expensive computation.\n *          canvas.drawImage(hugeImage);\n *        }\n *\n *    }\n * }\n * ```\n *\n * The above works but it is a simple gating a call to run at a set rate.\n * Here is a slightly more complex usage where you can \"schedule\" the last call.\n *\n * This will also draw at 30FPS but the difference is that it is debounced\n * so your very last call to draw is guaranteed to run when the drawing goes idle.\n *\n * ```ts\n *\n * class myClass {\n *    contructor() {\n *       this.fps = new Fps(30);\n *       this.index = 0;\n *       draw(1);\n *       draw(2);\n *       draw(3);  // This last one gets executed in this example.\n *    }\n *\n *    draw(index) {\n *        // If this call came too quickly between 30FPS, schedule it to run.\n *        if(!this.fps.canRun()) {\n *          this.fps.schedule(()=> {\n *             this.draw(index);\n *          });\n *          return;\n *        }\n *\n *        // Do something expensive here.\n *    }\n * }\n * ```\n *\n *\n *\n */\nclass Fps {\n    constructor(fps) {\n        /**\n         * The time measurement used to measure internal fps.\n         */\n        this.lastUpdateTime = 0;\n        /**\n         * A timeout that is used for scheduling.\n         */\n        this.scheduleTimeout = 0;\n        this.fps = fps;\n        this.locked = true;\n    }\n    /**\n     * Sets the fps.\n     * @param fps\n     */\n    setFps(fps) {\n        this.fps = fps;\n    }\n    /**\n     * Locks or Unlocks fps.  This forces canRun to always return true.\n     * This is useful in cases you need to temporarily remove\n     * FPS throttling.\n     *\n     * ```ts\n     *\n     * // On Window resize we want to run the drawLoop regardless\n     * // of FPS.  We can temporarily tell fps to be unlocked.\n     * resize() {\n     *    this.fps.lock(false);\n     *    this.drawLoop();\n     *    this.fps.lock(true);\n     * }\n     *\n     *\n     * // Runs on RAF\n     * drawLoop() {\n     *  if(this.fps.canRun()) {\n     *     // Do some expensive computation.\n     *     canvas.drawImage(hugeImage);\n     *  }\n     * }\n     *\n     * ```\n     */\n    lock(lock) {\n        this.locked = lock;\n    }\n    /**\n     * Schedules a callback to force run after a set period.\n     */\n    schedule(callback) {\n        this.cancelSchedule();\n        this.scheduleTimeout = window.setTimeout(() => {\n            this.locked = false;\n            callback();\n            this.locked = true;\n        }, 1000 / this.fps + 1);\n    }\n    /**\n     * Clears the schdule timeout.\n     */\n    cancelSchedule() {\n        if (this.scheduleTimeout) {\n            window.clearTimeout(this.scheduleTimeout);\n        }\n    }\n    /**\n     * Checks the lastUpdateTime and checks if it is within the threshold\n     * of being allowed to run.  This method would return true if it's okay\n     * to run but return false a call should be culled.\n     */\n    canRun() {\n        this.cancelSchedule();\n        // If the FPS is unlocked always return true.\n        if (!this.locked) {\n            return true;\n        }\n        if (this.lastUpdateTime) {\n            const current = time_1.time.now();\n            const elapsed = current - this.lastUpdateTime;\n            const fps = this.fps === 0 ? 0 : 1000 / this.fps;\n            if (elapsed > fps) {\n                this.lastUpdateTime = time_1.time.now();\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        if (!this.lastUpdateTime) {\n            this.lastUpdateTime = time_1.time.now();\n            return true;\n        }\n        return false;\n    }\n}\nexports.Fps = Fps;\n//# sourceMappingURL=fps.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvdGltZS9mcHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdGltZS9mcHMuanM/NGU3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRnBzID0gdm9pZCAwO1xuY29uc3QgdGltZV8xID0gcmVxdWlyZShcIi4uL3RpbWUvdGltZVwiKTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGhlbHBzIHdpdGggdGltZSB3aXRoIGZwcy5cbiAqXG4gKlxuICogYGBgdHNcbiAqXG4gKiBjbGFzcyBteUNsYXNzIHtcbiAqICAgIGNvbnRydWN0b3IoKSB7XG4gKiAgICAgICB0aGlzLmZwcyA9IG5ldyBGcHMoMzApO1xuICogICAgICAgZHJhdygpO1xuICogICAgfVxuICpcbiAqICAgIGRyYXcoKSB7XG4gKiAgICAgICAgLy8gS2VlcCBsb29wIGdvaW5nLlxuICogICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3KTtcbiAqXG4gKiAgICAgICAgLy8gQ2FuIHJ1biB3b3VsZCByZXR1cm4gdHJ1ZSB3aGVuIGl0IGlzIG9rYXkgdG8gZXhlY3V0ZSBsaW1pdGluZ1xuICogICAgICAgIC8vIHRoZSBjYWxscyB0byAzMCBGUFMuXG4gKiAgICAgICAgaWYodGhpcy5mcHMuY2FuUnVuKCkpIHtcbiAqICAgICAgICAgIC8vIERvIHNvbWUgZXhwZW5zaXZlIGNvbXB1dGF0aW9uLlxuICogICAgICAgICAgY2FudmFzLmRyYXdJbWFnZShodWdlSW1hZ2UpO1xuICogICAgICAgIH1cbiAqXG4gKiAgICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGUgYWJvdmUgd29ya3MgYnV0IGl0IGlzIGEgc2ltcGxlIGdhdGluZyBhIGNhbGwgdG8gcnVuIGF0IGEgc2V0IHJhdGUuXG4gKiBIZXJlIGlzIGEgc2xpZ2h0bHkgbW9yZSBjb21wbGV4IHVzYWdlIHdoZXJlIHlvdSBjYW4gXCJzY2hlZHVsZVwiIHRoZSBsYXN0IGNhbGwuXG4gKlxuICogVGhpcyB3aWxsIGFsc28gZHJhdyBhdCAzMEZQUyBidXQgdGhlIGRpZmZlcmVuY2UgaXMgdGhhdCBpdCBpcyBkZWJvdW5jZWRcbiAqIHNvIHlvdXIgdmVyeSBsYXN0IGNhbGwgdG8gZHJhdyBpcyBndWFyYW50ZWVkIHRvIHJ1biB3aGVuIHRoZSBkcmF3aW5nIGdvZXMgaWRsZS5cbiAqXG4gKiBgYGB0c1xuICpcbiAqIGNsYXNzIG15Q2xhc3Mge1xuICogICAgY29udHJ1Y3RvcigpIHtcbiAqICAgICAgIHRoaXMuZnBzID0gbmV3IEZwcygzMCk7XG4gKiAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAqICAgICAgIGRyYXcoMSk7XG4gKiAgICAgICBkcmF3KDIpO1xuICogICAgICAgZHJhdygzKTsgIC8vIFRoaXMgbGFzdCBvbmUgZ2V0cyBleGVjdXRlZCBpbiB0aGlzIGV4YW1wbGUuXG4gKiAgICB9XG4gKlxuICogICAgZHJhdyhpbmRleCkge1xuICogICAgICAgIC8vIElmIHRoaXMgY2FsbCBjYW1lIHRvbyBxdWlja2x5IGJldHdlZW4gMzBGUFMsIHNjaGVkdWxlIGl0IHRvIHJ1bi5cbiAqICAgICAgICBpZighdGhpcy5mcHMuY2FuUnVuKCkpIHtcbiAqICAgICAgICAgIHRoaXMuZnBzLnNjaGVkdWxlKCgpPT4ge1xuICogICAgICAgICAgICAgdGhpcy5kcmF3KGluZGV4KTtcbiAqICAgICAgICAgIH0pO1xuICogICAgICAgICAgcmV0dXJuO1xuICogICAgICAgIH1cbiAqXG4gKiAgICAgICAgLy8gRG8gc29tZXRoaW5nIGV4cGVuc2l2ZSBoZXJlLlxuICogICAgfVxuICogfVxuICogYGBgXG4gKlxuICpcbiAqXG4gKi9cbmNsYXNzIEZwcyB7XG4gICAgY29uc3RydWN0b3IoZnBzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSBtZWFzdXJlbWVudCB1c2VkIHRvIG1lYXN1cmUgaW50ZXJuYWwgZnBzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlVGltZSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHRpbWVvdXQgdGhhdCBpcyB1c2VkIGZvciBzY2hlZHVsaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2hlZHVsZVRpbWVvdXQgPSAwO1xuICAgICAgICB0aGlzLmZwcyA9IGZwcztcbiAgICAgICAgdGhpcy5sb2NrZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmcHMuXG4gICAgICogQHBhcmFtIGZwc1xuICAgICAqL1xuICAgIHNldEZwcyhmcHMpIHtcbiAgICAgICAgdGhpcy5mcHMgPSBmcHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvY2tzIG9yIFVubG9ja3MgZnBzLiAgVGhpcyBmb3JjZXMgY2FuUnVuIHRvIGFsd2F5cyByZXR1cm4gdHJ1ZS5cbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlcyB5b3UgbmVlZCB0byB0ZW1wb3JhcmlseSByZW1vdmVcbiAgICAgKiBGUFMgdGhyb3R0bGluZy5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICpcbiAgICAgKiAvLyBPbiBXaW5kb3cgcmVzaXplIHdlIHdhbnQgdG8gcnVuIHRoZSBkcmF3TG9vcCByZWdhcmRsZXNzXG4gICAgICogLy8gb2YgRlBTLiAgV2UgY2FuIHRlbXBvcmFyaWx5IHRlbGwgZnBzIHRvIGJlIHVubG9ja2VkLlxuICAgICAqIHJlc2l6ZSgpIHtcbiAgICAgKiAgICB0aGlzLmZwcy5sb2NrKGZhbHNlKTtcbiAgICAgKiAgICB0aGlzLmRyYXdMb29wKCk7XG4gICAgICogICAgdGhpcy5mcHMubG9jayh0cnVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKlxuICAgICAqIC8vIFJ1bnMgb24gUkFGXG4gICAgICogZHJhd0xvb3AoKSB7XG4gICAgICogIGlmKHRoaXMuZnBzLmNhblJ1bigpKSB7XG4gICAgICogICAgIC8vIERvIHNvbWUgZXhwZW5zaXZlIGNvbXB1dGF0aW9uLlxuICAgICAqICAgICBjYW52YXMuZHJhd0ltYWdlKGh1Z2VJbWFnZSk7XG4gICAgICogIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBsb2NrKGxvY2spIHtcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBmb3JjZSBydW4gYWZ0ZXIgYSBzZXQgcGVyaW9kLlxuICAgICAqL1xuICAgIHNjaGVkdWxlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsU2NoZWR1bGUoKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHRoaXMubG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgfSwgMTAwMCAvIHRoaXMuZnBzICsgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgc2NoZHVsZSB0aW1lb3V0LlxuICAgICAqL1xuICAgIGNhbmNlbFNjaGVkdWxlKCkge1xuICAgICAgICBpZiAodGhpcy5zY2hlZHVsZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5zY2hlZHVsZVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgbGFzdFVwZGF0ZVRpbWUgYW5kIGNoZWNrcyBpZiBpdCBpcyB3aXRoaW4gdGhlIHRocmVzaG9sZFxuICAgICAqIG9mIGJlaW5nIGFsbG93ZWQgdG8gcnVuLiAgVGhpcyBtZXRob2Qgd291bGQgcmV0dXJuIHRydWUgaWYgaXQncyBva2F5XG4gICAgICogdG8gcnVuIGJ1dCByZXR1cm4gZmFsc2UgYSBjYWxsIHNob3VsZCBiZSBjdWxsZWQuXG4gICAgICovXG4gICAgY2FuUnVuKCkge1xuICAgICAgICB0aGlzLmNhbmNlbFNjaGVkdWxlKCk7XG4gICAgICAgIC8vIElmIHRoZSBGUFMgaXMgdW5sb2NrZWQgYWx3YXlzIHJldHVybiB0cnVlLlxuICAgICAgICBpZiAoIXRoaXMubG9ja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXN0VXBkYXRlVGltZSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRpbWVfMS50aW1lLm5vdygpO1xuICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IGN1cnJlbnQgLSB0aGlzLmxhc3RVcGRhdGVUaW1lO1xuICAgICAgICAgICAgY29uc3QgZnBzID0gdGhpcy5mcHMgPT09IDAgPyAwIDogMTAwMCAvIHRoaXMuZnBzO1xuICAgICAgICAgICAgaWYgKGVsYXBzZWQgPiBmcHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RVcGRhdGVUaW1lID0gdGltZV8xLnRpbWUubm93KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmxhc3RVcGRhdGVUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RVcGRhdGVUaW1lID0gdGltZV8xLnRpbWUubm93KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5GcHMgPSBGcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcHMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/time/fps.js\n");

/***/ }),

/***/ "./lib/time/time.js":
/*!**************************!*\
  !*** ./lib/time/time.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.time = void 0;\nconst is_1 = __webpack_require__(/*! ../is/is */ \"./lib/is/is.js\");\n/**\n * A class that helps with time.\n */\nclass time {\n    /**\n     * Returns the current time.\n     */\n    static now() {\n        return Date.now();\n    }\n    /**\n     * Calculates the time difference in milliseconds between to times.\n     *\n     * ```ts\n     * let startTime = time.now();\n     *\n     * window.setTimeout(() {\n     *   let diff = time.timDiffMs(startTime, time.now());\n     *   console.log(diff); // 300\n     * }, 300);\n     *\n     * ```\n     * @param startTime\n     * @param endTime\n     */\n    static timeDiffMs(startTime, endTime) {\n        return endTime - startTime;\n    }\n    /**\n     * Given a startTime and endTime, tests whether the provided testTime\n     * is within that time.\n     * @param startTime\n     * @param endTime\n     * @param testTime\n     */\n    static isInBetween(startTime, endTime, testTime) {\n        if (startTime && endTime) {\n            return testTime >= startTime && testTime < endTime;\n        }\n        else if (startTime) {\n            return testTime >= startTime;\n        }\n        else if (endTime) {\n            return testTime < endTime;\n        }\n        return false;\n    }\n    /**\n     * Converts a utc based time that you might created into the local time.\n     *\n     * ```\n     * const myUTCDate = new Date('2020-06-20 03:45:00');\n     * const theUTCDateInLocalTime = time.utcDateToLocalTimeZone(myUTCDate);\n     *\n     *\n     * // Do Stuff.  Now it is in local time zone.\n     * const diff = thisUTCDateInLocalTime - new Date();\n     * ```\n     * Now the theUTCDateInLocalTime is the UTC time adjusted to your\n     * local computer timezone.\n     *\n     * @param utcDate\n     */\n    static utcDateToLocalTimeZone(utcDate) {\n        // Safari for some reason, defaults to utc and does the conversion\n        // for you.\n        if (is_1.is.safari()) {\n            return utcDate;\n        }\n        else {\n            const timeOffsetInMS = utcDate.getTimezoneOffset() * 60000;\n            return new Date(utcDate.getTime() - timeOffsetInMS);\n        }\n    }\n    /**\n     * Create a local timezone date string.  This is mainly here to normalize\n     * browser differences.  Safari creates a new date in utc whereas\n     * other browsers create the date based on the users timezone.\n     *\n     * By using this method, you are guaranteed that the created date is adjusted\n     * to the current users computer time.\n     * ---\n     *\n     * const myDate = time.createLocalTimeZoneDate('2021-06-20T03:45:00');\n     * const myDate2 = time.createLocalTimeZoneDate('2021-06-20 03:45:00');\n     *\n     * ---\n     *\n     * The localTimeDate would be the localtime on the users computer.\n     *\n     * ---\n     * const myDate = time.createLocalTimeZoneDate('2021-06-20T03:45:00');\n     * ---\n     */\n    static createLocalTimeZoneDate(localTimeDate) {\n        if (is_1.is.safari()) {\n            const utcDate = new Date(localTimeDate);\n            const timeOffsetInMS = utcDate.getTimezoneOffset() * 60000;\n            // Add it since safari creates it in UTC.\n            return new Date(utcDate.getTime() + timeOffsetInMS);\n        }\n        else {\n            return new Date(localTimeDate);\n        }\n    }\n    /**\n     * Converts a pacific time over to utc.\n     *\n     * ---\n     * const myPacificTime = '2020-12-12 03:34:00';\n     * time.pacificTimeToLocalTimeDate(myPacificTime);\n     *\n     * ---\n     *\n     */\n    static pacificTimeToLocalTimeDate(pacificTime) {\n        // First create the time locally.\n        // 7 Hour diff.\n        const pacificOffset = 420 * 60000;\n        // UTC\n        const utc = new Date(new Date(pacificTime).getTime() + pacificOffset);\n        return time.utcDateToLocalTimeZone(utc);\n    }\n    /**\n     * Converts a pacific time over to utc.\n     *\n     * ---\n     * const myEastTime = '2020-12-12 03:34:00';\n     * time.easternTimeToLocalTimeDate(myEastern);\n     *\n     * ---\n     *\n     */\n    static easternTimeToLocalTimeDate(pacificTime) {\n        // First create the time locally.\n        // 4 Hour diff.\n        const pacificOffset = 240 * 60000;\n        // UTC\n        const utc = new Date(new Date(pacificTime).getTime() + pacificOffset);\n        return time.utcDateToLocalTimeZone(utc);\n    }\n    /**\n     * Use to calculate the countdown to a given time.  Note that the\n     * currentTime and endTime should both be in the same local timezone.\n     *\n     * Returns an object with days, hours, minutes, seconds.\n     *\n     * ```\n     * const now = new Date();\n     * const endTime = new Date('2021-06-20 03:34:00 UTC');\n     * const countDown = time.countdown(now, endTime);\n     *\n     *\n     * countdown.days; // the number of days\n     * countdown.hours; // the number of hours\n     * countdown.minutes; // the number of minutes\n     * countdown.seconds; // the number of seconds\n     * ```\n     */\n    static countdown(currentTime, endTime) {\n        const time = endTime.getTime() - currentTime.getTime();\n        return {\n            days: Math.floor(time / (1000 * 60 * 60 * 24)),\n            hours: Math.floor((time % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)),\n            minutes: Math.floor((time % (1000 * 60 * 60)) / (1000 * 60)),\n            seconds: Math.floor((time % (1000 * 60)) / 1000),\n        };\n    }\n}\nexports.time = time;\n//# sourceMappingURL=time.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvdGltZS90aW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3RpbWUvdGltZS5qcz80NzhiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50aW1lID0gdm9pZCAwO1xuY29uc3QgaXNfMSA9IHJlcXVpcmUoXCIuLi9pcy9pc1wiKTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGhlbHBzIHdpdGggdGltZS5cbiAqL1xuY2xhc3MgdGltZSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCB0aW1lLlxuICAgICAqL1xuICAgIHN0YXRpYyBub3coKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB0aW1lIGRpZmZlcmVuY2UgaW4gbWlsbGlzZWNvbmRzIGJldHdlZW4gdG8gdGltZXMuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGxldCBzdGFydFRpbWUgPSB0aW1lLm5vdygpO1xuICAgICAqXG4gICAgICogd2luZG93LnNldFRpbWVvdXQoKCkge1xuICAgICAqICAgbGV0IGRpZmYgPSB0aW1lLnRpbURpZmZNcyhzdGFydFRpbWUsIHRpbWUubm93KCkpO1xuICAgICAqICAgY29uc29sZS5sb2coZGlmZik7IC8vIDMwMFxuICAgICAqIH0sIDMwMCk7XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lXG4gICAgICogQHBhcmFtIGVuZFRpbWVcbiAgICAgKi9cbiAgICBzdGF0aWMgdGltZURpZmZNcyhzdGFydFRpbWUsIGVuZFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc3RhcnRUaW1lIGFuZCBlbmRUaW1lLCB0ZXN0cyB3aGV0aGVyIHRoZSBwcm92aWRlZCB0ZXN0VGltZVxuICAgICAqIGlzIHdpdGhpbiB0aGF0IHRpbWUuXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZVxuICAgICAqIEBwYXJhbSBlbmRUaW1lXG4gICAgICogQHBhcmFtIHRlc3RUaW1lXG4gICAgICovXG4gICAgc3RhdGljIGlzSW5CZXR3ZWVuKHN0YXJ0VGltZSwgZW5kVGltZSwgdGVzdFRpbWUpIHtcbiAgICAgICAgaWYgKHN0YXJ0VGltZSAmJiBlbmRUaW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdFRpbWUgPj0gc3RhcnRUaW1lICYmIHRlc3RUaW1lIDwgZW5kVGltZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0VGltZSA+PSBzdGFydFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW5kVGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlc3RUaW1lIDwgZW5kVGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgdXRjIGJhc2VkIHRpbWUgdGhhdCB5b3UgbWlnaHQgY3JlYXRlZCBpbnRvIHRoZSBsb2NhbCB0aW1lLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgbXlVVENEYXRlID0gbmV3IERhdGUoJzIwMjAtMDYtMjAgMDM6NDU6MDAnKTtcbiAgICAgKiBjb25zdCB0aGVVVENEYXRlSW5Mb2NhbFRpbWUgPSB0aW1lLnV0Y0RhdGVUb0xvY2FsVGltZVpvbmUobXlVVENEYXRlKTtcbiAgICAgKlxuICAgICAqXG4gICAgICogLy8gRG8gU3R1ZmYuICBOb3cgaXQgaXMgaW4gbG9jYWwgdGltZSB6b25lLlxuICAgICAqIGNvbnN0IGRpZmYgPSB0aGlzVVRDRGF0ZUluTG9jYWxUaW1lIC0gbmV3IERhdGUoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBOb3cgdGhlIHRoZVVUQ0RhdGVJbkxvY2FsVGltZSBpcyB0aGUgVVRDIHRpbWUgYWRqdXN0ZWQgdG8geW91clxuICAgICAqIGxvY2FsIGNvbXB1dGVyIHRpbWV6b25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHV0Y0RhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgdXRjRGF0ZVRvTG9jYWxUaW1lWm9uZSh1dGNEYXRlKSB7XG4gICAgICAgIC8vIFNhZmFyaSBmb3Igc29tZSByZWFzb24sIGRlZmF1bHRzIHRvIHV0YyBhbmQgZG9lcyB0aGUgY29udmVyc2lvblxuICAgICAgICAvLyBmb3IgeW91LlxuICAgICAgICBpZiAoaXNfMS5pcy5zYWZhcmkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0Y0RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lT2Zmc2V0SW5NUyA9IHV0Y0RhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHV0Y0RhdGUuZ2V0VGltZSgpIC0gdGltZU9mZnNldEluTVMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGxvY2FsIHRpbWV6b25lIGRhdGUgc3RyaW5nLiAgVGhpcyBpcyBtYWlubHkgaGVyZSB0byBub3JtYWxpemVcbiAgICAgKiBicm93c2VyIGRpZmZlcmVuY2VzLiAgU2FmYXJpIGNyZWF0ZXMgYSBuZXcgZGF0ZSBpbiB1dGMgd2hlcmVhc1xuICAgICAqIG90aGVyIGJyb3dzZXJzIGNyZWF0ZSB0aGUgZGF0ZSBiYXNlZCBvbiB0aGUgdXNlcnMgdGltZXpvbmUuXG4gICAgICpcbiAgICAgKiBCeSB1c2luZyB0aGlzIG1ldGhvZCwgeW91IGFyZSBndWFyYW50ZWVkIHRoYXQgdGhlIGNyZWF0ZWQgZGF0ZSBpcyBhZGp1c3RlZFxuICAgICAqIHRvIHRoZSBjdXJyZW50IHVzZXJzIGNvbXB1dGVyIHRpbWUuXG4gICAgICogLS0tXG4gICAgICpcbiAgICAgKiBjb25zdCBteURhdGUgPSB0aW1lLmNyZWF0ZUxvY2FsVGltZVpvbmVEYXRlKCcyMDIxLTA2LTIwVDAzOjQ1OjAwJyk7XG4gICAgICogY29uc3QgbXlEYXRlMiA9IHRpbWUuY3JlYXRlTG9jYWxUaW1lWm9uZURhdGUoJzIwMjEtMDYtMjAgMDM6NDU6MDAnKTtcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqXG4gICAgICogVGhlIGxvY2FsVGltZURhdGUgd291bGQgYmUgdGhlIGxvY2FsdGltZSBvbiB0aGUgdXNlcnMgY29tcHV0ZXIuXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBjb25zdCBteURhdGUgPSB0aW1lLmNyZWF0ZUxvY2FsVGltZVpvbmVEYXRlKCcyMDIxLTA2LTIwVDAzOjQ1OjAwJyk7XG4gICAgICogLS0tXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUxvY2FsVGltZVpvbmVEYXRlKGxvY2FsVGltZURhdGUpIHtcbiAgICAgICAgaWYgKGlzXzEuaXMuc2FmYXJpKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHV0Y0RhdGUgPSBuZXcgRGF0ZShsb2NhbFRpbWVEYXRlKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVPZmZzZXRJbk1TID0gdXRjRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDA7XG4gICAgICAgICAgICAvLyBBZGQgaXQgc2luY2Ugc2FmYXJpIGNyZWF0ZXMgaXQgaW4gVVRDLlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHV0Y0RhdGUuZ2V0VGltZSgpICsgdGltZU9mZnNldEluTVMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGxvY2FsVGltZURhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgcGFjaWZpYyB0aW1lIG92ZXIgdG8gdXRjLlxuICAgICAqXG4gICAgICogLS0tXG4gICAgICogY29uc3QgbXlQYWNpZmljVGltZSA9ICcyMDIwLTEyLTEyIDAzOjM0OjAwJztcbiAgICAgKiB0aW1lLnBhY2lmaWNUaW1lVG9Mb2NhbFRpbWVEYXRlKG15UGFjaWZpY1RpbWUpO1xuICAgICAqXG4gICAgICogLS0tXG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFjaWZpY1RpbWVUb0xvY2FsVGltZURhdGUocGFjaWZpY1RpbWUpIHtcbiAgICAgICAgLy8gRmlyc3QgY3JlYXRlIHRoZSB0aW1lIGxvY2FsbHkuXG4gICAgICAgIC8vIDcgSG91ciBkaWZmLlxuICAgICAgICBjb25zdCBwYWNpZmljT2Zmc2V0ID0gNDIwICogNjAwMDA7XG4gICAgICAgIC8vIFVUQ1xuICAgICAgICBjb25zdCB1dGMgPSBuZXcgRGF0ZShuZXcgRGF0ZShwYWNpZmljVGltZSkuZ2V0VGltZSgpICsgcGFjaWZpY09mZnNldCk7XG4gICAgICAgIHJldHVybiB0aW1lLnV0Y0RhdGVUb0xvY2FsVGltZVpvbmUodXRjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBwYWNpZmljIHRpbWUgb3ZlciB0byB1dGMuXG4gICAgICpcbiAgICAgKiAtLS1cbiAgICAgKiBjb25zdCBteUVhc3RUaW1lID0gJzIwMjAtMTItMTIgMDM6MzQ6MDAnO1xuICAgICAqIHRpbWUuZWFzdGVyblRpbWVUb0xvY2FsVGltZURhdGUobXlFYXN0ZXJuKTtcbiAgICAgKlxuICAgICAqIC0tLVxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGVhc3Rlcm5UaW1lVG9Mb2NhbFRpbWVEYXRlKHBhY2lmaWNUaW1lKSB7XG4gICAgICAgIC8vIEZpcnN0IGNyZWF0ZSB0aGUgdGltZSBsb2NhbGx5LlxuICAgICAgICAvLyA0IEhvdXIgZGlmZi5cbiAgICAgICAgY29uc3QgcGFjaWZpY09mZnNldCA9IDI0MCAqIDYwMDAwO1xuICAgICAgICAvLyBVVENcbiAgICAgICAgY29uc3QgdXRjID0gbmV3IERhdGUobmV3IERhdGUocGFjaWZpY1RpbWUpLmdldFRpbWUoKSArIHBhY2lmaWNPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGltZS51dGNEYXRlVG9Mb2NhbFRpbWVab25lKHV0Yyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSB0byBjYWxjdWxhdGUgdGhlIGNvdW50ZG93biB0byBhIGdpdmVuIHRpbWUuICBOb3RlIHRoYXQgdGhlXG4gICAgICogY3VycmVudFRpbWUgYW5kIGVuZFRpbWUgc2hvdWxkIGJvdGggYmUgaW4gdGhlIHNhbWUgbG9jYWwgdGltZXpvbmUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGRheXMsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgKiBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoJzIwMjEtMDYtMjAgMDM6MzQ6MDAgVVRDJyk7XG4gICAgICogY29uc3QgY291bnREb3duID0gdGltZS5jb3VudGRvd24obm93LCBlbmRUaW1lKTtcbiAgICAgKlxuICAgICAqXG4gICAgICogY291bnRkb3duLmRheXM7IC8vIHRoZSBudW1iZXIgb2YgZGF5c1xuICAgICAqIGNvdW50ZG93bi5ob3VyczsgLy8gdGhlIG51bWJlciBvZiBob3Vyc1xuICAgICAqIGNvdW50ZG93bi5taW51dGVzOyAvLyB0aGUgbnVtYmVyIG9mIG1pbnV0ZXNcbiAgICAgKiBjb3VudGRvd24uc2Vjb25kczsgLy8gdGhlIG51bWJlciBvZiBzZWNvbmRzXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIGNvdW50ZG93bihjdXJyZW50VGltZSwgZW5kVGltZSkge1xuICAgICAgICBjb25zdCB0aW1lID0gZW5kVGltZS5nZXRUaW1lKCkgLSBjdXJyZW50VGltZS5nZXRUaW1lKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXlzOiBNYXRoLmZsb29yKHRpbWUgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpLFxuICAgICAgICAgICAgaG91cnM6IE1hdGguZmxvb3IoKHRpbWUgJSAoMTAwMCAqIDYwICogNjAgKiAyNCkpIC8gKDEwMDAgKiA2MCAqIDYwKSksXG4gICAgICAgICAgICBtaW51dGVzOiBNYXRoLmZsb29yKCh0aW1lICUgKDEwMDAgKiA2MCAqIDYwKSkgLyAoMTAwMCAqIDYwKSksXG4gICAgICAgICAgICBzZWNvbmRzOiBNYXRoLmZsb29yKCh0aW1lICUgKDEwMDAgKiA2MCkpIC8gMTAwMCksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy50aW1lID0gdGltZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/time/time.js\n");

/***/ }),

/***/ "./lib/ui/carousel/carousel.js":
/*!*************************************!*\
  !*** ./lib/ui/carousel/carousel.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Carousel = exports.CarouselEvent = void 0;\nconst transitions_1 = __webpack_require__(/*! ./transitions */ \"./lib/ui/carousel/transitions.js\");\nconst __1 = __webpack_require__(/*! ../.. */ \"./lib/index.js\");\nconst events_1 = __webpack_require__(/*! ../events */ \"./lib/ui/events.js\");\nconst setf_1 = __webpack_require__(/*! ../../setf/setf */ \"./lib/setf/setf.js\");\nconst arrayf_1 = __webpack_require__(/*! ../../arrayf/arrayf */ \"./lib/arrayf/arrayf.js\");\nconst DEFAULT_DISTANCE_TO_ACTIVE_SLIDE_ATTR = 'data-index';\n/**\n * For readability, specifies which half should be gotten by providing a\n * direction to loop through elements.\n */\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"LEFT\"] = -1] = \"LEFT\";\n    Direction[Direction[\"RIGHT\"] = 1] = \"RIGHT\";\n})(Direction || (Direction = {}));\n/**\n * Carousel events.\n */\nvar CarouselEvent;\n(function (CarouselEvent) {\n    CarouselEvent[\"BEFORE_CHANGE\"] = \"beforeChange\";\n    CarouselEvent[\"AFTER_CHANGE\"] = \"afterChange\";\n})(CarouselEvent = exports.CarouselEvent || (exports.CarouselEvent = {}));\n/**\n * Default classes applied to slide elements.\n */\nvar DefaultCssClass;\n(function (DefaultCssClass) {\n    DefaultCssClass[\"ACTIVE_SLIDE\"] = \"active\";\n    DefaultCssClass[\"BEFORE_SLIDE\"] = \"before\";\n    DefaultCssClass[\"AFTER_SLIDE\"] = \"after\";\n})(DefaultCssClass || (DefaultCssClass = {}));\n/**\n * Internal class used to manage autoplay behaviour.\n *\n * Stores and handles the information needed to pause and resume triggers using\n * a timeout.\n */\nclass AutoplayTimeout {\n    constructor(callback, delay) {\n        this.callback = callback;\n        this.delay = delay;\n        this.timePassed = 0;\n        this.timeout = setTimeout(callback, delay);\n        this.lastStartTime = +new Date();\n    }\n    /**\n     * Returns true if the timeout autoplay timeout is currently paused/disabled.\n     */\n    isPaused() {\n        return this.timeout === null;\n    }\n    /**\n     * Disable the timeout to pause the autplay.\n     */\n    pause() {\n        this.timePassed += +new Date() - this.lastStartTime;\n        this.clear();\n    }\n    /**\n     * Create a new timeout with the time remaining when the autoplay was paused.\n     */\n    unpause() {\n        if (!this.isPaused()) {\n            return;\n        }\n        this.timeout = setTimeout(this.callback, this.delay - this.timePassed);\n        this.lastStartTime = +new Date();\n    }\n    /**\n     * Dispose of the timeout.\n     */\n    dispose() {\n        this.clear();\n    }\n    clear() {\n        if (this.timeout) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n    }\n}\nclass Carousel {\n    /**\n     * @param container Parent element of slides.\n     * Element that acts as the carousel, in which all slides are contained.\n     * Does not need to be the direct parent.\n     *\n     * @param slides HTMLElements containing slide content.\n     *\n     * @param condition Under what conditions the carousel should run\n     * @param activeCssClass Class to apply to active slide.\n     * @param beforeCssClass Class to apply to slides before active slide.\n     * @param afterCssClass Class to apply to slides after active slide.\n     * @param distanceToActiveSlideAttr Slide attribute on which the index\n     *     distance to the currently active slide is set.\n     * @param loop Whether the carousel should be allowed to loop.\n     * @param transition How the Carousel should transition.\n     * @param autoplaySpeed How long the carousel should stay on a slide (in ms)\n     *     before transitioning to the next slide.\n     */\n    constructor(container, slides, { condition = () => true, activeCssClass = DefaultCssClass.ACTIVE_SLIDE, beforeCssClass = DefaultCssClass.BEFORE_SLIDE, afterCssClass = DefaultCssClass.AFTER_SLIDE, distanceToActiveSlideAttr = DEFAULT_DISTANCE_TO_ACTIVE_SLIDE_ATTR, loop = true, transition = undefined, autoplaySpeed = undefined, } = {}) {\n        if (slides.length < 1) {\n            throw new Error('Cannot start carousel without slides');\n        }\n        this.raf = new __1.Raf(() => this.onRaf());\n        this.activeCssClass = activeCssClass;\n        this.beforeCssClass = beforeCssClass;\n        this.afterCssClass = afterCssClass;\n        this.distanceToActiveSlideAttr = distanceToActiveSlideAttr;\n        this.loop = loop;\n        this.condition = condition;\n        this.container = container;\n        this.lastActiveSlide = null;\n        this.eventManager = new events_1.EventManager();\n        this.slides = slides;\n        if (typeof transition === 'string') {\n            switch (transition) {\n                case 'css':\n                    this.transition = new transitions_1.CssClassesOnly();\n                    break;\n                case 'draggable':\n                    this.transition = new transitions_1.DraggableSlide();\n                    break;\n                default:\n                    throw new Error(`Unrecognized transition type \"${transition}\" passed to ` +\n                        'Carousel.');\n            }\n        }\n        else {\n            this.transition = transition || new transitions_1.CssClassesOnly();\n        }\n        this.transitionTarget = null;\n        this.autoplaySpeed = autoplaySpeed;\n        this.autoplayTimeout = null;\n        this.syncedCarousels = new Set([this]);\n        this.init();\n    }\n    /**\n     * Returns true if the carousel is disabled, false otherwise.\n     */\n    isDisabled() {\n        return !this.condition();\n    }\n    /**\n     * Returns true if the carousel is enabled, false otherwise.\n     */\n    isEnabled() {\n        return this.condition();\n    }\n    /**\n     * Change the active slide to the given slide by either index or element.\n     */\n    goTo(target, drivenBySync = false) {\n        if (typeof target === 'number') {\n            this.goToIndex(target, drivenBySync);\n        }\n        else {\n            this.goToSlide(target, drivenBySync);\n        }\n    }\n    /**\n     * Transition the carousel to the given slide.\n     */\n    goToSlide(targetSlide, drivenBySync = false) {\n        if (this.isBeingInteractedWith()) {\n            return;\n        }\n        if (this.transitionTarget === targetSlide) {\n            return;\n        }\n        this.transitionTarget = targetSlide;\n        this.eventManager.dispatch(CarouselEvent.BEFORE_CHANGE, {\n            carousel: this,\n            currentSlide: this.getActiveSlide(),\n            currentIndex: this.getActiveIndex(),\n            nextSlide: this.transitionTarget,\n            nextIndex: this.getIndex(this.transitionTarget),\n        });\n        if (!drivenBySync) {\n            this.syncedCarousels.forEach(carousel => {\n                if (carousel !== this) {\n                    carousel.syncTo(this.getIndex(targetSlide), this);\n                }\n            });\n        }\n    }\n    /**\n     * Returns true if the user is interacting with the carousel.\n     */\n    isBeingInteractedWith() {\n        return this.transition.isInteracting();\n    }\n    /**\n     * Returns the currently active slide.\n     */\n    getActiveSlide() {\n        return this.transition.getActiveSlide();\n    }\n    /**\n     * Return the index of the currently active slide.\n     */\n    getActiveIndex() {\n        return this.getIndex(this.getActiveSlide());\n    }\n    /**\n     * Return the first slide in the carousel.\n     */\n    getFirstSlide() {\n        return this.slides[0];\n    }\n    /**\n     * Return the last slide in the carousel.\n     */\n    getLastSlide() {\n        return this.slides[this.slides.length - 1];\n    }\n    /**\n     * Return the index of the given slide within the list of slides.\n     * @param slide\n     */\n    getIndex(slide) {\n        return this.getSlides().indexOf(slide);\n    }\n    /**\n     * Return a copy of the list of slide elements.\n     */\n    getSlides() {\n        return [...this.slides];\n    }\n    /**\n     * Return the slides before the given slide. Looping if allowed.\n     * @param slide\n     */\n    getSlidesBefore(slide) {\n        if (this.loop) {\n            return this.splitSlidesInHalf(slide, Direction.LEFT);\n        }\n        else {\n            return this.getSlides().slice(0, this.getSlides().indexOf(slide));\n        }\n    }\n    /**\n     * Return the slides after the given slide. Looping if allowed.\n     * @param slide\n     */\n    getSlidesAfter(slide) {\n        if (this.loop) {\n            return this.splitSlidesInHalf(slide, Direction.RIGHT);\n        }\n        else {\n            return this.getSlides().slice(this.getSlides().indexOf(slide) + 1);\n        }\n    }\n    /**\n     * Go to the next slide.\n     */\n    next() {\n        this.transitionSlidesBy(1);\n    }\n    /**\n     * Go to the previous slide.\n     */\n    prev() {\n        this.transitionSlidesBy(-1);\n    }\n    /**\n     * Transition to the slide with the given index.\n     */\n    goToIndex(index, drivenBySync = false) {\n        const clampedIndex = this.getClampedIndex(index);\n        this.goToSlide(this.getSlideByIndex(clampedIndex), drivenBySync);\n    }\n    /**\n     * Register a function to be called when the given event is fired.\n     */\n    on(event, callback) {\n        this.eventManager.on(event, callback);\n    }\n    /**\n     * Remove a function that is called when the given event is fired.\n     */\n    off(event, callback) {\n        this.eventManager.off(event, callback);\n    }\n    /**\n     * Return the slide element at the given index in the list of slides.\n     * @param index\n     */\n    getSlideByIndex(index) {\n        return this.slides[index];\n    }\n    /**\n     * Return the number of slides.\n     */\n    getSlideCount() {\n        return this.slides.length;\n    }\n    /**\n     * Dispose of the carousel.\n     */\n    dispose() {\n        this.raf.dispose();\n        this.transition.dispose();\n    }\n    /**\n     * Clear the transition target, stop transitioning.\n     */\n    stopTransition() {\n        this.transitionTarget = null;\n    }\n    /**\n     * Clamp a given index to land within the possible slide indices.\n     * @param index\n     */\n    getClampedIndex(index) {\n        const slidesLength = this.getSlides().length;\n        if (this.loop) {\n            return __1.mathf.wrap(index, 0, slidesLength);\n        }\n        else {\n            return __1.mathf.clamp(0, slidesLength - 1, index);\n        }\n    }\n    /**\n     * Synchronize this carousel with the given carousels.\n     */\n    sync(...carousels) {\n        const masterSet = setf_1.setf.merge(this.syncedCarousels, ...carousels.map(c => c.syncedCarousels));\n        this.syncedCarousels = masterSet;\n        masterSet.forEach(c => (c.syncedCarousels = masterSet));\n    }\n    /**\n     * Pause the autoplay functionality of the carousel.\n     */\n    pause() {\n        if (this.autoplayTimeout) {\n            this.autoplayTimeout.pause();\n        }\n    }\n    /**\n     * Unpause the autoplay functionality of the carousel.\n     */\n    unpause() {\n        if (this.autoplayTimeout) {\n            this.autoplayTimeout.unpause();\n        }\n    }\n    /**\n     * Returns true if the carousel autoplay is currently paused.\n     */\n    isPaused() {\n        return this.autoplayTimeout === null || this.autoplayTimeout.isPaused();\n    }\n    /**\n     * Transition to the slide `value` slides away.\n     * @param value\n     */\n    transitionSlidesBy(value) {\n        const nextIndex = this.getSlides().indexOf(this.transitionTarget || this.getActiveSlide()) +\n            value;\n        this.goToIndex(nextIndex);\n    }\n    /**\n     * Sync this carousel to the given index in the given carousel.\n     *\n     * Allow for syncing with duplicate slides.\n     *\n     * In some cases, to meet design requirements a carousel may need to\n     * duplicate some slides, for cases where a slide loops but due to a small\n     * number of slides, it may be visible on either side simultaneously.\n     *\n     * In this case, it may not be necessary to duplicate other synchronized\n     * carousels.\n     *\n     * Take the following case where there are images that loop that need to\n     * be duplicated, synchronized with dots acting as navigation, and a third\n     * carousel with copy that cross-fades depending on the active image.\n     *\n     * DOM Tags <a>, <b> and <c> are used as shorthand for the various slides.\n     *\n     * ```\n     * <div class=\"images\">\n     *   <a></a>\n     *   <b></b>\n     *   <c></c>\n     *   <a></a>\n     *   <b></b>\n     *   <c></c>\n     * </div>\n     * <div class=\"nav-dots\">\n     *   <a></a>\n     *   <b></b>\n     *   <c></c>\n     * </div>\n     * <div class=\"copy\">\n     *   <a></a>\n     *   <b></b>\n     *   <c></c>\n     * </div>\n     * ```\n     *\n     * If the user has moved the images so that the fourth image (an <a>) tag\n     * is visible, we would want the first slide in the other two to be the\n     * active slide.\n     *\n     * If the user were to click on the navigation to go to the second slide, it\n     * would seem odd if the images went backwards past the third image, and\n     * then on to the second image.\n     *\n     * Instead it would seem more natural for the slide to advance to the\n     * nearest copy of the second image, in this case, the fifth slide in the\n     * images carousel.\n     *\n     * We also run a modulus on the given index, for the case where things are\n     * the other way around, and the carousel we are syncing to has more slides\n     * than the current carousel.\n     *\n     * @param rawIndex\n     * @param carousel\n     * @private\n     */\n    syncTo(rawIndex, carousel) {\n        const index = rawIndex % this.getSlideCount();\n        // Assuming this carousel has more slides than the carousel we are syncing\n        // to:\n        // Use modulus to get the equivalent index of the current transition\n        // target, as if it were a slide in the carousel we are syncing to.\n        // If the slide counts match up, this modulus operation will be a no-op and\n        // no harm is done.\n        const equivalentTransitionTargetIndex = this.getIndex(this.transitionTarget) % carousel.getSlideCount();\n        // If we are already on an equivalent index, we can stop and return early.\n        if (equivalentTransitionTargetIndex === index) {\n            return;\n        }\n        // If the current carousel has more slides than the syncing carousel,\n        // then we want to grab the closest equivalent slide to transition to.\n        if (this.getSlideCount() > carousel.getSlideCount()) {\n            // Build a set of all equivalent indices.\n            const equivalentIndices = [];\n            let equivalentIndex = index;\n            while (equivalentIndex < this.getSlideCount()) {\n                equivalentIndices.push(equivalentIndex);\n                equivalentIndex += carousel.getSlideCount();\n            }\n            this.goTo(arrayf_1.arrayf.min(equivalentIndices, i => Math.abs(this.getActiveIndex() - i)), true);\n        }\n        else {\n            this.goTo(index, true);\n        }\n    }\n    /**\n     * Returns an integer number for half of the slides. The parameter\n     * specifies whether, if given an array containing an odd number of elements,\n     * the larger odd value for half should be returned, or the smaller even\n     * number.\n     * @param weightOdd\n     * @private\n     */\n    getHalfOfSlideCount(weightOdd) {\n        const halfLength = (this.getSlides().length - 1) / 2;\n        if (halfLength % 2 === 0) {\n            return halfLength;\n        }\n        else if (weightOdd) {\n            return Math.ceil(halfLength);\n        }\n        else {\n            return Math.floor(halfLength);\n        }\n    }\n    /**\n     * Return half of the slides by taking slides to one side of the given slide.\n     *\n     * This function assumes looping is enabled and loops around if needed to get\n     * half of the slides.\n     */\n    splitSlidesInHalf(slide, direction) {\n        const targetLength = this.getHalfOfSlideCount(direction === Direction.RIGHT);\n        const result = [];\n        let indexToAdd = this.getIndex(slide);\n        while (result.length < targetLength) {\n            // Build the looped index\n            indexToAdd = __1.mathf.wrap(indexToAdd + direction, 0, this.getSlideCount());\n            const slideToAdd = this.getSlideByIndex(indexToAdd);\n            if (direction === Direction.RIGHT) {\n                result.push(slideToAdd);\n            }\n            else {\n                result.unshift(slideToAdd);\n            }\n        }\n        return result;\n    }\n    /**\n     * Setup initial values.\n     */\n    init() {\n        this.transition.init(this);\n        this.raf.start();\n        this.resetAutoplayTimeout();\n    }\n    /**\n     * Clear the current autoplay timeout and prep a new one.\n     * @private\n     */\n    resetAutoplayTimeout() {\n        if (this.autoplaySpeed) {\n            if (this.autoplayTimeout) {\n                this.autoplayTimeout.dispose();\n            }\n            this.autoplayTimeout = new AutoplayTimeout(() => this.next(), this.autoplaySpeed);\n        }\n    }\n    /**\n     * Run the loop to do all the necessary work for the carousel.\n     */\n    onRaf() {\n        this.raf.read(() => {\n            if (!this.condition()) {\n                return;\n            }\n            if (this.isBeingInteractedWith()) {\n                this.resetAutoplayTimeout();\n            }\n            const activeSlide = this.getActiveSlide();\n            if (activeSlide !== this.lastActiveSlide) {\n                this.lastActiveSlide = activeSlide;\n                if (activeSlide) {\n                    this.updateClasses(activeSlide);\n                }\n            }\n            if (this.transitionTarget !== null) {\n                const hasTransitionedToTarget = this.transition.hasTransitionedTo(this.transitionTarget);\n                if (hasTransitionedToTarget) {\n                    this.transitionTarget = null;\n                    this.eventManager.dispatch(CarouselEvent.AFTER_CHANGE, {\n                        carousel: this,\n                        currentSlide: this.getActiveSlide(),\n                        currentIndex: this.getActiveIndex(),\n                    });\n                    this.resetAutoplayTimeout();\n                }\n                else {\n                    this.transition.transition(this.transitionTarget);\n                }\n            }\n        });\n    }\n    /**\n     * Update the slide elements' CSS classes\n     * @param activeSlide\n     */\n    updateClasses(activeSlide) {\n        const slidesBefore = this.getSlidesBefore(activeSlide);\n        const slidesAfter = this.getSlidesAfter(activeSlide);\n        this.raf.write(() => {\n            // Create active slide\n            activeSlide.classList.add(this.activeCssClass);\n            activeSlide.classList.remove(this.beforeCssClass, this.afterCssClass);\n            activeSlide.setAttribute(this.distanceToActiveSlideAttr, '0');\n            slidesBefore.reverse().forEach((slide, index) => {\n                slide.classList.add(this.beforeCssClass);\n                slide.classList.remove(this.activeCssClass, this.afterCssClass);\n                slide.setAttribute(this.distanceToActiveSlideAttr, `${-index - 1}`);\n            });\n            slidesAfter.forEach((slide, index) => {\n                slide.classList.add(this.afterCssClass);\n                slide.classList.remove(this.activeCssClass, this.beforeCssClass);\n                slide.setAttribute(this.distanceToActiveSlideAttr, `${index + 1}`);\n            });\n        });\n    }\n}\nexports.Carousel = Carousel;\n//# sourceMappingURL=carousel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdWkvY2Fyb3VzZWwvY2Fyb3VzZWwuanM/ZWY4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2Fyb3VzZWwgPSBleHBvcnRzLkNhcm91c2VsRXZlbnQgPSB2b2lkIDA7XG5jb25zdCB0cmFuc2l0aW9uc18xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbnNcIik7XG5jb25zdCBfXzEgPSByZXF1aXJlKFwiLi4vLi5cIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCIuLi9ldmVudHNcIik7XG5jb25zdCBzZXRmXzEgPSByZXF1aXJlKFwiLi4vLi4vc2V0Zi9zZXRmXCIpO1xuY29uc3QgYXJyYXlmXzEgPSByZXF1aXJlKFwiLi4vLi4vYXJyYXlmL2FycmF5ZlwiKTtcbmNvbnN0IERFRkFVTFRfRElTVEFOQ0VfVE9fQUNUSVZFX1NMSURFX0FUVFIgPSAnZGF0YS1pbmRleCc7XG4vKipcbiAqIEZvciByZWFkYWJpbGl0eSwgc3BlY2lmaWVzIHdoaWNoIGhhbGYgc2hvdWxkIGJlIGdvdHRlbiBieSBwcm92aWRpbmcgYVxuICogZGlyZWN0aW9uIHRvIGxvb3AgdGhyb3VnaCBlbGVtZW50cy5cbiAqL1xudmFyIERpcmVjdGlvbjtcbihmdW5jdGlvbiAoRGlyZWN0aW9uKSB7XG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkxFRlRcIl0gPSAtMV0gPSBcIkxFRlRcIjtcbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiUklHSFRcIl0gPSAxXSA9IFwiUklHSFRcIjtcbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcbi8qKlxuICogQ2Fyb3VzZWwgZXZlbnRzLlxuICovXG52YXIgQ2Fyb3VzZWxFdmVudDtcbihmdW5jdGlvbiAoQ2Fyb3VzZWxFdmVudCkge1xuICAgIENhcm91c2VsRXZlbnRbXCJCRUZPUkVfQ0hBTkdFXCJdID0gXCJiZWZvcmVDaGFuZ2VcIjtcbiAgICBDYXJvdXNlbEV2ZW50W1wiQUZURVJfQ0hBTkdFXCJdID0gXCJhZnRlckNoYW5nZVwiO1xufSkoQ2Fyb3VzZWxFdmVudCA9IGV4cG9ydHMuQ2Fyb3VzZWxFdmVudCB8fCAoZXhwb3J0cy5DYXJvdXNlbEV2ZW50ID0ge30pKTtcbi8qKlxuICogRGVmYXVsdCBjbGFzc2VzIGFwcGxpZWQgdG8gc2xpZGUgZWxlbWVudHMuXG4gKi9cbnZhciBEZWZhdWx0Q3NzQ2xhc3M7XG4oZnVuY3Rpb24gKERlZmF1bHRDc3NDbGFzcykge1xuICAgIERlZmF1bHRDc3NDbGFzc1tcIkFDVElWRV9TTElERVwiXSA9IFwiYWN0aXZlXCI7XG4gICAgRGVmYXVsdENzc0NsYXNzW1wiQkVGT1JFX1NMSURFXCJdID0gXCJiZWZvcmVcIjtcbiAgICBEZWZhdWx0Q3NzQ2xhc3NbXCJBRlRFUl9TTElERVwiXSA9IFwiYWZ0ZXJcIjtcbn0pKERlZmF1bHRDc3NDbGFzcyB8fCAoRGVmYXVsdENzc0NsYXNzID0ge30pKTtcbi8qKlxuICogSW50ZXJuYWwgY2xhc3MgdXNlZCB0byBtYW5hZ2UgYXV0b3BsYXkgYmVoYXZpb3VyLlxuICpcbiAqIFN0b3JlcyBhbmQgaGFuZGxlcyB0aGUgaW5mb3JtYXRpb24gbmVlZGVkIHRvIHBhdXNlIGFuZCByZXN1bWUgdHJpZ2dlcnMgdXNpbmdcbiAqIGEgdGltZW91dC5cbiAqL1xuY2xhc3MgQXV0b3BsYXlUaW1lb3V0IHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgZGVsYXkpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIHRoaXMudGltZVBhc3NlZCA9IDA7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5KTtcbiAgICAgICAgdGhpcy5sYXN0U3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGltZW91dCBhdXRvcGxheSB0aW1lb3V0IGlzIGN1cnJlbnRseSBwYXVzZWQvZGlzYWJsZWQuXG4gICAgICovXG4gICAgaXNQYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVvdXQgPT09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIHRpbWVvdXQgdG8gcGF1c2UgdGhlIGF1dHBsYXkuXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMudGltZVBhc3NlZCArPSArbmV3IERhdGUoKSAtIHRoaXMubGFzdFN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdGltZW91dCB3aXRoIHRoZSB0aW1lIHJlbWFpbmluZyB3aGVuIHRoZSBhdXRvcGxheSB3YXMgcGF1c2VkLlxuICAgICAqL1xuICAgIHVucGF1c2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNhbGxiYWNrLCB0aGlzLmRlbGF5IC0gdGhpcy50aW1lUGFzc2VkKTtcbiAgICAgICAgdGhpcy5sYXN0U3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ2Fyb3VzZWwge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb250YWluZXIgUGFyZW50IGVsZW1lbnQgb2Ygc2xpZGVzLlxuICAgICAqIEVsZW1lbnQgdGhhdCBhY3RzIGFzIHRoZSBjYXJvdXNlbCwgaW4gd2hpY2ggYWxsIHNsaWRlcyBhcmUgY29udGFpbmVkLlxuICAgICAqIERvZXMgbm90IG5lZWQgdG8gYmUgdGhlIGRpcmVjdCBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2xpZGVzIEhUTUxFbGVtZW50cyBjb250YWluaW5nIHNsaWRlIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZGl0aW9uIFVuZGVyIHdoYXQgY29uZGl0aW9ucyB0aGUgY2Fyb3VzZWwgc2hvdWxkIHJ1blxuICAgICAqIEBwYXJhbSBhY3RpdmVDc3NDbGFzcyBDbGFzcyB0byBhcHBseSB0byBhY3RpdmUgc2xpZGUuXG4gICAgICogQHBhcmFtIGJlZm9yZUNzc0NsYXNzIENsYXNzIHRvIGFwcGx5IHRvIHNsaWRlcyBiZWZvcmUgYWN0aXZlIHNsaWRlLlxuICAgICAqIEBwYXJhbSBhZnRlckNzc0NsYXNzIENsYXNzIHRvIGFwcGx5IHRvIHNsaWRlcyBhZnRlciBhY3RpdmUgc2xpZGUuXG4gICAgICogQHBhcmFtIGRpc3RhbmNlVG9BY3RpdmVTbGlkZUF0dHIgU2xpZGUgYXR0cmlidXRlIG9uIHdoaWNoIHRoZSBpbmRleFxuICAgICAqICAgICBkaXN0YW5jZSB0byB0aGUgY3VycmVudGx5IGFjdGl2ZSBzbGlkZSBpcyBzZXQuXG4gICAgICogQHBhcmFtIGxvb3AgV2hldGhlciB0aGUgY2Fyb3VzZWwgc2hvdWxkIGJlIGFsbG93ZWQgdG8gbG9vcC5cbiAgICAgKiBAcGFyYW0gdHJhbnNpdGlvbiBIb3cgdGhlIENhcm91c2VsIHNob3VsZCB0cmFuc2l0aW9uLlxuICAgICAqIEBwYXJhbSBhdXRvcGxheVNwZWVkIEhvdyBsb25nIHRoZSBjYXJvdXNlbCBzaG91bGQgc3RheSBvbiBhIHNsaWRlIChpbiBtcylcbiAgICAgKiAgICAgYmVmb3JlIHRyYW5zaXRpb25pbmcgdG8gdGhlIG5leHQgc2xpZGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBzbGlkZXMsIHsgY29uZGl0aW9uID0gKCkgPT4gdHJ1ZSwgYWN0aXZlQ3NzQ2xhc3MgPSBEZWZhdWx0Q3NzQ2xhc3MuQUNUSVZFX1NMSURFLCBiZWZvcmVDc3NDbGFzcyA9IERlZmF1bHRDc3NDbGFzcy5CRUZPUkVfU0xJREUsIGFmdGVyQ3NzQ2xhc3MgPSBEZWZhdWx0Q3NzQ2xhc3MuQUZURVJfU0xJREUsIGRpc3RhbmNlVG9BY3RpdmVTbGlkZUF0dHIgPSBERUZBVUxUX0RJU1RBTkNFX1RPX0FDVElWRV9TTElERV9BVFRSLCBsb29wID0gdHJ1ZSwgdHJhbnNpdGlvbiA9IHVuZGVmaW5lZCwgYXV0b3BsYXlTcGVlZCA9IHVuZGVmaW5lZCwgfSA9IHt9KSB7XG4gICAgICAgIGlmIChzbGlkZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3RhcnQgY2Fyb3VzZWwgd2l0aG91dCBzbGlkZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhZiA9IG5ldyBfXzEuUmFmKCgpID0+IHRoaXMub25SYWYoKSk7XG4gICAgICAgIHRoaXMuYWN0aXZlQ3NzQ2xhc3MgPSBhY3RpdmVDc3NDbGFzcztcbiAgICAgICAgdGhpcy5iZWZvcmVDc3NDbGFzcyA9IGJlZm9yZUNzc0NsYXNzO1xuICAgICAgICB0aGlzLmFmdGVyQ3NzQ2xhc3MgPSBhZnRlckNzc0NsYXNzO1xuICAgICAgICB0aGlzLmRpc3RhbmNlVG9BY3RpdmVTbGlkZUF0dHIgPSBkaXN0YW5jZVRvQWN0aXZlU2xpZGVBdHRyO1xuICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMubGFzdEFjdGl2ZVNsaWRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIgPSBuZXcgZXZlbnRzXzEuRXZlbnRNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuc2xpZGVzID0gc2xpZGVzO1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zaXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjc3MnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSBuZXcgdHJhbnNpdGlvbnNfMS5Dc3NDbGFzc2VzT25seSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkcmFnZ2FibGUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSBuZXcgdHJhbnNpdGlvbnNfMS5EcmFnZ2FibGVTbGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCB0cmFuc2l0aW9uIHR5cGUgXCIke3RyYW5zaXRpb259XCIgcGFzc2VkIHRvIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0Nhcm91c2VsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvbiB8fCBuZXcgdHJhbnNpdGlvbnNfMS5Dc3NDbGFzc2VzT25seSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuYXV0b3BsYXlTcGVlZCA9IGF1dG9wbGF5U3BlZWQ7XG4gICAgICAgIHRoaXMuYXV0b3BsYXlUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zeW5jZWRDYXJvdXNlbHMgPSBuZXcgU2V0KFt0aGlzXSk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNhcm91c2VsIGlzIGRpc2FibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNEaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbmRpdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNhcm91c2VsIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGFjdGl2ZSBzbGlkZSB0byB0aGUgZ2l2ZW4gc2xpZGUgYnkgZWl0aGVyIGluZGV4IG9yIGVsZW1lbnQuXG4gICAgICovXG4gICAgZ29Ubyh0YXJnZXQsIGRyaXZlbkJ5U3luYyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5nb1RvSW5kZXgodGFyZ2V0LCBkcml2ZW5CeVN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nb1RvU2xpZGUodGFyZ2V0LCBkcml2ZW5CeVN5bmMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zaXRpb24gdGhlIGNhcm91c2VsIHRvIHRoZSBnaXZlbiBzbGlkZS5cbiAgICAgKi9cbiAgICBnb1RvU2xpZGUodGFyZ2V0U2xpZGUsIGRyaXZlbkJ5U3luYyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQmVpbmdJbnRlcmFjdGVkV2l0aCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblRhcmdldCA9PT0gdGFyZ2V0U2xpZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zaXRpb25UYXJnZXQgPSB0YXJnZXRTbGlkZTtcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZGlzcGF0Y2goQ2Fyb3VzZWxFdmVudC5CRUZPUkVfQ0hBTkdFLCB7XG4gICAgICAgICAgICBjYXJvdXNlbDogdGhpcyxcbiAgICAgICAgICAgIGN1cnJlbnRTbGlkZTogdGhpcy5nZXRBY3RpdmVTbGlkZSgpLFxuICAgICAgICAgICAgY3VycmVudEluZGV4OiB0aGlzLmdldEFjdGl2ZUluZGV4KCksXG4gICAgICAgICAgICBuZXh0U2xpZGU6IHRoaXMudHJhbnNpdGlvblRhcmdldCxcbiAgICAgICAgICAgIG5leHRJbmRleDogdGhpcy5nZXRJbmRleCh0aGlzLnRyYW5zaXRpb25UYXJnZXQpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFkcml2ZW5CeVN5bmMpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY2VkQ2Fyb3VzZWxzLmZvckVhY2goY2Fyb3VzZWwgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYXJvdXNlbCAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICBjYXJvdXNlbC5zeW5jVG8odGhpcy5nZXRJbmRleCh0YXJnZXRTbGlkZSksIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdXNlciBpcyBpbnRlcmFjdGluZyB3aXRoIHRoZSBjYXJvdXNlbC5cbiAgICAgKi9cbiAgICBpc0JlaW5nSW50ZXJhY3RlZFdpdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb24uaXNJbnRlcmFjdGluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNsaWRlLlxuICAgICAqL1xuICAgIGdldEFjdGl2ZVNsaWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uLmdldEFjdGl2ZVNsaWRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2xpZGUuXG4gICAgICovXG4gICAgZ2V0QWN0aXZlSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEluZGV4KHRoaXMuZ2V0QWN0aXZlU2xpZGUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZmlyc3Qgc2xpZGUgaW4gdGhlIGNhcm91c2VsLlxuICAgICAqL1xuICAgIGdldEZpcnN0U2xpZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWRlc1swXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBsYXN0IHNsaWRlIGluIHRoZSBjYXJvdXNlbC5cbiAgICAgKi9cbiAgICBnZXRMYXN0U2xpZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWRlc1t0aGlzLnNsaWRlcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc2xpZGUgd2l0aGluIHRoZSBsaXN0IG9mIHNsaWRlcy5cbiAgICAgKiBAcGFyYW0gc2xpZGVcbiAgICAgKi9cbiAgICBnZXRJbmRleChzbGlkZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTbGlkZXMoKS5pbmRleE9mKHNsaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgY29weSBvZiB0aGUgbGlzdCBvZiBzbGlkZSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBnZXRTbGlkZXMoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5zbGlkZXNdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHNsaWRlcyBiZWZvcmUgdGhlIGdpdmVuIHNsaWRlLiBMb29waW5nIGlmIGFsbG93ZWQuXG4gICAgICogQHBhcmFtIHNsaWRlXG4gICAgICovXG4gICAgZ2V0U2xpZGVzQmVmb3JlKHNsaWRlKSB7XG4gICAgICAgIGlmICh0aGlzLmxvb3ApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwbGl0U2xpZGVzSW5IYWxmKHNsaWRlLCBEaXJlY3Rpb24uTEVGVCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTbGlkZXMoKS5zbGljZSgwLCB0aGlzLmdldFNsaWRlcygpLmluZGV4T2Yoc2xpZGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHNsaWRlcyBhZnRlciB0aGUgZ2l2ZW4gc2xpZGUuIExvb3BpbmcgaWYgYWxsb3dlZC5cbiAgICAgKiBAcGFyYW0gc2xpZGVcbiAgICAgKi9cbiAgICBnZXRTbGlkZXNBZnRlcihzbGlkZSkge1xuICAgICAgICBpZiAodGhpcy5sb29wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGxpdFNsaWRlc0luSGFsZihzbGlkZSwgRGlyZWN0aW9uLlJJR0hUKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNsaWRlcygpLnNsaWNlKHRoaXMuZ2V0U2xpZGVzKCkuaW5kZXhPZihzbGlkZSkgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHbyB0byB0aGUgbmV4dCBzbGlkZS5cbiAgICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25TbGlkZXNCeSgxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR28gdG8gdGhlIHByZXZpb3VzIHNsaWRlLlxuICAgICAqL1xuICAgIHByZXYoKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblNsaWRlc0J5KC0xKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNpdGlvbiB0byB0aGUgc2xpZGUgd2l0aCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICovXG4gICAgZ29Ub0luZGV4KGluZGV4LCBkcml2ZW5CeVN5bmMgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBjbGFtcGVkSW5kZXggPSB0aGlzLmdldENsYW1wZWRJbmRleChpbmRleCk7XG4gICAgICAgIHRoaXMuZ29Ub1NsaWRlKHRoaXMuZ2V0U2xpZGVCeUluZGV4KGNsYW1wZWRJbmRleCksIGRyaXZlbkJ5U3luYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGdpdmVuIGV2ZW50IGlzIGZpcmVkLlxuICAgICAqL1xuICAgIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5vbihldmVudCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBnaXZlbiBldmVudCBpcyBmaXJlZC5cbiAgICAgKi9cbiAgICBvZmYoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHNsaWRlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4IGluIHRoZSBsaXN0IG9mIHNsaWRlcy5cbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICBnZXRTbGlkZUJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpZGVzW2luZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2Ygc2xpZGVzLlxuICAgICAqL1xuICAgIGdldFNsaWRlQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsaWRlcy5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIGNhcm91c2VsLlxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMucmFmLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIHRyYW5zaXRpb24gdGFyZ2V0LCBzdG9wIHRyYW5zaXRpb25pbmcuXG4gICAgICovXG4gICAgc3RvcFRyYW5zaXRpb24oKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRhcmdldCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsYW1wIGEgZ2l2ZW4gaW5kZXggdG8gbGFuZCB3aXRoaW4gdGhlIHBvc3NpYmxlIHNsaWRlIGluZGljZXMuXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICovXG4gICAgZ2V0Q2xhbXBlZEluZGV4KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHNsaWRlc0xlbmd0aCA9IHRoaXMuZ2V0U2xpZGVzKCkubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5sb29wKSB7XG4gICAgICAgICAgICByZXR1cm4gX18xLm1hdGhmLndyYXAoaW5kZXgsIDAsIHNsaWRlc0xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX18xLm1hdGhmLmNsYW1wKDAsIHNsaWRlc0xlbmd0aCAtIDEsIGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbml6ZSB0aGlzIGNhcm91c2VsIHdpdGggdGhlIGdpdmVuIGNhcm91c2Vscy5cbiAgICAgKi9cbiAgICBzeW5jKC4uLmNhcm91c2Vscykge1xuICAgICAgICBjb25zdCBtYXN0ZXJTZXQgPSBzZXRmXzEuc2V0Zi5tZXJnZSh0aGlzLnN5bmNlZENhcm91c2VscywgLi4uY2Fyb3VzZWxzLm1hcChjID0+IGMuc3luY2VkQ2Fyb3VzZWxzKSk7XG4gICAgICAgIHRoaXMuc3luY2VkQ2Fyb3VzZWxzID0gbWFzdGVyU2V0O1xuICAgICAgICBtYXN0ZXJTZXQuZm9yRWFjaChjID0+IChjLnN5bmNlZENhcm91c2VscyA9IG1hc3RlclNldCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgYXV0b3BsYXkgZnVuY3Rpb25hbGl0eSBvZiB0aGUgY2Fyb3VzZWwuXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9wbGF5VGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy5hdXRvcGxheVRpbWVvdXQucGF1c2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnBhdXNlIHRoZSBhdXRvcGxheSBmdW5jdGlvbmFsaXR5IG9mIHRoZSBjYXJvdXNlbC5cbiAgICAgKi9cbiAgICB1bnBhdXNlKCkge1xuICAgICAgICBpZiAodGhpcy5hdXRvcGxheVRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b3BsYXlUaW1lb3V0LnVucGF1c2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNhcm91c2VsIGF1dG9wbGF5IGlzIGN1cnJlbnRseSBwYXVzZWQuXG4gICAgICovXG4gICAgaXNQYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dG9wbGF5VGltZW91dCA9PT0gbnVsbCB8fCB0aGlzLmF1dG9wbGF5VGltZW91dC5pc1BhdXNlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2l0aW9uIHRvIHRoZSBzbGlkZSBgdmFsdWVgIHNsaWRlcyBhd2F5LlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHRyYW5zaXRpb25TbGlkZXNCeSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLmdldFNsaWRlcygpLmluZGV4T2YodGhpcy50cmFuc2l0aW9uVGFyZ2V0IHx8IHRoaXMuZ2V0QWN0aXZlU2xpZGUoKSkgK1xuICAgICAgICAgICAgdmFsdWU7XG4gICAgICAgIHRoaXMuZ29Ub0luZGV4KG5leHRJbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmMgdGhpcyBjYXJvdXNlbCB0byB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIGdpdmVuIGNhcm91c2VsLlxuICAgICAqXG4gICAgICogQWxsb3cgZm9yIHN5bmNpbmcgd2l0aCBkdXBsaWNhdGUgc2xpZGVzLlxuICAgICAqXG4gICAgICogSW4gc29tZSBjYXNlcywgdG8gbWVldCBkZXNpZ24gcmVxdWlyZW1lbnRzIGEgY2Fyb3VzZWwgbWF5IG5lZWQgdG9cbiAgICAgKiBkdXBsaWNhdGUgc29tZSBzbGlkZXMsIGZvciBjYXNlcyB3aGVyZSBhIHNsaWRlIGxvb3BzIGJ1dCBkdWUgdG8gYSBzbWFsbFxuICAgICAqIG51bWJlciBvZiBzbGlkZXMsIGl0IG1heSBiZSB2aXNpYmxlIG9uIGVpdGhlciBzaWRlIHNpbXVsdGFuZW91c2x5LlxuICAgICAqXG4gICAgICogSW4gdGhpcyBjYXNlLCBpdCBtYXkgbm90IGJlIG5lY2Vzc2FyeSB0byBkdXBsaWNhdGUgb3RoZXIgc3luY2hyb25pemVkXG4gICAgICogY2Fyb3VzZWxzLlxuICAgICAqXG4gICAgICogVGFrZSB0aGUgZm9sbG93aW5nIGNhc2Ugd2hlcmUgdGhlcmUgYXJlIGltYWdlcyB0aGF0IGxvb3AgdGhhdCBuZWVkIHRvXG4gICAgICogYmUgZHVwbGljYXRlZCwgc3luY2hyb25pemVkIHdpdGggZG90cyBhY3RpbmcgYXMgbmF2aWdhdGlvbiwgYW5kIGEgdGhpcmRcbiAgICAgKiBjYXJvdXNlbCB3aXRoIGNvcHkgdGhhdCBjcm9zcy1mYWRlcyBkZXBlbmRpbmcgb24gdGhlIGFjdGl2ZSBpbWFnZS5cbiAgICAgKlxuICAgICAqIERPTSBUYWdzIDxhPiwgPGI+IGFuZCA8Yz4gYXJlIHVzZWQgYXMgc2hvcnRoYW5kIGZvciB0aGUgdmFyaW91cyBzbGlkZXMuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8ZGl2IGNsYXNzPVwiaW1hZ2VzXCI+XG4gICAgICogICA8YT48L2E+XG4gICAgICogICA8Yj48L2I+XG4gICAgICogICA8Yz48L2M+XG4gICAgICogICA8YT48L2E+XG4gICAgICogICA8Yj48L2I+XG4gICAgICogICA8Yz48L2M+XG4gICAgICogPC9kaXY+XG4gICAgICogPGRpdiBjbGFzcz1cIm5hdi1kb3RzXCI+XG4gICAgICogICA8YT48L2E+XG4gICAgICogICA8Yj48L2I+XG4gICAgICogICA8Yz48L2M+XG4gICAgICogPC9kaXY+XG4gICAgICogPGRpdiBjbGFzcz1cImNvcHlcIj5cbiAgICAgKiAgIDxhPjwvYT5cbiAgICAgKiAgIDxiPjwvYj5cbiAgICAgKiAgIDxjPjwvYz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIElmIHRoZSB1c2VyIGhhcyBtb3ZlZCB0aGUgaW1hZ2VzIHNvIHRoYXQgdGhlIGZvdXJ0aCBpbWFnZSAoYW4gPGE+KSB0YWdcbiAgICAgKiBpcyB2aXNpYmxlLCB3ZSB3b3VsZCB3YW50IHRoZSBmaXJzdCBzbGlkZSBpbiB0aGUgb3RoZXIgdHdvIHRvIGJlIHRoZVxuICAgICAqIGFjdGl2ZSBzbGlkZS5cbiAgICAgKlxuICAgICAqIElmIHRoZSB1c2VyIHdlcmUgdG8gY2xpY2sgb24gdGhlIG5hdmlnYXRpb24gdG8gZ28gdG8gdGhlIHNlY29uZCBzbGlkZSwgaXRcbiAgICAgKiB3b3VsZCBzZWVtIG9kZCBpZiB0aGUgaW1hZ2VzIHdlbnQgYmFja3dhcmRzIHBhc3QgdGhlIHRoaXJkIGltYWdlLCBhbmRcbiAgICAgKiB0aGVuIG9uIHRvIHRoZSBzZWNvbmQgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBJbnN0ZWFkIGl0IHdvdWxkIHNlZW0gbW9yZSBuYXR1cmFsIGZvciB0aGUgc2xpZGUgdG8gYWR2YW5jZSB0byB0aGVcbiAgICAgKiBuZWFyZXN0IGNvcHkgb2YgdGhlIHNlY29uZCBpbWFnZSwgaW4gdGhpcyBjYXNlLCB0aGUgZmlmdGggc2xpZGUgaW4gdGhlXG4gICAgICogaW1hZ2VzIGNhcm91c2VsLlxuICAgICAqXG4gICAgICogV2UgYWxzbyBydW4gYSBtb2R1bHVzIG9uIHRoZSBnaXZlbiBpbmRleCwgZm9yIHRoZSBjYXNlIHdoZXJlIHRoaW5ncyBhcmVcbiAgICAgKiB0aGUgb3RoZXIgd2F5IGFyb3VuZCwgYW5kIHRoZSBjYXJvdXNlbCB3ZSBhcmUgc3luY2luZyB0byBoYXMgbW9yZSBzbGlkZXNcbiAgICAgKiB0aGFuIHRoZSBjdXJyZW50IGNhcm91c2VsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJhd0luZGV4XG4gICAgICogQHBhcmFtIGNhcm91c2VsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzeW5jVG8ocmF3SW5kZXgsIGNhcm91c2VsKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcmF3SW5kZXggJSB0aGlzLmdldFNsaWRlQ291bnQoKTtcbiAgICAgICAgLy8gQXNzdW1pbmcgdGhpcyBjYXJvdXNlbCBoYXMgbW9yZSBzbGlkZXMgdGhhbiB0aGUgY2Fyb3VzZWwgd2UgYXJlIHN5bmNpbmdcbiAgICAgICAgLy8gdG86XG4gICAgICAgIC8vIFVzZSBtb2R1bHVzIHRvIGdldCB0aGUgZXF1aXZhbGVudCBpbmRleCBvZiB0aGUgY3VycmVudCB0cmFuc2l0aW9uXG4gICAgICAgIC8vIHRhcmdldCwgYXMgaWYgaXQgd2VyZSBhIHNsaWRlIGluIHRoZSBjYXJvdXNlbCB3ZSBhcmUgc3luY2luZyB0by5cbiAgICAgICAgLy8gSWYgdGhlIHNsaWRlIGNvdW50cyBtYXRjaCB1cCwgdGhpcyBtb2R1bHVzIG9wZXJhdGlvbiB3aWxsIGJlIGEgbm8tb3AgYW5kXG4gICAgICAgIC8vIG5vIGhhcm0gaXMgZG9uZS5cbiAgICAgICAgY29uc3QgZXF1aXZhbGVudFRyYW5zaXRpb25UYXJnZXRJbmRleCA9IHRoaXMuZ2V0SW5kZXgodGhpcy50cmFuc2l0aW9uVGFyZ2V0KSAlIGNhcm91c2VsLmdldFNsaWRlQ291bnQoKTtcbiAgICAgICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgb24gYW4gZXF1aXZhbGVudCBpbmRleCwgd2UgY2FuIHN0b3AgYW5kIHJldHVybiBlYXJseS5cbiAgICAgICAgaWYgKGVxdWl2YWxlbnRUcmFuc2l0aW9uVGFyZ2V0SW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2Fyb3VzZWwgaGFzIG1vcmUgc2xpZGVzIHRoYW4gdGhlIHN5bmNpbmcgY2Fyb3VzZWwsXG4gICAgICAgIC8vIHRoZW4gd2Ugd2FudCB0byBncmFiIHRoZSBjbG9zZXN0IGVxdWl2YWxlbnQgc2xpZGUgdG8gdHJhbnNpdGlvbiB0by5cbiAgICAgICAgaWYgKHRoaXMuZ2V0U2xpZGVDb3VudCgpID4gY2Fyb3VzZWwuZ2V0U2xpZGVDb3VudCgpKSB7XG4gICAgICAgICAgICAvLyBCdWlsZCBhIHNldCBvZiBhbGwgZXF1aXZhbGVudCBpbmRpY2VzLlxuICAgICAgICAgICAgY29uc3QgZXF1aXZhbGVudEluZGljZXMgPSBbXTtcbiAgICAgICAgICAgIGxldCBlcXVpdmFsZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChlcXVpdmFsZW50SW5kZXggPCB0aGlzLmdldFNsaWRlQ291bnQoKSkge1xuICAgICAgICAgICAgICAgIGVxdWl2YWxlbnRJbmRpY2VzLnB1c2goZXF1aXZhbGVudEluZGV4KTtcbiAgICAgICAgICAgICAgICBlcXVpdmFsZW50SW5kZXggKz0gY2Fyb3VzZWwuZ2V0U2xpZGVDb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nb1RvKGFycmF5Zl8xLmFycmF5Zi5taW4oZXF1aXZhbGVudEluZGljZXMsIGkgPT4gTWF0aC5hYnModGhpcy5nZXRBY3RpdmVJbmRleCgpIC0gaSkpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ29UbyhpbmRleCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnRlZ2VyIG51bWJlciBmb3IgaGFsZiBvZiB0aGUgc2xpZGVzLiBUaGUgcGFyYW1ldGVyXG4gICAgICogc3BlY2lmaWVzIHdoZXRoZXIsIGlmIGdpdmVuIGFuIGFycmF5IGNvbnRhaW5pbmcgYW4gb2RkIG51bWJlciBvZiBlbGVtZW50cyxcbiAgICAgKiB0aGUgbGFyZ2VyIG9kZCB2YWx1ZSBmb3IgaGFsZiBzaG91bGQgYmUgcmV0dXJuZWQsIG9yIHRoZSBzbWFsbGVyIGV2ZW5cbiAgICAgKiBudW1iZXIuXG4gICAgICogQHBhcmFtIHdlaWdodE9kZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0SGFsZk9mU2xpZGVDb3VudCh3ZWlnaHRPZGQpIHtcbiAgICAgICAgY29uc3QgaGFsZkxlbmd0aCA9ICh0aGlzLmdldFNsaWRlcygpLmxlbmd0aCAtIDEpIC8gMjtcbiAgICAgICAgaWYgKGhhbGZMZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFsZkxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3ZWlnaHRPZGQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwoaGFsZkxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihoYWxmTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gaGFsZiBvZiB0aGUgc2xpZGVzIGJ5IHRha2luZyBzbGlkZXMgdG8gb25lIHNpZGUgb2YgdGhlIGdpdmVuIHNsaWRlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIGxvb3BpbmcgaXMgZW5hYmxlZCBhbmQgbG9vcHMgYXJvdW5kIGlmIG5lZWRlZCB0byBnZXRcbiAgICAgKiBoYWxmIG9mIHRoZSBzbGlkZXMuXG4gICAgICovXG4gICAgc3BsaXRTbGlkZXNJbkhhbGYoc2xpZGUsIGRpcmVjdGlvbikge1xuICAgICAgICBjb25zdCB0YXJnZXRMZW5ndGggPSB0aGlzLmdldEhhbGZPZlNsaWRlQ291bnQoZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uUklHSFQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGluZGV4VG9BZGQgPSB0aGlzLmdldEluZGV4KHNsaWRlKTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBsb29wZWQgaW5kZXhcbiAgICAgICAgICAgIGluZGV4VG9BZGQgPSBfXzEubWF0aGYud3JhcChpbmRleFRvQWRkICsgZGlyZWN0aW9uLCAwLCB0aGlzLmdldFNsaWRlQ291bnQoKSk7XG4gICAgICAgICAgICBjb25zdCBzbGlkZVRvQWRkID0gdGhpcy5nZXRTbGlkZUJ5SW5kZXgoaW5kZXhUb0FkZCk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uUklHSFQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzbGlkZVRvQWRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KHNsaWRlVG9BZGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHVwIGluaXRpYWwgdmFsdWVzLlxuICAgICAqL1xuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbi5pbml0KHRoaXMpO1xuICAgICAgICB0aGlzLnJhZi5zdGFydCgpO1xuICAgICAgICB0aGlzLnJlc2V0QXV0b3BsYXlUaW1lb3V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjdXJyZW50IGF1dG9wbGF5IHRpbWVvdXQgYW5kIHByZXAgYSBuZXcgb25lLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVzZXRBdXRvcGxheVRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9wbGF5U3BlZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9wbGF5VGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b3BsYXlUaW1lb3V0LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXV0b3BsYXlUaW1lb3V0ID0gbmV3IEF1dG9wbGF5VGltZW91dCgoKSA9PiB0aGlzLm5leHQoKSwgdGhpcy5hdXRvcGxheVNwZWVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gdGhlIGxvb3AgdG8gZG8gYWxsIHRoZSBuZWNlc3Nhcnkgd29yayBmb3IgdGhlIGNhcm91c2VsLlxuICAgICAqL1xuICAgIG9uUmFmKCkge1xuICAgICAgICB0aGlzLnJhZi5yZWFkKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25kaXRpb24oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzQmVpbmdJbnRlcmFjdGVkV2l0aCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEF1dG9wbGF5VGltZW91dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWN0aXZlU2xpZGUgPSB0aGlzLmdldEFjdGl2ZVNsaWRlKCk7XG4gICAgICAgICAgICBpZiAoYWN0aXZlU2xpZGUgIT09IHRoaXMubGFzdEFjdGl2ZVNsaWRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0QWN0aXZlU2xpZGUgPSBhY3RpdmVTbGlkZTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlU2xpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDbGFzc2VzKGFjdGl2ZVNsaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzVHJhbnNpdGlvbmVkVG9UYXJnZXQgPSB0aGlzLnRyYW5zaXRpb24uaGFzVHJhbnNpdGlvbmVkVG8odGhpcy50cmFuc2l0aW9uVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVHJhbnNpdGlvbmVkVG9UYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuZGlzcGF0Y2goQ2Fyb3VzZWxFdmVudC5BRlRFUl9DSEFOR0UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcm91c2VsOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNsaWRlOiB0aGlzLmdldEFjdGl2ZVNsaWRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXg6IHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRBdXRvcGxheVRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbi50cmFuc2l0aW9uKHRoaXMudHJhbnNpdGlvblRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzbGlkZSBlbGVtZW50cycgQ1NTIGNsYXNzZXNcbiAgICAgKiBAcGFyYW0gYWN0aXZlU2xpZGVcbiAgICAgKi9cbiAgICB1cGRhdGVDbGFzc2VzKGFjdGl2ZVNsaWRlKSB7XG4gICAgICAgIGNvbnN0IHNsaWRlc0JlZm9yZSA9IHRoaXMuZ2V0U2xpZGVzQmVmb3JlKGFjdGl2ZVNsaWRlKTtcbiAgICAgICAgY29uc3Qgc2xpZGVzQWZ0ZXIgPSB0aGlzLmdldFNsaWRlc0FmdGVyKGFjdGl2ZVNsaWRlKTtcbiAgICAgICAgdGhpcy5yYWYud3JpdGUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGFjdGl2ZSBzbGlkZVxuICAgICAgICAgICAgYWN0aXZlU2xpZGUuY2xhc3NMaXN0LmFkZCh0aGlzLmFjdGl2ZUNzc0NsYXNzKTtcbiAgICAgICAgICAgIGFjdGl2ZVNsaWRlLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5iZWZvcmVDc3NDbGFzcywgdGhpcy5hZnRlckNzc0NsYXNzKTtcbiAgICAgICAgICAgIGFjdGl2ZVNsaWRlLnNldEF0dHJpYnV0ZSh0aGlzLmRpc3RhbmNlVG9BY3RpdmVTbGlkZUF0dHIsICcwJyk7XG4gICAgICAgICAgICBzbGlkZXNCZWZvcmUucmV2ZXJzZSgpLmZvckVhY2goKHNsaWRlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHNsaWRlLmNsYXNzTGlzdC5hZGQodGhpcy5iZWZvcmVDc3NDbGFzcyk7XG4gICAgICAgICAgICAgICAgc2xpZGUuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmFjdGl2ZUNzc0NsYXNzLCB0aGlzLmFmdGVyQ3NzQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHNsaWRlLnNldEF0dHJpYnV0ZSh0aGlzLmRpc3RhbmNlVG9BY3RpdmVTbGlkZUF0dHIsIGAkey1pbmRleCAtIDF9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNsaWRlc0FmdGVyLmZvckVhY2goKHNsaWRlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHNsaWRlLmNsYXNzTGlzdC5hZGQodGhpcy5hZnRlckNzc0NsYXNzKTtcbiAgICAgICAgICAgICAgICBzbGlkZS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuYWN0aXZlQ3NzQ2xhc3MsIHRoaXMuYmVmb3JlQ3NzQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHNsaWRlLnNldEF0dHJpYnV0ZSh0aGlzLmRpc3RhbmNlVG9BY3RpdmVTbGlkZUF0dHIsIGAke2luZGV4ICsgMX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkNhcm91c2VsID0gQ2Fyb3VzZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXJvdXNlbC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/ui/carousel/carousel.js\n");

/***/ }),

/***/ "./lib/ui/carousel/draggable-slide.js":
/*!********************************************!*\
  !*** ./lib/ui/carousel/draggable-slide.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DraggableSlide = void 0;\nconst __1 = __webpack_require__(/*! ../.. */ \"./lib/index.js\");\nconst cubic_bezier_1 = __webpack_require__(/*! ../../mathf/cubic-bezier */ \"./lib/mathf/cubic-bezier.js\");\nconst arrayf_1 = __webpack_require__(/*! ../../arrayf/arrayf */ \"./lib/arrayf/arrayf.js\");\nconst default_map_1 = __webpack_require__(/*! ../../map/default-map */ \"./lib/map/default-map.js\");\nconst cached_mouse_tracker_1 = __webpack_require__(/*! ../../dom/cached-mouse-tracker */ \"./lib/dom/cached-mouse-tracker.js\");\n/**\n * Small enum for readability when traversing slide indices.\n */\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"LEFT\"] = -1] = \"LEFT\";\n    Direction[Direction[\"RIGHT\"] = 1] = \"RIGHT\";\n})(Direction || (Direction = {}));\n/**\n * Encapsulates information around a slide that needs to be transitioned to.\n */\nclass TransitionTarget {\n    constructor(target, timeRange, startDistance) {\n        this.target = target;\n        this.timeRange = timeRange;\n        this.startDistance = startDistance;\n    }\n}\n/**\n * Track the information associated with a user interaction.\n */\nclass Interaction {\n    constructor(startX, startTime) {\n        this.startX = startX;\n        this.startTime = startTime;\n        this.lastMouseX = startX;\n    }\n}\n/**\n * Return the x translation amount from the given element's transform.\n */\nfunction getTranslateX(el) {\n    const transform = __1.dom.getComputedStyle(el).transform;\n    if (!transform.length || transform === 'none') {\n        return 0;\n    }\n    // Grab the tx value from the matrix\n    return parseFloat(transform.slice(7, -1).split(',')[4]);\n}\n/**\n * A transition for a carousel that allows the user to drag and fling slides\n * around. Similar to the default interaction for a \"slick\" carousel.\n *\n * For proper operation, the slide elements within the carousel should be\n * lined up side-by-side and overflowing the container. The container should\n * be overflow: hidden; The slide elements themselves should not have transforms\n * applied. Children of the slide elements however can be transformed as needed\n * to achieve necessary visual effects.\n */\nclass DraggableSlide {\n    /**\n     * @param transitionTime Determines how long in ms it takes to transition from\n     *     one slide to another.\n     * @param easingFunction Easing function used to adjust slides transitions.\n     */\n    constructor({ transitionTime = 500, easingFunction = DraggableSlide.DEFAULT_EASING, } = {}) {\n        this.raf = new __1.Raf(() => this.onRaf());\n        this.domWatcher = new __1.DomWatcher();\n        this.easingFunction = easingFunction;\n        this.transitionTime = transitionTime;\n        this.transitionTarget = null;\n        this.resizeTimeout = null;\n        this.mouseTracker = new cached_mouse_tracker_1.CachedMouseTracker();\n        this.interaction = null;\n        // Tracks the current X translation of each slide.\n        // Used so that slide can be adjusted for looping and dragging within the\n        // same frame without introducing layout thrashing by updating the DOM\n        // twice.\n        this.xTranslate = default_map_1.DefaultMap.usingFunction((el) => getTranslateX(el));\n        this.lastXTranslate = default_map_1.DefaultMap.usingFunction(() => null);\n    }\n    /**\n     * Sums the offsetWidth of the given slides.\n     *\n     * Was repeated enough to seem worth extracting.\n     */\n    static sumWidth(slides) {\n        return __1.mathf.sum(slides.map(slide => slide.offsetWidth));\n    }\n    /**\n     * This function is called by the carousel when the transition is passed to\n     * the carousel. Until this function is called the DraggableSlide instance is\n     * more or less inert.\n     */\n    init(carousel) {\n        this.initResizeHandler();\n        this.carousel = carousel;\n        // Transition to the given active slide\n        this.raf.read(() => this.transition(carousel.getFirstSlide(), 0));\n        this.initDraggableSlides();\n        this.raf.start();\n    }\n    /**\n     * Updates slide positioning in response to user interaction and transition\n     * animations.\n     */\n    onRaf() {\n        if (this.carousel.isDisabled()) {\n            return;\n        }\n        this.raf.read(() => {\n            if (!this.isInteracting() && this.transitionTarget) {\n                this.renderTransition();\n            }\n            else {\n                if (this.isInteracting()) {\n                    this.renderInteraction();\n                }\n                this.loopSlides();\n            }\n            // Applies the scheduled X translations set up in other functions.\n            // This ensures that splitting slides for looping, transitions and\n            // interactions can all adjust the X position without updating the DOM\n            // more than once per frame.\n            this.applyXTranslations();\n        });\n    }\n    /**\n     * Transition to the given target within the given time.\n     * @param targetEl\n     * @param optTransitionTime Time the transition should take, uses value\n     *    provided to the constructor is no value is provided for this call.\n     */\n    transition(targetEl, optTransitionTime = null) {\n        if (this.transitionTarget !== null &&\n            this.transitionTarget.target === targetEl) {\n            return; // Don't reset target time\n        }\n        const transitionTime = optTransitionTime === null ? this.transitionTime : optTransitionTime;\n        const now = performance.now();\n        const timeRange = [now, now + transitionTime];\n        const distance = this.getDistanceToCenter(targetEl);\n        this.transitionTarget = new TransitionTarget(targetEl, timeRange, distance);\n    }\n    /**\n     * Returns the currently active slide.\n     */\n    getActiveSlide() {\n        return arrayf_1.arrayf.min(this.carousel.getSlides(), \n        // Start with the one closest to the center\n        el => {\n            return Math.abs(this.getDistanceBetween(el, this.carousel.container));\n        }, \n        // If neither slide was last active default to the one that appears first\n        // in the list of slides\n        el => -1 * this.carousel.getIndex(el));\n    }\n    /**\n     * Returns true if the carousel has transitioned to the given slide.\n     * @param slide\n     */\n    hasTransitionedTo(slide) {\n        return this.getDistanceToCenter(slide) === 0;\n    }\n    /**\n     * Returns true if the user is interacting with the slides.\n     */\n    isInteracting() {\n        return this.interaction !== null;\n    }\n    /**\n     * Dispose of the transition.\n     */\n    dispose() {\n        this.resizeTimeout && window.clearTimeout(this.resizeTimeout);\n        this.mouseTracker.dispose();\n        this.domWatcher.dispose();\n        this.xTranslate.clear();\n        this.lastXTranslate.clear();\n    }\n    initResizeHandler() {\n        this.domWatcher.add({\n            element: window,\n            on: 'resize',\n            eventOptions: { passive: true },\n            callback: () => {\n                if (this.resizeTimeout) {\n                    window.clearTimeout(this.resizeTimeout);\n                }\n                this.resizeTimeout = window.setTimeout(() => this.transition(this.carousel.getActiveSlide(), 0));\n            },\n        });\n    }\n    /**\n     * Limit how far slides can be moved left/right if looping is not allowed for\n     * the carousel.\n     */\n    constrainXTranslations() {\n        if (this.carousel.loop) {\n            return;\n        }\n        const slides = this.carousel.getSlides();\n        // Allow for centering the last slide\n        const halfContainer = this.carousel.container.offsetWidth / 2;\n        const totalSlideWidth = DraggableSlide.sumWidth(slides);\n        const lastSlideWidth = slides.slice(-1)[0].offsetWidth;\n        const halfLastSlide = lastSlideWidth / 2;\n        const halfFirstSlide = slides[0].offsetWidth / 2;\n        const min = halfContainer - totalSlideWidth + halfLastSlide;\n        const max = halfContainer - halfFirstSlide;\n        slides.forEach((slide) => {\n            const currentX = this.xTranslate.get(slide);\n            this.xTranslate.set(slide, __1.mathf.clamp(min, max, currentX));\n        });\n    }\n    applyXTranslations() {\n        this.constrainXTranslations();\n        // Apply all X Translates in a single step\n        this.raf.write(() => {\n            this.xTranslate.forEach((xTranslate, slide) => {\n                // Don't re-apply the same style twice, it will just clog up the\n                // inspector and make debugging difficult.\n                if (this.lastXTranslate.get(slide) !== xTranslate) {\n                    slide.style.transform = `translateX(${xTranslate}px)`;\n                    this.lastXTranslate.set(slide, xTranslate);\n                }\n            });\n        });\n    }\n    renderInteraction() {\n        const currentMouseX = this.getMouseX();\n        const delta = currentMouseX - this.interaction.lastMouseX;\n        this.carousel.getSlides().forEach(slide => {\n            this.xTranslate.set(slide, this.xTranslate.get(slide) + delta);\n        });\n        this.interaction.lastMouseX = currentMouseX;\n    }\n    /**\n     * Return the distance between the given slide and the center of the carousel.\n     */\n    getDistanceToCenter(slide) {\n        return this.getDistanceBetween(slide, this.carousel.container);\n    }\n    /**\n     * Setup the Draggable instances that will correspond to the slide elements.\n     */\n    initDraggableSlides() {\n        this.carousel.getSlides().forEach(slide => {\n            ['touchstart', 'mousedown'].forEach((event) => {\n                this.domWatcher.add({\n                    element: slide,\n                    on: event,\n                    eventOptions: { passive: true },\n                    callback: () => this.startInteraction(),\n                });\n            });\n            ['contextmenu', 'dragstart', 'touchend', 'mouseup'].forEach((event) => {\n                this.domWatcher.add({\n                    element: window,\n                    on: event,\n                    eventOptions: { passive: true },\n                    callback: () => this.endInteraction(),\n                });\n            });\n        });\n    }\n    /**\n     * Returns the eased transition percent.\n     *\n     * Extracted from renderTransition so its name can serve to help\n     * readability.\n     */\n    getEasedTransitionPercent() {\n        const transitionPercent = __1.mathf.inverseLerp(this.transitionTarget.timeRange[0], this.transitionTarget.timeRange[1], performance.now());\n        return this.easingFunction(transitionPercent);\n    }\n    /**\n     * Adjust CSS properties to reflect the current state of the transition\n     * animation to the current target.\n     */\n    renderTransition() {\n        const target = this.transitionTarget;\n        if (!target) {\n            return;\n        }\n        const easedPercent = this.getEasedTransitionPercent();\n        const targetDistance = __1.mathf.lerp(target.startDistance, 0, easedPercent);\n        const currentDistance = this.getDistanceToCenter(target.target);\n        const absDelta = Math.abs(targetDistance) - Math.abs(currentDistance);\n        const currentDistanceSign = Math.sign(currentDistance);\n        const xDelta = absDelta * currentDistanceSign;\n        this.carousel.getSlides().forEach(slide => this.translate(slide, xDelta));\n        this.loopSlides();\n        // If we're close enough, let's call it\n        if (easedPercent === 1) {\n            this.transitionTarget = null;\n        }\n    }\n    /**\n     * Translate the given slide by the given amoutn\n     * @param slide\n     * @param delta\n     */\n    translate(slide, delta) {\n        this.xTranslate.set(slide, this.xTranslate.get(slide) + delta);\n    }\n    /**\n     * Adjust the split of slides around the currently active slide.\n     *\n     * Is a no-op for non-looping carousels.\n     *\n     * Ensures:\n     * - Slides cover as much of the carousel as possible.\n     * - Slides loop from one side to the other.\n     */\n    loopSlides() {\n        if (!this.carousel.loop) {\n            return;\n        }\n        // No matter what we need to loop adjust the target if we have one\n        const target = (this.transitionTarget && this.transitionTarget.target) ||\n            this.carousel.getActiveSlide();\n        const targetIndex = this.carousel.getIndex(target);\n        const slides = this.carousel.getSlides();\n        const slidesToAdjust = new Set(slides.filter(slide => slide !== target));\n        const leftEdge = target.getBoundingClientRect().left;\n        const left = {\n            area: Math.max(leftEdge, 0),\n            index: targetIndex,\n            direction: Direction.LEFT, // Direction to move in for the next slide\n        };\n        const clientWidth = __1.dom.getScrollElement().clientWidth;\n        const rightEdge = leftEdge + target.offsetWidth;\n        const right = {\n            area: Math.min(clientWidth, clientWidth - rightEdge),\n            index: targetIndex,\n            direction: Direction.RIGHT,\n        };\n        const sides = [left, right];\n        while (slidesToAdjust.size > 0) {\n            const side = arrayf_1.arrayf.max(sides, s => s.area);\n            side.index += side.direction;\n            const slideToAdjust = slides[__1.mathf.wrap(side.index, 0, slides.length)];\n            side.area -= slideToAdjust.offsetWidth;\n            const desiredOffset = this.getDesiredDistanceBetween(target, slideToAdjust, side.direction);\n            const delta = desiredOffset - this.getDistanceBetween(slideToAdjust, target);\n            if (delta !== 0) {\n                this.translate(slideToAdjust, delta);\n            }\n            slidesToAdjust.delete(slideToAdjust);\n        }\n    }\n    /**\n     * Handle the start of user interaction with the carousel.\n     * @param event\n     */\n    startInteraction() {\n        if (this.isInteracting()) {\n            return;\n        }\n        this.interaction = new Interaction(this.getMouseX(), performance.now());\n        this.transitionTarget = null;\n        this.carousel.stopTransition();\n    }\n    /**\n     * Handle the end of user interaction with the carousel.\n     * @param event\n     */\n    endInteraction() {\n        if (this.interaction === null) {\n            return;\n        }\n        const duration = performance.now() - this.interaction.startTime;\n        const activeSlide = this.getActiveSlide();\n        const distance = this.getDistanceToCenter(activeSlide);\n        const interactionDelta = this.getMouseX() - this.interaction.startX;\n        const velocity = duration > 700 ? interactionDelta : 0;\n        this.interaction = null;\n        const velocitySign = Math.sign(velocity);\n        const distanceSign = Math.sign(distance) * -1;\n        const allowsLooping = this.carousel.loop;\n        // If the slide is already centered, then it is clearly the slide to\n        // transition to.\n        if (distance === 0 || distanceSign === velocitySign || velocity === 0) {\n            this.carousel.goToSlide(activeSlide);\n        }\n        else {\n            // If the user was dragging to the right, transition in the opposite\n            // direction.\n            if (velocitySign === Direction.RIGHT) {\n                if (allowsLooping || activeSlide !== this.carousel.getFirstSlide()) {\n                    this.carousel.prev();\n                }\n                else {\n                    // If we are already at the first slide and can't loop, transition\n                    // as is.\n                    this.carousel.goToSlide(activeSlide);\n                }\n                // If the user was dragging to the left, transition in the opposite\n                // direction.\n            }\n            else {\n                if (allowsLooping || activeSlide !== this.carousel.getLastSlide()) {\n                    this.carousel.next();\n                }\n                else {\n                    // If we are already at the last slide and can't loop, transition\n                    // as is.\n                    this.carousel.goToSlide(activeSlide);\n                }\n            }\n        }\n    }\n    /**\n     * Return the current mouse position.\n     */\n    getMouseX() {\n        return this.mouseTracker.getClientPosition().x;\n    }\n    /**\n     * Return the X position of the given elements center.\n     *\n     * Factors in upcoming X translation changes.\n     */\n    getCenter(el) {\n        const rect = el.getBoundingClientRect();\n        const raw = rect.left + rect.width / 2;\n        const xTranslationDelta = this.xTranslate.get(el) - getTranslateX(el);\n        return raw + xTranslationDelta;\n    }\n    /**\n     * Returns the distance between the given elements centers.\n     *\n     * If no second element is given, the root element's center is used instead.\n     */\n    getDistanceBetween(a, b = null) {\n        // Gather up the information on the first element's center position.\n        const aCenter = this.getCenter(a);\n        // Gather the info on the second element's center position or the root\n        // element's center position.\n        if (b !== null) {\n            return aCenter - this.getCenter(b);\n        }\n        else {\n            return aCenter - document.children[0].clientWidth / 2;\n        }\n    }\n    /**\n     * Return how far the given slide is from the given target slide in terms of\n     * slide width in pixels.\n     */\n    getDesiredDistanceBetween(a, b, direction) {\n        if (a === b) {\n            return 0;\n        }\n        const inBetweenSlides = this.getInBetweenSlides(a, b, direction);\n        const inBetweenWidth = DraggableSlide.sumWidth(inBetweenSlides);\n        const halfSlide = b.offsetWidth / 2;\n        const halfTarget = a.offsetWidth / 2;\n        return (halfSlide + inBetweenWidth + halfTarget) * direction;\n    }\n    /**\n     * Return the slides in between the given start and end slide.\n     * If the carousel is looping, work in the given direction.\n     */\n    getInBetweenSlides(startSlide, endSlide, direction) {\n        const start = this.carousel.getIndex(startSlide);\n        const end = this.carousel.getIndex(endSlide) - direction;\n        if (start === end) {\n            return [];\n        }\n        else if (this.carousel.loop) {\n            return arrayf_1.arrayf.loopSlice(this.carousel.getSlides(), end, start, -direction);\n        }\n        else {\n            // Use min and max to ensure that we slice in the right direction.\n            return this.carousel.getSlides().slice(Math.min(start + 1, end), Math.max(start, end + direction));\n        }\n    }\n}\nexports.DraggableSlide = DraggableSlide;\nDraggableSlide.DEFAULT_EASING = new cubic_bezier_1.CubicBezier(0.445, 0.05, 0.55, 0.95).easingFunction();\n//# sourceMappingURL=draggable-slide.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvdWkvY2Fyb3VzZWwvZHJhZ2dhYmxlLXNsaWRlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3VpL2Nhcm91c2VsL2RyYWdnYWJsZS1zbGlkZS5qcz83ZTEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EcmFnZ2FibGVTbGlkZSA9IHZvaWQgMDtcbmNvbnN0IF9fMSA9IHJlcXVpcmUoXCIuLi8uLlwiKTtcbmNvbnN0IGN1YmljX2Jlemllcl8xID0gcmVxdWlyZShcIi4uLy4uL21hdGhmL2N1YmljLWJlemllclwiKTtcbmNvbnN0IGFycmF5Zl8xID0gcmVxdWlyZShcIi4uLy4uL2FycmF5Zi9hcnJheWZcIik7XG5jb25zdCBkZWZhdWx0X21hcF8xID0gcmVxdWlyZShcIi4uLy4uL21hcC9kZWZhdWx0LW1hcFwiKTtcbmNvbnN0IGNhY2hlZF9tb3VzZV90cmFja2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vZG9tL2NhY2hlZC1tb3VzZS10cmFja2VyXCIpO1xuLyoqXG4gKiBTbWFsbCBlbnVtIGZvciByZWFkYWJpbGl0eSB3aGVuIHRyYXZlcnNpbmcgc2xpZGUgaW5kaWNlcy5cbiAqL1xudmFyIERpcmVjdGlvbjtcbihmdW5jdGlvbiAoRGlyZWN0aW9uKSB7XG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkxFRlRcIl0gPSAtMV0gPSBcIkxFRlRcIjtcbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiUklHSFRcIl0gPSAxXSA9IFwiUklHSFRcIjtcbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcbi8qKlxuICogRW5jYXBzdWxhdGVzIGluZm9ybWF0aW9uIGFyb3VuZCBhIHNsaWRlIHRoYXQgbmVlZHMgdG8gYmUgdHJhbnNpdGlvbmVkIHRvLlxuICovXG5jbGFzcyBUcmFuc2l0aW9uVGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHRpbWVSYW5nZSwgc3RhcnREaXN0YW5jZSkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy50aW1lUmFuZ2UgPSB0aW1lUmFuZ2U7XG4gICAgICAgIHRoaXMuc3RhcnREaXN0YW5jZSA9IHN0YXJ0RGlzdGFuY2U7XG4gICAgfVxufVxuLyoqXG4gKiBUcmFjayB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIGEgdXNlciBpbnRlcmFjdGlvbi5cbiAqL1xuY2xhc3MgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0WCwgc3RhcnRUaW1lKSB7XG4gICAgICAgIHRoaXMuc3RhcnRYID0gc3RhcnRYO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5sYXN0TW91c2VYID0gc3RhcnRYO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJuIHRoZSB4IHRyYW5zbGF0aW9uIGFtb3VudCBmcm9tIHRoZSBnaXZlbiBlbGVtZW50J3MgdHJhbnNmb3JtLlxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGVYKGVsKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gX18xLmRvbS5nZXRDb21wdXRlZFN0eWxlKGVsKS50cmFuc2Zvcm07XG4gICAgaWYgKCF0cmFuc2Zvcm0ubGVuZ3RoIHx8IHRyYW5zZm9ybSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvLyBHcmFiIHRoZSB0eCB2YWx1ZSBmcm9tIHRoZSBtYXRyaXhcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0cmFuc2Zvcm0uc2xpY2UoNywgLTEpLnNwbGl0KCcsJylbNF0pO1xufVxuLyoqXG4gKiBBIHRyYW5zaXRpb24gZm9yIGEgY2Fyb3VzZWwgdGhhdCBhbGxvd3MgdGhlIHVzZXIgdG8gZHJhZyBhbmQgZmxpbmcgc2xpZGVzXG4gKiBhcm91bmQuIFNpbWlsYXIgdG8gdGhlIGRlZmF1bHQgaW50ZXJhY3Rpb24gZm9yIGEgXCJzbGlja1wiIGNhcm91c2VsLlxuICpcbiAqIEZvciBwcm9wZXIgb3BlcmF0aW9uLCB0aGUgc2xpZGUgZWxlbWVudHMgd2l0aGluIHRoZSBjYXJvdXNlbCBzaG91bGQgYmVcbiAqIGxpbmVkIHVwIHNpZGUtYnktc2lkZSBhbmQgb3ZlcmZsb3dpbmcgdGhlIGNvbnRhaW5lci4gVGhlIGNvbnRhaW5lciBzaG91bGRcbiAqIGJlIG92ZXJmbG93OiBoaWRkZW47IFRoZSBzbGlkZSBlbGVtZW50cyB0aGVtc2VsdmVzIHNob3VsZCBub3QgaGF2ZSB0cmFuc2Zvcm1zXG4gKiBhcHBsaWVkLiBDaGlsZHJlbiBvZiB0aGUgc2xpZGUgZWxlbWVudHMgaG93ZXZlciBjYW4gYmUgdHJhbnNmb3JtZWQgYXMgbmVlZGVkXG4gKiB0byBhY2hpZXZlIG5lY2Vzc2FyeSB2aXN1YWwgZWZmZWN0cy5cbiAqL1xuY2xhc3MgRHJhZ2dhYmxlU2xpZGUge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB0cmFuc2l0aW9uVGltZSBEZXRlcm1pbmVzIGhvdyBsb25nIGluIG1zIGl0IHRha2VzIHRvIHRyYW5zaXRpb24gZnJvbVxuICAgICAqICAgICBvbmUgc2xpZGUgdG8gYW5vdGhlci5cbiAgICAgKiBAcGFyYW0gZWFzaW5nRnVuY3Rpb24gRWFzaW5nIGZ1bmN0aW9uIHVzZWQgdG8gYWRqdXN0IHNsaWRlcyB0cmFuc2l0aW9ucy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IHRyYW5zaXRpb25UaW1lID0gNTAwLCBlYXNpbmdGdW5jdGlvbiA9IERyYWdnYWJsZVNsaWRlLkRFRkFVTFRfRUFTSU5HLCB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5yYWYgPSBuZXcgX18xLlJhZigoKSA9PiB0aGlzLm9uUmFmKCkpO1xuICAgICAgICB0aGlzLmRvbVdhdGNoZXIgPSBuZXcgX18xLkRvbVdhdGNoZXIoKTtcbiAgICAgICAgdGhpcy5lYXNpbmdGdW5jdGlvbiA9IGVhc2luZ0Z1bmN0aW9uO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25UaW1lID0gdHJhbnNpdGlvblRpbWU7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMubW91c2VUcmFja2VyID0gbmV3IGNhY2hlZF9tb3VzZV90cmFja2VyXzEuQ2FjaGVkTW91c2VUcmFja2VyKCk7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb24gPSBudWxsO1xuICAgICAgICAvLyBUcmFja3MgdGhlIGN1cnJlbnQgWCB0cmFuc2xhdGlvbiBvZiBlYWNoIHNsaWRlLlxuICAgICAgICAvLyBVc2VkIHNvIHRoYXQgc2xpZGUgY2FuIGJlIGFkanVzdGVkIGZvciBsb29waW5nIGFuZCBkcmFnZ2luZyB3aXRoaW4gdGhlXG4gICAgICAgIC8vIHNhbWUgZnJhbWUgd2l0aG91dCBpbnRyb2R1Y2luZyBsYXlvdXQgdGhyYXNoaW5nIGJ5IHVwZGF0aW5nIHRoZSBET01cbiAgICAgICAgLy8gdHdpY2UuXG4gICAgICAgIHRoaXMueFRyYW5zbGF0ZSA9IGRlZmF1bHRfbWFwXzEuRGVmYXVsdE1hcC51c2luZ0Z1bmN0aW9uKChlbCkgPT4gZ2V0VHJhbnNsYXRlWChlbCkpO1xuICAgICAgICB0aGlzLmxhc3RYVHJhbnNsYXRlID0gZGVmYXVsdF9tYXBfMS5EZWZhdWx0TWFwLnVzaW5nRnVuY3Rpb24oKCkgPT4gbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1bXMgdGhlIG9mZnNldFdpZHRoIG9mIHRoZSBnaXZlbiBzbGlkZXMuXG4gICAgICpcbiAgICAgKiBXYXMgcmVwZWF0ZWQgZW5vdWdoIHRvIHNlZW0gd29ydGggZXh0cmFjdGluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3VtV2lkdGgoc2xpZGVzKSB7XG4gICAgICAgIHJldHVybiBfXzEubWF0aGYuc3VtKHNsaWRlcy5tYXAoc2xpZGUgPT4gc2xpZGUub2Zmc2V0V2lkdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgdGhlIGNhcm91c2VsIHdoZW4gdGhlIHRyYW5zaXRpb24gaXMgcGFzc2VkIHRvXG4gICAgICogdGhlIGNhcm91c2VsLiBVbnRpbCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0aGUgRHJhZ2dhYmxlU2xpZGUgaW5zdGFuY2UgaXNcbiAgICAgKiBtb3JlIG9yIGxlc3MgaW5lcnQuXG4gICAgICovXG4gICAgaW5pdChjYXJvdXNlbCkge1xuICAgICAgICB0aGlzLmluaXRSZXNpemVIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMuY2Fyb3VzZWwgPSBjYXJvdXNlbDtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgZ2l2ZW4gYWN0aXZlIHNsaWRlXG4gICAgICAgIHRoaXMucmFmLnJlYWQoKCkgPT4gdGhpcy50cmFuc2l0aW9uKGNhcm91c2VsLmdldEZpcnN0U2xpZGUoKSwgMCkpO1xuICAgICAgICB0aGlzLmluaXREcmFnZ2FibGVTbGlkZXMoKTtcbiAgICAgICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBzbGlkZSBwb3NpdGlvbmluZyBpbiByZXNwb25zZSB0byB1c2VyIGludGVyYWN0aW9uIGFuZCB0cmFuc2l0aW9uXG4gICAgICogYW5pbWF0aW9ucy5cbiAgICAgKi9cbiAgICBvblJhZigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2Fyb3VzZWwuaXNEaXNhYmxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYWYucmVhZCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNJbnRlcmFjdGluZygpICYmIHRoaXMudHJhbnNpdGlvblRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnRlcmFjdGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVySW50ZXJhY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sb29wU2xpZGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcHBsaWVzIHRoZSBzY2hlZHVsZWQgWCB0cmFuc2xhdGlvbnMgc2V0IHVwIGluIG90aGVyIGZ1bmN0aW9ucy5cbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHNwbGl0dGluZyBzbGlkZXMgZm9yIGxvb3BpbmcsIHRyYW5zaXRpb25zIGFuZFxuICAgICAgICAgICAgLy8gaW50ZXJhY3Rpb25zIGNhbiBhbGwgYWRqdXN0IHRoZSBYIHBvc2l0aW9uIHdpdGhvdXQgdXBkYXRpbmcgdGhlIERPTVxuICAgICAgICAgICAgLy8gbW9yZSB0aGFuIG9uY2UgcGVyIGZyYW1lLlxuICAgICAgICAgICAgdGhpcy5hcHBseVhUcmFuc2xhdGlvbnMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zaXRpb24gdG8gdGhlIGdpdmVuIHRhcmdldCB3aXRoaW4gdGhlIGdpdmVuIHRpbWUuXG4gICAgICogQHBhcmFtIHRhcmdldEVsXG4gICAgICogQHBhcmFtIG9wdFRyYW5zaXRpb25UaW1lIFRpbWUgdGhlIHRyYW5zaXRpb24gc2hvdWxkIHRha2UsIHVzZXMgdmFsdWVcbiAgICAgKiAgICBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IgaXMgbm8gdmFsdWUgaXMgcHJvdmlkZWQgZm9yIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uKHRhcmdldEVsLCBvcHRUcmFuc2l0aW9uVGltZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblRhcmdldCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVGFyZ2V0LnRhcmdldCA9PT0gdGFyZ2V0RWwpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3QgcmVzZXQgdGFyZ2V0IHRpbWVcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2l0aW9uVGltZSA9IG9wdFRyYW5zaXRpb25UaW1lID09PSBudWxsID8gdGhpcy50cmFuc2l0aW9uVGltZSA6IG9wdFRyYW5zaXRpb25UaW1lO1xuICAgICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY29uc3QgdGltZVJhbmdlID0gW25vdywgbm93ICsgdHJhbnNpdGlvblRpbWVdO1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMuZ2V0RGlzdGFuY2VUb0NlbnRlcih0YXJnZXRFbCk7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRhcmdldCA9IG5ldyBUcmFuc2l0aW9uVGFyZ2V0KHRhcmdldEVsLCB0aW1lUmFuZ2UsIGRpc3RhbmNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IGFjdGl2ZSBzbGlkZS5cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVTbGlkZSgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Zl8xLmFycmF5Zi5taW4odGhpcy5jYXJvdXNlbC5nZXRTbGlkZXMoKSwgXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggdGhlIG9uZSBjbG9zZXN0IHRvIHRoZSBjZW50ZXJcbiAgICAgICAgZWwgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuZ2V0RGlzdGFuY2VCZXR3ZWVuKGVsLCB0aGlzLmNhcm91c2VsLmNvbnRhaW5lcikpO1xuICAgICAgICB9LCBcbiAgICAgICAgLy8gSWYgbmVpdGhlciBzbGlkZSB3YXMgbGFzdCBhY3RpdmUgZGVmYXVsdCB0byB0aGUgb25lIHRoYXQgYXBwZWFycyBmaXJzdFxuICAgICAgICAvLyBpbiB0aGUgbGlzdCBvZiBzbGlkZXNcbiAgICAgICAgZWwgPT4gLTEgKiB0aGlzLmNhcm91c2VsLmdldEluZGV4KGVsKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2Fyb3VzZWwgaGFzIHRyYW5zaXRpb25lZCB0byB0aGUgZ2l2ZW4gc2xpZGUuXG4gICAgICogQHBhcmFtIHNsaWRlXG4gICAgICovXG4gICAgaGFzVHJhbnNpdGlvbmVkVG8oc2xpZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzdGFuY2VUb0NlbnRlcihzbGlkZSkgPT09IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdXNlciBpcyBpbnRlcmFjdGluZyB3aXRoIHRoZSBzbGlkZXMuXG4gICAgICovXG4gICAgaXNJbnRlcmFjdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJhY3Rpb24gIT09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIHRyYW5zaXRpb24uXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ICYmIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5tb3VzZVRyYWNrZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmRvbVdhdGNoZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnhUcmFuc2xhdGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5sYXN0WFRyYW5zbGF0ZS5jbGVhcigpO1xuICAgIH1cbiAgICBpbml0UmVzaXplSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5kb21XYXRjaGVyLmFkZCh7XG4gICAgICAgICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICAgICAgICBvbjogJ3Jlc2l6ZScsXG4gICAgICAgICAgICBldmVudE9wdGlvbnM6IHsgcGFzc2l2ZTogdHJ1ZSB9LFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNpemVUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy50cmFuc2l0aW9uKHRoaXMuY2Fyb3VzZWwuZ2V0QWN0aXZlU2xpZGUoKSwgMCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpbWl0IGhvdyBmYXIgc2xpZGVzIGNhbiBiZSBtb3ZlZCBsZWZ0L3JpZ2h0IGlmIGxvb3BpbmcgaXMgbm90IGFsbG93ZWQgZm9yXG4gICAgICogdGhlIGNhcm91c2VsLlxuICAgICAqL1xuICAgIGNvbnN0cmFpblhUcmFuc2xhdGlvbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhcm91c2VsLmxvb3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbGlkZXMgPSB0aGlzLmNhcm91c2VsLmdldFNsaWRlcygpO1xuICAgICAgICAvLyBBbGxvdyBmb3IgY2VudGVyaW5nIHRoZSBsYXN0IHNsaWRlXG4gICAgICAgIGNvbnN0IGhhbGZDb250YWluZXIgPSB0aGlzLmNhcm91c2VsLmNvbnRhaW5lci5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IHRvdGFsU2xpZGVXaWR0aCA9IERyYWdnYWJsZVNsaWRlLnN1bVdpZHRoKHNsaWRlcyk7XG4gICAgICAgIGNvbnN0IGxhc3RTbGlkZVdpZHRoID0gc2xpZGVzLnNsaWNlKC0xKVswXS5vZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3QgaGFsZkxhc3RTbGlkZSA9IGxhc3RTbGlkZVdpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgaGFsZkZpcnN0U2xpZGUgPSBzbGlkZXNbMF0ub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICBjb25zdCBtaW4gPSBoYWxmQ29udGFpbmVyIC0gdG90YWxTbGlkZVdpZHRoICsgaGFsZkxhc3RTbGlkZTtcbiAgICAgICAgY29uc3QgbWF4ID0gaGFsZkNvbnRhaW5lciAtIGhhbGZGaXJzdFNsaWRlO1xuICAgICAgICBzbGlkZXMuZm9yRWFjaCgoc2xpZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRYID0gdGhpcy54VHJhbnNsYXRlLmdldChzbGlkZSk7XG4gICAgICAgICAgICB0aGlzLnhUcmFuc2xhdGUuc2V0KHNsaWRlLCBfXzEubWF0aGYuY2xhbXAobWluLCBtYXgsIGN1cnJlbnRYKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhcHBseVhUcmFuc2xhdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuY29uc3RyYWluWFRyYW5zbGF0aW9ucygpO1xuICAgICAgICAvLyBBcHBseSBhbGwgWCBUcmFuc2xhdGVzIGluIGEgc2luZ2xlIHN0ZXBcbiAgICAgICAgdGhpcy5yYWYud3JpdGUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy54VHJhbnNsYXRlLmZvckVhY2goKHhUcmFuc2xhdGUsIHNsaWRlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgcmUtYXBwbHkgdGhlIHNhbWUgc3R5bGUgdHdpY2UsIGl0IHdpbGwganVzdCBjbG9nIHVwIHRoZVxuICAgICAgICAgICAgICAgIC8vIGluc3BlY3RvciBhbmQgbWFrZSBkZWJ1Z2dpbmcgZGlmZmljdWx0LlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RYVHJhbnNsYXRlLmdldChzbGlkZSkgIT09IHhUcmFuc2xhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGUuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoJHt4VHJhbnNsYXRlfXB4KWA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdFhUcmFuc2xhdGUuc2V0KHNsaWRlLCB4VHJhbnNsYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlckludGVyYWN0aW9uKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50TW91c2VYID0gdGhpcy5nZXRNb3VzZVgoKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBjdXJyZW50TW91c2VYIC0gdGhpcy5pbnRlcmFjdGlvbi5sYXN0TW91c2VYO1xuICAgICAgICB0aGlzLmNhcm91c2VsLmdldFNsaWRlcygpLmZvckVhY2goc2xpZGUgPT4ge1xuICAgICAgICAgICAgdGhpcy54VHJhbnNsYXRlLnNldChzbGlkZSwgdGhpcy54VHJhbnNsYXRlLmdldChzbGlkZSkgKyBkZWx0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uLmxhc3RNb3VzZVggPSBjdXJyZW50TW91c2VYO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGdpdmVuIHNsaWRlIGFuZCB0aGUgY2VudGVyIG9mIHRoZSBjYXJvdXNlbC5cbiAgICAgKi9cbiAgICBnZXREaXN0YW5jZVRvQ2VudGVyKHNsaWRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERpc3RhbmNlQmV0d2VlbihzbGlkZSwgdGhpcy5jYXJvdXNlbC5jb250YWluZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXR1cCB0aGUgRHJhZ2dhYmxlIGluc3RhbmNlcyB0aGF0IHdpbGwgY29ycmVzcG9uZCB0byB0aGUgc2xpZGUgZWxlbWVudHMuXG4gICAgICovXG4gICAgaW5pdERyYWdnYWJsZVNsaWRlcygpIHtcbiAgICAgICAgdGhpcy5jYXJvdXNlbC5nZXRTbGlkZXMoKS5mb3JFYWNoKHNsaWRlID0+IHtcbiAgICAgICAgICAgIFsndG91Y2hzdGFydCcsICdtb3VzZWRvd24nXS5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBzbGlkZSxcbiAgICAgICAgICAgICAgICAgICAgb246IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBldmVudE9wdGlvbnM6IHsgcGFzc2l2ZTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5zdGFydEludGVyYWN0aW9uKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFsnY29udGV4dG1lbnUnLCAnZHJhZ3N0YXJ0JywgJ3RvdWNoZW5kJywgJ21vdXNldXAnXS5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tV2F0Y2hlci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICAgICAgICAgICAgICAgIG9uOiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRPcHRpb25zOiB7IHBhc3NpdmU6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMuZW5kSW50ZXJhY3Rpb24oKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZWFzZWQgdHJhbnNpdGlvbiBwZXJjZW50LlxuICAgICAqXG4gICAgICogRXh0cmFjdGVkIGZyb20gcmVuZGVyVHJhbnNpdGlvbiBzbyBpdHMgbmFtZSBjYW4gc2VydmUgdG8gaGVscFxuICAgICAqIHJlYWRhYmlsaXR5LlxuICAgICAqL1xuICAgIGdldEVhc2VkVHJhbnNpdGlvblBlcmNlbnQoKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25QZXJjZW50ID0gX18xLm1hdGhmLmludmVyc2VMZXJwKHRoaXMudHJhbnNpdGlvblRhcmdldC50aW1lUmFuZ2VbMF0sIHRoaXMudHJhbnNpdGlvblRhcmdldC50aW1lUmFuZ2VbMV0sIHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFzaW5nRnVuY3Rpb24odHJhbnNpdGlvblBlcmNlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgQ1NTIHByb3BlcnRpZXMgdG8gcmVmbGVjdCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgdHJhbnNpdGlvblxuICAgICAqIGFuaW1hdGlvbiB0byB0aGUgY3VycmVudCB0YXJnZXQuXG4gICAgICovXG4gICAgcmVuZGVyVHJhbnNpdGlvbigpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50cmFuc2l0aW9uVGFyZ2V0O1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVhc2VkUGVyY2VudCA9IHRoaXMuZ2V0RWFzZWRUcmFuc2l0aW9uUGVyY2VudCgpO1xuICAgICAgICBjb25zdCB0YXJnZXREaXN0YW5jZSA9IF9fMS5tYXRoZi5sZXJwKHRhcmdldC5zdGFydERpc3RhbmNlLCAwLCBlYXNlZFBlcmNlbnQpO1xuICAgICAgICBjb25zdCBjdXJyZW50RGlzdGFuY2UgPSB0aGlzLmdldERpc3RhbmNlVG9DZW50ZXIodGFyZ2V0LnRhcmdldCk7XG4gICAgICAgIGNvbnN0IGFic0RlbHRhID0gTWF0aC5hYnModGFyZ2V0RGlzdGFuY2UpIC0gTWF0aC5hYnMoY3VycmVudERpc3RhbmNlKTtcbiAgICAgICAgY29uc3QgY3VycmVudERpc3RhbmNlU2lnbiA9IE1hdGguc2lnbihjdXJyZW50RGlzdGFuY2UpO1xuICAgICAgICBjb25zdCB4RGVsdGEgPSBhYnNEZWx0YSAqIGN1cnJlbnREaXN0YW5jZVNpZ247XG4gICAgICAgIHRoaXMuY2Fyb3VzZWwuZ2V0U2xpZGVzKCkuZm9yRWFjaChzbGlkZSA9PiB0aGlzLnRyYW5zbGF0ZShzbGlkZSwgeERlbHRhKSk7XG4gICAgICAgIHRoaXMubG9vcFNsaWRlcygpO1xuICAgICAgICAvLyBJZiB3ZSdyZSBjbG9zZSBlbm91Z2gsIGxldCdzIGNhbGwgaXRcbiAgICAgICAgaWYgKGVhc2VkUGVyY2VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGUgdGhlIGdpdmVuIHNsaWRlIGJ5IHRoZSBnaXZlbiBhbW91dG5cbiAgICAgKiBAcGFyYW0gc2xpZGVcbiAgICAgKiBAcGFyYW0gZGVsdGFcbiAgICAgKi9cbiAgICB0cmFuc2xhdGUoc2xpZGUsIGRlbHRhKSB7XG4gICAgICAgIHRoaXMueFRyYW5zbGF0ZS5zZXQoc2xpZGUsIHRoaXMueFRyYW5zbGF0ZS5nZXQoc2xpZGUpICsgZGVsdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIHNwbGl0IG9mIHNsaWRlcyBhcm91bmQgdGhlIGN1cnJlbnRseSBhY3RpdmUgc2xpZGUuXG4gICAgICpcbiAgICAgKiBJcyBhIG5vLW9wIGZvciBub24tbG9vcGluZyBjYXJvdXNlbHMuXG4gICAgICpcbiAgICAgKiBFbnN1cmVzOlxuICAgICAqIC0gU2xpZGVzIGNvdmVyIGFzIG11Y2ggb2YgdGhlIGNhcm91c2VsIGFzIHBvc3NpYmxlLlxuICAgICAqIC0gU2xpZGVzIGxvb3AgZnJvbSBvbmUgc2lkZSB0byB0aGUgb3RoZXIuXG4gICAgICovXG4gICAgbG9vcFNsaWRlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhcm91c2VsLmxvb3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBtYXR0ZXIgd2hhdCB3ZSBuZWVkIHRvIGxvb3AgYWRqdXN0IHRoZSB0YXJnZXQgaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gKHRoaXMudHJhbnNpdGlvblRhcmdldCAmJiB0aGlzLnRyYW5zaXRpb25UYXJnZXQudGFyZ2V0KSB8fFxuICAgICAgICAgICAgdGhpcy5jYXJvdXNlbC5nZXRBY3RpdmVTbGlkZSgpO1xuICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuY2Fyb3VzZWwuZ2V0SW5kZXgodGFyZ2V0KTtcbiAgICAgICAgY29uc3Qgc2xpZGVzID0gdGhpcy5jYXJvdXNlbC5nZXRTbGlkZXMoKTtcbiAgICAgICAgY29uc3Qgc2xpZGVzVG9BZGp1c3QgPSBuZXcgU2V0KHNsaWRlcy5maWx0ZXIoc2xpZGUgPT4gc2xpZGUgIT09IHRhcmdldCkpO1xuICAgICAgICBjb25zdCBsZWZ0RWRnZSA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgICBjb25zdCBsZWZ0ID0ge1xuICAgICAgICAgICAgYXJlYTogTWF0aC5tYXgobGVmdEVkZ2UsIDApLFxuICAgICAgICAgICAgaW5kZXg6IHRhcmdldEluZGV4LFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBEaXJlY3Rpb24uTEVGVCwgLy8gRGlyZWN0aW9uIHRvIG1vdmUgaW4gZm9yIHRoZSBuZXh0IHNsaWRlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsaWVudFdpZHRoID0gX18xLmRvbS5nZXRTY3JvbGxFbGVtZW50KCkuY2xpZW50V2lkdGg7XG4gICAgICAgIGNvbnN0IHJpZ2h0RWRnZSA9IGxlZnRFZGdlICsgdGFyZ2V0Lm9mZnNldFdpZHRoO1xuICAgICAgICBjb25zdCByaWdodCA9IHtcbiAgICAgICAgICAgIGFyZWE6IE1hdGgubWluKGNsaWVudFdpZHRoLCBjbGllbnRXaWR0aCAtIHJpZ2h0RWRnZSksXG4gICAgICAgICAgICBpbmRleDogdGFyZ2V0SW5kZXgsXG4gICAgICAgICAgICBkaXJlY3Rpb246IERpcmVjdGlvbi5SSUdIVCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2lkZXMgPSBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB3aGlsZSAoc2xpZGVzVG9BZGp1c3Quc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZGUgPSBhcnJheWZfMS5hcnJheWYubWF4KHNpZGVzLCBzID0+IHMuYXJlYSk7XG4gICAgICAgICAgICBzaWRlLmluZGV4ICs9IHNpZGUuZGlyZWN0aW9uO1xuICAgICAgICAgICAgY29uc3Qgc2xpZGVUb0FkanVzdCA9IHNsaWRlc1tfXzEubWF0aGYud3JhcChzaWRlLmluZGV4LCAwLCBzbGlkZXMubGVuZ3RoKV07XG4gICAgICAgICAgICBzaWRlLmFyZWEgLT0gc2xpZGVUb0FkanVzdC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRPZmZzZXQgPSB0aGlzLmdldERlc2lyZWREaXN0YW5jZUJldHdlZW4odGFyZ2V0LCBzbGlkZVRvQWRqdXN0LCBzaWRlLmRpcmVjdGlvbik7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGRlc2lyZWRPZmZzZXQgLSB0aGlzLmdldERpc3RhbmNlQmV0d2VlbihzbGlkZVRvQWRqdXN0LCB0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKGRlbHRhICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUoc2xpZGVUb0FkanVzdCwgZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2xpZGVzVG9BZGp1c3QuZGVsZXRlKHNsaWRlVG9BZGp1c3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgc3RhcnQgb2YgdXNlciBpbnRlcmFjdGlvbiB3aXRoIHRoZSBjYXJvdXNlbC5cbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBzdGFydEludGVyYWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc0ludGVyYWN0aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVyYWN0aW9uID0gbmV3IEludGVyYWN0aW9uKHRoaXMuZ2V0TW91c2VYKCksIHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYXJvdXNlbC5zdG9wVHJhbnNpdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdGhlIGVuZCBvZiB1c2VyIGludGVyYWN0aW9uIHdpdGggdGhlIGNhcm91c2VsLlxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqL1xuICAgIGVuZEludGVyYWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcmFjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gcGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLmludGVyYWN0aW9uLnN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgYWN0aXZlU2xpZGUgPSB0aGlzLmdldEFjdGl2ZVNsaWRlKCk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5nZXREaXN0YW5jZVRvQ2VudGVyKGFjdGl2ZVNsaWRlKTtcbiAgICAgICAgY29uc3QgaW50ZXJhY3Rpb25EZWx0YSA9IHRoaXMuZ2V0TW91c2VYKCkgLSB0aGlzLmludGVyYWN0aW9uLnN0YXJ0WDtcbiAgICAgICAgY29uc3QgdmVsb2NpdHkgPSBkdXJhdGlvbiA+IDcwMCA/IGludGVyYWN0aW9uRGVsdGEgOiAwO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uID0gbnVsbDtcbiAgICAgICAgY29uc3QgdmVsb2NpdHlTaWduID0gTWF0aC5zaWduKHZlbG9jaXR5KTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VTaWduID0gTWF0aC5zaWduKGRpc3RhbmNlKSAqIC0xO1xuICAgICAgICBjb25zdCBhbGxvd3NMb29waW5nID0gdGhpcy5jYXJvdXNlbC5sb29wO1xuICAgICAgICAvLyBJZiB0aGUgc2xpZGUgaXMgYWxyZWFkeSBjZW50ZXJlZCwgdGhlbiBpdCBpcyBjbGVhcmx5IHRoZSBzbGlkZSB0b1xuICAgICAgICAvLyB0cmFuc2l0aW9uIHRvLlxuICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDAgfHwgZGlzdGFuY2VTaWduID09PSB2ZWxvY2l0eVNpZ24gfHwgdmVsb2NpdHkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2Fyb3VzZWwuZ29Ub1NsaWRlKGFjdGl2ZVNsaWRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHdhcyBkcmFnZ2luZyB0byB0aGUgcmlnaHQsIHRyYW5zaXRpb24gaW4gdGhlIG9wcG9zaXRlXG4gICAgICAgICAgICAvLyBkaXJlY3Rpb24uXG4gICAgICAgICAgICBpZiAodmVsb2NpdHlTaWduID09PSBEaXJlY3Rpb24uUklHSFQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dzTG9vcGluZyB8fCBhY3RpdmVTbGlkZSAhPT0gdGhpcy5jYXJvdXNlbC5nZXRGaXJzdFNsaWRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXJvdXNlbC5wcmV2KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBhdCB0aGUgZmlyc3Qgc2xpZGUgYW5kIGNhbid0IGxvb3AsIHRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgaXMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2Fyb3VzZWwuZ29Ub1NsaWRlKGFjdGl2ZVNsaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgd2FzIGRyYWdnaW5nIHRvIHRoZSBsZWZ0LCB0cmFuc2l0aW9uIGluIHRoZSBvcHBvc2l0ZVxuICAgICAgICAgICAgICAgIC8vIGRpcmVjdGlvbi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd3NMb29waW5nIHx8IGFjdGl2ZVNsaWRlICE9PSB0aGlzLmNhcm91c2VsLmdldExhc3RTbGlkZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2Fyb3VzZWwubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgYXQgdGhlIGxhc3Qgc2xpZGUgYW5kIGNhbid0IGxvb3AsIHRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgaXMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2Fyb3VzZWwuZ29Ub1NsaWRlKGFjdGl2ZVNsaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGdldE1vdXNlWCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW91c2VUcmFja2VyLmdldENsaWVudFBvc2l0aW9uKCkueDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBYIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBlbGVtZW50cyBjZW50ZXIuXG4gICAgICpcbiAgICAgKiBGYWN0b3JzIGluIHVwY29taW5nIFggdHJhbnNsYXRpb24gY2hhbmdlcy5cbiAgICAgKi9cbiAgICBnZXRDZW50ZXIoZWwpIHtcbiAgICAgICAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCByYXcgPSByZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgeFRyYW5zbGF0aW9uRGVsdGEgPSB0aGlzLnhUcmFuc2xhdGUuZ2V0KGVsKSAtIGdldFRyYW5zbGF0ZVgoZWwpO1xuICAgICAgICByZXR1cm4gcmF3ICsgeFRyYW5zbGF0aW9uRGVsdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGdpdmVuIGVsZW1lbnRzIGNlbnRlcnMuXG4gICAgICpcbiAgICAgKiBJZiBubyBzZWNvbmQgZWxlbWVudCBpcyBnaXZlbiwgdGhlIHJvb3QgZWxlbWVudCdzIGNlbnRlciBpcyB1c2VkIGluc3RlYWQuXG4gICAgICovXG4gICAgZ2V0RGlzdGFuY2VCZXR3ZWVuKGEsIGIgPSBudWxsKSB7XG4gICAgICAgIC8vIEdhdGhlciB1cCB0aGUgaW5mb3JtYXRpb24gb24gdGhlIGZpcnN0IGVsZW1lbnQncyBjZW50ZXIgcG9zaXRpb24uXG4gICAgICAgIGNvbnN0IGFDZW50ZXIgPSB0aGlzLmdldENlbnRlcihhKTtcbiAgICAgICAgLy8gR2F0aGVyIHRoZSBpbmZvIG9uIHRoZSBzZWNvbmQgZWxlbWVudCdzIGNlbnRlciBwb3NpdGlvbiBvciB0aGUgcm9vdFxuICAgICAgICAvLyBlbGVtZW50J3MgY2VudGVyIHBvc2l0aW9uLlxuICAgICAgICBpZiAoYiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGFDZW50ZXIgLSB0aGlzLmdldENlbnRlcihiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhQ2VudGVyIC0gZG9jdW1lbnQuY2hpbGRyZW5bMF0uY2xpZW50V2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBob3cgZmFyIHRoZSBnaXZlbiBzbGlkZSBpcyBmcm9tIHRoZSBnaXZlbiB0YXJnZXQgc2xpZGUgaW4gdGVybXMgb2ZcbiAgICAgKiBzbGlkZSB3aWR0aCBpbiBwaXhlbHMuXG4gICAgICovXG4gICAgZ2V0RGVzaXJlZERpc3RhbmNlQmV0d2VlbihhLCBiLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluQmV0d2VlblNsaWRlcyA9IHRoaXMuZ2V0SW5CZXR3ZWVuU2xpZGVzKGEsIGIsIGRpcmVjdGlvbik7XG4gICAgICAgIGNvbnN0IGluQmV0d2VlbldpZHRoID0gRHJhZ2dhYmxlU2xpZGUuc3VtV2lkdGgoaW5CZXR3ZWVuU2xpZGVzKTtcbiAgICAgICAgY29uc3QgaGFsZlNsaWRlID0gYi5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IGhhbGZUYXJnZXQgPSBhLm9mZnNldFdpZHRoIC8gMjtcbiAgICAgICAgcmV0dXJuIChoYWxmU2xpZGUgKyBpbkJldHdlZW5XaWR0aCArIGhhbGZUYXJnZXQpICogZGlyZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHNsaWRlcyBpbiBiZXR3ZWVuIHRoZSBnaXZlbiBzdGFydCBhbmQgZW5kIHNsaWRlLlxuICAgICAqIElmIHRoZSBjYXJvdXNlbCBpcyBsb29waW5nLCB3b3JrIGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgZ2V0SW5CZXR3ZWVuU2xpZGVzKHN0YXJ0U2xpZGUsIGVuZFNsaWRlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmNhcm91c2VsLmdldEluZGV4KHN0YXJ0U2xpZGUpO1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLmNhcm91c2VsLmdldEluZGV4KGVuZFNsaWRlKSAtIGRpcmVjdGlvbjtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNhcm91c2VsLmxvb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheWZfMS5hcnJheWYubG9vcFNsaWNlKHRoaXMuY2Fyb3VzZWwuZ2V0U2xpZGVzKCksIGVuZCwgc3RhcnQsIC1kaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVXNlIG1pbiBhbmQgbWF4IHRvIGVuc3VyZSB0aGF0IHdlIHNsaWNlIGluIHRoZSByaWdodCBkaXJlY3Rpb24uXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYXJvdXNlbC5nZXRTbGlkZXMoKS5zbGljZShNYXRoLm1pbihzdGFydCArIDEsIGVuZCksIE1hdGgubWF4KHN0YXJ0LCBlbmQgKyBkaXJlY3Rpb24pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRHJhZ2dhYmxlU2xpZGUgPSBEcmFnZ2FibGVTbGlkZTtcbkRyYWdnYWJsZVNsaWRlLkRFRkFVTFRfRUFTSU5HID0gbmV3IGN1YmljX2Jlemllcl8xLkN1YmljQmV6aWVyKDAuNDQ1LCAwLjA1LCAwLjU1LCAwLjk1KS5lYXNpbmdGdW5jdGlvbigpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZHJhZ2dhYmxlLXNsaWRlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/ui/carousel/draggable-slide.js\n");

/***/ }),

/***/ "./lib/ui/carousel/transitions.js":
/*!****************************************!*\
  !*** ./lib/ui/carousel/transitions.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CssClassesOnly = exports.DraggableSlide = void 0;\nvar draggable_slide_1 = __webpack_require__(/*! ./draggable-slide */ \"./lib/ui/carousel/draggable-slide.js\");\nObject.defineProperty(exports, \"DraggableSlide\", { enumerable: true, get: function () { return draggable_slide_1.DraggableSlide; } });\n/**\n * A transition that doesn't really do anything.\n * This is used for when all effects can be set via CSS and triggered off the\n * default active/before/after classes.\n */\nclass CssClassesOnly {\n    init(carousel) {\n        this.activeSlide = carousel.getFirstSlide();\n    }\n    getActiveSlide() {\n        if (!this.activeSlide) {\n            throw new Error('CssClassesOnly transition not initialized');\n        }\n        return this.activeSlide;\n    }\n    transition(targetSlide) {\n        this.activeSlide = targetSlide;\n    }\n    hasTransitionedTo(slide) {\n        return this.activeSlide === slide;\n    }\n    /**\n     * Always false, this transition doesn't support any interaction.\n     */\n    isInteracting() {\n        return false;\n    }\n    /**\n     * No special disposal needed.\n     */\n    dispose() { }\n}\nexports.CssClassesOnly = CssClassesOnly;\n//# sourceMappingURL=transitions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvdWkvY2Fyb3VzZWwvdHJhbnNpdGlvbnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdWkvY2Fyb3VzZWwvdHJhbnNpdGlvbnMuanM/YjM2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3NzQ2xhc3Nlc09ubHkgPSBleHBvcnRzLkRyYWdnYWJsZVNsaWRlID0gdm9pZCAwO1xudmFyIGRyYWdnYWJsZV9zbGlkZV8xID0gcmVxdWlyZShcIi4vZHJhZ2dhYmxlLXNsaWRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRHJhZ2dhYmxlU2xpZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRyYWdnYWJsZV9zbGlkZV8xLkRyYWdnYWJsZVNsaWRlOyB9IH0pO1xuLyoqXG4gKiBBIHRyYW5zaXRpb24gdGhhdCBkb2Vzbid0IHJlYWxseSBkbyBhbnl0aGluZy5cbiAqIFRoaXMgaXMgdXNlZCBmb3Igd2hlbiBhbGwgZWZmZWN0cyBjYW4gYmUgc2V0IHZpYSBDU1MgYW5kIHRyaWdnZXJlZCBvZmYgdGhlXG4gKiBkZWZhdWx0IGFjdGl2ZS9iZWZvcmUvYWZ0ZXIgY2xhc3Nlcy5cbiAqL1xuY2xhc3MgQ3NzQ2xhc3Nlc09ubHkge1xuICAgIGluaXQoY2Fyb3VzZWwpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVTbGlkZSA9IGNhcm91c2VsLmdldEZpcnN0U2xpZGUoKTtcbiAgICB9XG4gICAgZ2V0QWN0aXZlU2xpZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmVTbGlkZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDc3NDbGFzc2VzT25seSB0cmFuc2l0aW9uIG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVNsaWRlO1xuICAgIH1cbiAgICB0cmFuc2l0aW9uKHRhcmdldFNsaWRlKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlU2xpZGUgPSB0YXJnZXRTbGlkZTtcbiAgICB9XG4gICAgaGFzVHJhbnNpdGlvbmVkVG8oc2xpZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlU2xpZGUgPT09IHNsaWRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbHdheXMgZmFsc2UsIHRoaXMgdHJhbnNpdGlvbiBkb2Vzbid0IHN1cHBvcnQgYW55IGludGVyYWN0aW9uLlxuICAgICAqL1xuICAgIGlzSW50ZXJhY3RpbmcoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm8gc3BlY2lhbCBkaXNwb3NhbCBuZWVkZWQuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHsgfVxufVxuZXhwb3J0cy5Dc3NDbGFzc2VzT25seSA9IENzc0NsYXNzZXNPbmx5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNpdGlvbnMuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/ui/carousel/transitions.js\n");

/***/ }),

/***/ "./lib/ui/events.js":
/*!**************************!*\
  !*** ./lib/ui/events.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventManager = void 0;\nconst default_map_1 = __webpack_require__(/*! ../map/default-map */ \"./lib/map/default-map.js\");\n/**\n * Utility class to simplify implementation of the EventDispatcher interface.\n *\n * Example:\n * ```\n * class Foo implements EventDispatcher {\n *   private eventManager: EventManager;\n *   constructor() {\n *     this.eventManager = new EventManager();\n *   }\n *\n *   on(event: string, callback: Callback) {\n *     this.eventManager.on(event, callback);\n *   }\n *\n *   off(event: string, callback: Callback) {\n *     this.eventManager.off(event, callback);\n *   }\n *\n *   bar() {\n *     this.eventManager.dispatch('someEvent');\n *   }\n * }\n * ```\n */\nclass EventManager {\n    constructor() {\n        this.callbacks = default_map_1.DefaultMap.usingFunction(() => new Set());\n    }\n    /**\n     * Run the given callback when the given event is dispatched.\n     */\n    on(event, callback) {\n        this.callbacks.get(event).add(callback);\n    }\n    /**\n     * Run callbacks for the given event with the given arguments.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    dispatch(event, ...args) {\n        this.callbacks.get(event).forEach(callback => callback(...args));\n    }\n    /**\n     * Stop running the given callback on the given event.\n     */\n    off(event, callback) {\n        const callbacks = this.callbacks.get(event);\n        callbacks.delete(callback);\n        if (callbacks.size === 0) {\n            this.callbacks.delete(event);\n        }\n    }\n    /**\n     * Clear out internal Sets and Map.\n     */\n    dispose() {\n        const values = this.callbacks.values();\n        let callbackSet = values.next();\n        while (!callbackSet.done) {\n            callbackSet.value.clear();\n            callbackSet = values.next();\n        }\n        this.callbacks.clear();\n    }\n}\nexports.EventManager = EventManager;\n//# sourceMappingURL=events.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIvdWkvZXZlbnRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3VpL2V2ZW50cy5qcz9hMWE4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdmVudE1hbmFnZXIgPSB2b2lkIDA7XG5jb25zdCBkZWZhdWx0X21hcF8xID0gcmVxdWlyZShcIi4uL21hcC9kZWZhdWx0LW1hcFwiKTtcbi8qKlxuICogVXRpbGl0eSBjbGFzcyB0byBzaW1wbGlmeSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgRXZlbnREaXNwYXRjaGVyIGludGVyZmFjZS5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgXG4gKiBjbGFzcyBGb28gaW1wbGVtZW50cyBFdmVudERpc3BhdGNoZXIge1xuICogICBwcml2YXRlIGV2ZW50TWFuYWdlcjogRXZlbnRNYW5hZ2VyO1xuICogICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIoKTtcbiAqICAgfVxuICpcbiAqICAgb24oZXZlbnQ6IHN0cmluZywgY2FsbGJhY2s6IENhbGxiYWNrKSB7XG4gKiAgICAgdGhpcy5ldmVudE1hbmFnZXIub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAqICAgfVxuICpcbiAqICAgb2ZmKGV2ZW50OiBzdHJpbmcsIGNhbGxiYWNrOiBDYWxsYmFjaykge1xuICogICAgIHRoaXMuZXZlbnRNYW5hZ2VyLm9mZihldmVudCwgY2FsbGJhY2spO1xuICogICB9XG4gKlxuICogICBiYXIoKSB7XG4gKiAgICAgdGhpcy5ldmVudE1hbmFnZXIuZGlzcGF0Y2goJ3NvbWVFdmVudCcpO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgRXZlbnRNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBkZWZhdWx0X21hcF8xLkRlZmF1bHRNYXAudXNpbmdGdW5jdGlvbigoKSA9PiBuZXcgU2V0KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW4gdGhlIGdpdmVuIGNhbGxiYWNrIHdoZW4gdGhlIGdpdmVuIGV2ZW50IGlzIGRpc3BhdGNoZWQuXG4gICAgICovXG4gICAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmdldChldmVudCkuYWRkKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVuIGNhbGxiYWNrcyBmb3IgdGhlIGdpdmVuIGV2ZW50IHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGRpc3BhdGNoKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmdldChldmVudCkuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayguLi5hcmdzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgcnVubmluZyB0aGUgZ2l2ZW4gY2FsbGJhY2sgb24gdGhlIGdpdmVuIGV2ZW50LlxuICAgICAqL1xuICAgIG9mZihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MuZ2V0KGV2ZW50KTtcbiAgICAgICAgY2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIGlmIChjYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuZGVsZXRlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBvdXQgaW50ZXJuYWwgU2V0cyBhbmQgTWFwLlxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuY2FsbGJhY2tzLnZhbHVlcygpO1xuICAgICAgICBsZXQgY2FsbGJhY2tTZXQgPSB2YWx1ZXMubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIWNhbGxiYWNrU2V0LmRvbmUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrU2V0LnZhbHVlLmNsZWFyKCk7XG4gICAgICAgICAgICBjYWxsYmFja1NldCA9IHZhbHVlcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsYmFja3MuY2xlYXIoKTtcbiAgICB9XG59XG5leHBvcnRzLkV2ZW50TWFuYWdlciA9IEV2ZW50TWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50cy5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/ui/events.js\n");

/***/ }),

/***/ "./lib/x/x-game-object.js":
/*!********************************!*\
  !*** ./lib/x/x-game-object.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XGameObject = exports.XGameObjectDefaults = void 0;\nconst func_1 = __webpack_require__(/*! ../func/func */ \"./lib/func/func.js\");\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst vector_1 = __webpack_require__(/*! ../mathf/vector */ \"./lib/mathf/vector.js\");\nconst ease_1 = __webpack_require__(/*! ../ease/ease */ \"./lib/ease/ease.js\");\nexports.XGameObjectDefaults = {\n    id: '',\n    x: 0,\n    y: 0,\n    alpha: 1,\n    width: 0,\n    height: 0,\n    scaleX: 1,\n    scaleY: 1,\n    anchorX: 0,\n    anchorY: 0,\n    rotation: 0,\n    interactable: false,\n    zIndex: 0,\n};\n/**\n * # XEngine Game Object\n *\n * The GameObject is a central part of the X Engine and specifically,\n * the coordinate system is designed to make global calculations easy\n * so that the x-engine objects that exist in canvas can ultimately,\n * easily be aligned with DOM elements.\n *\n * At a high level, the XStage typically is the top level GameObject.\n * Each GameObject can have children.  When a child is attached to\n * a GameObject, it becomes grouped with it's parents and it's x,y positions\n * will become relative to the parent.\n *\n *\n * # Positioning System\n * Positioning is coordinated by a combination of position, velocity and\n * acceleration vectors.\n *\n * position vector  (x,y)\n * - this is the actual coordinates of the GameObject.\n *\n * velocity vector (vx, vy)\n * - velocity is how much the position is changed per frame.  In short,\n *   velocity gets added to the position every frame.\n *\n * acceleration vector (ax, ay)\n * - A force that changes velocity.\n *   acceleration is added to the velocity vector every frame.  acceleration\n *   changes velocity.\n *\n * See the updatePosition method to see how these are added on each gameLoop\n * cycle.\n *\n *\n *\n *\n *\n * @unstable\n */\nclass XGameObject {\n    constructor(config) {\n        this.parent = undefined;\n        this.visible = true;\n        this.debugObject = false;\n        this.children = [];\n        this.alpha_ = func_1.func.setDefault(config.alpha, 1);\n        this.id = func_1.func.setDefault(config.id, exports.XGameObjectDefaults.id);\n        this.zIndex = func_1.func.setDefault(config.zIndex, exports.XGameObjectDefaults.zIndex);\n        const x = func_1.func.setDefault(config.x, exports.XGameObjectDefaults.x);\n        const y = func_1.func.setDefault(config.y, exports.XGameObjectDefaults.y);\n        this.position = new vector_1.Vector(x, y);\n        this.velocity = vector_1.Vector.ZERO;\n        this.acceleration = vector_1.Vector.ZERO;\n        this.naturalScaleX = func_1.func.setDefault(config.scaleX, exports.XGameObjectDefaults.scaleX);\n        this.naturalScaleY = func_1.func.setDefault(config.scaleY, exports.XGameObjectDefaults.scaleY);\n        this.anchorX = func_1.func.setDefault(config.anchorX, exports.XGameObjectDefaults.anchorX);\n        this.anchorY = func_1.func.setDefault(config.anchorY, exports.XGameObjectDefaults.anchorY);\n        this.naturalWidth = func_1.func.setDefault(config.width, exports.XGameObjectDefaults.width);\n        this.naturalHeight = func_1.func.setDefault(config.height, exports.XGameObjectDefaults.height);\n        this.rotation = func_1.func.setDefault(config.rotation, exports.XGameObjectDefaults.rotation);\n        this.interactable = func_1.func.setDefault(config.interactable, exports.XGameObjectDefaults.interactable);\n        this.onMouseUp = func_1.func.setDefault(config.onMouseUp, null);\n        this.onMouseMove = func_1.func.setDefault(config.onMouseMove, null);\n        this.onMouseDown = func_1.func.setDefault(config.onMouseDown, null);\n        this.texture = func_1.func.setDefault(config.texture, null);\n        if (this.texture) {\n            this.setTexture(this.texture);\n        }\n    }\n    get x() {\n        return this.position.x;\n    }\n    set x(value) {\n        this.position.x = value;\n    }\n    get y() {\n        return this.position.y;\n    }\n    set y(value) {\n        this.position.y = value;\n    }\n    get vx() {\n        return this.velocity.x;\n    }\n    set vx(value) {\n        this.velocity.x = value;\n    }\n    get vy() {\n        return this.velocity.y;\n    }\n    set vy(value) {\n        this.velocity.y = value;\n    }\n    get ax() {\n        return this.acceleration.x;\n    }\n    set ax(value) {\n        this.acceleration.x = value;\n    }\n    get ay() {\n        return this.acceleration.y;\n    }\n    set ay(value) {\n        this.acceleration.y = value;\n    }\n    /**\n     * Sets a main texture for this sprite.\n     * @param texture\n     */\n    setTexture(texture) {\n        this.texture = texture;\n        this.naturalWidth = this.texture.width;\n        this.naturalHeight = this.texture.height;\n    }\n    /**\n     * The global x coordinates of this GameObject.  This is a combination\n     * of the local x value + the parents global x value.  Does not consider\n     * rotation (use globalCorners for that).\n     */\n    get gx() {\n        const parentGx = (this.parent && this.parent.gx) || 0;\n        return this.x + parentGx;\n    }\n    /**\n     * The global y coordinates of this GameObject.  This is a combination\n     * of the local y value + the parents global y value.  Does not consider\n     * rotation (use global corders for that.)\n     */\n    get gy() {\n        const parentGy = (this.parent && this.parent.gy) || 0;\n        return this.y + parentGy;\n    }\n    /**\n     * The global computed positions of this gameObject with scale and rotation.\n     * The top left, top right, bottom left, and bottom right\n     * x, y coordinates of this game object (assume it is rectangular) in\n     * the actually computed sizes on the screen.\n     * This value is computed and considers scales and rotation as represented\n     * the exact coordinates on the screen so it useful if you want global\n     * coordinates of the gameObject position, width and height.\n     *\n     * Return the XGameConfigComputedBox\n     * @returns {XGameConfigComputedBox}\n     */\n    get globalComputedBox() {\n        // First figure out the coordinates of each corner\n        // without the rotation.\n        const box = {\n            centerPoint: {\n                x: this.gcx,\n                y: this.gcy,\n            },\n            width: this.width,\n            height: this.height,\n            topLeft: {\n                x: this.gx,\n                y: this.gy,\n            },\n            topRight: {\n                x: this.gx + this.width,\n                y: this.gy,\n            },\n            bottomLeft: {\n                x: this.gx,\n                y: this.gy + this.height,\n            },\n            bottomRight: {\n                x: this.gx + this.width,\n                y: this.gy + this.height,\n            },\n        };\n        // Now calculate the rotation of each point via 2d rotation matrix.\n        const cx = this.gcx;\n        const cy = this.gcy;\n        const topLeft = mathf_1.mathf.calculate2dPointRotation(cx, cy, box.topLeft.x, box.topLeft.y, this.rotation);\n        box.topLeft.x = topLeft.x;\n        box.topLeft.y = topLeft.y;\n        const topRight = mathf_1.mathf.calculate2dPointRotation(cx, cy, box.topRight.x, box.topRight.y, this.rotation);\n        box.topRight.x = topRight.x;\n        box.topRight.y = topRight.y;\n        const bottomLeft = mathf_1.mathf.calculate2dPointRotation(cx, cy, box.bottomLeft.x, box.bottomLeft.y, this.rotation);\n        box.bottomLeft.x = bottomLeft.x;\n        box.bottomLeft.y = bottomLeft.y;\n        const bottomRight = mathf_1.mathf.calculate2dPointRotation(cx, cy, box.bottomRight.x, box.bottomRight.y, this.rotation);\n        box.bottomRight.x = bottomRight.x;\n        box.bottomRight.y = bottomRight.y;\n        return box;\n    }\n    /**\n     * The global center point x of this object.\n     */\n    get gcx() {\n        return this.gx + this.anchorXOffset;\n    }\n    /**\n     * The global center point y of this object.\n     */\n    get gcy() {\n        return this.gy + this.anchorYOffset;\n    }\n    get globalCenterVector() {\n        return new vector_1.Vector(this.gcx, this.gcy).floor();\n    }\n    get anchorXOffset() {\n        return this.naturalAnchorXOffset * this.scaleX;\n    }\n    get anchorYOffset() {\n        return this.naturalAnchorYOffset * this.scaleY;\n    }\n    /**\n     * This is a vector representing the \"computed\" (including scale),\n     * vector from the top, left of the GameObject to the center point.\n     */\n    get anchorOffsetVector() {\n        return new vector_1.Vector(this.anchorXOffset, this.anchorYOffset).floor();\n    }\n    /**\n     * Give that the x, y position represent the position of the Gameobject,\n     * the amount we need to move to get to the anchor point.\n     *\n     * Let's say we have an object that is 500x500 at coords 0,0.\n     * If the anchor is 0.5, 0.5 for example, the anchor is dead center of the\n     * object.\n     *-----------\n     *\n     *     a\n     *\n     * ----------\n     *\n     * The anchorXOffset would be 250 and anchorYOffset would be 250.\n     * That is 0 (x) + 250 (anchorXOffset) = 250\n     * That is 0 (y) + 250 (anchorYOffset) = 250\n     *\n     */\n    get naturalAnchorXOffset() {\n        return this.naturalWidth * this.anchorX;\n    }\n    get naturalAnchorYOffset() {\n        return this.naturalHeight * this.anchorY;\n    }\n    /**\n     * The computed width of this gameObject when it is rendered on the canvas.\n     * This is effectively the global scale * the width internal width value.\n     */\n    get width() {\n        return this.naturalWidth * this.scaleX;\n    }\n    set width(value) {\n        this.naturalWidth = value;\n    }\n    /**\n     * The computed height of this gameObject when it is rendered on the canvas.\n     * This is effectively the global scale * the width internal width value.\n     */\n    get height() {\n        return this.naturalHeight * this.scaleX;\n    }\n    set height(value) {\n        this.naturalHeight = value;\n    }\n    /**\n     * The global anchor x positon.\n     */\n    get anchorGx() {\n        return this.gx + this.naturalAnchorXOffset;\n    }\n    /**\n     * The global anchor y positon.\n     */\n    get anchorGy() {\n        return this.gy + this.naturalAnchorYOffset;\n    }\n    get alpha() {\n        const parentAlpha = (this.parent && this.parent.alpha) || 1;\n        const relativeAlpha = parentAlpha * this.alpha_;\n        return relativeAlpha;\n    }\n    set alpha(value) {\n        this.alpha_ = value;\n    }\n    get scaleX() {\n        const parentScaleX = (this.parent && this.parent.scaleX) || 1;\n        const relativeScale = parentScaleX * this.naturalScaleY;\n        return relativeScale;\n    }\n    set scaleX(value) {\n        this.scaleX = value;\n    }\n    get scaleY() {\n        const parentScaleY = (this.parent && this.parent.scaleY) || 1;\n        const relativeScale = parentScaleY * this.naturalScaleY;\n        return relativeScale;\n    }\n    set scaleY(value) {\n        this.scaleY = value;\n    }\n    setPosition(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    /**\n     * Adds a child to this sprite.  At the highest level, the stage sprite\n     * will receive the canvas context and element when it\n     * [[XStage.attachToCanvas]] is called.  From there, any sprite that attaches\n     * to the stage, receives the canvas, context and then further, passes it\n     * on to it's descendants in this method.\n     * @param sprite\n     */\n    addChild(sprite) {\n        sprite.parent = this;\n        this.children.push(sprite);\n        // Always maintain an ordered list of children.\n        this.orderChildrenByZIndex();\n    }\n    /**\n     * Order the children by z-index\n     */\n    orderChildrenByZIndex() {\n        this.children = this.children.sort((a, b) => {\n            return a.zIndex - b.zIndex;\n        });\n    }\n    removeChild(sprite) {\n        if (sprite.parent !== this) {\n            throw new Error(sprite + 'is not a child of ' + this);\n        }\n        this.children = this.children.filter(childSprites => {\n            return sprite !== childSprites;\n        });\n    }\n    /**\n     * In the game loop called prior to rendering to update position of this\n     * object.\n     */\n    updatePositions() {\n        if (this.debugObject) {\n            this.velocity.add(this.acceleration);\n            this.position.add(this.velocity);\n        }\n        else {\n            this.velocity.ease(this.acceleration, 1, ease_1.EASE.linear);\n            this.position.add(this.velocity);\n        }\n    }\n    /**\n     * Render this object onto the current canvas.\n     */\n    render(context) {\n        if (this.texture) {\n            context.drawImage(this.texture.imageElement, 0, 0, this.texture.width, this.texture.height, \n            // If the anchor is 0,0, this value would be 0,0.\n            // we want to paint it at exactly where the anchor is.\n            -this.naturalAnchorXOffset, -this.naturalAnchorYOffset, this.naturalWidth, this.naturalHeight);\n        }\n    }\n    renderDebuggingOutlines(context) {\n        context.strokeStyle = 'red';\n        context.lineWidth = 10;\n        context.strokeRect(\n        // If the anchor is 0,0, this value would be 0,0.\n        // we want to paint it at exactly where the anchor is.\n        -this.naturalAnchorXOffset, -this.naturalAnchorYOffset, this.naturalWidth, this.naturalHeight);\n    }\n}\nexports.XGameObject = XGameObject;\n//# sourceMappingURL=x-game-object.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIveC94LWdhbWUtb2JqZWN0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3gveC1nYW1lLW9iamVjdC5qcz83ZDc0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5YR2FtZU9iamVjdCA9IGV4cG9ydHMuWEdhbWVPYmplY3REZWZhdWx0cyA9IHZvaWQgMDtcbmNvbnN0IGZ1bmNfMSA9IHJlcXVpcmUoXCIuLi9mdW5jL2Z1bmNcIik7XG5jb25zdCBtYXRoZl8xID0gcmVxdWlyZShcIi4uL21hdGhmL21hdGhmXCIpO1xuY29uc3QgdmVjdG9yXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvdmVjdG9yXCIpO1xuY29uc3QgZWFzZV8xID0gcmVxdWlyZShcIi4uL2Vhc2UvZWFzZVwiKTtcbmV4cG9ydHMuWEdhbWVPYmplY3REZWZhdWx0cyA9IHtcbiAgICBpZDogJycsXG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIGFscGhhOiAxLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBzY2FsZVg6IDEsXG4gICAgc2NhbGVZOiAxLFxuICAgIGFuY2hvclg6IDAsXG4gICAgYW5jaG9yWTogMCxcbiAgICByb3RhdGlvbjogMCxcbiAgICBpbnRlcmFjdGFibGU6IGZhbHNlLFxuICAgIHpJbmRleDogMCxcbn07XG4vKipcbiAqICMgWEVuZ2luZSBHYW1lIE9iamVjdFxuICpcbiAqIFRoZSBHYW1lT2JqZWN0IGlzIGEgY2VudHJhbCBwYXJ0IG9mIHRoZSBYIEVuZ2luZSBhbmQgc3BlY2lmaWNhbGx5LFxuICogdGhlIGNvb3JkaW5hdGUgc3lzdGVtIGlzIGRlc2lnbmVkIHRvIG1ha2UgZ2xvYmFsIGNhbGN1bGF0aW9ucyBlYXN5XG4gKiBzbyB0aGF0IHRoZSB4LWVuZ2luZSBvYmplY3RzIHRoYXQgZXhpc3QgaW4gY2FudmFzIGNhbiB1bHRpbWF0ZWx5LFxuICogZWFzaWx5IGJlIGFsaWduZWQgd2l0aCBET00gZWxlbWVudHMuXG4gKlxuICogQXQgYSBoaWdoIGxldmVsLCB0aGUgWFN0YWdlIHR5cGljYWxseSBpcyB0aGUgdG9wIGxldmVsIEdhbWVPYmplY3QuXG4gKiBFYWNoIEdhbWVPYmplY3QgY2FuIGhhdmUgY2hpbGRyZW4uICBXaGVuIGEgY2hpbGQgaXMgYXR0YWNoZWQgdG9cbiAqIGEgR2FtZU9iamVjdCwgaXQgYmVjb21lcyBncm91cGVkIHdpdGggaXQncyBwYXJlbnRzIGFuZCBpdCdzIHgseSBwb3NpdGlvbnNcbiAqIHdpbGwgYmVjb21lIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQuXG4gKlxuICpcbiAqICMgUG9zaXRpb25pbmcgU3lzdGVtXG4gKiBQb3NpdGlvbmluZyBpcyBjb29yZGluYXRlZCBieSBhIGNvbWJpbmF0aW9uIG9mIHBvc2l0aW9uLCB2ZWxvY2l0eSBhbmRcbiAqIGFjY2VsZXJhdGlvbiB2ZWN0b3JzLlxuICpcbiAqIHBvc2l0aW9uIHZlY3RvciAgKHgseSlcbiAqIC0gdGhpcyBpcyB0aGUgYWN0dWFsIGNvb3JkaW5hdGVzIG9mIHRoZSBHYW1lT2JqZWN0LlxuICpcbiAqIHZlbG9jaXR5IHZlY3RvciAodngsIHZ5KVxuICogLSB2ZWxvY2l0eSBpcyBob3cgbXVjaCB0aGUgcG9zaXRpb24gaXMgY2hhbmdlZCBwZXIgZnJhbWUuICBJbiBzaG9ydCxcbiAqICAgdmVsb2NpdHkgZ2V0cyBhZGRlZCB0byB0aGUgcG9zaXRpb24gZXZlcnkgZnJhbWUuXG4gKlxuICogYWNjZWxlcmF0aW9uIHZlY3RvciAoYXgsIGF5KVxuICogLSBBIGZvcmNlIHRoYXQgY2hhbmdlcyB2ZWxvY2l0eS5cbiAqICAgYWNjZWxlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSB2ZWxvY2l0eSB2ZWN0b3IgZXZlcnkgZnJhbWUuICBhY2NlbGVyYXRpb25cbiAqICAgY2hhbmdlcyB2ZWxvY2l0eS5cbiAqXG4gKiBTZWUgdGhlIHVwZGF0ZVBvc2l0aW9uIG1ldGhvZCB0byBzZWUgaG93IHRoZXNlIGFyZSBhZGRlZCBvbiBlYWNoIGdhbWVMb29wXG4gKiBjeWNsZS5cbiAqXG4gKlxuICpcbiAqXG4gKlxuICogQHVuc3RhYmxlXG4gKi9cbmNsYXNzIFhHYW1lT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVidWdPYmplY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmFscGhhXyA9IGZ1bmNfMS5mdW5jLnNldERlZmF1bHQoY29uZmlnLmFscGhhLCAxKTtcbiAgICAgICAgdGhpcy5pZCA9IGZ1bmNfMS5mdW5jLnNldERlZmF1bHQoY29uZmlnLmlkLCBleHBvcnRzLlhHYW1lT2JqZWN0RGVmYXVsdHMuaWQpO1xuICAgICAgICB0aGlzLnpJbmRleCA9IGZ1bmNfMS5mdW5jLnNldERlZmF1bHQoY29uZmlnLnpJbmRleCwgZXhwb3J0cy5YR2FtZU9iamVjdERlZmF1bHRzLnpJbmRleCk7XG4gICAgICAgIGNvbnN0IHggPSBmdW5jXzEuZnVuYy5zZXREZWZhdWx0KGNvbmZpZy54LCBleHBvcnRzLlhHYW1lT2JqZWN0RGVmYXVsdHMueCk7XG4gICAgICAgIGNvbnN0IHkgPSBmdW5jXzEuZnVuYy5zZXREZWZhdWx0KGNvbmZpZy55LCBleHBvcnRzLlhHYW1lT2JqZWN0RGVmYXVsdHMueSk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgdmVjdG9yXzEuVmVjdG9yKHgsIHkpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdmVjdG9yXzEuVmVjdG9yLlpFUk87XG4gICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gdmVjdG9yXzEuVmVjdG9yLlpFUk87XG4gICAgICAgIHRoaXMubmF0dXJhbFNjYWxlWCA9IGZ1bmNfMS5mdW5jLnNldERlZmF1bHQoY29uZmlnLnNjYWxlWCwgZXhwb3J0cy5YR2FtZU9iamVjdERlZmF1bHRzLnNjYWxlWCk7XG4gICAgICAgIHRoaXMubmF0dXJhbFNjYWxlWSA9IGZ1bmNfMS5mdW5jLnNldERlZmF1bHQoY29uZmlnLnNjYWxlWSwgZXhwb3J0cy5YR2FtZU9iamVjdERlZmF1bHRzLnNjYWxlWSk7XG4gICAgICAgIHRoaXMuYW5jaG9yWCA9IGZ1bmNfMS5mdW5jLnNldERlZmF1bHQoY29uZmlnLmFuY2hvclgsIGV4cG9ydHMuWEdhbWVPYmplY3REZWZhdWx0cy5hbmNob3JYKTtcbiAgICAgICAgdGhpcy5hbmNob3JZID0gZnVuY18xLmZ1bmMuc2V0RGVmYXVsdChjb25maWcuYW5jaG9yWSwgZXhwb3J0cy5YR2FtZU9iamVjdERlZmF1bHRzLmFuY2hvclkpO1xuICAgICAgICB0aGlzLm5hdHVyYWxXaWR0aCA9IGZ1bmNfMS5mdW5jLnNldERlZmF1bHQoY29uZmlnLndpZHRoLCBleHBvcnRzLlhHYW1lT2JqZWN0RGVmYXVsdHMud2lkdGgpO1xuICAgICAgICB0aGlzLm5hdHVyYWxIZWlnaHQgPSBmdW5jXzEuZnVuYy5zZXREZWZhdWx0KGNvbmZpZy5oZWlnaHQsIGV4cG9ydHMuWEdhbWVPYmplY3REZWZhdWx0cy5oZWlnaHQpO1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gZnVuY18xLmZ1bmMuc2V0RGVmYXVsdChjb25maWcucm90YXRpb24sIGV4cG9ydHMuWEdhbWVPYmplY3REZWZhdWx0cy5yb3RhdGlvbik7XG4gICAgICAgIHRoaXMuaW50ZXJhY3RhYmxlID0gZnVuY18xLmZ1bmMuc2V0RGVmYXVsdChjb25maWcuaW50ZXJhY3RhYmxlLCBleHBvcnRzLlhHYW1lT2JqZWN0RGVmYXVsdHMuaW50ZXJhY3RhYmxlKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlVXAgPSBmdW5jXzEuZnVuYy5zZXREZWZhdWx0KGNvbmZpZy5vbk1vdXNlVXAsIG51bGwpO1xuICAgICAgICB0aGlzLm9uTW91c2VNb3ZlID0gZnVuY18xLmZ1bmMuc2V0RGVmYXVsdChjb25maWcub25Nb3VzZU1vdmUsIG51bGwpO1xuICAgICAgICB0aGlzLm9uTW91c2VEb3duID0gZnVuY18xLmZ1bmMuc2V0RGVmYXVsdChjb25maWcub25Nb3VzZURvd24sIG51bGwpO1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBmdW5jXzEuZnVuYy5zZXREZWZhdWx0KGNvbmZpZy50ZXh0dXJlLCBudWxsKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRUZXh0dXJlKHRoaXMudGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XG4gICAgfVxuICAgIHNldCB4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueTtcbiAgICB9XG4gICAgc2V0IHkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCB2eCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVsb2NpdHkueDtcbiAgICB9XG4gICAgc2V0IHZ4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmVsb2NpdHkueCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlbG9jaXR5Lnk7XG4gICAgfVxuICAgIHNldCB2eSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZlbG9jaXR5LnkgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbGVyYXRpb24ueDtcbiAgICB9XG4gICAgc2V0IGF4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uLnggPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbGVyYXRpb24ueTtcbiAgICB9XG4gICAgc2V0IGF5KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uLnkgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1haW4gdGV4dHVyZSBmb3IgdGhpcyBzcHJpdGUuXG4gICAgICogQHBhcmFtIHRleHR1cmVcbiAgICAgKi9cbiAgICBzZXRUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgICAgdGhpcy5uYXR1cmFsV2lkdGggPSB0aGlzLnRleHR1cmUud2lkdGg7XG4gICAgICAgIHRoaXMubmF0dXJhbEhlaWdodCA9IHRoaXMudGV4dHVyZS5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBnbG9iYWwgeCBjb29yZGluYXRlcyBvZiB0aGlzIEdhbWVPYmplY3QuICBUaGlzIGlzIGEgY29tYmluYXRpb25cbiAgICAgKiBvZiB0aGUgbG9jYWwgeCB2YWx1ZSArIHRoZSBwYXJlbnRzIGdsb2JhbCB4IHZhbHVlLiAgRG9lcyBub3QgY29uc2lkZXJcbiAgICAgKiByb3RhdGlvbiAodXNlIGdsb2JhbENvcm5lcnMgZm9yIHRoYXQpLlxuICAgICAqL1xuICAgIGdldCBneCgpIHtcbiAgICAgICAgY29uc3QgcGFyZW50R3ggPSAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuZ3gpIHx8IDA7XG4gICAgICAgIHJldHVybiB0aGlzLnggKyBwYXJlbnRHeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGdsb2JhbCB5IGNvb3JkaW5hdGVzIG9mIHRoaXMgR2FtZU9iamVjdC4gIFRoaXMgaXMgYSBjb21iaW5hdGlvblxuICAgICAqIG9mIHRoZSBsb2NhbCB5IHZhbHVlICsgdGhlIHBhcmVudHMgZ2xvYmFsIHkgdmFsdWUuICBEb2VzIG5vdCBjb25zaWRlclxuICAgICAqIHJvdGF0aW9uICh1c2UgZ2xvYmFsIGNvcmRlcnMgZm9yIHRoYXQuKVxuICAgICAqL1xuICAgIGdldCBneSgpIHtcbiAgICAgICAgY29uc3QgcGFyZW50R3kgPSAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuZ3kpIHx8IDA7XG4gICAgICAgIHJldHVybiB0aGlzLnkgKyBwYXJlbnRHeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGdsb2JhbCBjb21wdXRlZCBwb3NpdGlvbnMgb2YgdGhpcyBnYW1lT2JqZWN0IHdpdGggc2NhbGUgYW5kIHJvdGF0aW9uLlxuICAgICAqIFRoZSB0b3AgbGVmdCwgdG9wIHJpZ2h0LCBib3R0b20gbGVmdCwgYW5kIGJvdHRvbSByaWdodFxuICAgICAqIHgsIHkgY29vcmRpbmF0ZXMgb2YgdGhpcyBnYW1lIG9iamVjdCAoYXNzdW1lIGl0IGlzIHJlY3Rhbmd1bGFyKSBpblxuICAgICAqIHRoZSBhY3R1YWxseSBjb21wdXRlZCBzaXplcyBvbiB0aGUgc2NyZWVuLlxuICAgICAqIFRoaXMgdmFsdWUgaXMgY29tcHV0ZWQgYW5kIGNvbnNpZGVycyBzY2FsZXMgYW5kIHJvdGF0aW9uIGFzIHJlcHJlc2VudGVkXG4gICAgICogdGhlIGV4YWN0IGNvb3JkaW5hdGVzIG9uIHRoZSBzY3JlZW4gc28gaXQgdXNlZnVsIGlmIHlvdSB3YW50IGdsb2JhbFxuICAgICAqIGNvb3JkaW5hdGVzIG9mIHRoZSBnYW1lT2JqZWN0IHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqXG4gICAgICogUmV0dXJuIHRoZSBYR2FtZUNvbmZpZ0NvbXB1dGVkQm94XG4gICAgICogQHJldHVybnMge1hHYW1lQ29uZmlnQ29tcHV0ZWRCb3h9XG4gICAgICovXG4gICAgZ2V0IGdsb2JhbENvbXB1dGVkQm94KCkge1xuICAgICAgICAvLyBGaXJzdCBmaWd1cmUgb3V0IHRoZSBjb29yZGluYXRlcyBvZiBlYWNoIGNvcm5lclxuICAgICAgICAvLyB3aXRob3V0IHRoZSByb3RhdGlvbi5cbiAgICAgICAgY29uc3QgYm94ID0ge1xuICAgICAgICAgICAgY2VudGVyUG9pbnQ6IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmdjeCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmdjeSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICB0b3BMZWZ0OiB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5neCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmd5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvcFJpZ2h0OiB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5neCArIHRoaXMud2lkdGgsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5neSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib3R0b21MZWZ0OiB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5neCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmd5ICsgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm90dG9tUmlnaHQ6IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmd4ICsgdGhpcy53aWR0aCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmd5ICsgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBOb3cgY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBvZiBlYWNoIHBvaW50IHZpYSAyZCByb3RhdGlvbiBtYXRyaXguXG4gICAgICAgIGNvbnN0IGN4ID0gdGhpcy5nY3g7XG4gICAgICAgIGNvbnN0IGN5ID0gdGhpcy5nY3k7XG4gICAgICAgIGNvbnN0IHRvcExlZnQgPSBtYXRoZl8xLm1hdGhmLmNhbGN1bGF0ZTJkUG9pbnRSb3RhdGlvbihjeCwgY3ksIGJveC50b3BMZWZ0LngsIGJveC50b3BMZWZ0LnksIHRoaXMucm90YXRpb24pO1xuICAgICAgICBib3gudG9wTGVmdC54ID0gdG9wTGVmdC54O1xuICAgICAgICBib3gudG9wTGVmdC55ID0gdG9wTGVmdC55O1xuICAgICAgICBjb25zdCB0b3BSaWdodCA9IG1hdGhmXzEubWF0aGYuY2FsY3VsYXRlMmRQb2ludFJvdGF0aW9uKGN4LCBjeSwgYm94LnRvcFJpZ2h0LngsIGJveC50b3BSaWdodC55LCB0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgYm94LnRvcFJpZ2h0LnggPSB0b3BSaWdodC54O1xuICAgICAgICBib3gudG9wUmlnaHQueSA9IHRvcFJpZ2h0Lnk7XG4gICAgICAgIGNvbnN0IGJvdHRvbUxlZnQgPSBtYXRoZl8xLm1hdGhmLmNhbGN1bGF0ZTJkUG9pbnRSb3RhdGlvbihjeCwgY3ksIGJveC5ib3R0b21MZWZ0LngsIGJveC5ib3R0b21MZWZ0LnksIHRoaXMucm90YXRpb24pO1xuICAgICAgICBib3guYm90dG9tTGVmdC54ID0gYm90dG9tTGVmdC54O1xuICAgICAgICBib3guYm90dG9tTGVmdC55ID0gYm90dG9tTGVmdC55O1xuICAgICAgICBjb25zdCBib3R0b21SaWdodCA9IG1hdGhmXzEubWF0aGYuY2FsY3VsYXRlMmRQb2ludFJvdGF0aW9uKGN4LCBjeSwgYm94LmJvdHRvbVJpZ2h0LngsIGJveC5ib3R0b21SaWdodC55LCB0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgYm94LmJvdHRvbVJpZ2h0LnggPSBib3R0b21SaWdodC54O1xuICAgICAgICBib3guYm90dG9tUmlnaHQueSA9IGJvdHRvbVJpZ2h0Lnk7XG4gICAgICAgIHJldHVybiBib3g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBnbG9iYWwgY2VudGVyIHBvaW50IHggb2YgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgZ2V0IGdjeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3ggKyB0aGlzLmFuY2hvclhPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBnbG9iYWwgY2VudGVyIHBvaW50IHkgb2YgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgZ2V0IGdjeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3kgKyB0aGlzLmFuY2hvcllPZmZzZXQ7XG4gICAgfVxuICAgIGdldCBnbG9iYWxDZW50ZXJWZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBuZXcgdmVjdG9yXzEuVmVjdG9yKHRoaXMuZ2N4LCB0aGlzLmdjeSkuZmxvb3IoKTtcbiAgICB9XG4gICAgZ2V0IGFuY2hvclhPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdHVyYWxBbmNob3JYT2Zmc2V0ICogdGhpcy5zY2FsZVg7XG4gICAgfVxuICAgIGdldCBhbmNob3JZT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXR1cmFsQW5jaG9yWU9mZnNldCAqIHRoaXMuc2NhbGVZO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgXCJjb21wdXRlZFwiIChpbmNsdWRpbmcgc2NhbGUpLFxuICAgICAqIHZlY3RvciBmcm9tIHRoZSB0b3AsIGxlZnQgb2YgdGhlIEdhbWVPYmplY3QgdG8gdGhlIGNlbnRlciBwb2ludC5cbiAgICAgKi9cbiAgICBnZXQgYW5jaG9yT2Zmc2V0VmVjdG9yKCkge1xuICAgICAgICByZXR1cm4gbmV3IHZlY3Rvcl8xLlZlY3Rvcih0aGlzLmFuY2hvclhPZmZzZXQsIHRoaXMuYW5jaG9yWU9mZnNldCkuZmxvb3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZSB0aGF0IHRoZSB4LCB5IHBvc2l0aW9uIHJlcHJlc2VudCB0aGUgcG9zaXRpb24gb2YgdGhlIEdhbWVvYmplY3QsXG4gICAgICogdGhlIGFtb3VudCB3ZSBuZWVkIHRvIG1vdmUgdG8gZ2V0IHRvIHRoZSBhbmNob3IgcG9pbnQuXG4gICAgICpcbiAgICAgKiBMZXQncyBzYXkgd2UgaGF2ZSBhbiBvYmplY3QgdGhhdCBpcyA1MDB4NTAwIGF0IGNvb3JkcyAwLDAuXG4gICAgICogSWYgdGhlIGFuY2hvciBpcyAwLjUsIDAuNSBmb3IgZXhhbXBsZSwgdGhlIGFuY2hvciBpcyBkZWFkIGNlbnRlciBvZiB0aGVcbiAgICAgKiBvYmplY3QuXG4gICAgICotLS0tLS0tLS0tLVxuICAgICAqXG4gICAgICogICAgIGFcbiAgICAgKlxuICAgICAqIC0tLS0tLS0tLS1cbiAgICAgKlxuICAgICAqIFRoZSBhbmNob3JYT2Zmc2V0IHdvdWxkIGJlIDI1MCBhbmQgYW5jaG9yWU9mZnNldCB3b3VsZCBiZSAyNTAuXG4gICAgICogVGhhdCBpcyAwICh4KSArIDI1MCAoYW5jaG9yWE9mZnNldCkgPSAyNTBcbiAgICAgKiBUaGF0IGlzIDAgKHkpICsgMjUwIChhbmNob3JZT2Zmc2V0KSA9IDI1MFxuICAgICAqXG4gICAgICovXG4gICAgZ2V0IG5hdHVyYWxBbmNob3JYT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXR1cmFsV2lkdGggKiB0aGlzLmFuY2hvclg7XG4gICAgfVxuICAgIGdldCBuYXR1cmFsQW5jaG9yWU9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF0dXJhbEhlaWdodCAqIHRoaXMuYW5jaG9yWTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbXB1dGVkIHdpZHRoIG9mIHRoaXMgZ2FtZU9iamVjdCB3aGVuIGl0IGlzIHJlbmRlcmVkIG9uIHRoZSBjYW52YXMuXG4gICAgICogVGhpcyBpcyBlZmZlY3RpdmVseSB0aGUgZ2xvYmFsIHNjYWxlICogdGhlIHdpZHRoIGludGVybmFsIHdpZHRoIHZhbHVlLlxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF0dXJhbFdpZHRoICogdGhpcy5zY2FsZVg7XG4gICAgfVxuICAgIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm5hdHVyYWxXaWR0aCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29tcHV0ZWQgaGVpZ2h0IG9mIHRoaXMgZ2FtZU9iamVjdCB3aGVuIGl0IGlzIHJlbmRlcmVkIG9uIHRoZSBjYW52YXMuXG4gICAgICogVGhpcyBpcyBlZmZlY3RpdmVseSB0aGUgZ2xvYmFsIHNjYWxlICogdGhlIHdpZHRoIGludGVybmFsIHdpZHRoIHZhbHVlLlxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdHVyYWxIZWlnaHQgKiB0aGlzLnNjYWxlWDtcbiAgICB9XG4gICAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm5hdHVyYWxIZWlnaHQgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGdsb2JhbCBhbmNob3IgeCBwb3NpdG9uLlxuICAgICAqL1xuICAgIGdldCBhbmNob3JHeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3ggKyB0aGlzLm5hdHVyYWxBbmNob3JYT2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZ2xvYmFsIGFuY2hvciB5IHBvc2l0b24uXG4gICAgICovXG4gICAgZ2V0IGFuY2hvckd5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5neSArIHRoaXMubmF0dXJhbEFuY2hvcllPZmZzZXQ7XG4gICAgfVxuICAgIGdldCBhbHBoYSgpIHtcbiAgICAgICAgY29uc3QgcGFyZW50QWxwaGEgPSAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuYWxwaGEpIHx8IDE7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlQWxwaGEgPSBwYXJlbnRBbHBoYSAqIHRoaXMuYWxwaGFfO1xuICAgICAgICByZXR1cm4gcmVsYXRpdmVBbHBoYTtcbiAgICB9XG4gICAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYWxwaGFfID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBzY2FsZVgoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFNjYWxlWCA9ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5zY2FsZVgpIHx8IDE7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlU2NhbGUgPSBwYXJlbnRTY2FsZVggKiB0aGlzLm5hdHVyYWxTY2FsZVk7XG4gICAgICAgIHJldHVybiByZWxhdGl2ZVNjYWxlO1xuICAgIH1cbiAgICBzZXQgc2NhbGVYKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2NhbGVYID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBzY2FsZVkoKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFNjYWxlWSA9ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5zY2FsZVkpIHx8IDE7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlU2NhbGUgPSBwYXJlbnRTY2FsZVkgKiB0aGlzLm5hdHVyYWxTY2FsZVk7XG4gICAgICAgIHJldHVybiByZWxhdGl2ZVNjYWxlO1xuICAgIH1cbiAgICBzZXQgc2NhbGVZKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2NhbGVZID0gdmFsdWU7XG4gICAgfVxuICAgIHNldFBvc2l0aW9uKHgsIHkpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNoaWxkIHRvIHRoaXMgc3ByaXRlLiAgQXQgdGhlIGhpZ2hlc3QgbGV2ZWwsIHRoZSBzdGFnZSBzcHJpdGVcbiAgICAgKiB3aWxsIHJlY2VpdmUgdGhlIGNhbnZhcyBjb250ZXh0IGFuZCBlbGVtZW50IHdoZW4gaXRcbiAgICAgKiBbW1hTdGFnZS5hdHRhY2hUb0NhbnZhc11dIGlzIGNhbGxlZC4gIEZyb20gdGhlcmUsIGFueSBzcHJpdGUgdGhhdCBhdHRhY2hlc1xuICAgICAqIHRvIHRoZSBzdGFnZSwgcmVjZWl2ZXMgdGhlIGNhbnZhcywgY29udGV4dCBhbmQgdGhlbiBmdXJ0aGVyLCBwYXNzZXMgaXRcbiAgICAgKiBvbiB0byBpdCdzIGRlc2NlbmRhbnRzIGluIHRoaXMgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBzcHJpdGVcbiAgICAgKi9cbiAgICBhZGRDaGlsZChzcHJpdGUpIHtcbiAgICAgICAgc3ByaXRlLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChzcHJpdGUpO1xuICAgICAgICAvLyBBbHdheXMgbWFpbnRhaW4gYW4gb3JkZXJlZCBsaXN0IG9mIGNoaWxkcmVuLlxuICAgICAgICB0aGlzLm9yZGVyQ2hpbGRyZW5CeVpJbmRleCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcmRlciB0aGUgY2hpbGRyZW4gYnkgei1pbmRleFxuICAgICAqL1xuICAgIG9yZGVyQ2hpbGRyZW5CeVpJbmRleCgpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGEuekluZGV4IC0gYi56SW5kZXg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZChzcHJpdGUpIHtcbiAgICAgICAgaWYgKHNwcml0ZS5wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzcHJpdGUgKyAnaXMgbm90IGEgY2hpbGQgb2YgJyArIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmZpbHRlcihjaGlsZFNwcml0ZXMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHNwcml0ZSAhPT0gY2hpbGRTcHJpdGVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW4gdGhlIGdhbWUgbG9vcCBjYWxsZWQgcHJpb3IgdG8gcmVuZGVyaW5nIHRvIHVwZGF0ZSBwb3NpdGlvbiBvZiB0aGlzXG4gICAgICogb2JqZWN0LlxuICAgICAqL1xuICAgIHVwZGF0ZVBvc2l0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVidWdPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkuYWRkKHRoaXMuYWNjZWxlcmF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24uYWRkKHRoaXMudmVsb2NpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS5lYXNlKHRoaXMuYWNjZWxlcmF0aW9uLCAxLCBlYXNlXzEuRUFTRS5saW5lYXIpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5hZGQodGhpcy52ZWxvY2l0eSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoaXMgb2JqZWN0IG9udG8gdGhlIGN1cnJlbnQgY2FudmFzLlxuICAgICAqL1xuICAgIHJlbmRlcihjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRoaXMudGV4dHVyZS5pbWFnZUVsZW1lbnQsIDAsIDAsIHRoaXMudGV4dHVyZS53aWR0aCwgdGhpcy50ZXh0dXJlLmhlaWdodCwgXG4gICAgICAgICAgICAvLyBJZiB0aGUgYW5jaG9yIGlzIDAsMCwgdGhpcyB2YWx1ZSB3b3VsZCBiZSAwLDAuXG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRvIHBhaW50IGl0IGF0IGV4YWN0bHkgd2hlcmUgdGhlIGFuY2hvciBpcy5cbiAgICAgICAgICAgIC10aGlzLm5hdHVyYWxBbmNob3JYT2Zmc2V0LCAtdGhpcy5uYXR1cmFsQW5jaG9yWU9mZnNldCwgdGhpcy5uYXR1cmFsV2lkdGgsIHRoaXMubmF0dXJhbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyRGVidWdnaW5nT3V0bGluZXMoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTA7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChcbiAgICAgICAgLy8gSWYgdGhlIGFuY2hvciBpcyAwLDAsIHRoaXMgdmFsdWUgd291bGQgYmUgMCwwLlxuICAgICAgICAvLyB3ZSB3YW50IHRvIHBhaW50IGl0IGF0IGV4YWN0bHkgd2hlcmUgdGhlIGFuY2hvciBpcy5cbiAgICAgICAgLXRoaXMubmF0dXJhbEFuY2hvclhPZmZzZXQsIC10aGlzLm5hdHVyYWxBbmNob3JZT2Zmc2V0LCB0aGlzLm5hdHVyYWxXaWR0aCwgdGhpcy5uYXR1cmFsSGVpZ2h0KTtcbiAgICB9XG59XG5leHBvcnRzLlhHYW1lT2JqZWN0ID0gWEdhbWVPYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD14LWdhbWUtb2JqZWN0LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/x/x-game-object.js\n");

/***/ }),

/***/ "./lib/x/x-line.js":
/*!*************************!*\
  !*** ./lib/x/x-line.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XLine = void 0;\nconst func_1 = __webpack_require__(/*! ../func/func */ \"./lib/func/func.js\");\nconst x_game_object_1 = __webpack_require__(/*! ./x-game-object */ \"./lib/x/x-game-object.js\");\n/**\n * A single line in the x-engine.\n * @unstable\n */\nclass XLine extends x_game_object_1.XGameObject {\n    constructor(config) {\n        super(config);\n        /**\n         * An Object defining startX, startY, endX and endY for the linear gradient.\n         * TODO (uxder): Clean this up.\n         */\n        this.linearGradient = null;\n        this.radialGradient = null;\n        this.strokeStyle = func_1.func.setDefault(config.strokeStyle, 'red');\n        this.lineWidth = func_1.func.setDefault(config.lineWidth, 1);\n        this.startX = func_1.func.setDefault(config.startX, 0);\n        this.startY = func_1.func.setDefault(config.startY, 0);\n        this.endX = func_1.func.setDefault(config.endX, 0);\n        this.endY = func_1.func.setDefault(config.endY, 0);\n        this.gradientStops = func_1.func.setDefault(config.gradientStops, null);\n        this.linearGradient = func_1.func.setDefault(config.linearGradient, null);\n        //Options are \"round\", \"mitre\" and \"bevel\".\n        this.lineJoin = 'round';\n    }\n    render(ctx) {\n        ctx.strokeStyle = this.strokeStyle;\n        if (this.gradientStops) {\n            let grad = ctx.createLinearGradient(this.startX, this.startY, this.endX, this.endY);\n            // Override linear gradient poitns.\n            if (this.linearGradient) {\n                grad = ctx.createLinearGradient(this.linearGradient.startX, this.linearGradient.startY, this.linearGradient.endX, this.linearGradient.endY);\n            }\n            // Override linear gradient poitns.\n            if (this.radialGradient) {\n                grad = ctx.createRadialGradient(this.radialGradient.x0, this.radialGradient.y0, this.radialGradient.r0, this.radialGradient.x1, this.radialGradient.y1, this.radialGradient.r1);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.gradientStops.forEach((stop) => {\n                grad.addColorStop(stop.stop, stop.color);\n            });\n            ctx.strokeStyle = grad;\n        }\n        ctx.lineWidth = this.lineWidth;\n        ctx.beginPath();\n        ctx.lineJoin = 'round';\n        ctx.moveTo(this.startX, this.startY);\n        ctx.lineTo(this.endX, this.endY);\n        //ctx.closePath();\n        ctx.stroke();\n        // if (this..strokeStyle !== \"none\") ctx.stroke();\n        // if (o.fillStyle !== \"none\") ctx.fill();\n    }\n}\nexports.XLine = XLine;\n//# sourceMappingURL=x-line.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIveC94LWxpbmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIveC94LWxpbmUuanM/NThjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuWExpbmUgPSB2b2lkIDA7XG5jb25zdCBmdW5jXzEgPSByZXF1aXJlKFwiLi4vZnVuYy9mdW5jXCIpO1xuY29uc3QgeF9nYW1lX29iamVjdF8xID0gcmVxdWlyZShcIi4veC1nYW1lLW9iamVjdFwiKTtcbi8qKlxuICogQSBzaW5nbGUgbGluZSBpbiB0aGUgeC1lbmdpbmUuXG4gKiBAdW5zdGFibGVcbiAqL1xuY2xhc3MgWExpbmUgZXh0ZW5kcyB4X2dhbWVfb2JqZWN0XzEuWEdhbWVPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gT2JqZWN0IGRlZmluaW5nIHN0YXJ0WCwgc3RhcnRZLCBlbmRYIGFuZCBlbmRZIGZvciB0aGUgbGluZWFyIGdyYWRpZW50LlxuICAgICAgICAgKiBUT0RPICh1eGRlcik6IENsZWFuIHRoaXMgdXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVhckdyYWRpZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yYWRpYWxHcmFkaWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUgPSBmdW5jXzEuZnVuYy5zZXREZWZhdWx0KGNvbmZpZy5zdHJva2VTdHlsZSwgJ3JlZCcpO1xuICAgICAgICB0aGlzLmxpbmVXaWR0aCA9IGZ1bmNfMS5mdW5jLnNldERlZmF1bHQoY29uZmlnLmxpbmVXaWR0aCwgMSk7XG4gICAgICAgIHRoaXMuc3RhcnRYID0gZnVuY18xLmZ1bmMuc2V0RGVmYXVsdChjb25maWcuc3RhcnRYLCAwKTtcbiAgICAgICAgdGhpcy5zdGFydFkgPSBmdW5jXzEuZnVuYy5zZXREZWZhdWx0KGNvbmZpZy5zdGFydFksIDApO1xuICAgICAgICB0aGlzLmVuZFggPSBmdW5jXzEuZnVuYy5zZXREZWZhdWx0KGNvbmZpZy5lbmRYLCAwKTtcbiAgICAgICAgdGhpcy5lbmRZID0gZnVuY18xLmZ1bmMuc2V0RGVmYXVsdChjb25maWcuZW5kWSwgMCk7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRTdG9wcyA9IGZ1bmNfMS5mdW5jLnNldERlZmF1bHQoY29uZmlnLmdyYWRpZW50U3RvcHMsIG51bGwpO1xuICAgICAgICB0aGlzLmxpbmVhckdyYWRpZW50ID0gZnVuY18xLmZ1bmMuc2V0RGVmYXVsdChjb25maWcubGluZWFyR3JhZGllbnQsIG51bGwpO1xuICAgICAgICAvL09wdGlvbnMgYXJlIFwicm91bmRcIiwgXCJtaXRyZVwiIGFuZCBcImJldmVsXCIuXG4gICAgICAgIHRoaXMubGluZUpvaW4gPSAncm91bmQnO1xuICAgIH1cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlU3R5bGU7XG4gICAgICAgIGlmICh0aGlzLmdyYWRpZW50U3RvcHMpIHtcbiAgICAgICAgICAgIGxldCBncmFkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHRoaXMuc3RhcnRYLCB0aGlzLnN0YXJ0WSwgdGhpcy5lbmRYLCB0aGlzLmVuZFkpO1xuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgbGluZWFyIGdyYWRpZW50IHBvaXRucy5cbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVhckdyYWRpZW50KSB7XG4gICAgICAgICAgICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLmxpbmVhckdyYWRpZW50LnN0YXJ0WCwgdGhpcy5saW5lYXJHcmFkaWVudC5zdGFydFksIHRoaXMubGluZWFyR3JhZGllbnQuZW5kWCwgdGhpcy5saW5lYXJHcmFkaWVudC5lbmRZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIGxpbmVhciBncmFkaWVudCBwb2l0bnMuXG4gICAgICAgICAgICBpZiAodGhpcy5yYWRpYWxHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIGdyYWQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQodGhpcy5yYWRpYWxHcmFkaWVudC54MCwgdGhpcy5yYWRpYWxHcmFkaWVudC55MCwgdGhpcy5yYWRpYWxHcmFkaWVudC5yMCwgdGhpcy5yYWRpYWxHcmFkaWVudC54MSwgdGhpcy5yYWRpYWxHcmFkaWVudC55MSwgdGhpcy5yYWRpYWxHcmFkaWVudC5yMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFN0b3BzLmZvckVhY2goKHN0b3ApID0+IHtcbiAgICAgICAgICAgICAgICBncmFkLmFkZENvbG9yU3RvcChzdG9wLnN0b3AsIHN0b3AuY29sb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBncmFkO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVXaWR0aDtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubGluZUpvaW4gPSAncm91bmQnO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMuc3RhcnRYLCB0aGlzLnN0YXJ0WSk7XG4gICAgICAgIGN0eC5saW5lVG8odGhpcy5lbmRYLCB0aGlzLmVuZFkpO1xuICAgICAgICAvL2N0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAvLyBpZiAodGhpcy4uc3Ryb2tlU3R5bGUgIT09IFwibm9uZVwiKSBjdHguc3Ryb2tlKCk7XG4gICAgICAgIC8vIGlmIChvLmZpbGxTdHlsZSAhPT0gXCJub25lXCIpIGN0eC5maWxsKCk7XG4gICAgfVxufVxuZXhwb3J0cy5YTGluZSA9IFhMaW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eC1saW5lLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/x/x-line.js\n");

/***/ }),

/***/ "./lib/x/x-offscreen-canvas.js":
/*!*************************************!*\
  !*** ./lib/x/x-offscreen-canvas.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XOffScreenCanvas = void 0;\n/**\n * A general canvas that exists in memery for x-engine to perform offscreen\n * calculatons.  Note this is NOT the same as the buffer rendering canvas\n * TODO (uxder) to be implemented.  But more a shared, singleton to canvas\n * that can be drawn on to do calculations.\n *\n * Note that since this is shared resource, there is no guarantee of state.\n * Objects using it should clean up.\n * @unstable\n */\nclass XOffScreenCanvas {\n    constructor() {\n        this.canvas = document.createElement('canvas');\n        this.context = this.canvas.getContext('2d');\n        this.dpr = window.devicePixelRatio || 1;\n        this.canvas.width = 1000 * this.dpr;\n        this.canvas.height = 1000 * this.dpr;\n    }\n}\nexports.XOffScreenCanvas = XOffScreenCanvas;\n//# sourceMappingURL=x-offscreen-canvas.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIveC94LW9mZnNjcmVlbi1jYW52YXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIveC94LW9mZnNjcmVlbi1jYW52YXMuanM/MzllNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuWE9mZlNjcmVlbkNhbnZhcyA9IHZvaWQgMDtcbi8qKlxuICogQSBnZW5lcmFsIGNhbnZhcyB0aGF0IGV4aXN0cyBpbiBtZW1lcnkgZm9yIHgtZW5naW5lIHRvIHBlcmZvcm0gb2Zmc2NyZWVuXG4gKiBjYWxjdWxhdG9ucy4gIE5vdGUgdGhpcyBpcyBOT1QgdGhlIHNhbWUgYXMgdGhlIGJ1ZmZlciByZW5kZXJpbmcgY2FudmFzXG4gKiBUT0RPICh1eGRlcikgdG8gYmUgaW1wbGVtZW50ZWQuICBCdXQgbW9yZSBhIHNoYXJlZCwgc2luZ2xldG9uIHRvIGNhbnZhc1xuICogdGhhdCBjYW4gYmUgZHJhd24gb24gdG8gZG8gY2FsY3VsYXRpb25zLlxuICpcbiAqIE5vdGUgdGhhdCBzaW5jZSB0aGlzIGlzIHNoYXJlZCByZXNvdXJjZSwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIG9mIHN0YXRlLlxuICogT2JqZWN0cyB1c2luZyBpdCBzaG91bGQgY2xlYW4gdXAuXG4gKiBAdW5zdGFibGVcbiAqL1xuY2xhc3MgWE9mZlNjcmVlbkNhbnZhcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSAxMDAwICogdGhpcy5kcHI7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IDEwMDAgKiB0aGlzLmRwcjtcbiAgICB9XG59XG5leHBvcnRzLlhPZmZTY3JlZW5DYW52YXMgPSBYT2ZmU2NyZWVuQ2FudmFzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eC1vZmZzY3JlZW4tY2FudmFzLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/x/x-offscreen-canvas.js\n");

/***/ }),

/***/ "./lib/x/x-pointer.js":
/*!****************************!*\
  !*** ./lib/x/x-pointer.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XPointer = void 0;\nconst mathf_1 = __webpack_require__(/*! ../mathf/mathf */ \"./lib/mathf/mathf.js\");\nconst vector_1 = __webpack_require__(/*! ../mathf/vector */ \"./lib/mathf/vector.js\");\n/**\n * The main pointer class for x-engine.  Use this to detect collision with\n * GameObjects and respond to the pointer.\n * @unstable\n */\nclass XPointer {\n    constructor(element) {\n        /**\n         * Wehther the mouse is down.\n         */\n        this.isMouseDown = false;\n        this.position = vector_1.Vector.ZERO;\n        this.radius = 1;\n        this.element = element;\n        this.element.addEventListener('mousedown', this.pointerDownHandler.bind(this), { passive: true });\n        this.element.addEventListener('touchstart', this.pointerDownHandler.bind(this), { passive: true });\n        this.element.addEventListener('mouseup', this.pointerUpHandler.bind(this), {\n            passive: true,\n        });\n        this.element.addEventListener('touchend', this.pointerUpHandler.bind(this), { passive: true });\n        this.element.addEventListener('mousemove', this.pointerMoveHandler.bind(this), { passive: true });\n        this.element.addEventListener('touchmove', this.pointerMoveHandler.bind(this), { passive: true });\n    }\n    get x() {\n        return this.position.x;\n    }\n    set x(x) {\n        this.position.x = x;\n    }\n    get y() {\n        return this.position.y;\n    }\n    set y(y) {\n        this.position.y = y;\n    }\n    pointerDownHandler() {\n        this.isMouseDown = true;\n    }\n    pointerUpHandler() {\n        this.isMouseDown = false;\n    }\n    pointerMoveHandler(event) {\n        //Find the pointers x and y position (for mouse).\n        //Subtract the element's top and left offset from the browser window.\n        let pageX;\n        let pageY;\n        if (event.touches) {\n            pageX = event.touches[0].pageX;\n            pageY = event.touches[0].pageY;\n        }\n        else {\n            pageX = event.pageX;\n            pageY = event.pageY;\n        }\n        // TODO (uxder) Optimization point. Cache offset value to avoid thrashing.\n        const x = pageX - this.element.offsetLeft;\n        const y = pageY - this.element.offsetTop;\n        this.position.set(x, y);\n    }\n    /**\n     * Tests a collision with a GameObject.\n     * @param object\n     */\n    testCollidingWithGameObject(object) {\n        const point = {\n            x: this.x,\n            y: this.y,\n        };\n        // Generate a polygon out of the (possibly rotated)\n        // box coordinates.\n        const polygon = [\n            object.globalComputedBox.topLeft,\n            object.globalComputedBox.topRight,\n            object.globalComputedBox.bottomRight,\n            object.globalComputedBox.bottomLeft,\n        ];\n        // console.log(this.position);\n        // Account for anchor.\n        // rect.x += object.width * object.anchorX;\n        // rect.y += object.height * object.anchorY;\n        // console.log('rect.x', rect.x);\n        // console.log('rect.y', rect.y);\n        return mathf_1.mathf.collisionPointVersusConvexPolygon(point, polygon);\n    }\n}\nexports.XPointer = XPointer;\n//# sourceMappingURL=x-pointer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIveC94LXBvaW50ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIveC94LXBvaW50ZXIuanM/YmY5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuWFBvaW50ZXIgPSB2b2lkIDA7XG5jb25zdCBtYXRoZl8xID0gcmVxdWlyZShcIi4uL21hdGhmL21hdGhmXCIpO1xuY29uc3QgdmVjdG9yXzEgPSByZXF1aXJlKFwiLi4vbWF0aGYvdmVjdG9yXCIpO1xuLyoqXG4gKiBUaGUgbWFpbiBwb2ludGVyIGNsYXNzIGZvciB4LWVuZ2luZS4gIFVzZSB0aGlzIHRvIGRldGVjdCBjb2xsaXNpb24gd2l0aFxuICogR2FtZU9iamVjdHMgYW5kIHJlc3BvbmQgdG8gdGhlIHBvaW50ZXIuXG4gKiBAdW5zdGFibGVcbiAqL1xuY2xhc3MgWFBvaW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlaHRoZXIgdGhlIG1vdXNlIGlzIGRvd24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzTW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB2ZWN0b3JfMS5WZWN0b3IuWkVSTztcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAxO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5wb2ludGVyRG93bkhhbmRsZXIuYmluZCh0aGlzKSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMucG9pbnRlckRvd25IYW5kbGVyLmJpbmQodGhpcyksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLnBvaW50ZXJVcEhhbmRsZXIuYmluZCh0aGlzKSwge1xuICAgICAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMucG9pbnRlclVwSGFuZGxlci5iaW5kKHRoaXMpLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLnBvaW50ZXJNb3ZlSGFuZGxlci5iaW5kKHRoaXMpLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLnBvaW50ZXJNb3ZlSGFuZGxlci5iaW5kKHRoaXMpLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgfVxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi54O1xuICAgIH1cbiAgICBzZXQgeCh4KSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueCA9IHg7XG4gICAgfVxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xuICAgIH1cbiAgICBzZXQgeSh5KSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueSA9IHk7XG4gICAgfVxuICAgIHBvaW50ZXJEb3duSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5pc01vdXNlRG93biA9IHRydWU7XG4gICAgfVxuICAgIHBvaW50ZXJVcEhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICB9XG4gICAgcG9pbnRlck1vdmVIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIC8vRmluZCB0aGUgcG9pbnRlcuKAmXMgeCBhbmQgeSBwb3NpdGlvbiAoZm9yIG1vdXNlKS5cbiAgICAgICAgLy9TdWJ0cmFjdCB0aGUgZWxlbWVudCdzIHRvcCBhbmQgbGVmdCBvZmZzZXQgZnJvbSB0aGUgYnJvd3NlciB3aW5kb3cuXG4gICAgICAgIGxldCBwYWdlWDtcbiAgICAgICAgbGV0IHBhZ2VZO1xuICAgICAgICBpZiAoZXZlbnQudG91Y2hlcykge1xuICAgICAgICAgICAgcGFnZVggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgcGFnZVkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFnZVggPSBldmVudC5wYWdlWDtcbiAgICAgICAgICAgIHBhZ2VZID0gZXZlbnQucGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyAodXhkZXIpIE9wdGltaXphdGlvbiBwb2ludC4gQ2FjaGUgb2Zmc2V0IHZhbHVlIHRvIGF2b2lkIHRocmFzaGluZy5cbiAgICAgICAgY29uc3QgeCA9IHBhZ2VYIC0gdGhpcy5lbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgICAgIGNvbnN0IHkgPSBwYWdlWSAtIHRoaXMuZWxlbWVudC5vZmZzZXRUb3A7XG4gICAgICAgIHRoaXMucG9zaXRpb24uc2V0KHgsIHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0cyBhIGNvbGxpc2lvbiB3aXRoIGEgR2FtZU9iamVjdC5cbiAgICAgKiBAcGFyYW0gb2JqZWN0XG4gICAgICovXG4gICAgdGVzdENvbGxpZGluZ1dpdGhHYW1lT2JqZWN0KG9iamVjdCkge1xuICAgICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICAgIHk6IHRoaXMueSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSBwb2x5Z29uIG91dCBvZiB0aGUgKHBvc3NpYmx5IHJvdGF0ZWQpXG4gICAgICAgIC8vIGJveCBjb29yZGluYXRlcy5cbiAgICAgICAgY29uc3QgcG9seWdvbiA9IFtcbiAgICAgICAgICAgIG9iamVjdC5nbG9iYWxDb21wdXRlZEJveC50b3BMZWZ0LFxuICAgICAgICAgICAgb2JqZWN0Lmdsb2JhbENvbXB1dGVkQm94LnRvcFJpZ2h0LFxuICAgICAgICAgICAgb2JqZWN0Lmdsb2JhbENvbXB1dGVkQm94LmJvdHRvbVJpZ2h0LFxuICAgICAgICAgICAgb2JqZWN0Lmdsb2JhbENvbXB1dGVkQm94LmJvdHRvbUxlZnQsXG4gICAgICAgIF07XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucG9zaXRpb24pO1xuICAgICAgICAvLyBBY2NvdW50IGZvciBhbmNob3IuXG4gICAgICAgIC8vIHJlY3QueCArPSBvYmplY3Qud2lkdGggKiBvYmplY3QuYW5jaG9yWDtcbiAgICAgICAgLy8gcmVjdC55ICs9IG9iamVjdC5oZWlnaHQgKiBvYmplY3QuYW5jaG9yWTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlY3QueCcsIHJlY3QueCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZWN0LnknLCByZWN0LnkpO1xuICAgICAgICByZXR1cm4gbWF0aGZfMS5tYXRoZi5jb2xsaXNpb25Qb2ludFZlcnN1c0NvbnZleFBvbHlnb24ocG9pbnQsIHBvbHlnb24pO1xuICAgIH1cbn1cbmV4cG9ydHMuWFBvaW50ZXIgPSBYUG9pbnRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXgtcG9pbnRlci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/x/x-pointer.js\n");

/***/ }),

/***/ "./lib/x/x-rectangle.js":
/*!******************************!*\
  !*** ./lib/x/x-rectangle.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XRectangle = void 0;\nconst func_1 = __webpack_require__(/*! ../func/func */ \"./lib/func/func.js\");\nconst x_game_object_1 = __webpack_require__(/*! ./x-game-object */ \"./lib/x/x-game-object.js\");\n/**\n * @unstable\n */\nclass XRectangle extends x_game_object_1.XGameObject {\n    constructor(config) {\n        super(config);\n        this.strokeStyle = func_1.func.setDefault(config.strokeStyle, null);\n        this.fillStyle = func_1.func.setDefault(config.fillStyle, null);\n        this.lineWidth = func_1.func.setDefault(config.lineWidth, 1);\n    }\n    render(ctx) {\n        ctx.fillStyle = this.fillStyle;\n        ctx.strokeStyle = this.strokeStyle;\n        ctx.rect(-this.naturalWidth * this.anchorX, -this.naturalHeight * this.anchorY, this.naturalWidth, this.naturalHeight);\n        if (this.strokeStyle) {\n            ctx.stroke();\n        }\n        if (this.fillStyle)\n            ctx.fill();\n    }\n}\nexports.XRectangle = XRectangle;\n//# sourceMappingURL=x-rectangle.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIveC94LXJlY3RhbmdsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYi94L3gtcmVjdGFuZ2xlLmpzPzFlNjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlhSZWN0YW5nbGUgPSB2b2lkIDA7XG5jb25zdCBmdW5jXzEgPSByZXF1aXJlKFwiLi4vZnVuYy9mdW5jXCIpO1xuY29uc3QgeF9nYW1lX29iamVjdF8xID0gcmVxdWlyZShcIi4veC1nYW1lLW9iamVjdFwiKTtcbi8qKlxuICogQHVuc3RhYmxlXG4gKi9cbmNsYXNzIFhSZWN0YW5nbGUgZXh0ZW5kcyB4X2dhbWVfb2JqZWN0XzEuWEdhbWVPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLnN0cm9rZVN0eWxlID0gZnVuY18xLmZ1bmMuc2V0RGVmYXVsdChjb25maWcuc3Ryb2tlU3R5bGUsIG51bGwpO1xuICAgICAgICB0aGlzLmZpbGxTdHlsZSA9IGZ1bmNfMS5mdW5jLnNldERlZmF1bHQoY29uZmlnLmZpbGxTdHlsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gZnVuY18xLmZ1bmMuc2V0RGVmYXVsdChjb25maWcubGluZVdpZHRoLCAxKTtcbiAgICB9XG4gICAgcmVuZGVyKGN0eCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsU3R5bGU7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlU3R5bGU7XG4gICAgICAgIGN0eC5yZWN0KC10aGlzLm5hdHVyYWxXaWR0aCAqIHRoaXMuYW5jaG9yWCwgLXRoaXMubmF0dXJhbEhlaWdodCAqIHRoaXMuYW5jaG9yWSwgdGhpcy5uYXR1cmFsV2lkdGgsIHRoaXMubmF0dXJhbEhlaWdodCk7XG4gICAgICAgIGlmICh0aGlzLnN0cm9rZVN0eWxlKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmlsbFN0eWxlKVxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG59XG5leHBvcnRzLlhSZWN0YW5nbGUgPSBYUmVjdGFuZ2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eC1yZWN0YW5nbGUuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./lib/x/x-rectangle.js\n");

/***/ }),

/***/ "./lib/x/x-stage.js":
/*!**************************!*\
  !*** ./lib/x/x-stage.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XStage = void 0;\nconst x_game_object_1 = __webpack_require__(/*! ./x-game-object */ \"./lib/x/x-game-object.js\");\n/**\n * Base stage class used for the x-engine.\n * @unstable\n */\nclass XStage extends x_game_object_1.XGameObject {\n    constructor(config = x_game_object_1.XGameObjectDefaults) {\n        super(config);\n        /**\n         * A flag to denote that this is a special GameObject of stage.\n         */\n        this.stage = true;\n        this.canvasElement = null;\n        this.context = null;\n    }\n    attachToCanvas(canvas) {\n        this.canvasElement = canvas;\n        this.context = this.canvasElement.getContext('2d');\n        this.naturalWidth = canvas.offsetWidth;\n        this.naturalHeight = canvas.offsetHeight;\n        this.setPosition(0, 0);\n    }\n}\nexports.XStage = XStage;\n//# sourceMappingURL=x-stage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIveC94LXN0YWdlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3gveC1zdGFnZS5qcz83YmI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5YU3RhZ2UgPSB2b2lkIDA7XG5jb25zdCB4X2dhbWVfb2JqZWN0XzEgPSByZXF1aXJlKFwiLi94LWdhbWUtb2JqZWN0XCIpO1xuLyoqXG4gKiBCYXNlIHN0YWdlIGNsYXNzIHVzZWQgZm9yIHRoZSB4LWVuZ2luZS5cbiAqIEB1bnN0YWJsZVxuICovXG5jbGFzcyBYU3RhZ2UgZXh0ZW5kcyB4X2dhbWVfb2JqZWN0XzEuWEdhbWVPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHhfZ2FtZV9vYmplY3RfMS5YR2FtZU9iamVjdERlZmF1bHRzKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gZGVub3RlIHRoYXQgdGhpcyBpcyBhIHNwZWNpYWwgR2FtZU9iamVjdCBvZiBzdGFnZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhZ2UgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIH1cbiAgICBhdHRhY2hUb0NhbnZhcyhjYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50ID0gY2FudmFzO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGhpcy5uYXR1cmFsV2lkdGggPSBjYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIHRoaXMubmF0dXJhbEhlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oMCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5YU3RhZ2UgPSBYU3RhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD14LXN0YWdlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/x/x-stage.js\n");

/***/ }),

/***/ "./lib/x/x-text.js":
/*!*************************!*\
  !*** ./lib/x/x-text.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XText = void 0;\nconst func_1 = __webpack_require__(/*! ../func/func */ \"./lib/func/func.js\");\nconst x_game_object_1 = __webpack_require__(/*! ./x-game-object */ \"./lib/x/x-game-object.js\");\nconst x_offscreen_canvas_1 = __webpack_require__(/*! ./x-offscreen-canvas */ \"./lib/x/x-offscreen-canvas.js\");\n/**\n * A single text in the x-engine.\n * TODO (uxder) Add an option or alternate that is DOM based.\n * @unstable\n */\nclass XText extends x_game_object_1.XGameObject {\n    constructor(config) {\n        super(config);\n        this.text = func_1.func.setDefault(config.text, 'Hello');\n        this.font = func_1.func.setDefault(config.font, '12px sans-serif');\n        this.textAlign = func_1.func.setDefault(config.textAlign, 'left');\n        this.fillStyle = func_1.func.setDefault(config.fillStyle, 'red');\n        this.textBaseline = func_1.func.setDefault(config.textBaseline, 'top');\n        this.offScreenCanvas = new x_offscreen_canvas_1.XOffScreenCanvas();\n    }\n    /**\n     * Sets the font to measure the width.\n     * https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics\n     */\n    get width() {\n        let width = 0;\n        this.offScreenCanvas.context.font = this.font;\n        this.offScreenCanvas.context.textAlign = this.textAlign;\n        this.offScreenCanvas.context.textBaseline = this.textBaseline;\n        width = this.offScreenCanvas.context.measureText(this.text).width;\n        return width || 0;\n    }\n    /**\n     * Sets the font to measure the height.  There isn't really a crossbrowser\n     * or realiable way to measure text at the moment, so we measure the\n     * width of a single character and multiply that by an assumed 1.2 line\n     * height for now as an approximation.\n     * https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics\n     */\n    get height() {\n        this.offScreenCanvas.context.font = this.font;\n        this.offScreenCanvas.context.textAlign = this.textAlign;\n        this.offScreenCanvas.context.textBaseline = this.textBaseline;\n        const width = this.offScreenCanvas.context.measureText('w').width;\n        return width * 1.2;\n    }\n    setText(text) {\n        this.text = text;\n    }\n    render(ctx) {\n        ctx.fillStyle = this.fillStyle;\n        ctx.translate(this.naturalAnchorXOffset, this.naturalAnchorYOffset);\n        ctx.font = this.font;\n        ctx.textBaseline = this.textBaseline;\n        ctx.fillText(this.text, 0, 0);\n    }\n}\nexports.XText = XText;\n//# sourceMappingURL=x-text.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIveC94LXRleHQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIveC94LXRleHQuanM/ZTliZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuWFRleHQgPSB2b2lkIDA7XG5jb25zdCBmdW5jXzEgPSByZXF1aXJlKFwiLi4vZnVuYy9mdW5jXCIpO1xuY29uc3QgeF9nYW1lX29iamVjdF8xID0gcmVxdWlyZShcIi4veC1nYW1lLW9iamVjdFwiKTtcbmNvbnN0IHhfb2Zmc2NyZWVuX2NhbnZhc18xID0gcmVxdWlyZShcIi4veC1vZmZzY3JlZW4tY2FudmFzXCIpO1xuLyoqXG4gKiBBIHNpbmdsZSB0ZXh0IGluIHRoZSB4LWVuZ2luZS5cbiAqIFRPRE8gKHV4ZGVyKSBBZGQgYW4gb3B0aW9uIG9yIGFsdGVybmF0ZSB0aGF0IGlzIERPTSBiYXNlZC5cbiAqIEB1bnN0YWJsZVxuICovXG5jbGFzcyBYVGV4dCBleHRlbmRzIHhfZ2FtZV9vYmplY3RfMS5YR2FtZU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMudGV4dCA9IGZ1bmNfMS5mdW5jLnNldERlZmF1bHQoY29uZmlnLnRleHQsICdIZWxsbycpO1xuICAgICAgICB0aGlzLmZvbnQgPSBmdW5jXzEuZnVuYy5zZXREZWZhdWx0KGNvbmZpZy5mb250LCAnMTJweCBzYW5zLXNlcmlmJyk7XG4gICAgICAgIHRoaXMudGV4dEFsaWduID0gZnVuY18xLmZ1bmMuc2V0RGVmYXVsdChjb25maWcudGV4dEFsaWduLCAnbGVmdCcpO1xuICAgICAgICB0aGlzLmZpbGxTdHlsZSA9IGZ1bmNfMS5mdW5jLnNldERlZmF1bHQoY29uZmlnLmZpbGxTdHlsZSwgJ3JlZCcpO1xuICAgICAgICB0aGlzLnRleHRCYXNlbGluZSA9IGZ1bmNfMS5mdW5jLnNldERlZmF1bHQoY29uZmlnLnRleHRCYXNlbGluZSwgJ3RvcCcpO1xuICAgICAgICB0aGlzLm9mZlNjcmVlbkNhbnZhcyA9IG5ldyB4X29mZnNjcmVlbl9jYW52YXNfMS5YT2ZmU2NyZWVuQ2FudmFzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGZvbnQgdG8gbWVhc3VyZSB0aGUgd2lkdGguXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RleHRNZXRyaWNzXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgICB0aGlzLm9mZlNjcmVlbkNhbnZhcy5jb250ZXh0LmZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgICAgIHRoaXMub2ZmU2NyZWVuQ2FudmFzLmNvbnRleHQudGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ247XG4gICAgICAgIHRoaXMub2ZmU2NyZWVuQ2FudmFzLmNvbnRleHQudGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmU7XG4gICAgICAgIHdpZHRoID0gdGhpcy5vZmZTY3JlZW5DYW52YXMuY29udGV4dC5tZWFzdXJlVGV4dCh0aGlzLnRleHQpLndpZHRoO1xuICAgICAgICByZXR1cm4gd2lkdGggfHwgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZm9udCB0byBtZWFzdXJlIHRoZSBoZWlnaHQuICBUaGVyZSBpc24ndCByZWFsbHkgYSBjcm9zc2Jyb3dzZXJcbiAgICAgKiBvciByZWFsaWFibGUgd2F5IHRvIG1lYXN1cmUgdGV4dCBhdCB0aGUgbW9tZW50LCBzbyB3ZSBtZWFzdXJlIHRoZVxuICAgICAqIHdpZHRoIG9mIGEgc2luZ2xlIGNoYXJhY3RlciBhbmQgbXVsdGlwbHkgdGhhdCBieSBhbiBhc3N1bWVkIDEuMiBsaW5lXG4gICAgICogaGVpZ2h0IGZvciBub3cgYXMgYW4gYXBwcm94aW1hdGlvbi5cbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGV4dE1ldHJpY3NcbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICB0aGlzLm9mZlNjcmVlbkNhbnZhcy5jb250ZXh0LmZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgICAgIHRoaXMub2ZmU2NyZWVuQ2FudmFzLmNvbnRleHQudGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ247XG4gICAgICAgIHRoaXMub2ZmU2NyZWVuQ2FudmFzLmNvbnRleHQudGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmU7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5vZmZTY3JlZW5DYW52YXMuY29udGV4dC5tZWFzdXJlVGV4dCgndycpLndpZHRoO1xuICAgICAgICByZXR1cm4gd2lkdGggKiAxLjI7XG4gICAgfVxuICAgIHNldFRleHQodGV4dCkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZpbGxTdHlsZTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLm5hdHVyYWxBbmNob3JYT2Zmc2V0LCB0aGlzLm5hdHVyYWxBbmNob3JZT2Zmc2V0KTtcbiAgICAgICAgY3R4LmZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0aGlzLnRleHRCYXNlbGluZTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMudGV4dCwgMCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5YVGV4dCA9IFhUZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eC10ZXh0LmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/x/x-text.js\n");

/***/ }),

/***/ "./lib/x/x-texture.js":
/*!****************************!*\
  !*** ./lib/x/x-texture.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XTexture = void 0;\n/**\n * Texture class to be used with the x-engine.\n * @unstable\n */\nclass XTexture {\n    constructor(imageElement) {\n        this.imageElement = imageElement;\n        this.width = imageElement.width;\n        this.height = imageElement.height;\n    }\n}\nexports.XTexture = XTexture;\n//# sourceMappingURL=x-texture.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIveC94LXRleHR1cmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIveC94LXRleHR1cmUuanM/NGM4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuWFRleHR1cmUgPSB2b2lkIDA7XG4vKipcbiAqIFRleHR1cmUgY2xhc3MgdG8gYmUgdXNlZCB3aXRoIHRoZSB4LWVuZ2luZS5cbiAqIEB1bnN0YWJsZVxuICovXG5jbGFzcyBYVGV4dHVyZSB7XG4gICAgY29uc3RydWN0b3IoaW1hZ2VFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50ID0gaW1hZ2VFbGVtZW50O1xuICAgICAgICB0aGlzLndpZHRoID0gaW1hZ2VFbGVtZW50LndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGltYWdlRWxlbWVudC5oZWlnaHQ7XG4gICAgfVxufVxuZXhwb3J0cy5YVGV4dHVyZSA9IFhUZXh0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eC10ZXh0dXJlLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/x/x-texture.js\n");

/***/ }),

/***/ "./lib/x/x.js":
/*!********************!*\
  !*** ./lib/x/x.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.X = void 0;\nconst func_1 = __webpack_require__(/*! ../func/func */ \"./lib/func/func.js\");\nconst raf_1 = __webpack_require__(/*! ../raf/raf */ \"./lib/raf/raf.js\");\nconst x_stage_1 = __webpack_require__(/*! ./x-stage */ \"./lib/x/x-stage.js\");\nconst x_pointer_1 = __webpack_require__(/*! ./x-pointer */ \"./lib/x/x-pointer.js\");\nconst x_text_1 = __webpack_require__(/*! ./x-text */ \"./lib/x/x-text.js\");\nconst dom_watcher_1 = __webpack_require__(/*! ../dom/dom-watcher */ \"./lib/dom/dom-watcher.js\");\n/**\n * # X is a mini canvas + dom 2d engine within degu.\n *\n * ```ts\n *\n *\n *\n * ```\n * @unstable\n */\nclass X {\n    constructor(config) {\n        this.canvasElement = config.canvasElement;\n        // Note the ! at the end.  Required to force typescript to assume\n        // getContext('2d') never returns null.\n        this.context = this.canvasElement.getContext('2d');\n        // Force set the canvas size. When you set the canvas size via css,\n        // css stretches the pixels within the canvas.\n        // Setting it as such, forces the correct size.\n        this.dpr = window.devicePixelRatio || 1;\n        this.canvasElement.width = 0;\n        this.canvasElement.height = 0;\n        this.width = 0;\n        this.height = 0;\n        this.resize();\n        this.watcher = new dom_watcher_1.DomWatcher();\n        this.watcher.add({\n            element: window,\n            on: 'resize',\n            callback: this.resize.bind(this),\n        });\n        this.debugMode = func_1.func.setDefault(config.debugMode, false);\n        // Create the main stage sprite.\n        this.stage = new x_stage_1.XStage();\n        this.stage.attachToCanvas(this.canvasElement);\n        // If we want to debug the mouse coords, add a text object to\n        // display.\n        this.mouseCoordsTextDebugObject = new x_text_1.XText({\n            // Add it at a really high index.\n            zIndex: 999999,\n        });\n        this.mouseCoordsTextDebugObject.debugObject = true;\n        if (this.debugMode) {\n            window['X'] = this;\n            window['X_STAGE'] = this.stage;\n            this.stage.addChild(this.mouseCoordsTextDebugObject);\n        }\n        /**\n         * The background color.\n         */\n        this.stageColor = null;\n        // Create the main pointer.\n        this.pointer = new x_pointer_1.XPointer(this.canvasElement);\n        this.raf = new raf_1.Raf(() => {\n            this.gameLoop();\n            // Update the mouse display to follow the mouse and display the\n            // current coordinates.\n            if (this.debugMode && this.mouseCoordsTextDebugObject) {\n                this.mouseCoordsTextDebugObject.setPosition(this.pointer.x + 20, this.pointer.y + 20);\n                this.mouseCoordsTextDebugObject.setText(`x: ${this.pointer.x}, y: ${this.pointer.y}`);\n            }\n        });\n    }\n    /**\n     * The background color for the stage.\n     * @param color\n     */\n    setStageColor(color) {\n        this.stageColor = color;\n    }\n    resize() {\n        this.dpr = window.devicePixelRatio || 1;\n        this.canvasElement.width = this.canvasElement.offsetWidth * this.dpr;\n        this.canvasElement.height = this.canvasElement.offsetHeight * this.dpr;\n        this.width = this.canvasElement.offsetWidth * this.dpr;\n        this.height = this.canvasElement.offsetHeight * this.dpr;\n    }\n    getPointer() {\n        return this.pointer;\n    }\n    clear() {\n        this.context.clearRect(0, 0, this.width, this.height);\n    }\n    /**\n     * The main engine loop.  Here we call through all the\n     * sprites on the main stage.\n     */\n    gameLoop() {\n        //Clear the canvas.\n        this.clear();\n        if (this.stageColor) {\n            this.context.fillStyle = this.stageColor;\n            this.context.fillRect(0, 0, this.width, this.height);\n        }\n        // Update the positions of each object\n        this.stage.children.forEach((gameObject) => {\n            gameObject.updatePositions();\n        });\n        // Render each object.\n        this.stage.children.forEach((gameObject) => {\n            this.renderGameObject(gameObject);\n        });\n    }\n    /**\n     * Renders a given sprite onto the canvas.  This is sort of imagined like\n     * a stamping process in which we turn, scale, change alpha of the context\n     * itself and stamp out the sprite per frame.\n     * @param gameObject\n     */\n    renderGameObject(gameObject) {\n        // Whether this gameObject is off screen.\n        const shouldRender = gameObject.visible &&\n            gameObject.gx < this.width + gameObject.width &&\n            gameObject.gx + gameObject.width >= -gameObject.width &&\n            gameObject.gy < this.height + gameObject.height &&\n            gameObject.gy + gameObject.height >= -gameObject.height;\n        if (!shouldRender) {\n            return;\n        }\n        // If this object is interactable, check the collision state\n        // with the pointer.\n        let colliding = false;\n        if (gameObject.interactable) {\n            colliding = this.pointer.testCollidingWithGameObject(gameObject);\n            if (colliding && this.pointer.isMouseDown) {\n                gameObject.onMouseDown && gameObject.onMouseDown(gameObject);\n            }\n            if (colliding && !this.pointer.isMouseDown) {\n                gameObject.onMouseUp && gameObject.onMouseUp(gameObject);\n            }\n            if (colliding) {\n                gameObject.onMouseMove && gameObject.onMouseMove(gameObject);\n            }\n        }\n        this.context.save();\n        // this.context.translate(\n        //         this.canvasElement.width  / 2,\n        //         this.canvasElement.height / 2)\n        // Scale to aspect ratio first.\n        this.context.scale(this.dpr, this.dpr);\n        // Adjust alpha\n        this.context.globalAlpha = gameObject.alpha;\n        // Move first\n        this.context.translate(\n        // gameObject.x + (gameObject.width * gameObject.anchorX),\n        // gameObject.y + (gameObject.height * gameObject.anchorY)\n        ~~gameObject.anchorGx, ~~gameObject.anchorGy);\n        // Then rotate\n        // Not sure why but canvas calculations rotation in anticlockwise manner?\n        // We counter this by interving the rotation value.\n        this.context.rotate(-gameObject.rotation);\n        // Now scale\n        this.context.scale(gameObject.scaleX, gameObject.scaleY);\n        // Call the gameObject render method to figure out how to draw this\n        // GameObject.\n        gameObject.render(this.context);\n        // Renders debugging outlines for this object if it is colliding.\n        if (this.debugMode && !gameObject.debugObject && colliding) {\n            gameObject.renderDebuggingOutlines(this.context);\n        }\n        this.context.restore();\n        // Now loop through each child and paint it out.\n        gameObject.children.forEach(childGameObject => {\n            this.renderGameObject(childGameObject);\n        });\n    }\n    /*\n     * Adds a watcher callback to the raf loop.\n     */\n    onTick(callback) {\n        this.raf.watch(callback);\n    }\n    /**\n     * Starts the main game loop.\n     */\n    start() {\n        this.raf.start();\n    }\n}\nexports.X = X;\n//# sourceMappingURL=x.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWIveC94LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGliL3gveC5qcz9jYTkxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5YID0gdm9pZCAwO1xuY29uc3QgZnVuY18xID0gcmVxdWlyZShcIi4uL2Z1bmMvZnVuY1wiKTtcbmNvbnN0IHJhZl8xID0gcmVxdWlyZShcIi4uL3JhZi9yYWZcIik7XG5jb25zdCB4X3N0YWdlXzEgPSByZXF1aXJlKFwiLi94LXN0YWdlXCIpO1xuY29uc3QgeF9wb2ludGVyXzEgPSByZXF1aXJlKFwiLi94LXBvaW50ZXJcIik7XG5jb25zdCB4X3RleHRfMSA9IHJlcXVpcmUoXCIuL3gtdGV4dFwiKTtcbmNvbnN0IGRvbV93YXRjaGVyXzEgPSByZXF1aXJlKFwiLi4vZG9tL2RvbS13YXRjaGVyXCIpO1xuLyoqXG4gKiAjIFggaXMgYSBtaW5pIGNhbnZhcyArIGRvbSAyZCBlbmdpbmUgd2l0aGluIGRlZ3UuXG4gKlxuICogYGBgdHNcbiAqXG4gKlxuICpcbiAqIGBgYFxuICogQHVuc3RhYmxlXG4gKi9cbmNsYXNzIFgge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQgPSBjb25maWcuY2FudmFzRWxlbWVudDtcbiAgICAgICAgLy8gTm90ZSB0aGUgISBhdCB0aGUgZW5kLiAgUmVxdWlyZWQgdG8gZm9yY2UgdHlwZXNjcmlwdCB0byBhc3N1bWVcbiAgICAgICAgLy8gZ2V0Q29udGV4dCgnMmQnKSBuZXZlciByZXR1cm5zIG51bGwuXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzRWxlbWVudC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAvLyBGb3JjZSBzZXQgdGhlIGNhbnZhcyBzaXplLiBXaGVuIHlvdSBzZXQgdGhlIGNhbnZhcyBzaXplIHZpYSBjc3MsXG4gICAgICAgIC8vIGNzcyBzdHJldGNoZXMgdGhlIHBpeGVscyB3aXRoaW4gdGhlIGNhbnZhcy5cbiAgICAgICAgLy8gU2V0dGluZyBpdCBhcyBzdWNoLCBmb3JjZXMgdGhlIGNvcnJlY3Qgc2l6ZS5cbiAgICAgICAgdGhpcy5kcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQud2lkdGggPSAwO1xuICAgICAgICB0aGlzLmNhbnZhc0VsZW1lbnQuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgdGhpcy53YXRjaGVyID0gbmV3IGRvbV93YXRjaGVyXzEuRG9tV2F0Y2hlcigpO1xuICAgICAgICB0aGlzLndhdGNoZXIuYWRkKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHdpbmRvdyxcbiAgICAgICAgICAgIG9uOiAncmVzaXplJyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiB0aGlzLnJlc2l6ZS5iaW5kKHRoaXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWJ1Z01vZGUgPSBmdW5jXzEuZnVuYy5zZXREZWZhdWx0KGNvbmZpZy5kZWJ1Z01vZGUsIGZhbHNlKTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBtYWluIHN0YWdlIHNwcml0ZS5cbiAgICAgICAgdGhpcy5zdGFnZSA9IG5ldyB4X3N0YWdlXzEuWFN0YWdlKCk7XG4gICAgICAgIHRoaXMuc3RhZ2UuYXR0YWNoVG9DYW52YXModGhpcy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgLy8gSWYgd2Ugd2FudCB0byBkZWJ1ZyB0aGUgbW91c2UgY29vcmRzLCBhZGQgYSB0ZXh0IG9iamVjdCB0b1xuICAgICAgICAvLyBkaXNwbGF5LlxuICAgICAgICB0aGlzLm1vdXNlQ29vcmRzVGV4dERlYnVnT2JqZWN0ID0gbmV3IHhfdGV4dF8xLlhUZXh0KHtcbiAgICAgICAgICAgIC8vIEFkZCBpdCBhdCBhIHJlYWxseSBoaWdoIGluZGV4LlxuICAgICAgICAgICAgekluZGV4OiA5OTk5OTksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vdXNlQ29vcmRzVGV4dERlYnVnT2JqZWN0LmRlYnVnT2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlKSB7XG4gICAgICAgICAgICB3aW5kb3dbJ1gnXSA9IHRoaXM7XG4gICAgICAgICAgICB3aW5kb3dbJ1hfU1RBR0UnXSA9IHRoaXMuc3RhZ2U7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMubW91c2VDb29yZHNUZXh0RGVidWdPYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYmFja2dyb3VuZCBjb2xvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhZ2VDb2xvciA9IG51bGw7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbWFpbiBwb2ludGVyLlxuICAgICAgICB0aGlzLnBvaW50ZXIgPSBuZXcgeF9wb2ludGVyXzEuWFBvaW50ZXIodGhpcy5jYW52YXNFbGVtZW50KTtcbiAgICAgICAgdGhpcy5yYWYgPSBuZXcgcmFmXzEuUmFmKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ2FtZUxvb3AoKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbW91c2UgZGlzcGxheSB0byBmb2xsb3cgdGhlIG1vdXNlIGFuZCBkaXNwbGF5IHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBjb29yZGluYXRlcy5cbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnTW9kZSAmJiB0aGlzLm1vdXNlQ29vcmRzVGV4dERlYnVnT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZUNvb3Jkc1RleHREZWJ1Z09iamVjdC5zZXRQb3NpdGlvbih0aGlzLnBvaW50ZXIueCArIDIwLCB0aGlzLnBvaW50ZXIueSArIDIwKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlQ29vcmRzVGV4dERlYnVnT2JqZWN0LnNldFRleHQoYHg6ICR7dGhpcy5wb2ludGVyLnh9LCB5OiAke3RoaXMucG9pbnRlci55fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGJhY2tncm91bmQgY29sb3IgZm9yIHRoZSBzdGFnZS5cbiAgICAgKiBAcGFyYW0gY29sb3JcbiAgICAgKi9cbiAgICBzZXRTdGFnZUNvbG9yKGNvbG9yKSB7XG4gICAgICAgIHRoaXMuc3RhZ2VDb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICByZXNpemUoKSB7XG4gICAgICAgIHRoaXMuZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LndpZHRoID0gdGhpcy5jYW52YXNFbGVtZW50Lm9mZnNldFdpZHRoICogdGhpcy5kcHI7XG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudC5oZWlnaHQgPSB0aGlzLmNhbnZhc0VsZW1lbnQub2Zmc2V0SGVpZ2h0ICogdGhpcy5kcHI7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhc0VsZW1lbnQub2Zmc2V0V2lkdGggKiB0aGlzLmRwcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbnZhc0VsZW1lbnQub2Zmc2V0SGVpZ2h0ICogdGhpcy5kcHI7XG4gICAgfVxuICAgIGdldFBvaW50ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50ZXI7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1haW4gZW5naW5lIGxvb3AuICBIZXJlIHdlIGNhbGwgdGhyb3VnaCBhbGwgdGhlXG4gICAgICogc3ByaXRlcyBvbiB0aGUgbWFpbiBzdGFnZS5cbiAgICAgKi9cbiAgICBnYW1lTG9vcCgpIHtcbiAgICAgICAgLy9DbGVhciB0aGUgY2FudmFzLlxuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWdlQ29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLnN0YWdlQ29sb3I7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcG9zaXRpb25zIG9mIGVhY2ggb2JqZWN0XG4gICAgICAgIHRoaXMuc3RhZ2UuY2hpbGRyZW4uZm9yRWFjaCgoZ2FtZU9iamVjdCkgPT4ge1xuICAgICAgICAgICAgZ2FtZU9iamVjdC51cGRhdGVQb3NpdGlvbnMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlbmRlciBlYWNoIG9iamVjdC5cbiAgICAgICAgdGhpcy5zdGFnZS5jaGlsZHJlbi5mb3JFYWNoKChnYW1lT2JqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckdhbWVPYmplY3QoZ2FtZU9iamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgZ2l2ZW4gc3ByaXRlIG9udG8gdGhlIGNhbnZhcy4gIFRoaXMgaXMgc29ydCBvZiBpbWFnaW5lZCBsaWtlXG4gICAgICogYSBzdGFtcGluZyBwcm9jZXNzIGluIHdoaWNoIHdlIHR1cm4sIHNjYWxlLCBjaGFuZ2UgYWxwaGEgb2YgdGhlIGNvbnRleHRcbiAgICAgKiBpdHNlbGYgYW5kIHN0YW1wIG91dCB0aGUgc3ByaXRlIHBlciBmcmFtZS5cbiAgICAgKiBAcGFyYW0gZ2FtZU9iamVjdFxuICAgICAqL1xuICAgIHJlbmRlckdhbWVPYmplY3QoZ2FtZU9iamVjdCkge1xuICAgICAgICAvLyBXaGV0aGVyIHRoaXMgZ2FtZU9iamVjdCBpcyBvZmYgc2NyZWVuLlxuICAgICAgICBjb25zdCBzaG91bGRSZW5kZXIgPSBnYW1lT2JqZWN0LnZpc2libGUgJiZcbiAgICAgICAgICAgIGdhbWVPYmplY3QuZ3ggPCB0aGlzLndpZHRoICsgZ2FtZU9iamVjdC53aWR0aCAmJlxuICAgICAgICAgICAgZ2FtZU9iamVjdC5neCArIGdhbWVPYmplY3Qud2lkdGggPj0gLWdhbWVPYmplY3Qud2lkdGggJiZcbiAgICAgICAgICAgIGdhbWVPYmplY3QuZ3kgPCB0aGlzLmhlaWdodCArIGdhbWVPYmplY3QuaGVpZ2h0ICYmXG4gICAgICAgICAgICBnYW1lT2JqZWN0Lmd5ICsgZ2FtZU9iamVjdC5oZWlnaHQgPj0gLWdhbWVPYmplY3QuaGVpZ2h0O1xuICAgICAgICBpZiAoIXNob3VsZFJlbmRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoaXMgb2JqZWN0IGlzIGludGVyYWN0YWJsZSwgY2hlY2sgdGhlIGNvbGxpc2lvbiBzdGF0ZVxuICAgICAgICAvLyB3aXRoIHRoZSBwb2ludGVyLlxuICAgICAgICBsZXQgY29sbGlkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChnYW1lT2JqZWN0LmludGVyYWN0YWJsZSkge1xuICAgICAgICAgICAgY29sbGlkaW5nID0gdGhpcy5wb2ludGVyLnRlc3RDb2xsaWRpbmdXaXRoR2FtZU9iamVjdChnYW1lT2JqZWN0KTtcbiAgICAgICAgICAgIGlmIChjb2xsaWRpbmcgJiYgdGhpcy5wb2ludGVyLmlzTW91c2VEb3duKSB7XG4gICAgICAgICAgICAgICAgZ2FtZU9iamVjdC5vbk1vdXNlRG93biAmJiBnYW1lT2JqZWN0Lm9uTW91c2VEb3duKGdhbWVPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbGxpZGluZyAmJiAhdGhpcy5wb2ludGVyLmlzTW91c2VEb3duKSB7XG4gICAgICAgICAgICAgICAgZ2FtZU9iamVjdC5vbk1vdXNlVXAgJiYgZ2FtZU9iamVjdC5vbk1vdXNlVXAoZ2FtZU9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sbGlkaW5nKSB7XG4gICAgICAgICAgICAgICAgZ2FtZU9iamVjdC5vbk1vdXNlTW92ZSAmJiBnYW1lT2JqZWN0Lm9uTW91c2VNb3ZlKGdhbWVPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XG4gICAgICAgIC8vIHRoaXMuY29udGV4dC50cmFuc2xhdGUoXG4gICAgICAgIC8vICAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LndpZHRoICAvIDIsXG4gICAgICAgIC8vICAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50LmhlaWdodCAvIDIpXG4gICAgICAgIC8vIFNjYWxlIHRvIGFzcGVjdCByYXRpbyBmaXJzdC5cbiAgICAgICAgdGhpcy5jb250ZXh0LnNjYWxlKHRoaXMuZHByLCB0aGlzLmRwcik7XG4gICAgICAgIC8vIEFkanVzdCBhbHBoYVxuICAgICAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSBnYW1lT2JqZWN0LmFscGhhO1xuICAgICAgICAvLyBNb3ZlIGZpcnN0XG4gICAgICAgIHRoaXMuY29udGV4dC50cmFuc2xhdGUoXG4gICAgICAgIC8vIGdhbWVPYmplY3QueCArIChnYW1lT2JqZWN0LndpZHRoICogZ2FtZU9iamVjdC5hbmNob3JYKSxcbiAgICAgICAgLy8gZ2FtZU9iamVjdC55ICsgKGdhbWVPYmplY3QuaGVpZ2h0ICogZ2FtZU9iamVjdC5hbmNob3JZKVxuICAgICAgICB+fmdhbWVPYmplY3QuYW5jaG9yR3gsIH5+Z2FtZU9iamVjdC5hbmNob3JHeSk7XG4gICAgICAgIC8vIFRoZW4gcm90YXRlXG4gICAgICAgIC8vIE5vdCBzdXJlIHdoeSBidXQgY2FudmFzIGNhbGN1bGF0aW9ucyByb3RhdGlvbiBpbiBhbnRpY2xvY2t3aXNlIG1hbm5lcj9cbiAgICAgICAgLy8gV2UgY291bnRlciB0aGlzIGJ5IGludGVydmluZyB0aGUgcm90YXRpb24gdmFsdWUuXG4gICAgICAgIHRoaXMuY29udGV4dC5yb3RhdGUoLWdhbWVPYmplY3Qucm90YXRpb24pO1xuICAgICAgICAvLyBOb3cgc2NhbGVcbiAgICAgICAgdGhpcy5jb250ZXh0LnNjYWxlKGdhbWVPYmplY3Quc2NhbGVYLCBnYW1lT2JqZWN0LnNjYWxlWSk7XG4gICAgICAgIC8vIENhbGwgdGhlIGdhbWVPYmplY3QgcmVuZGVyIG1ldGhvZCB0byBmaWd1cmUgb3V0IGhvdyB0byBkcmF3IHRoaXNcbiAgICAgICAgLy8gR2FtZU9iamVjdC5cbiAgICAgICAgZ2FtZU9iamVjdC5yZW5kZXIodGhpcy5jb250ZXh0KTtcbiAgICAgICAgLy8gUmVuZGVycyBkZWJ1Z2dpbmcgb3V0bGluZXMgZm9yIHRoaXMgb2JqZWN0IGlmIGl0IGlzIGNvbGxpZGluZy5cbiAgICAgICAgaWYgKHRoaXMuZGVidWdNb2RlICYmICFnYW1lT2JqZWN0LmRlYnVnT2JqZWN0ICYmIGNvbGxpZGluZykge1xuICAgICAgICAgICAgZ2FtZU9iamVjdC5yZW5kZXJEZWJ1Z2dpbmdPdXRsaW5lcyh0aGlzLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIC8vIE5vdyBsb29wIHRocm91Z2ggZWFjaCBjaGlsZCBhbmQgcGFpbnQgaXQgb3V0LlxuICAgICAgICBnYW1lT2JqZWN0LmNoaWxkcmVuLmZvckVhY2goY2hpbGRHYW1lT2JqZWN0ID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyR2FtZU9iamVjdChjaGlsZEdhbWVPYmplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBBZGRzIGEgd2F0Y2hlciBjYWxsYmFjayB0byB0aGUgcmFmIGxvb3AuXG4gICAgICovXG4gICAgb25UaWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucmFmLndhdGNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBtYWluIGdhbWUgbG9vcC5cbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5yYWYuc3RhcnQoKTtcbiAgICB9XG59XG5leHBvcnRzLlggPSBYO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/x/x.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?sourceMap=true!./node_modules/sass-loader/lib/loader.js!./examples/styles/index.sass":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js?sourceMap=true!./node_modules/sass-loader/lib/loader.js!./examples/styles/index.sass ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(true);\n// Module\nexports.push([module.i, \"body {\\n  background-color: white;\\n  padding: 20px; }\\n\\n.easer {\\n  width: 100%;\\n  position: relative;\\n  margin: 20px; }\\n\\n.easer__ball {\\n  width: 50px;\\n  height: 50px;\\n  background-color: green;\\n  border-radius: 50%; }\\n\", \"\",{\"version\":3,\"sources\":[\"index.sass\"],\"names\":[],\"mappings\":\"AAAA;EACE,uBAAuB;EACvB,aAAa,EAAE;;AAEjB;EACE,WAAW;EACX,kBAAkB;EAClB,YAAY,EAAE;;AAEhB;EACE,WAAW;EACX,YAAY;EACZ,uBAAuB;EACvB,kBAAkB,EAAE\",\"file\":\"index.sass\",\"sourcesContent\":[\"body {\\n  background-color: white;\\n  padding: 20px; }\\n\\n.easer {\\n  width: 100%;\\n  position: relative;\\n  margin: 20px; }\\n\\n.easer__ball {\\n  width: 50px;\\n  height: 50px;\\n  background-color: green;\\n  border-radius: 50%; }\\n\"]}]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz9zb3VyY2VNYXA9dHJ1ZSEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vZXhhbXBsZXMvc3R5bGVzL2luZGV4LnNhc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9leGFtcGxlcy9zdHlsZXMvaW5kZXguc2Fzcz84MmZlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKHRydWUpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJib2R5IHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgcGFkZGluZzogMjBweDsgfVxcblxcbi5lYXNlciB7XFxuICB3aWR0aDogMTAwJTtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIG1hcmdpbjogMjBweDsgfVxcblxcbi5lYXNlcl9fYmFsbCB7XFxuICB3aWR0aDogNTBweDtcXG4gIGhlaWdodDogNTBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IGdyZWVuO1xcbiAgYm9yZGVyLXJhZGl1czogNTAlOyB9XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiaW5kZXguc2Fzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLHVCQUF1QjtFQUN2QixhQUFhLEVBQUU7O0FBRWpCO0VBQ0UsV0FBVztFQUNYLGtCQUFrQjtFQUNsQixZQUFZLEVBQUU7O0FBRWhCO0VBQ0UsV0FBVztFQUNYLFlBQVk7RUFDWix1QkFBdUI7RUFDdkIsa0JBQWtCLEVBQUVcIixcImZpbGVcIjpcImluZGV4LnNhc3NcIixcInNvdXJjZXNDb250ZW50XCI6W1wiYm9keSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gIHBhZGRpbmc6IDIwcHg7IH1cXG5cXG4uZWFzZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBtYXJnaW46IDIwcHg7IH1cXG5cXG4uZWFzZXJfX2JhbGwge1xcbiAgd2lkdGg6IDUwcHg7XFxuICBoZWlnaHQ6IDUwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBncmVlbjtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTsgfVxcblwiXX1dKTtcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js?sourceMap=true!./node_modules/sass-loader/lib/loader.js!./examples/styles/index.sass\n");

/***/ })

/******/ });